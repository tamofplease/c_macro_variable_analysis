<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/misc/spellfix.c"><comment type="block">/*
** 2012 April 10
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This module implements the spellfix1 VIRTUAL TABLE that can be used
** to search a large vocabulary for close matches.  See separate
** documentation (http://www.sqlite.org/spellfix1.html) for details.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>NDEBUG</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>NDEBUG</name></cpp:undef>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
  <typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>u8</name>;</typedef>
  <typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>u16</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<comment type="block">/*
** Character classes for ASCII characters:
**
**   0   ''        Silent letters:   H W
**   1   'A'       Any vowel:   A E I O U (Y)
**   2   'B'       A bilabeal stop or fricative:  B F P V W
**   3   'C'       Other fricatives or back stops:  C G J K Q S X Z
**   4   'D'       Alveolar stops:  D T
**   5   'H'       Letter H at the beginning of a word
**   6   'L'       Glide:  L
**   7   'R'       Semivowel:  R
**   8   'M'       Nasals:  M N
**   9   'Y'       Letter Y at the beginning of a word.
**   10  '9'       Digits: 0 1 2 3 4 5 6 7 8 9
**   11  ' '       White space
**   12  '?'       Other.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCLASS_SILENT</name></cpp:macro>         <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCLASS_VOWEL</name></cpp:macro>          <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCLASS_B</name></cpp:macro>              <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCLASS_C</name></cpp:macro>              <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCLASS_D</name></cpp:macro>              <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCLASS_H</name></cpp:macro>              <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCLASS_L</name></cpp:macro>              <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCLASS_R</name></cpp:macro>              <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCLASS_M</name></cpp:macro>              <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCLASS_Y</name></cpp:macro>              <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCLASS_DIGIT</name></cpp:macro>         <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCLASS_SPACE</name></cpp:macro>         <cpp:value>11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCLASS_OTHER</name></cpp:macro>         <cpp:value>12</cpp:value></cpp:define>

<comment type="block">/*
** The following table gives the character class for non-initial ASCII
** characters.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>midClass</name><index>[]</index></name> <init>= <expr><block>{
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_SPACE</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_SPACE</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_SPACE</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_SPACE</name></expr>,
 <comment type="block">/* ! */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* " */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* # */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* $ */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* % */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* &amp; */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* ' */</comment> <expr><name>CCLASS_SILENT</name></expr>,   <comment type="block">/* ( */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* ) */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* * */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* + */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* , */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* - */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* . */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* / */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* 0 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,    <comment type="block">/* 1 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,   <comment type="block">/* 2 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,
 <comment type="block">/* 3 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,    <comment type="block">/* 4 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,   <comment type="block">/* 5 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,
 <comment type="block">/* 6 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,    <comment type="block">/* 7 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,   <comment type="block">/* 8 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,
 <comment type="block">/* 9 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,    <comment type="block">/* : */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* ; */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* &lt; */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* = */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* &gt; */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* ? */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* @ */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* A */</comment> <expr><name>CCLASS_VOWEL</name></expr>,
 <comment type="block">/* B */</comment> <expr><name>CCLASS_B</name></expr>,        <comment type="block">/* C */</comment> <expr><name>CCLASS_C</name></expr>,       <comment type="block">/* D */</comment> <expr><name>CCLASS_D</name></expr>,
 <comment type="block">/* E */</comment> <expr><name>CCLASS_VOWEL</name></expr>,    <comment type="block">/* F */</comment> <expr><name>CCLASS_B</name></expr>,       <comment type="block">/* G */</comment> <expr><name>CCLASS_C</name></expr>,
 <comment type="block">/* H */</comment> <expr><name>CCLASS_SILENT</name></expr>,   <comment type="block">/* I */</comment> <expr><name>CCLASS_VOWEL</name></expr>,   <comment type="block">/* J */</comment> <expr><name>CCLASS_C</name></expr>,
 <comment type="block">/* K */</comment> <expr><name>CCLASS_C</name></expr>,        <comment type="block">/* L */</comment> <expr><name>CCLASS_L</name></expr>,       <comment type="block">/* M */</comment> <expr><name>CCLASS_M</name></expr>,
 <comment type="block">/* N */</comment> <expr><name>CCLASS_M</name></expr>,        <comment type="block">/* O */</comment> <expr><name>CCLASS_VOWEL</name></expr>,   <comment type="block">/* P */</comment> <expr><name>CCLASS_B</name></expr>,
 <comment type="block">/* Q */</comment> <expr><name>CCLASS_C</name></expr>,        <comment type="block">/* R */</comment> <expr><name>CCLASS_R</name></expr>,       <comment type="block">/* S */</comment> <expr><name>CCLASS_C</name></expr>,
 <comment type="block">/* T */</comment> <expr><name>CCLASS_D</name></expr>,        <comment type="block">/* U */</comment> <expr><name>CCLASS_VOWEL</name></expr>,   <comment type="block">/* V */</comment> <expr><name>CCLASS_B</name></expr>,
 <comment type="block">/* W */</comment> <expr><name>CCLASS_B</name></expr>,        <comment type="block">/* X */</comment> <expr><name>CCLASS_C</name></expr>,       <comment type="block">/* Y */</comment> <expr><name>CCLASS_VOWEL</name></expr>,
 <comment type="block">/* Z */</comment> <expr><name>CCLASS_C</name></expr>,        <comment type="block">/* [ */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* \ */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* ] */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* ^ */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* _ */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* ` */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* a */</comment> <expr><name>CCLASS_VOWEL</name></expr>,   <comment type="block">/* b */</comment> <expr><name>CCLASS_B</name></expr>,
 <comment type="block">/* c */</comment> <expr><name>CCLASS_C</name></expr>,        <comment type="block">/* d */</comment> <expr><name>CCLASS_D</name></expr>,       <comment type="block">/* e */</comment> <expr><name>CCLASS_VOWEL</name></expr>,
 <comment type="block">/* f */</comment> <expr><name>CCLASS_B</name></expr>,        <comment type="block">/* g */</comment> <expr><name>CCLASS_C</name></expr>,       <comment type="block">/* h */</comment> <expr><name>CCLASS_SILENT</name></expr>,
 <comment type="block">/* i */</comment> <expr><name>CCLASS_VOWEL</name></expr>,    <comment type="block">/* j */</comment> <expr><name>CCLASS_C</name></expr>,       <comment type="block">/* k */</comment> <expr><name>CCLASS_C</name></expr>,
 <comment type="block">/* l */</comment> <expr><name>CCLASS_L</name></expr>,        <comment type="block">/* m */</comment> <expr><name>CCLASS_M</name></expr>,       <comment type="block">/* n */</comment> <expr><name>CCLASS_M</name></expr>,
 <comment type="block">/* o */</comment> <expr><name>CCLASS_VOWEL</name></expr>,    <comment type="block">/* p */</comment> <expr><name>CCLASS_B</name></expr>,       <comment type="block">/* q */</comment> <expr><name>CCLASS_C</name></expr>,
 <comment type="block">/* r */</comment> <expr><name>CCLASS_R</name></expr>,        <comment type="block">/* s */</comment> <expr><name>CCLASS_C</name></expr>,       <comment type="block">/* t */</comment> <expr><name>CCLASS_D</name></expr>,
 <comment type="block">/* u */</comment> <expr><name>CCLASS_VOWEL</name></expr>,    <comment type="block">/* v */</comment> <expr><name>CCLASS_B</name></expr>,       <comment type="block">/* w */</comment> <expr><name>CCLASS_B</name></expr>,
 <comment type="block">/* x */</comment> <expr><name>CCLASS_C</name></expr>,        <comment type="block">/* y */</comment> <expr><name>CCLASS_VOWEL</name></expr>,   <comment type="block">/* z */</comment> <expr><name>CCLASS_C</name></expr>,
 <comment type="block">/* { */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* | */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* } */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* ~ */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   
}</block></expr></init></decl>;</decl_stmt>
<comment type="block">/* 
** This tables gives the character class for ASCII characters that form the
** initial character of a word.  The only difference from midClass is with
** the letters H, W, and Y.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>initClass</name><index>[]</index></name> <init>= <expr><block>{
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_SPACE</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_SPACE</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_SPACE</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/*   */</comment> <expr><name>CCLASS_SPACE</name></expr>,
 <comment type="block">/* ! */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* " */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* # */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* $ */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* % */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* &amp; */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* ' */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* ( */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* ) */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* * */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* + */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* , */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* - */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* . */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* / */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* 0 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,    <comment type="block">/* 1 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,   <comment type="block">/* 2 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,
 <comment type="block">/* 3 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,    <comment type="block">/* 4 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,   <comment type="block">/* 5 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,
 <comment type="block">/* 6 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,    <comment type="block">/* 7 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,   <comment type="block">/* 8 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,
 <comment type="block">/* 9 */</comment> <expr><name>CCLASS_DIGIT</name></expr>,    <comment type="block">/* : */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* ; */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* &lt; */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* = */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* &gt; */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* ? */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* @ */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* A */</comment> <expr><name>CCLASS_VOWEL</name></expr>,
 <comment type="block">/* B */</comment> <expr><name>CCLASS_B</name></expr>,        <comment type="block">/* C */</comment> <expr><name>CCLASS_C</name></expr>,       <comment type="block">/* D */</comment> <expr><name>CCLASS_D</name></expr>,
 <comment type="block">/* E */</comment> <expr><name>CCLASS_VOWEL</name></expr>,    <comment type="block">/* F */</comment> <expr><name>CCLASS_B</name></expr>,       <comment type="block">/* G */</comment> <expr><name>CCLASS_C</name></expr>,
 <comment type="block">/* H */</comment> <expr><name>CCLASS_SILENT</name></expr>,   <comment type="block">/* I */</comment> <expr><name>CCLASS_VOWEL</name></expr>,   <comment type="block">/* J */</comment> <expr><name>CCLASS_C</name></expr>,
 <comment type="block">/* K */</comment> <expr><name>CCLASS_C</name></expr>,        <comment type="block">/* L */</comment> <expr><name>CCLASS_L</name></expr>,       <comment type="block">/* M */</comment> <expr><name>CCLASS_M</name></expr>,
 <comment type="block">/* N */</comment> <expr><name>CCLASS_M</name></expr>,        <comment type="block">/* O */</comment> <expr><name>CCLASS_VOWEL</name></expr>,   <comment type="block">/* P */</comment> <expr><name>CCLASS_B</name></expr>,
 <comment type="block">/* Q */</comment> <expr><name>CCLASS_C</name></expr>,        <comment type="block">/* R */</comment> <expr><name>CCLASS_R</name></expr>,       <comment type="block">/* S */</comment> <expr><name>CCLASS_C</name></expr>,
 <comment type="block">/* T */</comment> <expr><name>CCLASS_D</name></expr>,        <comment type="block">/* U */</comment> <expr><name>CCLASS_VOWEL</name></expr>,   <comment type="block">/* V */</comment> <expr><name>CCLASS_B</name></expr>,
 <comment type="block">/* W */</comment> <expr><name>CCLASS_B</name></expr>,        <comment type="block">/* X */</comment> <expr><name>CCLASS_C</name></expr>,       <comment type="block">/* Y */</comment> <expr><name>CCLASS_Y</name></expr>,
 <comment type="block">/* Z */</comment> <expr><name>CCLASS_C</name></expr>,        <comment type="block">/* [ */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* \ */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* ] */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* ^ */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* _ */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* ` */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* a */</comment> <expr><name>CCLASS_VOWEL</name></expr>,   <comment type="block">/* b */</comment> <expr><name>CCLASS_B</name></expr>,
 <comment type="block">/* c */</comment> <expr><name>CCLASS_C</name></expr>,        <comment type="block">/* d */</comment> <expr><name>CCLASS_D</name></expr>,       <comment type="block">/* e */</comment> <expr><name>CCLASS_VOWEL</name></expr>,
 <comment type="block">/* f */</comment> <expr><name>CCLASS_B</name></expr>,        <comment type="block">/* g */</comment> <expr><name>CCLASS_C</name></expr>,       <comment type="block">/* h */</comment> <expr><name>CCLASS_SILENT</name></expr>,
 <comment type="block">/* i */</comment> <expr><name>CCLASS_VOWEL</name></expr>,    <comment type="block">/* j */</comment> <expr><name>CCLASS_C</name></expr>,       <comment type="block">/* k */</comment> <expr><name>CCLASS_C</name></expr>,
 <comment type="block">/* l */</comment> <expr><name>CCLASS_L</name></expr>,        <comment type="block">/* m */</comment> <expr><name>CCLASS_M</name></expr>,       <comment type="block">/* n */</comment> <expr><name>CCLASS_M</name></expr>,
 <comment type="block">/* o */</comment> <expr><name>CCLASS_VOWEL</name></expr>,    <comment type="block">/* p */</comment> <expr><name>CCLASS_B</name></expr>,       <comment type="block">/* q */</comment> <expr><name>CCLASS_C</name></expr>,
 <comment type="block">/* r */</comment> <expr><name>CCLASS_R</name></expr>,        <comment type="block">/* s */</comment> <expr><name>CCLASS_C</name></expr>,       <comment type="block">/* t */</comment> <expr><name>CCLASS_D</name></expr>,
 <comment type="block">/* u */</comment> <expr><name>CCLASS_VOWEL</name></expr>,    <comment type="block">/* v */</comment> <expr><name>CCLASS_B</name></expr>,       <comment type="block">/* w */</comment> <expr><name>CCLASS_B</name></expr>,
 <comment type="block">/* x */</comment> <expr><name>CCLASS_C</name></expr>,        <comment type="block">/* y */</comment> <expr><name>CCLASS_Y</name></expr>,       <comment type="block">/* z */</comment> <expr><name>CCLASS_C</name></expr>,
 <comment type="block">/* { */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/* | */</comment> <expr><name>CCLASS_OTHER</name></expr>,   <comment type="block">/* } */</comment> <expr><name>CCLASS_OTHER</name></expr>,
 <comment type="block">/* ~ */</comment> <expr><name>CCLASS_OTHER</name></expr>,    <comment type="block">/*   */</comment> <expr><name>CCLASS_OTHER</name></expr>,   
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Mapping from the character class number (0-13) to a symbol for each
** character class.  Note that initClass[] can be used to map the class
** symbol back into the class number.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>className</name><index>[]</index></name> <init>= <expr><literal type="string">".ABCDHLRMY9 ?"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Generate a "phonetic hash" from a string of ASCII characters
** in zIn[0..nIn-1].
**
**   * Map characters by character class as defined above.
**   * Omit double-letters
**   * Omit vowels beside R and L
**   * Omit T when followed by CH
**   * Omit W when followed by R
**   * Omit D when followed by J or G
**   * Omit K in KN or G in GN at the beginning of a word
**
** Space to hold the result is obtained from sqlite3_malloc()
**
** Return NULL if memory allocation fails.  
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>phoneticHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>nIn</name> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>cPrev</name> <init>= <expr><literal type="number">0x77</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>cPrevX</name> <init>= <expr><literal type="number">0x77</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aClass</name> <init>= <expr><name>initClass</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nIn</name><operator>&gt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <switch>switch<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="char">'g'</literal></expr>:</case> 
      <case>case <expr><literal type="char">'k'</literal></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'n'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>nIn</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nIn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name>nIn</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'w'</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'r'</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'d'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'j'</literal> <operator>||</operator> <name><name>zIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'g'</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>+</operator><literal type="number">2</literal><operator>&lt;</operator><name>nIn</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'c'</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'h'</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>aClass</name><index>[<expr><name>c</name><operator>&amp;</operator><literal type="number">0x7f</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>CCLASS_SPACE</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>CCLASS_OTHER</name> <operator>&amp;&amp;</operator> <name>cPrev</name><operator>!=</operator><name>CCLASS_DIGIT</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>aClass</name> <operator>=</operator> <name>midClass</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>CCLASS_VOWEL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>cPrevX</name><operator>==</operator><name>CCLASS_R</name> <operator>||</operator> <name>cPrevX</name><operator>==</operator><name>CCLASS_L</name><operator>)</operator></expr> )</condition><block>{<block_content>
       <continue>continue;</continue> <comment type="block">/* No vowels beside L or R */</comment> 
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>==</operator><name>CCLASS_R</name> <operator>||</operator> <name>c</name><operator>==</operator><name>CCLASS_L</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>cPrevX</name><operator>==</operator><name>CCLASS_VOWEL</name></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><name>nOut</name><operator>--</operator></expr>;</expr_stmt>   <comment type="block">/* No vowels beside L or R */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cPrev</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>CCLASS_SILENT</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cPrevX</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>className</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOut</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nOut</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>c</name><operator>!=</operator><name><name>zOut</name><index>[<expr><name>nOut</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>nOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>nOut</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>zOut</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is an SQL function wrapper around phoneticHash().  See
** the description of phoneticHash() for additional information.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>phoneticHashSqlFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zIn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>phoneticHash</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zOut</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the character class number for a character given its
** context.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name></type> <name>characterClass</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>cPrev</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>cPrev</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>initClass</name><index>[<expr><name>c</name><operator>&amp;</operator><literal type="number">0x7f</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>midClass</name><index>[<expr><name>c</name><operator>&amp;</operator><literal type="number">0x7f</literal></expr>]</index></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the cost of inserting or deleting character c immediately
** following character cPrev.  If cPrev==0, that means c is the first
** character of the word.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>insertOrDeleteCost</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>cPrev</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>cNext</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>classC</name> <init>= <expr><call><name>characterClass</name><argument_list>(<argument><expr><name>cPrev</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>classCprev</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>classC</name><operator>==</operator><name>CCLASS_SILENT</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Insert or delete "silent" characters such as H or W */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>cPrev</name><operator>==</operator><name>c</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Repeated characters, or miss a repeat */</comment>
    <return>return <expr><literal type="number">10</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>classC</name><operator>==</operator><name>CCLASS_VOWEL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>cPrev</name><operator>==</operator><literal type="char">'r'</literal> <operator>||</operator> <name>cNext</name><operator>==</operator><literal type="char">'r'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">20</literal></expr>;</return>  <comment type="block">/* Insert a vowel before or after 'r' */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>classCprev</name> <operator>=</operator> <call><name>characterClass</name><argument_list>(<argument><expr><name>cPrev</name></expr></argument>, <argument><expr><name>cPrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>classC</name><operator>==</operator><name>classCprev</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>classC</name><operator>==</operator><name>CCLASS_VOWEL</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Remove or add a new vowel to a vowel cluster */</comment>
      <return>return <expr><literal type="number">15</literal></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Remove or add a consonant not in the same class */</comment>
      <return>return <expr><literal type="number">50</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* any other character insertion or deletion */</comment>
  <return>return <expr><literal type="number">100</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Divide the insertion cost by this factor when appending to the
** end of the word.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FINAL_INS_COST_DIV</name></cpp:macro>  <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/*
** Return the cost of substituting cTo in place of cFrom assuming
** the previous character is cPrev.  If cPrev==0 then cTo is the first
** character of the word.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>substituteCost</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>cPrev</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>cFrom</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>cTo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>classFrom</name></decl>, <decl><type ref="prev"/><name>classTo</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>cFrom</name><operator>==</operator><name>cTo</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Exact match */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>cFrom</name><operator>==</operator><operator>(</operator><name>cTo</name><operator>^</operator><literal type="number">0x20</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>cTo</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>cTo</name><operator>&lt;=</operator><literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>cTo</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>cTo</name><operator>&lt;=</operator><literal type="char">'z'</literal><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
    <comment type="block">/* differ only in case */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>classFrom</name> <operator>=</operator> <call><name>characterClass</name><argument_list>(<argument><expr><name>cPrev</name></expr></argument>, <argument><expr><name>cFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>classTo</name> <operator>=</operator> <call><name>characterClass</name><argument_list>(<argument><expr><name>cPrev</name></expr></argument>, <argument><expr><name>cTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>classFrom</name><operator>==</operator><name>classTo</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Same character class */</comment>
    <return>return <expr><literal type="number">40</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>classFrom</name><operator>&gt;=</operator><name>CCLASS_B</name> <operator>&amp;&amp;</operator> <name>classFrom</name><operator>&lt;=</operator><name>CCLASS_Y</name>
      <operator>&amp;&amp;</operator> <name>classTo</name><operator>&gt;=</operator><name>CCLASS_B</name> <operator>&amp;&amp;</operator> <name>classTo</name><operator>&lt;=</operator><name>CCLASS_Y</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Convert from one consonant to another, but in a different class */</comment>
    <return>return <expr><literal type="number">75</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Any other subsitution */</comment>
  <return>return <expr><literal type="number">100</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given two strings zA and zB which are pure ASCII, return the cost
** of transforming zA into zB.  If zA ends with '*' assume that it is
** a prefix of zB and give only minimal penalty for extra characters
** on the end of zB.
**
** Smaller numbers mean a closer match.
**
** Negative values indicate an error:
**    -1  One of the inputs is NULL
**    -2  Non-ASCII characters on input
**    -3  Unable to allocate memory 
**
** If pnMatch is not NULL, then *pnMatch is set to the number of bytes
** of zB that matched the pattern in zA. If zA does not end with a '*',
** then this value is always the number of bytes in zB (i.e. strlen(zB)).
** If zA does end in a '*', then it is the number of bytes in the prefix
** of zB that was deemed to match zA.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>editdist1</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zB</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnMatch</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nA</name></decl>, <decl><type ref="prev"/><name>nB</name></decl>;</decl_stmt>            <comment type="block">/* Number of characters in zA[] and zB[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>xA</name></decl>, <decl><type ref="prev"/><name>xB</name></decl>;</decl_stmt>            <comment type="block">/* Loop counters for zA[] and zB[] */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>cA</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>cB</name></decl>;</decl_stmt>       <comment type="block">/* Current character of zA and zB */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>cAprev</name></decl>, <decl><type ref="prev"/><name>cBprev</name></decl>;</decl_stmt>   <comment type="block">/* Previous character of zA and zB */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>cAnext</name></decl>, <decl><type ref="prev"/><name>cBnext</name></decl>;</decl_stmt>   <comment type="block">/* Next character in zA and zB */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>                 <comment type="block">/* North-west cost value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>dc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* North-west character value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>               <comment type="block">/* Final result */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>                <comment type="block">/* The cost matrix */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cx</name></decl>;</decl_stmt>              <comment type="block">/* Corresponding character values */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>toFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Malloced space */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name><name>mStack</name><index>[<expr><literal type="number">60</literal><operator>+</operator><literal type="number">15</literal></expr>]</index></name></decl>;</decl_stmt>     <comment type="block">/* Stack space to use if not too much is needed */</comment>

  <comment type="block">/* Early out if either input is NULL */</comment>
  <if_stmt><if>if<condition>( <expr><name>zA</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zB</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Skip any common prefix */</comment>
  <while>while<condition>( <expr><name><name>zA</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zA</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name><name>zB</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>dc</name> <operator>=</operator> <name><name>zA</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>zA</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>zB</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>nMatch</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pnMatch</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnMatch</name> <operator>=</operator> <name>nMatch</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zA</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zB</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  printf("A=\"%s\" B=\"%s\" dc=%c\n", zA, zB, dc?dc:' ');
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Verify input strings and measure their lengths */</comment>
  <for>for<control>(<init><expr><name>nA</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zA</name><index>[<expr><name>nA</name></expr>]</index></name></expr>;</condition> <incr><expr><name>nA</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>zA</name><index>[<expr><name>nA</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>nB</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zB</name><index>[<expr><name>nB</name></expr>]</index></name></expr>;</condition> <incr><expr><name>nB</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>zB</name><index>[<expr><name>nB</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Special processing if either string is empty */</comment>
  <if_stmt><if>if<condition>( <expr><name>nA</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>cBprev</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>dc</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>xB</name><operator>=</operator><name>res</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>cB</name> <operator>=</operator> <name><name>zB</name><index>[<expr><name>xB</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>xB</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>+=</operator> <call><name>insertOrDeleteCost</name><argument_list>(<argument><expr><name>cBprev</name></expr></argument>, <argument><expr><name>cB</name></expr></argument>, <argument><expr><name><name>zB</name><index>[<expr><name>xB</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>/</operator><name>FINAL_INS_COST_DIV</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cBprev</name> <operator>=</operator> <name>cB</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>res</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nB</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>cAprev</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>dc</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>xA</name><operator>=</operator><name>res</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>cA</name> <operator>=</operator> <name><name>zA</name><index>[<expr><name>xA</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>xA</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>+=</operator> <call><name>insertOrDeleteCost</name><argument_list>(<argument><expr><name>cAprev</name></expr></argument>, <argument><expr><name>cA</name></expr></argument>, <argument><expr><name><name>zA</name><index>[<expr><name>xA</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cAprev</name> <operator>=</operator> <name>cA</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>res</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* A is a prefix of B */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>zA</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>zA</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Allocate and initialize the Wagner matrix */</comment>
  <if_stmt><if>if<condition>( <expr><name>nB</name><operator>&lt;</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>mStack</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">4</literal><operator>)</operator><operator>/</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>mStack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">5</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>m</name> <operator>=</operator> <name>mStack</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>m</name> <operator>=</operator> <name>toFree</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><operator>(</operator><name>nB</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">5</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>/</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>m</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">3</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>cx</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>m</name><index>[<expr><name>nB</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* Compute the Wagner edit distance */</comment>
  <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>dc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cBprev</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>dc</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>xB</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>xB</name><operator>&lt;=</operator><name>nB</name></expr>;</condition> <incr><expr><name>xB</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>cBnext</name> <operator>=</operator> <name><name>zB</name><index>[<expr><name>xB</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cB</name> <operator>=</operator> <name><name>zB</name><index>[<expr><name>xB</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cx</name><index>[<expr><name>xB</name></expr>]</index></name> <operator>=</operator> <name>cB</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>m</name><index>[<expr><name>xB</name></expr>]</index></name> <operator>=</operator> <name><name>m</name><index>[<expr><name>xB</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <call><name>insertOrDeleteCost</name><argument_list>(<argument><expr><name>cBprev</name></expr></argument>, <argument><expr><name>cB</name></expr></argument>, <argument><expr><name>cBnext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cBprev</name> <operator>=</operator> <name>cB</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>cAprev</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>dc</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>xA</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>xA</name><operator>&lt;=</operator><name>nA</name></expr>;</condition> <incr><expr><name>xA</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>lastA</name> <init>= <expr><operator>(</operator><name>xA</name><operator>==</operator><name>nA</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>cA</name> <operator>=</operator> <name><name>zA</name><index>[<expr><name>xA</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cAnext</name> <operator>=</operator> <name><name>zA</name><index>[<expr><name>xA</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>cA</name><operator>==</operator><literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name>lastA</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dc</name> <operator>=</operator> <name><name>cx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>d</name> <operator>+</operator> <call><name>insertOrDeleteCost</name><argument_list>(<argument><expr><name>cAprev</name></expr></argument>, <argument><expr><name>cA</name></expr></argument>, <argument><expr><name>cAnext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cBprev</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>xB</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>xB</name><operator>&lt;=</operator><name>nB</name></expr>;</condition> <incr><expr><name>xB</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>totalCost</name></decl>, <decl><type ref="prev"/><name>insCost</name></decl>, <decl><type ref="prev"/><name>delCost</name></decl>, <decl><type ref="prev"/><name>subCost</name></decl>, <decl><type ref="prev"/><name>ncx</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>cB</name> <operator>=</operator> <name><name>zB</name><index>[<expr><name>xB</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cBnext</name> <operator>=</operator> <name><name>zB</name><index>[<expr><name>xB</name></expr>]</index></name></expr>;</expr_stmt>

      <comment type="block">/* Cost to insert cB */</comment>
      <expr_stmt><expr><name>insCost</name> <operator>=</operator> <call><name>insertOrDeleteCost</name><argument_list>(<argument><expr><name><name>cx</name><index>[<expr><name>xB</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>cB</name></expr></argument>, <argument><expr><name>cBnext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>lastA</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>insCost</name> <operator>/=</operator> <name>FINAL_INS_COST_DIV</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <comment type="block">/* Cost to delete cA */</comment>
      <expr_stmt><expr><name>delCost</name> <operator>=</operator> <call><name>insertOrDeleteCost</name><argument_list>(<argument><expr><name><name>cx</name><index>[<expr><name>xB</name></expr>]</index></name></expr></argument>, <argument><expr><name>cA</name></expr></argument>, <argument><expr><name>cBnext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Cost to substitute cA-&gt;cB */</comment>
      <expr_stmt><expr><name>subCost</name> <operator>=</operator> <call><name>substituteCost</name><argument_list>(<argument><expr><name><name>cx</name><index>[<expr><name>xB</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>cA</name></expr></argument>, <argument><expr><name>cB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Best cost */</comment>
      <expr_stmt><expr><name>totalCost</name> <operator>=</operator> <name>insCost</name> <operator>+</operator> <name><name>m</name><index>[<expr><name>xB</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ncx</name> <operator>=</operator> <name>cB</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>delCost</name> <operator>+</operator> <name><name>m</name><index>[<expr><name>xB</name></expr>]</index></name><operator>)</operator><operator>&lt;</operator><name>totalCost</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>totalCost</name> <operator>=</operator> <name>delCost</name> <operator>+</operator> <name><name>m</name><index>[<expr><name>xB</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ncx</name> <operator>=</operator> <name>cA</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>subCost</name> <operator>+</operator> <name>d</name><operator>)</operator><operator>&lt;</operator><name>totalCost</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>totalCost</name> <operator>=</operator> <name>subCost</name> <operator>+</operator> <name>d</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
      printf("%d,%d d=%4d u=%4d r=%4d dc=%c cA=%c cB=%c"
             " ins=%4d del=%4d sub=%4d t=%4d ncx=%c\n",
             xA, xB, d, m[xB], m[xB-1], dc?dc:' ', cA, cB,
             insCost, delCost, subCost, totalCost, ncx?ncx:' ');
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="block">/* Update the matrix */</comment>
      <expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>m</name><index>[<expr><name>xB</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>dc</name> <operator>=</operator> <name><name>cx</name><index>[<expr><name>xB</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>m</name><index>[<expr><name>xB</name></expr>]</index></name> <operator>=</operator> <name>totalCost</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cx</name><index>[<expr><name>xB</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>ncx</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cBprev</name> <operator>=</operator> <name>cB</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>cAprev</name> <operator>=</operator> <name>cA</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Free the wagner matrix and return the result */</comment>
  <if_stmt><if>if<condition>( <expr><name>cA</name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>xB</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>xB</name><operator>&lt;=</operator><name>nB</name></expr>;</condition> <incr><expr><name>xB</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>m</name><index>[<expr><name>xB</name></expr>]</index></name><operator>&lt;</operator><name>res</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>m</name><index>[<expr><name>xB</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pnMatch</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnMatch</name> <operator>=</operator> <name>xB</name><operator>+</operator><name>nMatch</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>m</name><index>[<expr><name>nB</name></expr>]</index></name></expr>;</expr_stmt>
    <comment type="block">/* In the current implementation, pnMatch is always NULL if zA does
    ** not end in "*" */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pnMatch</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>toFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Function:    editdist(A,B)
**
** Return the cost of transforming string A into string B.  Both strings
** must be pure ASCII text.  If A ends with '*' then it is assumed to be
** a prefix of B and extra characters on the end of B have minimal additional
** cost.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>editdistSqlFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>editdist1</name><argument_list>(
                    <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">3</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"non-ASCII input to editdist()"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"NULL input to editdist()"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content> 
    <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* End of the fixed-cost edit distance implementation
******************************************************************************
*****************************************************************************
** Begin: Configurable cost unicode edit distance routines
*/</comment>
<comment type="block">/* Forward declaration of structures */</comment>
<typedef>typedef <type><name><name>struct</name> <name>EditDist3Cost</name></name></type> <name>EditDist3Cost</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>EditDist3Config</name></name></type> <name>EditDist3Config</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>EditDist3Point</name></name></type> <name>EditDist3Point</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>EditDist3From</name></name></type> <name>EditDist3From</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>EditDist3FromString</name></name></type> <name>EditDist3FromString</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>EditDist3To</name></name></type> <name>EditDist3To</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>EditDist3ToString</name></name></type> <name>EditDist3ToString</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>EditDist3Lang</name></name></type> <name>EditDist3Lang</name>;</typedef>


<comment type="block">/*
** An entry in the edit cost table
*/</comment>
<struct>struct <name>EditDist3Cost</name> <block>{
  <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>     <comment type="block">/* Next cost element */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nFrom</name></decl>;</decl_stmt>                 <comment type="block">/* Number of bytes in aFrom */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nTo</name></decl>;</decl_stmt>                   <comment type="block">/* Number of bytes in aTo */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>iCost</name></decl>;</decl_stmt>                <comment type="block">/* Cost of this transformation */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>    ;</decl_stmt>            <comment type="block">/* FROM string followed by TO string */</comment>
  <comment type="block">/* Additional TO and FROM string bytes appended as necessary */</comment>
}</block>;</struct>

<comment type="block">/*
** Edit costs for a particular language ID 
*/</comment>
<struct>struct <name>EditDist3Lang</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iLang</name></decl>;</decl_stmt>             <comment type="block">/* Language ID */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iInsCost</name></decl>;</decl_stmt>          <comment type="block">/* Default insertion cost */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDelCost</name></decl>;</decl_stmt>          <comment type="block">/* Default deletion cost */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSubCost</name></decl>;</decl_stmt>          <comment type="block">/* Default substitution cost */</comment>
  <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>pCost</name></decl>;</decl_stmt>  <comment type="block">/* Costs */</comment>
}</block>;</struct>


<comment type="block">/*
** The default EditDist3Lang object, with default costs.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>EditDist3Lang</name></type> <name>editDist3Lang</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><literal type="number">150</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Complete configuration
*/</comment>
<struct>struct <name>EditDist3Config</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nLang</name></decl>;</decl_stmt>             <comment type="block">/* Number of language IDs.  Size of a[] */</comment>
  <decl_stmt><decl><type><name>EditDist3Lang</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>      <comment type="block">/* One for each distinct language ID */</comment>
}</block>;</struct>

<comment type="block">/*
** Extra information about each character in the FROM string.
*/</comment>
<struct>struct <name>EditDist3From</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nSubst</name></decl>;</decl_stmt>              <comment type="block">/* Number of substitution cost entries */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nDel</name></decl>;</decl_stmt>                <comment type="block">/* Number of deletion cost entries */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>               <comment type="block">/* Number of bytes in this character */</comment>
  <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier><modifier>*</modifier></type><name>apSubst</name></decl>;</decl_stmt> <comment type="block">/* Array of substitution costs for this element */</comment>
  <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier><modifier>*</modifier></type><name>apDel</name></decl>;</decl_stmt>   <comment type="block">/* Array of deletion cost entries */</comment>
}</block>;</struct>

<comment type="block">/*
** A precompiled FROM string.
*
** In the common case we expect the FROM string to be reused multiple times.
** In other words, the common case will be to measure the edit distance
** from a single origin string to multiple target strings.
*/</comment>
<struct>struct <name>EditDist3FromString</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>                 <comment type="block">/* The complete text of the FROM string */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                   <comment type="block">/* Number of characters in the FROM string */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isPrefix</name></decl>;</decl_stmt>            <comment type="block">/* True if ends with '*' character */</comment>
  <decl_stmt><decl><type><name>EditDist3From</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>        <comment type="block">/* Extra info about each char of the FROM string */</comment>
}</block>;</struct>

<comment type="block">/*
** Extra information about each character in the TO string.
*/</comment>
<struct>struct <name>EditDist3To</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nIns</name></decl>;</decl_stmt>                <comment type="block">/* Number of insertion cost entries */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>               <comment type="block">/* Number of bytes in this character */</comment>
  <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier><modifier>*</modifier></type><name>apIns</name></decl>;</decl_stmt>   <comment type="block">/* Array of deletion cost entries */</comment>
}</block>;</struct>

<comment type="block">/*
** A precompiled FROM string
*/</comment>
<struct>struct <name>EditDist3ToString</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>                 <comment type="block">/* The complete text of the TO string */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                   <comment type="block">/* Number of characters in the TO string */</comment>
  <decl_stmt><decl><type><name>EditDist3To</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>          <comment type="block">/* Extra info about each char of the TO string */</comment>
}</block>;</struct>

<comment type="block">/*
** Clear or delete an instance of the object that records all edit-distance
** weights.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>editDist3ConfigClear</name><parameter_list>(<parameter><decl><type><name>EditDist3Config</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nLang</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>pCost</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pCost</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pCost</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pCost</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pCost</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCost</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>editDist3ConfigDelete</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>EditDist3Config</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>EditDist3Config</name><operator>*</operator><operator>)</operator><name>pIn</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>editDist3ConfigClear</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Compare the FROM values of two EditDist3Cost objects, for sorting.
** Return negative, zero, or positive if the A is less than, equal to,
** or greater than B.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>editDist3CostCompare</name><parameter_list>(<parameter><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>pA</name><operator>-&gt;</operator><name>nFrom</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><name><name>pB</name><operator>-&gt;</operator><name>nFrom</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>nFrom</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pB</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>nFrom</name></name> <operator>-</operator> <name><name>pB</name><operator>-&gt;</operator><name>nFrom</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Merge together two sorted lists of EditDist3Cost objects, in order
** of increasing FROM.
*/</comment>
<function><type><specifier>static</specifier> <name>EditDist3Cost</name> <modifier>*</modifier></type><name>editDist3CostMerge</name><parameter_list>(
  <parameter><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>,
  <parameter><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>pHead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppTail</name> <init>= <expr><operator>&amp;</operator><name>pHead</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>pA</name> <operator>&amp;&amp;</operator> <name>pB</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>editDist3CostCompare</name><argument_list>(<argument><expr><name>pA</name></expr></argument>,<argument><expr><name>pB</name></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pA</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pB</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppTail</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ppTail</name> <operator>=</operator>  <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pA</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppTail</name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppTail</name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pHead</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Sort a list of EditDist3Cost objects into order of increasing FROM
*/</comment>
<function><type><specifier>static</specifier> <name>EditDist3Cost</name> <modifier>*</modifier></type><name>editDist3CostSort</name><parameter_list>(<parameter><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name><name>ap</name><index>[<expr><literal type="number">60</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ap</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ap</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>editDist3CostMerge</name><argument_list>(<argument><expr><name><name>ap</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>ap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><name>mx</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>mx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ap</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>mx</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>ap</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>editDist3CostMerge</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name><name>ap</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Load all edit-distance weights from a table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>editDist3ConfigLoad</name><parameter_list>(
  <parameter><decl><type><name>EditDist3Config</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,      <comment type="block">/* The edit distance configuration to load */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,            <comment type="block">/* Load from this database */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTable</name></decl></parameter>      <comment type="block">/* Name of the table from which to load */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>rc2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLangPrev</name> <init>= <expr><operator>-</operator><literal type="number">9999</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>EditDist3Lang</name> <modifier>*</modifier></type><name>pLang</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT iLang, cFrom, cTo, iCost"</literal>
                         <literal type="string">" FROM \"%w\" WHERE iLang&gt;=0 ORDER BY iLang"</literal></expr></argument>, <argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>editDist3ConfigClear</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iLang</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFrom</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nFrom</name> <init>= <expr><ternary><condition><expr><name>zFrom</name></expr> ?</condition><then> <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTo</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nTo</name> <init>= <expr><ternary><condition><expr><name>zTo</name></expr> ?</condition><then> <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCost</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zFrom</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>nFrom</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zTo</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>nTo</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nFrom</name><operator>&gt;</operator><literal type="number">100</literal> <operator>||</operator> <name>nTo</name><operator>&gt;</operator><literal type="number">100</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCost</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCost</name><operator>&gt;=</operator><literal type="number">10000</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Costs above 10K are considered infinite */</comment>
    <if_stmt><if>if<condition>( <expr><name>pLang</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iLang</name><operator>!=</operator><name>iLangPrev</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>EditDist3Lang</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nLang</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLang</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nLang</name></name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLang</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLang</name><operator>-&gt;</operator><name>iLang</name></name> <operator>=</operator> <name>iLang</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLang</name><operator>-&gt;</operator><name>iInsCost</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLang</name><operator>-&gt;</operator><name>iDelCost</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLang</name><operator>-&gt;</operator><name>iSubCost</name></name> <operator>=</operator> <literal type="number">150</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLang</name><operator>-&gt;</operator><name>pCost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>iLangPrev</name> <operator>=</operator> <name>iLang</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nFrom</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>zFrom</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'?'</literal> <operator>&amp;&amp;</operator> <name>nTo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLang</name><operator>-&gt;</operator><name>iDelCost</name></name> <operator>=</operator> <name>iCost</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nFrom</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nTo</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>zTo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'?'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLang</name><operator>-&gt;</operator><name>iInsCost</name></name> <operator>=</operator> <name>iCost</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nFrom</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nTo</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>zFrom</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'?'</literal> <operator>&amp;&amp;</operator> <name><name>zTo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'?'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLang</name><operator>-&gt;</operator><name>iSubCost</name></name> <operator>=</operator> <name>iCost</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>pCost</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nExtra</name> <init>= <expr><name>nFrom</name> <operator>+</operator> <name>nTo</name> <operator>-</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nExtra</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nExtra</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pCost</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCost</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nExtra</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pCost</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pCost</name><operator>-&gt;</operator><name>nFrom</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>nFrom</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCost</name><operator>-&gt;</operator><name>nTo</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>nTo</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCost</name><operator>-&gt;</operator><name>iCost</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>iCost</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCost</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>nFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCost</name><operator>-&gt;</operator><name>a</name></name> <operator>+</operator> <name>nFrom</name></expr></argument>, <argument><expr><name>zTo</name></expr></argument>, <argument><expr><name>nTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCost</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pLang</name><operator>-&gt;</operator><name>pCost</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLang</name><operator>-&gt;</operator><name>pCost</name></name> <operator>=</operator> <name>pCost</name></expr>;</expr_stmt> 
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iLang</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>iLang</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iLang</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nLang</name></name></expr>;</condition> <incr><expr><name>iLang</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iLang</name></expr>]</index></name><operator>.</operator><name>pCost</name> <operator>=</operator> <call><name>editDist3CostSort</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iLang</name></expr>]</index></name><operator>.</operator><name>pCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the length (in bytes) of a utf-8 character.  Or return a maximum
** of N.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>utf8Len</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;</operator><literal type="number">0x7f</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xe0</literal><operator>)</operator><operator>==</operator><literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xf0</literal><operator>)</operator><operator>==</operator><literal type="number">0xe0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>len</name><operator>&gt;</operator><name>N</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <name>N</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE (non-zero) if the To side of the given cost matches
** the given string.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>matchTo</name><parameter_list>(<parameter><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nFrom</name></name></expr>]</index></name><operator>!=</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nTo</name></name><operator>&gt;</operator><name>n</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nFrom</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nTo</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE (non-zero) if the From side of the given cost matches
** the given string.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>matchFrom</name><parameter_list>(<parameter><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nFrom</name></name><operator>&lt;=</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nFrom</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nFrom</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE (non-zero) of the next FROM character and the next TO
** character are the same.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>matchFromTo</name><parameter_list>(
  <parameter><decl><type><name>EditDist3FromString</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>,  <comment type="block">/* Left hand string */</comment>
  <parameter><decl><type><name>int</name></type> <name>n1</name></decl></parameter>,                     <comment type="block">/* Index of comparison character on the left */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z2</name></decl></parameter>,             <comment type="block">/* Right-handl comparison character */</comment>
  <parameter><decl><type><name>int</name></type> <name>n2</name></decl></parameter>                      <comment type="block">/* Bytes remaining in z2[] */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>b1</name> <init>= <expr><name><name>pStr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>n1</name></expr>]</index></name><operator>.</operator><name>nByte</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>b1</name><operator>&gt;</operator><name>n2</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>b1</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>n1</name></expr>]</index></name><operator>!=</operator><name><name>z2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name></name><operator>+</operator><name>n1</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete an EditDist3FromString objecct
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>editDist3FromStringDelete</name><parameter_list>(<parameter><decl><type><name>EditDist3FromString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>apDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>apSubst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Create a EditDist3FromString object.
*/</comment>
<function><type><specifier>static</specifier> <name>EditDist3FromString</name> <modifier>*</modifier></type><name>editDist3FromStringNew</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>EditDist3Lang</name> <modifier>*</modifier></type><name>pLang</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>EditDist3FromString</name> <modifier>*</modifier></type><name>pStr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pStr</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pStr</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>n</name> <operator>+</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <operator>(</operator><name>EditDist3From</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pStr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pStr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>isPrefix</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>n</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>isPrefix</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>EditDist3From</name> <modifier>*</modifier></type><name>pFrom</name> <init>= <expr><operator>&amp;</operator><name><name>pStr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pFrom</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>nByte</name></name> <operator>=</operator> <call><name>utf8Len</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>n</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pLang</name><operator>-&gt;</operator><name>pCost</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nFrom</name></name><operator>&gt;</operator><name>n</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>matchFrom</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>n</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nTo</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>apNew</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>apDel</name></name></expr></argument>,
                                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>apNew</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>pFrom</name><operator>-&gt;</operator><name>nDel</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>apNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>apDel</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>apNew</name><index>[<expr><name><name>pFrom</name><operator>-&gt;</operator><name>nDel</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>apNew</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>apSubst</name></name></expr></argument>,
                                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>apNew</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>pFrom</name><operator>-&gt;</operator><name>nSubst</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>apNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>apSubst</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>apNew</name><index>[<expr><name><name>pFrom</name><operator>-&gt;</operator><name>nSubst</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>editDist3FromStringDelete</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pStr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>pStr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Update entry m[i] such that it is the minimum of its current value
** and m[j]+iCost.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>updateCost</name><parameter_list>(
  <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>m</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iCost</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>b</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCost</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCost</name><operator>&lt;</operator><literal type="number">10000</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>m</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+</operator> <name>iCost</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>b</name><operator>&lt;</operator><name><name>m</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>m</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** How much stack space (int bytes) to use for Wagner matrix in 
** editDist3Core().  If more space than this is required, the entire
** matrix is taken from the heap.  To reduce the load on the memory
** allocator, make this value as large as practical for the
** architecture in use.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SPELLFIX_STACKALLOC_SZ</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_SPELLFIX_STACKALLOC_SZ</name></cpp:macro>  <cpp:value>(1024)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Compute the edit distance between two strings.
**
** If an error occurs, return a negative number which is the error code.
**
** If pnMatch is not NULL, then *pnMatch is set to the number of characters
** (not bytes) in z2 that matched the search pattern in *pFrom. If pFrom does
** not contain the pattern for a prefix-search, then this is always the number
** of characters in z2. If pFrom does contain a prefix search pattern, then
** it is the number of characters in the prefix of z2 that was deemed to 
** match pFrom.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>editDist3Core</name><parameter_list>(
  <parameter><decl><type><name>EditDist3FromString</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>,  <comment type="block">/* The FROM string */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z2</name></decl></parameter>,              <comment type="block">/* The TO string */</comment>
  <parameter><decl><type><name>int</name></type> <name>n2</name></decl></parameter>,                      <comment type="block">/* Length of the TO string */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>EditDist3Lang</name> <modifier>*</modifier></type><name>pLang</name></decl></parameter>,  <comment type="block">/* Edit weights for a particular language ID */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnMatch</name></decl></parameter>                 <comment type="block">/* OUT: Characters in matched prefix */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i1</name></decl>, <decl><type ref="prev"/><name>b1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i2</name></decl>, <decl><type ref="prev"/><name>b2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>EditDist3FromString</name></type> <name>f</name> <init>= <expr><operator>*</operator><name>pFrom</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>EditDist3To</name> <modifier>*</modifier></type><name>a2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>pToFree</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>szRow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>nByte</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>unsigned</name> <name>int</name> <name><name>stackSpace</name><index>[<expr><name>SQLITE_SPELLFIX_STACKALLOC_SZ</name><operator>/</operator></expr></index></name>sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator>]</expr>;</expr_stmt>

  <comment type="block">/* allocate the Wagner matrix and the aTo[] array for the TO string */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name><name>f</name><operator>.</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><operator>(</operator><name>n2</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>~</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <name>n</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>a2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>n2</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&lt;=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>stackSpace</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>m</name> <operator>=</operator> <name>stackSpace</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pToFree</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>m</name> <operator>=</operator> <name>pToFree</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>m</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* Out of memory */</comment>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>a2</name> <operator>=</operator> <operator>(</operator><name>EditDist3To</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>m</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>a2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Fill in the a1[] matrix for all characters of the TO string */</comment>
  <for>for<control>(<init><expr><name>i2</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i2</name><operator>&lt;</operator><name>n2</name></expr>;</condition> <incr><expr><name>i2</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>a2</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>nByte</name> <operator>=</operator> <call><name>utf8Len</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>z2</name><index>[<expr><name>i2</name></expr>]</index></name></expr></argument>, <argument><expr><name>n2</name><operator>-</operator><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pLang</name><operator>-&gt;</operator><name>pCost</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>EditDist3Cost</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nFrom</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>i2</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nTo</name></name><operator>&gt;</operator><name>n2</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;</operator><name><name>z2</name><index>[<expr><name>i2</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>matchTo</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z2</name><operator>+</operator><name>i2</name></expr></argument>, <argument><expr><name>n2</name><operator>-</operator><name>i2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>a2</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>nIns</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>apNew</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>a2</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>apIns</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>apNew</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>a2</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>nIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>apNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Out of memory */</comment>
        <goto>goto <name>editDist3Abort</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>a2</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>apIns</name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>a2</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name><name>apIns</name><index>[<expr><name><name>a2</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>nIns</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <comment type="block">/* Prepare to compute the minimum edit distance */</comment>
  <expr_stmt><expr><name>szRow</name> <operator>=</operator> <name><name>f</name><operator>.</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><literal type="number">0x01</literal></expr></argument>, <argument><expr><operator>(</operator><name>n2</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>szRow</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* First fill in the top-row of the matrix with FROM deletion costs */</comment>
  <for>for<control>(<init><expr><name>i1</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i1</name><operator>&lt;</operator><name><name>f</name><operator>.</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i1</name> <operator>+=</operator> <name>b1</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <name><name>f</name><operator>.</operator><name>a</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>nByte</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>updateCost</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i1</name><operator>+</operator><name>b1</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name><name>pLang</name><operator>-&gt;</operator><name>iDelCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>f</name><operator>.</operator><name>a</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>nDel</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>f</name><operator>.</operator><name>a</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name><name>apDel</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>updateCost</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i1</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nFrom</name></name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <comment type="block">/* Fill in all subsequent rows, top-to-bottom, left-to-right */</comment>
  <for>for<control>(<init><expr><name>i2</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i2</name><operator>&lt;</operator><name>n2</name></expr>;</condition> <incr><expr><name>i2</name> <operator>+=</operator> <name>b2</name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rx</name></decl>;</decl_stmt>      <comment type="block">/* Starting index for current row */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>rxp</name></decl>;</decl_stmt>     <comment type="block">/* Starting index for previous row */</comment>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <name><name>a2</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>nByte</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rx</name> <operator>=</operator> <name>szRow</name><operator>*</operator><operator>(</operator><name>i2</name><operator>+</operator><name>b2</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rxp</name> <operator>=</operator> <name>szRow</name><operator>*</operator><name>i2</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>updateCost</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>rx</name></expr></argument>, <argument><expr><name>rxp</name></expr></argument>, <argument><expr><name><name>pLang</name><operator>-&gt;</operator><name>iInsCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>a2</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>nIns</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>a2</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name><name>apIns</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>updateCost</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>szRow</name><operator>*</operator><operator>(</operator><name>i2</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nTo</name></name><operator>)</operator></expr></argument>, <argument><expr><name>rxp</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for<control>(<init><expr><name>i1</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i1</name><operator>&lt;</operator><name><name>f</name><operator>.</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i1</name><operator>+=</operator><name>b1</name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>cx</name></decl>;</decl_stmt>    <comment type="block">/* Index of current cell */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>cxp</name></decl>;</decl_stmt>   <comment type="block">/* Index of cell immediately to the left */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>cxd</name></decl>;</decl_stmt>   <comment type="block">/* Index of cell to the left and one row above */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>cxu</name></decl>;</decl_stmt>   <comment type="block">/* Index of cell immediately above */</comment>
      <expr_stmt><expr><name>b1</name> <operator>=</operator> <name><name>f</name><operator>.</operator><name>a</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>nByte</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cxp</name> <operator>=</operator> <name>rx</name> <operator>+</operator> <name>i1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cx</name> <operator>=</operator> <name>cxp</name> <operator>+</operator> <name>b1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cxd</name> <operator>=</operator> <name>rxp</name> <operator>+</operator> <name>i1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cxu</name> <operator>=</operator> <name>cxd</name> <operator>+</operator> <name>b1</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>updateCost</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cxp</name></expr></argument>, <argument><expr><name><name>pLang</name><operator>-&gt;</operator><name>iDelCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>f</name><operator>.</operator><name>a</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>nDel</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>f</name><operator>.</operator><name>a</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name><name>apDel</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>updateCost</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>cxp</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nFrom</name></name></expr></argument>, <argument><expr><name>cxp</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>updateCost</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cxu</name></expr></argument>, <argument><expr><name><name>pLang</name><operator>-&gt;</operator><name>iInsCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>matchFromTo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>z2</name><operator>+</operator><name>i2</name></expr></argument>, <argument><expr><name>n2</name><operator>-</operator><name>i2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>updateCost</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cxd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>updateCost</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cxd</name></expr></argument>, <argument><expr><name><name>pLang</name><operator>-&gt;</operator><name>iSubCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name><name>f</name><operator>.</operator><name>a</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>nSubst</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>f</name><operator>.</operator><name>a</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name><name>apSubst</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>matchTo</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z2</name><operator>+</operator><name>i2</name></expr></argument>, <argument><expr><name>n2</name><operator>-</operator><name>i2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>updateCost</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>cxd</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nFrom</name></name><operator>+</operator><name>szRow</name><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nTo</name></name></expr></argument>, <argument><expr><name>cxd</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iCost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
  </block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>  <comment type="block">/* Enable for debugging */</comment>
  printf("         ^");
  for(i1=0; i1&lt;f.n; i1++) printf(" %c-%2x", f.z[i1], f.z[i1]&amp;0xff);
  printf("\n   ^:");
  for(i1=0; i1&lt;szRow; i1++){
    int v = m[i1];
    if( v&gt;9999 ) printf(" ****");
    else         printf(" %4d", v);
  }
  printf("\n");
  for(i2=0; i2&lt;n2; i2++){
    printf("%c-%02x:", z2[i2], z2[i2]&amp;0xff);
    for(i1=0; i1&lt;szRow; i1++){
      int v = m[(i2+1)*szRow+i1];
      if( v&gt;9999 ) printf(" ****");
      else         printf(" %4d", v);
    }
    printf("\n");
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Free memory allocations and return the result */</comment>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>m</name><index>[<expr><name>szRow</name><operator>*</operator><operator>(</operator><name>n2</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name>n2</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>f</name><operator>.</operator><name>isPrefix</name></name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i2</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i2</name><operator>&lt;=</operator><name>n2</name></expr>;</condition> <incr><expr><name>i2</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>b</name> <init>= <expr><name><name>m</name><index>[<expr><name>szRow</name><operator>*</operator><name>i2</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>b</name><operator>&lt;=</operator><name>res</name></expr> )</condition><block>{<block_content> 
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name>i2</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pnMatch</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nExtra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>z2</name><index>[<expr><name>k</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nExtra</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>pnMatch</name> <operator>=</operator> <name>n</name> <operator>-</operator> <name>nExtra</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>editDist3Abort</name>:</label>
  <for>for<control>(<init><expr><name>i2</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i2</name><operator>&lt;</operator><name>n2</name></expr>;</condition> <incr><expr><name>i2</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>a2</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>apIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pToFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Get an appropriate EditDist3Lang object.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>EditDist3Lang</name> <modifier>*</modifier></type><name>editDist3FindLang</name><parameter_list>(
  <parameter><decl><type><name>EditDist3Config</name> <modifier>*</modifier></type><name>pConfig</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iLang</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pConfig</name><operator>-&gt;</operator><name>nLang</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pConfig</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iLang</name><operator>==</operator><name>iLang</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>&amp;</operator><name><name>pConfig</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>&amp;</operator><name>editDist3Lang</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Function:    editdist3(A,B,iLang)
**              editdist3(tablename)
**
** Return the cost of transforming string A into string B using edit
** weights for iLang.
**
** The second form loads edit weights into memory from a table.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>editDist3SqlFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>EditDist3Config</name> <modifier>*</modifier></type><name>pConfig</name> <init>= <expr><operator>(</operator><name>EditDist3Config</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTable</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>editDist3ConfigLoad</name><argument_list>(<argument><expr><name>pConfig</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zB</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nA</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nB</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iLang</name> <init>= <expr><ternary><condition><expr><name>argc</name><operator>==</operator><literal type="number">3</literal></expr> ?</condition><then> <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>EditDist3Lang</name> <modifier>*</modifier></type><name>pLang</name> <init>= <expr><call><name>editDist3FindLang</name><argument_list>(<argument><expr><name>pConfig</name></expr></argument>, <argument><expr><name>iLang</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EditDist3FromString</name> <modifier>*</modifier></type><name>pFrom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>dist</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pFrom</name> <operator>=</operator> <call><name>editDist3FromStringNew</name><argument_list>(<argument><expr><name>pLang</name></expr></argument>, <argument><expr><name>zA</name></expr></argument>, <argument><expr><name>nA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pFrom</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>editDist3Core</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>zB</name></expr></argument>, <argument><expr><name>nB</name></expr></argument>, <argument><expr><name>pLang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>editDist3FromStringDelete</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>dist</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt> 
</block_content>}</block></function>

<comment type="block">/*
** Register the editDist3 function with SQLite
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>editDist3Install</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>EditDist3Config</name> <modifier>*</modifier></type><name>pConfig</name> <init>= <expr><call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pConfig</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pConfig</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pConfig</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pConfig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"editdist3"</literal></expr></argument>,
              <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name></expr></argument>, <argument><expr><name>pConfig</name></expr></argument>,
              <argument><expr><name>editDist3SqlFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"editdist3"</literal></expr></argument>,
                <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name></expr></argument>, <argument><expr><name>pConfig</name></expr></argument>,
                <argument><expr><name>editDist3SqlFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"editdist3"</literal></expr></argument>,
                <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name></expr></argument>, <argument><expr><name>pConfig</name></expr></argument>,
                <argument><expr><name>editDist3SqlFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>editDist3ConfigDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pConfig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* End configurable cost unicode edit distance routines
******************************************************************************
******************************************************************************
** Begin transliterate unicode-to-ascii implementation
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_AMALGAMATION</name></expr></cpp:if>
<comment type="block">/*
** This lookup table is used to help decode the first byte of
** a multi-byte UTF8 character.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>sqlite3Utf8Trans1</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x02</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x04</literal></expr>, <expr><literal type="number">0x05</literal></expr>, <expr><literal type="number">0x06</literal></expr>, <expr><literal type="number">0x07</literal></expr>,
  <expr><literal type="number">0x08</literal></expr>, <expr><literal type="number">0x09</literal></expr>, <expr><literal type="number">0x0a</literal></expr>, <expr><literal type="number">0x0b</literal></expr>, <expr><literal type="number">0x0c</literal></expr>, <expr><literal type="number">0x0d</literal></expr>, <expr><literal type="number">0x0e</literal></expr>, <expr><literal type="number">0x0f</literal></expr>,
  <expr><literal type="number">0x10</literal></expr>, <expr><literal type="number">0x11</literal></expr>, <expr><literal type="number">0x12</literal></expr>, <expr><literal type="number">0x13</literal></expr>, <expr><literal type="number">0x14</literal></expr>, <expr><literal type="number">0x15</literal></expr>, <expr><literal type="number">0x16</literal></expr>, <expr><literal type="number">0x17</literal></expr>,
  <expr><literal type="number">0x18</literal></expr>, <expr><literal type="number">0x19</literal></expr>, <expr><literal type="number">0x1a</literal></expr>, <expr><literal type="number">0x1b</literal></expr>, <expr><literal type="number">0x1c</literal></expr>, <expr><literal type="number">0x1d</literal></expr>, <expr><literal type="number">0x1e</literal></expr>, <expr><literal type="number">0x1f</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x02</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x04</literal></expr>, <expr><literal type="number">0x05</literal></expr>, <expr><literal type="number">0x06</literal></expr>, <expr><literal type="number">0x07</literal></expr>,
  <expr><literal type="number">0x08</literal></expr>, <expr><literal type="number">0x09</literal></expr>, <expr><literal type="number">0x0a</literal></expr>, <expr><literal type="number">0x0b</literal></expr>, <expr><literal type="number">0x0c</literal></expr>, <expr><literal type="number">0x0d</literal></expr>, <expr><literal type="number">0x0e</literal></expr>, <expr><literal type="number">0x0f</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x02</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x04</literal></expr>, <expr><literal type="number">0x05</literal></expr>, <expr><literal type="number">0x06</literal></expr>, <expr><literal type="number">0x07</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x02</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return the value of the first UTF-8 character in the string.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>utf8Read</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

  <comment type="block">/* All callers to this routine (in the current implementation)
  ** always have n&gt;0. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="number">0xc0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>sqlite3Utf8Trans1</name><index>[<expr><name>c</name><operator>-</operator><literal type="number">0xc0</literal></expr>]</index></name></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>i</name><operator>&lt;</operator><name>n</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><literal type="number">0x3f</literal> <operator>&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of characters in the utf-8 string in the nIn byte
** buffer pointed to by zIn.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>utf8Charlen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nChar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nIn</name></expr>;</condition> <incr><expr><name>nChar</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>utf8Read</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nIn</name><operator>-</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>nChar</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>Transliteration</name></name></type> <name>Transliteration</name>;</typedef>
<struct>struct <name>Transliteration</name> <block>{
 <decl_stmt><decl><type><name>unsigned</name> <name>short</name> <name>int</name></type> <name>cFrom</name></decl>;</decl_stmt>
 <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>cTo0</name></decl>, <decl><type ref="prev"/><name>cTo1</name></decl>, <decl><type ref="prev"/><name>cTo2</name></decl>, <decl><type ref="prev"/><name>cTo3</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SPELLFIX_5BYTE_MAPPINGS</name></cpp:ifdef>
 <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>cTo4</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<comment type="block">/*
** Table of translations from unicode characters into ASCII.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Transliteration</name></type> <name><name>translit</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><literal type="number">0x00A0</literal></expr>,  <expr><literal type="number">0x20</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to   */</comment>
  <expr><block>{ <expr><literal type="number">0x00B5</literal></expr>,  <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to u */</comment>
  <expr><block>{ <expr><literal type="number">0x00C0</literal></expr>,  <expr><literal type="number">0x41</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to A */</comment>
  <expr><block>{ <expr><literal type="number">0x00C1</literal></expr>,  <expr><literal type="number">0x41</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to A */</comment>
  <expr><block>{ <expr><literal type="number">0x00C2</literal></expr>,  <expr><literal type="number">0x41</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to A */</comment>
  <expr><block>{ <expr><literal type="number">0x00C3</literal></expr>,  <expr><literal type="number">0x41</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to A */</comment>
  <expr><block>{ <expr><literal type="number">0x00C4</literal></expr>,  <expr><literal type="number">0x41</literal></expr>, <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Ae */</comment>
  <expr><block>{ <expr><literal type="number">0x00C5</literal></expr>,  <expr><literal type="number">0x41</literal></expr>, <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Aa */</comment>
  <expr><block>{ <expr><literal type="number">0x00C6</literal></expr>,  <expr><literal type="number">0x41</literal></expr>, <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to AE */</comment>
  <expr><block>{ <expr><literal type="number">0x00C7</literal></expr>,  <expr><literal type="number">0x43</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to C */</comment>
  <expr><block>{ <expr><literal type="number">0x00C8</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x00C9</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x00CA</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x00CB</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x00CC</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x00CD</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x00CE</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x00CF</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x00D0</literal></expr>,  <expr><literal type="number">0x44</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to D */</comment>
  <expr><block>{ <expr><literal type="number">0x00D1</literal></expr>,  <expr><literal type="number">0x4E</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to N */</comment>
  <expr><block>{ <expr><literal type="number">0x00D2</literal></expr>,  <expr><literal type="number">0x4F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to O */</comment>
  <expr><block>{ <expr><literal type="number">0x00D3</literal></expr>,  <expr><literal type="number">0x4F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to O */</comment>
  <expr><block>{ <expr><literal type="number">0x00D4</literal></expr>,  <expr><literal type="number">0x4F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to O */</comment>
  <expr><block>{ <expr><literal type="number">0x00D5</literal></expr>,  <expr><literal type="number">0x4F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to O */</comment>
  <expr><block>{ <expr><literal type="number">0x00D6</literal></expr>,  <expr><literal type="number">0x4F</literal></expr>, <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Oe */</comment>
  <expr><block>{ <expr><literal type="number">0x00D7</literal></expr>,  <expr><literal type="number">0x78</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to x */</comment>
  <expr><block>{ <expr><literal type="number">0x00D8</literal></expr>,  <expr><literal type="number">0x4F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to O */</comment>
  <expr><block>{ <expr><literal type="number">0x00D9</literal></expr>,  <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to U */</comment>
  <expr><block>{ <expr><literal type="number">0x00DA</literal></expr>,  <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to U */</comment>
  <expr><block>{ <expr><literal type="number">0x00DB</literal></expr>,  <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to U */</comment>
  <expr><block>{ <expr><literal type="number">0x00DC</literal></expr>,  <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Ue */</comment>
  <expr><block>{ <expr><literal type="number">0x00DD</literal></expr>,  <expr><literal type="number">0x59</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Y */</comment>
  <expr><block>{ <expr><literal type="number">0x00DE</literal></expr>,  <expr><literal type="number">0x54</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Th */</comment>
  <expr><block>{ <expr><literal type="number">0x00DF</literal></expr>,  <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to ss */</comment>
  <expr><block>{ <expr><literal type="number">0x00E0</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to a */</comment>
  <expr><block>{ <expr><literal type="number">0x00E1</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to a */</comment>
  <expr><block>{ <expr><literal type="number">0x00E2</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to a */</comment>
  <expr><block>{ <expr><literal type="number">0x00E3</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to a */</comment>
  <expr><block>{ <expr><literal type="number">0x00E4</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to ae */</comment>
  <expr><block>{ <expr><literal type="number">0x00E5</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to aa */</comment>
  <expr><block>{ <expr><literal type="number">0x00E6</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to ae */</comment>
  <expr><block>{ <expr><literal type="number">0x00E7</literal></expr>,  <expr><literal type="number">0x63</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to c */</comment>
  <expr><block>{ <expr><literal type="number">0x00E8</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x00E9</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x00EA</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x00EB</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x00EC</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x00ED</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x00EE</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x00EF</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x00F0</literal></expr>,  <expr><literal type="number">0x64</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to d */</comment>
  <expr><block>{ <expr><literal type="number">0x00F1</literal></expr>,  <expr><literal type="number">0x6E</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to n */</comment>
  <expr><block>{ <expr><literal type="number">0x00F2</literal></expr>,  <expr><literal type="number">0x6F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to o */</comment>
  <expr><block>{ <expr><literal type="number">0x00F3</literal></expr>,  <expr><literal type="number">0x6F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to o */</comment>
  <expr><block>{ <expr><literal type="number">0x00F4</literal></expr>,  <expr><literal type="number">0x6F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to o */</comment>
  <expr><block>{ <expr><literal type="number">0x00F5</literal></expr>,  <expr><literal type="number">0x6F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to o */</comment>
  <expr><block>{ <expr><literal type="number">0x00F6</literal></expr>,  <expr><literal type="number">0x6F</literal></expr>, <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to oe */</comment>
  <expr><block>{ <expr><literal type="number">0x00F7</literal></expr>,  <expr><literal type="number">0x3A</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to : */</comment>
  <expr><block>{ <expr><literal type="number">0x00F8</literal></expr>,  <expr><literal type="number">0x6F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to o */</comment>
  <expr><block>{ <expr><literal type="number">0x00F9</literal></expr>,  <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to u */</comment>
  <expr><block>{ <expr><literal type="number">0x00FA</literal></expr>,  <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to u */</comment>
  <expr><block>{ <expr><literal type="number">0x00FB</literal></expr>,  <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to u */</comment>
  <expr><block>{ <expr><literal type="number">0x00FC</literal></expr>,  <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to ue */</comment>
  <expr><block>{ <expr><literal type="number">0x00FD</literal></expr>,  <expr><literal type="number">0x79</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to y */</comment>
  <expr><block>{ <expr><literal type="number">0x00FE</literal></expr>,  <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to th */</comment>
  <expr><block>{ <expr><literal type="number">0x00FF</literal></expr>,  <expr><literal type="number">0x79</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to y */</comment>
  <expr><block>{ <expr><literal type="number">0x0100</literal></expr>,  <expr><literal type="number">0x41</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to A */</comment>
  <expr><block>{ <expr><literal type="number">0x0101</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to a */</comment>
  <expr><block>{ <expr><literal type="number">0x0102</literal></expr>,  <expr><literal type="number">0x41</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to A */</comment>
  <expr><block>{ <expr><literal type="number">0x0103</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to a */</comment>
  <expr><block>{ <expr><literal type="number">0x0104</literal></expr>,  <expr><literal type="number">0x41</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to A */</comment>
  <expr><block>{ <expr><literal type="number">0x0105</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to a */</comment>
  <expr><block>{ <expr><literal type="number">0x0106</literal></expr>,  <expr><literal type="number">0x43</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to C */</comment>
  <expr><block>{ <expr><literal type="number">0x0107</literal></expr>,  <expr><literal type="number">0x63</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to c */</comment>
  <expr><block>{ <expr><literal type="number">0x0108</literal></expr>,  <expr><literal type="number">0x43</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Ch */</comment>
  <expr><block>{ <expr><literal type="number">0x0109</literal></expr>,  <expr><literal type="number">0x63</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to ch */</comment>
  <expr><block>{ <expr><literal type="number">0x010A</literal></expr>,  <expr><literal type="number">0x43</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to C */</comment>
  <expr><block>{ <expr><literal type="number">0x010B</literal></expr>,  <expr><literal type="number">0x63</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to c */</comment>
  <expr><block>{ <expr><literal type="number">0x010C</literal></expr>,  <expr><literal type="number">0x43</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to C */</comment>
  <expr><block>{ <expr><literal type="number">0x010D</literal></expr>,  <expr><literal type="number">0x63</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to c */</comment>
  <expr><block>{ <expr><literal type="number">0x010E</literal></expr>,  <expr><literal type="number">0x44</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to D */</comment>
  <expr><block>{ <expr><literal type="number">0x010F</literal></expr>,  <expr><literal type="number">0x64</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to d */</comment>
  <expr><block>{ <expr><literal type="number">0x0110</literal></expr>,  <expr><literal type="number">0x44</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to D */</comment>
  <expr><block>{ <expr><literal type="number">0x0111</literal></expr>,  <expr><literal type="number">0x64</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to d */</comment>
  <expr><block>{ <expr><literal type="number">0x0112</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x0113</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x0114</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x0115</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x0116</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x0117</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x0118</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x0119</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x011A</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x011B</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x011C</literal></expr>,  <expr><literal type="number">0x47</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Gh */</comment>
  <expr><block>{ <expr><literal type="number">0x011D</literal></expr>,  <expr><literal type="number">0x67</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to gh */</comment>
  <expr><block>{ <expr><literal type="number">0x011E</literal></expr>,  <expr><literal type="number">0x47</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to G */</comment>
  <expr><block>{ <expr><literal type="number">0x011F</literal></expr>,  <expr><literal type="number">0x67</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to g */</comment>
  <expr><block>{ <expr><literal type="number">0x0120</literal></expr>,  <expr><literal type="number">0x47</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to G */</comment>
  <expr><block>{ <expr><literal type="number">0x0121</literal></expr>,  <expr><literal type="number">0x67</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to g */</comment>
  <expr><block>{ <expr><literal type="number">0x0122</literal></expr>,  <expr><literal type="number">0x47</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to G */</comment>
  <expr><block>{ <expr><literal type="number">0x0123</literal></expr>,  <expr><literal type="number">0x67</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to g */</comment>
  <expr><block>{ <expr><literal type="number">0x0124</literal></expr>,  <expr><literal type="number">0x48</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Hh */</comment>
  <expr><block>{ <expr><literal type="number">0x0125</literal></expr>,  <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to hh */</comment>
  <expr><block>{ <expr><literal type="number">0x0126</literal></expr>,  <expr><literal type="number">0x48</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to H */</comment>
  <expr><block>{ <expr><literal type="number">0x0127</literal></expr>,  <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to h */</comment>
  <expr><block>{ <expr><literal type="number">0x0128</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x0129</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x012A</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x012B</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x012C</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x012D</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x012E</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x012F</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x0130</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x0131</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x0132</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x4A</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to IJ */</comment>
  <expr><block>{ <expr><literal type="number">0x0133</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x6A</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to ij */</comment>
  <expr><block>{ <expr><literal type="number">0x0134</literal></expr>,  <expr><literal type="number">0x4A</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Jh */</comment>
  <expr><block>{ <expr><literal type="number">0x0135</literal></expr>,  <expr><literal type="number">0x6A</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to jh */</comment>
  <expr><block>{ <expr><literal type="number">0x0136</literal></expr>,  <expr><literal type="number">0x4B</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to K */</comment>
  <expr><block>{ <expr><literal type="number">0x0137</literal></expr>,  <expr><literal type="number">0x6B</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to k */</comment>
  <expr><block>{ <expr><literal type="number">0x0138</literal></expr>,  <expr><literal type="number">0x6B</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to k */</comment>
  <expr><block>{ <expr><literal type="number">0x0139</literal></expr>,  <expr><literal type="number">0x4C</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to L */</comment>
  <expr><block>{ <expr><literal type="number">0x013A</literal></expr>,  <expr><literal type="number">0x6C</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to l */</comment>
  <expr><block>{ <expr><literal type="number">0x013B</literal></expr>,  <expr><literal type="number">0x4C</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to L */</comment>
  <expr><block>{ <expr><literal type="number">0x013C</literal></expr>,  <expr><literal type="number">0x6C</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to l */</comment>
  <expr><block>{ <expr><literal type="number">0x013D</literal></expr>,  <expr><literal type="number">0x4C</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to L */</comment>
  <expr><block>{ <expr><literal type="number">0x013E</literal></expr>,  <expr><literal type="number">0x6C</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to l */</comment>
  <expr><block>{ <expr><literal type="number">0x013F</literal></expr>,  <expr><literal type="number">0x4C</literal></expr>, <expr><literal type="number">0x2E</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to L. */</comment>
  <expr><block>{ <expr><literal type="number">0x0140</literal></expr>,  <expr><literal type="number">0x6C</literal></expr>, <expr><literal type="number">0x2E</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to l. */</comment>
  <expr><block>{ <expr><literal type="number">0x0141</literal></expr>,  <expr><literal type="number">0x4C</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to L */</comment>
  <expr><block>{ <expr><literal type="number">0x0142</literal></expr>,  <expr><literal type="number">0x6C</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to l */</comment>
  <expr><block>{ <expr><literal type="number">0x0143</literal></expr>,  <expr><literal type="number">0x4E</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to N */</comment>
  <expr><block>{ <expr><literal type="number">0x0144</literal></expr>,  <expr><literal type="number">0x6E</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to n */</comment>
  <expr><block>{ <expr><literal type="number">0x0145</literal></expr>,  <expr><literal type="number">0x4E</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to N */</comment>
  <expr><block>{ <expr><literal type="number">0x0146</literal></expr>,  <expr><literal type="number">0x6E</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to n */</comment>
  <expr><block>{ <expr><literal type="number">0x0147</literal></expr>,  <expr><literal type="number">0x4E</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to N */</comment>
  <expr><block>{ <expr><literal type="number">0x0148</literal></expr>,  <expr><literal type="number">0x6E</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to n */</comment>
  <expr><block>{ <expr><literal type="number">0x0149</literal></expr>,  <expr><literal type="number">0x27</literal></expr>, <expr><literal type="number">0x6E</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to 'n */</comment>
  <expr><block>{ <expr><literal type="number">0x014A</literal></expr>,  <expr><literal type="number">0x4E</literal></expr>, <expr><literal type="number">0x47</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to NG */</comment>
  <expr><block>{ <expr><literal type="number">0x014B</literal></expr>,  <expr><literal type="number">0x6E</literal></expr>, <expr><literal type="number">0x67</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to ng */</comment>
  <expr><block>{ <expr><literal type="number">0x014C</literal></expr>,  <expr><literal type="number">0x4F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to O */</comment>
  <expr><block>{ <expr><literal type="number">0x014D</literal></expr>,  <expr><literal type="number">0x6F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to o */</comment>
  <expr><block>{ <expr><literal type="number">0x014E</literal></expr>,  <expr><literal type="number">0x4F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to O */</comment>
  <expr><block>{ <expr><literal type="number">0x014F</literal></expr>,  <expr><literal type="number">0x6F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to o */</comment>
  <expr><block>{ <expr><literal type="number">0x0150</literal></expr>,  <expr><literal type="number">0x4F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to O */</comment>
  <expr><block>{ <expr><literal type="number">0x0151</literal></expr>,  <expr><literal type="number">0x6F</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to o */</comment>
  <expr><block>{ <expr><literal type="number">0x0152</literal></expr>,  <expr><literal type="number">0x4F</literal></expr>, <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to OE */</comment>
  <expr><block>{ <expr><literal type="number">0x0153</literal></expr>,  <expr><literal type="number">0x6F</literal></expr>, <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to oe */</comment>
  <expr><block>{ <expr><literal type="number">0x0154</literal></expr>,  <expr><literal type="number">0x52</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to R */</comment>
  <expr><block>{ <expr><literal type="number">0x0155</literal></expr>,  <expr><literal type="number">0x72</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to r */</comment>
  <expr><block>{ <expr><literal type="number">0x0156</literal></expr>,  <expr><literal type="number">0x52</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to R */</comment>
  <expr><block>{ <expr><literal type="number">0x0157</literal></expr>,  <expr><literal type="number">0x72</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to r */</comment>
  <expr><block>{ <expr><literal type="number">0x0158</literal></expr>,  <expr><literal type="number">0x52</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to R */</comment>
  <expr><block>{ <expr><literal type="number">0x0159</literal></expr>,  <expr><literal type="number">0x72</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to r */</comment>
  <expr><block>{ <expr><literal type="number">0x015A</literal></expr>,  <expr><literal type="number">0x53</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to S */</comment>
  <expr><block>{ <expr><literal type="number">0x015B</literal></expr>,  <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to s */</comment>
  <expr><block>{ <expr><literal type="number">0x015C</literal></expr>,  <expr><literal type="number">0x53</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Sh */</comment>
  <expr><block>{ <expr><literal type="number">0x015D</literal></expr>,  <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to sh */</comment>
  <expr><block>{ <expr><literal type="number">0x015E</literal></expr>,  <expr><literal type="number">0x53</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to S */</comment>
  <expr><block>{ <expr><literal type="number">0x015F</literal></expr>,  <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to s */</comment>
  <expr><block>{ <expr><literal type="number">0x0160</literal></expr>,  <expr><literal type="number">0x53</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to S */</comment>
  <expr><block>{ <expr><literal type="number">0x0161</literal></expr>,  <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to s */</comment>
  <expr><block>{ <expr><literal type="number">0x0162</literal></expr>,  <expr><literal type="number">0x54</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to T */</comment>
  <expr><block>{ <expr><literal type="number">0x0163</literal></expr>,  <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to t */</comment>
  <expr><block>{ <expr><literal type="number">0x0164</literal></expr>,  <expr><literal type="number">0x54</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to T */</comment>
  <expr><block>{ <expr><literal type="number">0x0165</literal></expr>,  <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to t */</comment>
  <expr><block>{ <expr><literal type="number">0x0166</literal></expr>,  <expr><literal type="number">0x54</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to T */</comment>
  <expr><block>{ <expr><literal type="number">0x0167</literal></expr>,  <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to t */</comment>
  <expr><block>{ <expr><literal type="number">0x0168</literal></expr>,  <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to U */</comment>
  <expr><block>{ <expr><literal type="number">0x0169</literal></expr>,  <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to u */</comment>
  <expr><block>{ <expr><literal type="number">0x016A</literal></expr>,  <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to U */</comment>
  <expr><block>{ <expr><literal type="number">0x016B</literal></expr>,  <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to u */</comment>
  <expr><block>{ <expr><literal type="number">0x016C</literal></expr>,  <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to U */</comment>
  <expr><block>{ <expr><literal type="number">0x016D</literal></expr>,  <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to u */</comment>
  <expr><block>{ <expr><literal type="number">0x016E</literal></expr>,  <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to U */</comment>
  <expr><block>{ <expr><literal type="number">0x016F</literal></expr>,  <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to u */</comment>
  <expr><block>{ <expr><literal type="number">0x0170</literal></expr>,  <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to U */</comment>
  <expr><block>{ <expr><literal type="number">0x0171</literal></expr>,  <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to u */</comment>
  <expr><block>{ <expr><literal type="number">0x0172</literal></expr>,  <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to U */</comment>
  <expr><block>{ <expr><literal type="number">0x0173</literal></expr>,  <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to u */</comment>
  <expr><block>{ <expr><literal type="number">0x0174</literal></expr>,  <expr><literal type="number">0x57</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to W */</comment>
  <expr><block>{ <expr><literal type="number">0x0175</literal></expr>,  <expr><literal type="number">0x77</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to w */</comment>
  <expr><block>{ <expr><literal type="number">0x0176</literal></expr>,  <expr><literal type="number">0x59</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Y */</comment>
  <expr><block>{ <expr><literal type="number">0x0177</literal></expr>,  <expr><literal type="number">0x79</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to y */</comment>
  <expr><block>{ <expr><literal type="number">0x0178</literal></expr>,  <expr><literal type="number">0x59</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Y */</comment>
  <expr><block>{ <expr><literal type="number">0x0179</literal></expr>,  <expr><literal type="number">0x5A</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Z */</comment>
  <expr><block>{ <expr><literal type="number">0x017A</literal></expr>,  <expr><literal type="number">0x7A</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to z */</comment>
  <expr><block>{ <expr><literal type="number">0x017B</literal></expr>,  <expr><literal type="number">0x5A</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Z */</comment>
  <expr><block>{ <expr><literal type="number">0x017C</literal></expr>,  <expr><literal type="number">0x7A</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to z */</comment>
  <expr><block>{ <expr><literal type="number">0x017D</literal></expr>,  <expr><literal type="number">0x5A</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Z */</comment>
  <expr><block>{ <expr><literal type="number">0x017E</literal></expr>,  <expr><literal type="number">0x7A</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to z */</comment>
  <expr><block>{ <expr><literal type="number">0x017F</literal></expr>,  <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to s */</comment>
  <expr><block>{ <expr><literal type="number">0x0192</literal></expr>,  <expr><literal type="number">0x66</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to f */</comment>
  <expr><block>{ <expr><literal type="number">0x0218</literal></expr>,  <expr><literal type="number">0x53</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to S */</comment>
  <expr><block>{ <expr><literal type="number">0x0219</literal></expr>,  <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to s */</comment>
  <expr><block>{ <expr><literal type="number">0x021A</literal></expr>,  <expr><literal type="number">0x54</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to T */</comment>
  <expr><block>{ <expr><literal type="number">0x021B</literal></expr>,  <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to t */</comment>
  <expr><block>{ <expr><literal type="number">0x0386</literal></expr>,  <expr><literal type="number">0x41</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to A */</comment>
  <expr><block>{ <expr><literal type="number">0x0388</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x0389</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x038A</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x038C</literal></expr>,  <expr><literal type="number">0x4f</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to O */</comment>
  <expr><block>{ <expr><literal type="number">0x038E</literal></expr>,  <expr><literal type="number">0x59</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Y */</comment>
  <expr><block>{ <expr><literal type="number">0x038F</literal></expr>,  <expr><literal type="number">0x4f</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to O */</comment>
  <expr><block>{ <expr><literal type="number">0x0390</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x0391</literal></expr>,  <expr><literal type="number">0x41</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to A */</comment>
  <expr><block>{ <expr><literal type="number">0x0392</literal></expr>,  <expr><literal type="number">0x42</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to B */</comment>
  <expr><block>{ <expr><literal type="number">0x0393</literal></expr>,  <expr><literal type="number">0x47</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to G */</comment>
  <expr><block>{ <expr><literal type="number">0x0394</literal></expr>,  <expr><literal type="number">0x44</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to D */</comment>
  <expr><block>{ <expr><literal type="number">0x0395</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x0396</literal></expr>,  <expr><literal type="number">0x5a</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Z */</comment>
  <expr><block>{ <expr><literal type="number">0x0397</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x0398</literal></expr>,  <expr><literal type="number">0x54</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Th */</comment>
  <expr><block>{ <expr><literal type="number">0x0399</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x039A</literal></expr>,  <expr><literal type="number">0x4b</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to K */</comment>
  <expr><block>{ <expr><literal type="number">0x039B</literal></expr>,  <expr><literal type="number">0x4c</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to L */</comment>
  <expr><block>{ <expr><literal type="number">0x039C</literal></expr>,  <expr><literal type="number">0x4d</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to M */</comment>
  <expr><block>{ <expr><literal type="number">0x039D</literal></expr>,  <expr><literal type="number">0x4e</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to N */</comment>
  <expr><block>{ <expr><literal type="number">0x039E</literal></expr>,  <expr><literal type="number">0x58</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to X */</comment>
  <expr><block>{ <expr><literal type="number">0x039F</literal></expr>,  <expr><literal type="number">0x4f</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to O */</comment>
  <expr><block>{ <expr><literal type="number">0x03A0</literal></expr>,  <expr><literal type="number">0x50</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to P */</comment>
  <expr><block>{ <expr><literal type="number">0x03A1</literal></expr>,  <expr><literal type="number">0x52</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to R */</comment>
  <expr><block>{ <expr><literal type="number">0x03A3</literal></expr>,  <expr><literal type="number">0x53</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to S */</comment>
  <expr><block>{ <expr><literal type="number">0x03A4</literal></expr>,  <expr><literal type="number">0x54</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to T */</comment>
  <expr><block>{ <expr><literal type="number">0x03A5</literal></expr>,  <expr><literal type="number">0x59</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Y */</comment>
  <expr><block>{ <expr><literal type="number">0x03A6</literal></expr>,  <expr><literal type="number">0x46</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to F */</comment>
  <expr><block>{ <expr><literal type="number">0x03A7</literal></expr>,  <expr><literal type="number">0x43</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Ch */</comment>
  <expr><block>{ <expr><literal type="number">0x03A8</literal></expr>,  <expr><literal type="number">0x50</literal></expr>, <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Ps */</comment>
  <expr><block>{ <expr><literal type="number">0x03A9</literal></expr>,  <expr><literal type="number">0x4f</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to O */</comment>
  <expr><block>{ <expr><literal type="number">0x03AA</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x03AB</literal></expr>,  <expr><literal type="number">0x59</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Y */</comment>
  <expr><block>{ <expr><literal type="number">0x03AC</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to a */</comment>
  <expr><block>{ <expr><literal type="number">0x03AD</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x03AE</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x03AF</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x03B1</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to a */</comment>
  <expr><block>{ <expr><literal type="number">0x03B2</literal></expr>,  <expr><literal type="number">0x62</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to b */</comment>
  <expr><block>{ <expr><literal type="number">0x03B3</literal></expr>,  <expr><literal type="number">0x67</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to g */</comment>
  <expr><block>{ <expr><literal type="number">0x03B4</literal></expr>,  <expr><literal type="number">0x64</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to d */</comment>
  <expr><block>{ <expr><literal type="number">0x03B5</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x03B6</literal></expr>,  <expr><literal type="number">0x7a</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to z */</comment>
  <expr><block>{ <expr><literal type="number">0x03B7</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x03B8</literal></expr>,  <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to th */</comment>
  <expr><block>{ <expr><literal type="number">0x03B9</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x03BA</literal></expr>,  <expr><literal type="number">0x6b</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to k */</comment>
  <expr><block>{ <expr><literal type="number">0x03BB</literal></expr>,  <expr><literal type="number">0x6c</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to l */</comment>
  <expr><block>{ <expr><literal type="number">0x03BC</literal></expr>,  <expr><literal type="number">0x6d</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to m */</comment>
  <expr><block>{ <expr><literal type="number">0x03BD</literal></expr>,  <expr><literal type="number">0x6e</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to n */</comment>
  <expr><block>{ <expr><literal type="number">0x03BE</literal></expr>,  <expr><literal type="number">0x78</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to x */</comment>
  <expr><block>{ <expr><literal type="number">0x03BF</literal></expr>,  <expr><literal type="number">0x6f</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to o */</comment>
  <expr><block>{ <expr><literal type="number">0x03C0</literal></expr>,  <expr><literal type="number">0x70</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to p */</comment>
  <expr><block>{ <expr><literal type="number">0x03C1</literal></expr>,  <expr><literal type="number">0x72</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to r */</comment>
  <expr><block>{ <expr><literal type="number">0x03C3</literal></expr>,  <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to s */</comment>
  <expr><block>{ <expr><literal type="number">0x03C4</literal></expr>,  <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to t */</comment>
  <expr><block>{ <expr><literal type="number">0x03C5</literal></expr>,  <expr><literal type="number">0x79</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to y */</comment>
  <expr><block>{ <expr><literal type="number">0x03C6</literal></expr>,  <expr><literal type="number">0x66</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to f */</comment>
  <expr><block>{ <expr><literal type="number">0x03C7</literal></expr>,  <expr><literal type="number">0x63</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to ch */</comment>
  <expr><block>{ <expr><literal type="number">0x03C8</literal></expr>,  <expr><literal type="number">0x70</literal></expr>, <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to ps */</comment>
  <expr><block>{ <expr><literal type="number">0x03C9</literal></expr>,  <expr><literal type="number">0x6f</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to o */</comment>
  <expr><block>{ <expr><literal type="number">0x03CA</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x03CB</literal></expr>,  <expr><literal type="number">0x79</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to y */</comment>
  <expr><block>{ <expr><literal type="number">0x03CC</literal></expr>,  <expr><literal type="number">0x6f</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to o */</comment>
  <expr><block>{ <expr><literal type="number">0x03CD</literal></expr>,  <expr><literal type="number">0x79</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to y */</comment>
  <expr><block>{ <expr><literal type="number">0x03CE</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x0400</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x0401</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x0402</literal></expr>,  <expr><literal type="number">0x44</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to D */</comment>
  <expr><block>{ <expr><literal type="number">0x0403</literal></expr>,  <expr><literal type="number">0x47</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to G */</comment>
  <expr><block>{ <expr><literal type="number">0x0404</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x0405</literal></expr>,  <expr><literal type="number">0x5a</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Z */</comment>
  <expr><block>{ <expr><literal type="number">0x0406</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x0407</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x0408</literal></expr>,  <expr><literal type="number">0x4a</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to J */</comment>
  <expr><block>{ <expr><literal type="number">0x0409</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x040A</literal></expr>,  <expr><literal type="number">0x4e</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to N */</comment>
  <expr><block>{ <expr><literal type="number">0x040B</literal></expr>,  <expr><literal type="number">0x44</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to D */</comment>
  <expr><block>{ <expr><literal type="number">0x040C</literal></expr>,  <expr><literal type="number">0x4b</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to K */</comment>
  <expr><block>{ <expr><literal type="number">0x040D</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x040E</literal></expr>,  <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to U */</comment>
  <expr><block>{ <expr><literal type="number">0x040F</literal></expr>,  <expr><literal type="number">0x44</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to D */</comment>
  <expr><block>{ <expr><literal type="number">0x0410</literal></expr>,  <expr><literal type="number">0x41</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to A */</comment>
  <expr><block>{ <expr><literal type="number">0x0411</literal></expr>,  <expr><literal type="number">0x42</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to B */</comment>
  <expr><block>{ <expr><literal type="number">0x0412</literal></expr>,  <expr><literal type="number">0x56</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to V */</comment>
  <expr><block>{ <expr><literal type="number">0x0413</literal></expr>,  <expr><literal type="number">0x47</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to G */</comment>
  <expr><block>{ <expr><literal type="number">0x0414</literal></expr>,  <expr><literal type="number">0x44</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to D */</comment>
  <expr><block>{ <expr><literal type="number">0x0415</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x0416</literal></expr>,  <expr><literal type="number">0x5a</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Zh */</comment>
  <expr><block>{ <expr><literal type="number">0x0417</literal></expr>,  <expr><literal type="number">0x5a</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Z */</comment>
  <expr><block>{ <expr><literal type="number">0x0418</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x0419</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to I */</comment>
  <expr><block>{ <expr><literal type="number">0x041A</literal></expr>,  <expr><literal type="number">0x4b</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to K */</comment>
  <expr><block>{ <expr><literal type="number">0x041B</literal></expr>,  <expr><literal type="number">0x4c</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to L */</comment>
  <expr><block>{ <expr><literal type="number">0x041C</literal></expr>,  <expr><literal type="number">0x4d</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to M */</comment>
  <expr><block>{ <expr><literal type="number">0x041D</literal></expr>,  <expr><literal type="number">0x4e</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to N */</comment>
  <expr><block>{ <expr><literal type="number">0x041E</literal></expr>,  <expr><literal type="number">0x4f</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to O */</comment>
  <expr><block>{ <expr><literal type="number">0x041F</literal></expr>,  <expr><literal type="number">0x50</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to P */</comment>
  <expr><block>{ <expr><literal type="number">0x0420</literal></expr>,  <expr><literal type="number">0x52</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to R */</comment>
  <expr><block>{ <expr><literal type="number">0x0421</literal></expr>,  <expr><literal type="number">0x53</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to S */</comment>
  <expr><block>{ <expr><literal type="number">0x0422</literal></expr>,  <expr><literal type="number">0x54</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to T */</comment>
  <expr><block>{ <expr><literal type="number">0x0423</literal></expr>,  <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to U */</comment>
  <expr><block>{ <expr><literal type="number">0x0424</literal></expr>,  <expr><literal type="number">0x46</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to F */</comment>
  <expr><block>{ <expr><literal type="number">0x0425</literal></expr>,  <expr><literal type="number">0x4b</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Kh */</comment>
  <expr><block>{ <expr><literal type="number">0x0426</literal></expr>,  <expr><literal type="number">0x54</literal></expr>, <expr><literal type="number">0x63</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Tc */</comment>
  <expr><block>{ <expr><literal type="number">0x0427</literal></expr>,  <expr><literal type="number">0x43</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Ch */</comment>
  <expr><block>{ <expr><literal type="number">0x0428</literal></expr>,  <expr><literal type="number">0x53</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Sh */</comment>
  <expr><block>{ <expr><literal type="number">0x0429</literal></expr>,  <expr><literal type="number">0x53</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x63</literal></expr>, <expr><literal type="number">0x68</literal></expr> }</block></expr>,  <comment type="block">/*  to Shch */</comment>
  <expr><block>{ <expr><literal type="number">0x042A</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to A */</comment>
  <expr><block>{ <expr><literal type="number">0x042B</literal></expr>,  <expr><literal type="number">0x59</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Y */</comment>
  <expr><block>{ <expr><literal type="number">0x042C</literal></expr>,  <expr><literal type="number">0x59</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Y */</comment>
  <expr><block>{ <expr><literal type="number">0x042D</literal></expr>,  <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to E */</comment>
  <expr><block>{ <expr><literal type="number">0x042E</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Iu */</comment>
  <expr><block>{ <expr><literal type="number">0x042F</literal></expr>,  <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Ia */</comment>
  <expr><block>{ <expr><literal type="number">0x0430</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to a */</comment>
  <expr><block>{ <expr><literal type="number">0x0431</literal></expr>,  <expr><literal type="number">0x62</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to b */</comment>
  <expr><block>{ <expr><literal type="number">0x0432</literal></expr>,  <expr><literal type="number">0x76</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to v */</comment>
  <expr><block>{ <expr><literal type="number">0x0433</literal></expr>,  <expr><literal type="number">0x67</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to g */</comment>
  <expr><block>{ <expr><literal type="number">0x0434</literal></expr>,  <expr><literal type="number">0x64</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to d */</comment>
  <expr><block>{ <expr><literal type="number">0x0435</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x0436</literal></expr>,  <expr><literal type="number">0x7a</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to zh */</comment>
  <expr><block>{ <expr><literal type="number">0x0437</literal></expr>,  <expr><literal type="number">0x7a</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to z */</comment>
  <expr><block>{ <expr><literal type="number">0x0438</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x0439</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x043A</literal></expr>,  <expr><literal type="number">0x6b</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to k */</comment>
  <expr><block>{ <expr><literal type="number">0x043B</literal></expr>,  <expr><literal type="number">0x6c</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to l */</comment>
  <expr><block>{ <expr><literal type="number">0x043C</literal></expr>,  <expr><literal type="number">0x6d</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to m */</comment>
  <expr><block>{ <expr><literal type="number">0x043D</literal></expr>,  <expr><literal type="number">0x6e</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to n */</comment>
  <expr><block>{ <expr><literal type="number">0x043E</literal></expr>,  <expr><literal type="number">0x6f</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to o */</comment>
  <expr><block>{ <expr><literal type="number">0x043F</literal></expr>,  <expr><literal type="number">0x70</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to p */</comment>
  <expr><block>{ <expr><literal type="number">0x0440</literal></expr>,  <expr><literal type="number">0x72</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to r */</comment>
  <expr><block>{ <expr><literal type="number">0x0441</literal></expr>,  <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to s */</comment>
  <expr><block>{ <expr><literal type="number">0x0442</literal></expr>,  <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to t */</comment>
  <expr><block>{ <expr><literal type="number">0x0443</literal></expr>,  <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to u */</comment>
  <expr><block>{ <expr><literal type="number">0x0444</literal></expr>,  <expr><literal type="number">0x66</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to f */</comment>
  <expr><block>{ <expr><literal type="number">0x0445</literal></expr>,  <expr><literal type="number">0x6b</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to kh */</comment>
  <expr><block>{ <expr><literal type="number">0x0446</literal></expr>,  <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x63</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to tc */</comment>
  <expr><block>{ <expr><literal type="number">0x0447</literal></expr>,  <expr><literal type="number">0x63</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to ch */</comment>
  <expr><block>{ <expr><literal type="number">0x0448</literal></expr>,  <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to sh */</comment>
  <expr><block>{ <expr><literal type="number">0x0449</literal></expr>,  <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x63</literal></expr>, <expr><literal type="number">0x68</literal></expr> }</block></expr>,  <comment type="block">/*  to shch */</comment>
  <expr><block>{ <expr><literal type="number">0x044A</literal></expr>,  <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to a */</comment>
  <expr><block>{ <expr><literal type="number">0x044B</literal></expr>,  <expr><literal type="number">0x79</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to y */</comment>
  <expr><block>{ <expr><literal type="number">0x044C</literal></expr>,  <expr><literal type="number">0x79</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to y */</comment>
  <expr><block>{ <expr><literal type="number">0x044D</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x044E</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to iu */</comment>
  <expr><block>{ <expr><literal type="number">0x044F</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to ia */</comment>
  <expr><block>{ <expr><literal type="number">0x0450</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x0451</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x0452</literal></expr>,  <expr><literal type="number">0x64</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to d */</comment>
  <expr><block>{ <expr><literal type="number">0x0453</literal></expr>,  <expr><literal type="number">0x67</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to g */</comment>
  <expr><block>{ <expr><literal type="number">0x0454</literal></expr>,  <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to e */</comment>
  <expr><block>{ <expr><literal type="number">0x0455</literal></expr>,  <expr><literal type="number">0x7a</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to z */</comment>
  <expr><block>{ <expr><literal type="number">0x0456</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x0457</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x0458</literal></expr>,  <expr><literal type="number">0x6a</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to j */</comment>
  <expr><block>{ <expr><literal type="number">0x0459</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x045A</literal></expr>,  <expr><literal type="number">0x6e</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to n */</comment>
  <expr><block>{ <expr><literal type="number">0x045B</literal></expr>,  <expr><literal type="number">0x64</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to d */</comment>
  <expr><block>{ <expr><literal type="number">0x045C</literal></expr>,  <expr><literal type="number">0x6b</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to k */</comment>
  <expr><block>{ <expr><literal type="number">0x045D</literal></expr>,  <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to i */</comment>
  <expr><block>{ <expr><literal type="number">0x045E</literal></expr>,  <expr><literal type="number">0x75</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to u */</comment>
  <expr><block>{ <expr><literal type="number">0x045F</literal></expr>,  <expr><literal type="number">0x64</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to d */</comment>
  <expr><block>{ <expr><literal type="number">0x1E02</literal></expr>,  <expr><literal type="number">0x42</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to B */</comment>
  <expr><block>{ <expr><literal type="number">0x1E03</literal></expr>,  <expr><literal type="number">0x62</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to b */</comment>
  <expr><block>{ <expr><literal type="number">0x1E0A</literal></expr>,  <expr><literal type="number">0x44</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to D */</comment>
  <expr><block>{ <expr><literal type="number">0x1E0B</literal></expr>,  <expr><literal type="number">0x64</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to d */</comment>
  <expr><block>{ <expr><literal type="number">0x1E1E</literal></expr>,  <expr><literal type="number">0x46</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to F */</comment>
  <expr><block>{ <expr><literal type="number">0x1E1F</literal></expr>,  <expr><literal type="number">0x66</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to f */</comment>
  <expr><block>{ <expr><literal type="number">0x1E40</literal></expr>,  <expr><literal type="number">0x4D</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to M */</comment>
  <expr><block>{ <expr><literal type="number">0x1E41</literal></expr>,  <expr><literal type="number">0x6D</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to m */</comment>
  <expr><block>{ <expr><literal type="number">0x1E56</literal></expr>,  <expr><literal type="number">0x50</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to P */</comment>
  <expr><block>{ <expr><literal type="number">0x1E57</literal></expr>,  <expr><literal type="number">0x70</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to p */</comment>
  <expr><block>{ <expr><literal type="number">0x1E60</literal></expr>,  <expr><literal type="number">0x53</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to S */</comment>
  <expr><block>{ <expr><literal type="number">0x1E61</literal></expr>,  <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to s */</comment>
  <expr><block>{ <expr><literal type="number">0x1E6A</literal></expr>,  <expr><literal type="number">0x54</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to T */</comment>
  <expr><block>{ <expr><literal type="number">0x1E6B</literal></expr>,  <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to t */</comment>
  <expr><block>{ <expr><literal type="number">0x1E80</literal></expr>,  <expr><literal type="number">0x57</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to W */</comment>
  <expr><block>{ <expr><literal type="number">0x1E81</literal></expr>,  <expr><literal type="number">0x77</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to w */</comment>
  <expr><block>{ <expr><literal type="number">0x1E82</literal></expr>,  <expr><literal type="number">0x57</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to W */</comment>
  <expr><block>{ <expr><literal type="number">0x1E83</literal></expr>,  <expr><literal type="number">0x77</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to w */</comment>
  <expr><block>{ <expr><literal type="number">0x1E84</literal></expr>,  <expr><literal type="number">0x57</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to W */</comment>
  <expr><block>{ <expr><literal type="number">0x1E85</literal></expr>,  <expr><literal type="number">0x77</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to w */</comment>
  <expr><block>{ <expr><literal type="number">0x1EF2</literal></expr>,  <expr><literal type="number">0x59</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to Y */</comment>
  <expr><block>{ <expr><literal type="number">0x1EF3</literal></expr>,  <expr><literal type="number">0x79</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to y */</comment>
  <expr><block>{ <expr><literal type="number">0xFB00</literal></expr>,  <expr><literal type="number">0x66</literal></expr>, <expr><literal type="number">0x66</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to ff */</comment>
  <expr><block>{ <expr><literal type="number">0xFB01</literal></expr>,  <expr><literal type="number">0x66</literal></expr>, <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to fi */</comment>
  <expr><block>{ <expr><literal type="number">0xFB02</literal></expr>,  <expr><literal type="number">0x66</literal></expr>, <expr><literal type="number">0x6C</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to fl */</comment>
  <expr><block>{ <expr><literal type="number">0xFB05</literal></expr>,  <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to st */</comment>
  <expr><block>{ <expr><literal type="number">0xFB06</literal></expr>,  <expr><literal type="number">0x73</literal></expr>, <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr> }</block></expr>,  <comment type="block">/*  to st */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>Transliteration</name> <modifier>*</modifier></type><name>spellfixFindTranslit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pxTop</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pxTop</name> <operator>=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>translit</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>translit</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>translit</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert the input string from UTF-8 into pure ASCII by converting
** all non-ASCII characters to some combination of characters in the
** ASCII subset.
**
** The returned string might contain more characters than the input.
**
** Space to hold the returned string comes from sqlite3_malloc() and
** should be freed by the caller.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>transliterate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SPELLFIX_5BYTE_MAPPINGS</name></cpp:ifdef>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>nIn</name><operator>*</operator><literal type="number">5</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>nIn</name><operator>*</operator><literal type="number">4</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>sz</name></decl>, <decl><type ref="prev"/><name>nOut</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>nIn</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf8Read</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zIn</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nIn</name> <operator>-=</operator> <name>sz</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;=</operator><literal type="number">127</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>nOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>xTop</name></decl>, <decl><type ref="prev"/><name>xBtm</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>Transliteration</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>spellfixFindTranslit</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xTop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>xBtm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>xTop</name><operator>&gt;=</operator><name>xBtm</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>xTop</name> <operator>+</operator> <name>xBtm</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cFrom</name><operator>==</operator><name>c</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>nOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cTo0</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cTo1</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>nOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cTo1</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cTo2</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>nOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cTo2</name></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cTo3</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>nOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cTo3</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SPELLFIX_5BYTE_MAPPINGS</name></cpp:ifdef>
                <if_stmt><if>if<condition>( <expr><name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cTo4</name></expr> )</condition><block>{<block_content>
                  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>nOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cTo4</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_SPELLFIX_5BYTE_MAPPINGS */</comment>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cFrom</name><operator>&gt;</operator><name>c</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>xTop</name> <operator>=</operator> <name>x</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>xBtm</name> <operator>=</operator> <name>x</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>c</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>nOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>nOut</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>zOut</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of characters in the shortest prefix of the input
** string that transliterates to an ASCII string nTrans bytes or longer.
** Or, if the transliteration of the input string is less than nTrans
** bytes in size, return the number of characters in the input string.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>translen_to_charlen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTrans</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>c</name></decl>, <decl><type ref="prev"/><name>sz</name></decl>, <decl><type ref="prev"/><name>nOut</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nChar</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>i</name> <operator>=</operator> <name>nOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>nChar</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nIn</name> <operator>&amp;&amp;</operator> <name>nOut</name><operator>&lt;</operator><name>nTrans</name></expr>;</condition> <incr><expr><name>nChar</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf8Read</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nIn</name><operator>-</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>nOut</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="number">128</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>xTop</name></decl>, <decl><type ref="prev"/><name>xBtm</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>Transliteration</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>spellfixFindTranslit</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xTop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>xBtm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>xTop</name><operator>&gt;=</operator><name>xBtm</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>xTop</name> <operator>+</operator> <name>xBtm</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cFrom</name><operator>==</operator><name>c</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cTo1</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>nOut</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cTo2</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>nOut</name><operator>++</operator></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cTo3</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>nOut</name><operator>++</operator></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>tbl</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>cFrom</name><operator>&gt;</operator><name>c</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>xTop</name> <operator>=</operator> <name>x</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>xBtm</name> <operator>=</operator> <name>x</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>nChar</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
**    spellfix1_translit(X)
**
** Convert a string that contains non-ASCII Roman characters into 
** pure ASCII.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>transliterateSqlFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nIn</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><call><name>transliterate</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zOut</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
**    spellfix1_scriptcode(X)
**
** Try to determine the dominant script used by the word X and return
** its ISO 15924 numeric code.
**
** The current implementation only understands the following scripts:
**
**    215  (Latin)
**    220  (Cyrillic)
**    200  (Greek)
**
** This routine will return 998 if the input X contains characters from
** two or more of the above scripts or 999 if X contains no characters
** from any of the above scripts.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>scriptCodeSqlFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nIn</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>scriptMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>seenDigit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SCRIPT_LATIN</name></cpp:macro>       <cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SCRIPT_CYRILLIC</name></cpp:macro>    <cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SCRIPT_GREEK</name></cpp:macro>       <cpp:value>0x0004</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SCRIPT_HEBREW</name></cpp:macro>      <cpp:value>0x0008</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SCRIPT_ARABIC</name></cpp:macro>      <cpp:value>0x0010</cpp:value></cpp:define>

  <while>while<condition>( <expr><name>nIn</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf8Read</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zIn</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nIn</name> <operator>-=</operator> <name>sz</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;</operator><literal type="number">0x02af</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="number">0x80</literal> <operator>||</operator> <name><name>midClass</name><index>[<expr><name>c</name><operator>&amp;</operator><literal type="number">0x7f</literal></expr>]</index></name><operator>&lt;</operator><name>CCLASS_DIGIT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>scriptMask</name> <operator>|=</operator> <name>SCRIPT_LATIN</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>seenDigit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="number">0x0400</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="number">0x04ff</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>scriptMask</name> <operator>|=</operator> <name>SCRIPT_CYRILLIC</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="number">0x0386</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="number">0x03ce</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>scriptMask</name> <operator>|=</operator> <name>SCRIPT_GREEK</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="number">0x0590</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="number">0x05ff</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>scriptMask</name> <operator>|=</operator> <name>SCRIPT_HEBREW</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="number">0x0600</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="number">0x06ff</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>scriptMask</name> <operator>|=</operator> <name>SCRIPT_ARABIC</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>scriptMask</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>seenDigit</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>scriptMask</name> <operator>=</operator> <name>SCRIPT_LATIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <switch>switch<condition>( <expr><name>scriptMask</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case>                <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">999</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>SCRIPT_LATIN</name></expr>:</case>     <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">215</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>SCRIPT_CYRILLIC</name></expr>:</case>  <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">220</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>SCRIPT_GREEK</name></expr>:</case>     <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">200</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>SCRIPT_HEBREW</name></expr>:</case>    <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">125</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>SCRIPT_ARABIC</name></expr>:</case>    <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">160</literal></expr>;</expr_stmt> <break>break;</break>
    <default>default:</default>               <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">998</literal></expr>;</expr_stmt> <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* End transliterate
******************************************************************************
******************************************************************************
** Begin spellfix1 virtual table.
*/</comment>

<comment type="block">/* Maximum length of a phonehash used for querying the shadow table */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_MX_HASH</name></cpp:macro>  <cpp:value>32</cpp:value></cpp:define>

<comment type="block">/* Maximum number of hash strings to examine per query */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_MX_RUN</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>spellfix1_vtab</name></name></type> <name>spellfix1_vtab</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>spellfix1_cursor</name></name></type> <name>spellfix1_cursor</name>;</typedef>

<comment type="block">/* Fuzzy-search virtual table object */</comment>
<struct>struct <name>spellfix1_vtab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>         <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>               <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDbName</name></decl>;</decl_stmt>             <comment type="block">/* Name of database holding this table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTableName</name></decl>;</decl_stmt>          <comment type="block">/* Name of the virtual table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCostTable</name></decl>;</decl_stmt>          <comment type="block">/* Table holding edit-distance cost numbers */</comment>
  <decl_stmt><decl><type><name>EditDist3Config</name> <modifier>*</modifier></type><name>pConfig3</name></decl>;</decl_stmt> <comment type="block">/* Parsed edit distance costs */</comment>
}</block>;</struct>

<comment type="block">/* Fuzzy-search cursor object */</comment>
<struct>struct <name>spellfix1_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>    <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>spellfix1_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl>;</decl_stmt>       <comment type="block">/* The table to which this cursor belongs */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>              <comment type="block">/* rhs of MATCH clause */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idxNum</name></decl>;</decl_stmt>                  <comment type="block">/* idxNum value passed to xFilter() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRow</name></decl>;</decl_stmt>                    <comment type="block">/* Number of rows of content */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>                  <comment type="block">/* Number of allocated rows */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iRow</name></decl>;</decl_stmt>                    <comment type="block">/* Current row of content */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLang</name></decl>;</decl_stmt>                   <comment type="block">/* Value of the langid= constraint */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTop</name></decl>;</decl_stmt>                    <comment type="block">/* Value of the top= constraint */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iScope</name></decl>;</decl_stmt>                  <comment type="block">/* Value of the scope= constraint */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSearch</name></decl>;</decl_stmt>                 <comment type="block">/* Number of vocabulary items checked */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pFullScan</name></decl>;</decl_stmt>     <comment type="block">/* Shadow query for a full table scan */</comment>
  <struct>struct <name>spellfix1_row</name> <block>{       <comment type="block">/* For each row of content */</comment>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRowid</name></decl>;</decl_stmt>         <comment type="block">/* Rowid for this row */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWord</name></decl>;</decl_stmt>                  <comment type="block">/* Text for this row */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iRank</name></decl>;</decl_stmt>                    <comment type="block">/* Rank for this row */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iDistance</name></decl>;</decl_stmt>                <comment type="block">/* Distance from pattern for this row */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iScore</name></decl>;</decl_stmt>                   <comment type="block">/* Score for sorting */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iMatchlen</name></decl>;</decl_stmt>                <comment type="block">/* Value of matchlen column (or -1) */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zHash</name><index>[<expr><name>SPELLFIX_MX_HASH</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* the phonehash used for this match */</comment>
  }</block> <decl><modifier>*</modifier><name>a</name></decl>;</struct> 
}</block>;</struct>

<comment type="block">/*
** Construct one or more SQL statements from the format string given
** and then evaluate those statements. The success code is written
** into *pRc.
**
** If *pRc is initially non-zero then this routine is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>spellfix1DbExec</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>,              <comment type="block">/* Success code */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,           <comment type="block">/* Database in which to run SQL */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>,   <comment type="block">/* Format string for SQL */</comment>
  <parameter><decl><type><modifier>...</modifier></type></decl></parameter>                    <comment type="block">/* Arguments to the format string */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** xDisconnect/xDestroy method for the fuzzy-search module.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Uninit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>isDestroy</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>spellfix1_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>spellfix1_vtab</name><operator>*</operator><operator>)</operator><name>pVTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>isDestroy</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>spellfix1DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"DROP TABLE IF EXISTS \"%w\".\"%w_vocab\""</literal></expr></argument>,
                  <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDbName</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>editDist3ConfigDelete</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pConfig3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zCostTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Disconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>spellfix1Uninit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Destroy</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>spellfix1Uninit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Make a copy of a string.  Remove leading and trailing whitespace
** and dequote it.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>spellfix1Dequote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>  <comment type="block">/* The parser will never leave spaces at the end */</comment>
  while( i&gt;0 &amp;&amp; isspace(zOut[i-1]) ){ i--; }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zOut</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\''</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>zOut</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>zOut</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>zOut</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>c</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zOut</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>c</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zOut</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** xConnect/xCreate method for the spellfix1 module. Arguments are:
**
**   argv[0]   -&gt; module name  ("spellfix1")
**   argv[1]   -&gt; database name
**   argv[2]   -&gt; table name
**   argv[3].. -&gt; optional arguments (i.e. "edit_cost_table" parameter)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Init</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>isCreate</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVTab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>spellfix1_vtab</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <comment type="block">/* const char *zModule = argv[0]; // not used */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTableName</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDbName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>nDbName</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zDbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nDbName</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zDbName</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zDbName</name></name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>, <argument><expr><name>nDbName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zTableName</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zTableName</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_VTAB_INNOCUOUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, 
           <argument><expr><literal type="string">"CREATE TABLE x(word,rank,distance,langid, "</literal>
           <literal type="string">"score, matchlen, phonehash HIDDEN, "</literal>
           <literal type="string">"top HIDDEN, scope HIDDEN, srchcnt HIDDEN, "</literal>
           <literal type="string">"soundslike HIDDEN, command HIDDEN)"</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_COL_WORD</name></cpp:macro>            <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_COL_RANK</name></cpp:macro>            <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_COL_DISTANCE</name></cpp:macro>        <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_COL_LANGID</name></cpp:macro>          <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_COL_SCORE</name></cpp:macro>           <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_COL_MATCHLEN</name></cpp:macro>        <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_COL_PHONEHASH</name></cpp:macro>       <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_COL_TOP</name></cpp:macro>             <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_COL_SCOPE</name></cpp:macro>           <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_COL_SRCHCNT</name></cpp:macro>         <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_COL_SOUNDSLIKE</name></cpp:macro>     <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_COL_COMMAND</name></cpp:macro>        <cpp:value>11</cpp:value></cpp:define>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>isCreate</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>spellfix1DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>,
         <argument><expr><literal type="string">"CREATE TABLE IF NOT EXISTS \"%w\".\"%w_vocab\"(\n"</literal>
         <literal type="string">"  id INTEGER PRIMARY KEY,\n"</literal>
         <literal type="string">"  rank INT,\n"</literal>
         <literal type="string">"  langid INT,\n"</literal>
         <literal type="string">"  word TEXT,\n"</literal>
         <literal type="string">"  k1 TEXT,\n"</literal>
         <literal type="string">"  k2 TEXT\n"</literal>
         <literal type="string">");\n"</literal></expr></argument>,
         <argument><expr><name>zDbName</name></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>spellfix1DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>,
         <argument><expr><literal type="string">"CREATE INDEX IF NOT EXISTS \"%w\".\"%w_vocab_index_langid_k2\" "</literal>
            <literal type="string">"ON \"%w_vocab\"(langid,k2);"</literal></expr></argument>,
         <argument><expr><name>zDbName</name></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"edit_cost_table="</literal></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>zCostTable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zCostTable</name></name> <operator>=</operator> <call><name>spellfix1Dequote</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zCostTable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"bad argument to spellfix1(): \"%s\""</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt> 
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>&amp;&amp;</operator> <name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppVTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>spellfix1Uninit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppVTab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name> <operator>*</operator><operator>)</operator><name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The xConnect and xCreate methods
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Connect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVTab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>spellfix1Init</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ppVTab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Create</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVTab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>spellfix1Init</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ppVTab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Clear all of the content from a cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>spellfix1ResetCursor</name><parameter_list>(<parameter><decl><type><name>spellfix1_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nSearch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pFullScan</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pFullScan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pFullScan</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Resize the cursor to hold up to N rows of content
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>spellfix1ResizeCursor</name><parameter_list>(<parameter><decl><type><name>spellfix1_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>spellfix1_row</name></name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>N</name><operator>&gt;=</operator><name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aNew</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aNew</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>N</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>spellfix1ResetCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Close a fuzzy-search cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Close</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>spellfix1_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>spellfix1_cursor</name> <operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>spellfix1ResetCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>spellfix1ResizeCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_IDXNUM_MATCH</name></cpp:macro>  <cpp:value>0x01</cpp:value></cpp:define>         <comment type="block">/* word MATCH $str */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_IDXNUM_LANGID</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>         <comment type="block">/* langid == $langid */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_IDXNUM_TOP</name></cpp:macro>    <cpp:value>0x04</cpp:value></cpp:define>         <comment type="block">/* top = $top */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_IDXNUM_SCOPE</name></cpp:macro>  <cpp:value>0x08</cpp:value></cpp:define>         <comment type="block">/* scope = $scope */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_IDXNUM_DISTLT</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define>         <comment type="block">/* distance &lt; $distance */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_IDXNUM_DISTLE</name></cpp:macro> <cpp:value>0x20</cpp:value></cpp:define>         <comment type="block">/* distance &lt;= $distance */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_IDXNUM_ROWID</name></cpp:macro>  <cpp:value>0x40</cpp:value></cpp:define>         <comment type="block">/* rowid = $rowid */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELLFIX_IDXNUM_DIST</name></cpp:macro>   <cpp:value>(0x10|0x20)</cpp:value></cpp:define>  <comment type="block">/* DISTLT and DISTLE */</comment>

<comment type="block">/*
**
** The plan number is a bitmask of the SPELLFIX_IDXNUM_* values defined
** above.
**
** filter.argv[*] values contains $str, $langid, $top, $scope and $rowid
** if specified and in that order.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1BestIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iPlan</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLangTerm</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iTopTerm</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iScopeTerm</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDistTerm</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iRowidTerm</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pConstraint</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* Terms of the form:  word MATCH $str */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <name>SPELLFIX_IDXNUM_MATCH</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>SPELLFIX_COL_WORD</name>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_MATCH</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <name>SPELLFIX_IDXNUM_MATCH</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Terms of the form:  langid = $langid  */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <name>SPELLFIX_IDXNUM_LANGID</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>SPELLFIX_COL_LANGID</name>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <name>SPELLFIX_IDXNUM_LANGID</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iLangTerm</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Terms of the form:  top = $top */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <name>SPELLFIX_IDXNUM_TOP</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>SPELLFIX_COL_TOP</name>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <name>SPELLFIX_IDXNUM_TOP</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iTopTerm</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Terms of the form:  scope = $scope */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <name>SPELLFIX_IDXNUM_SCOPE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>SPELLFIX_COL_SCOPE</name>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <name>SPELLFIX_IDXNUM_SCOPE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iScopeTerm</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Terms of the form:  distance &lt; $dist or distance &lt;= $dist */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <name>SPELLFIX_IDXNUM_DIST</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>SPELLFIX_COL_DISTANCE</name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LT</name>
          <operator>||</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LE</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <name>SPELLFIX_IDXNUM_DISTLT</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <name>SPELLFIX_IDXNUM_DISTLE</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>iDistTerm</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Terms of the form:  distance &lt; $dist or distance &lt;= $dist */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <name>SPELLFIX_IDXNUM_ROWID</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <name>SPELLFIX_IDXNUM_ROWID</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iRowidTerm</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>iPlan</name><operator>&amp;</operator><name>SPELLFIX_IDXNUM_MATCH</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>iPlan</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nOrderBy</name></name><operator>==</operator><literal type="number">1</literal>
     <operator>&amp;&amp;</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iColumn</name><operator>==</operator><name>SPELLFIX_COL_SCORE</name>
     <operator>&amp;&amp;</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>desc</name><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>orderByConsumed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Default order by iScore */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iPlan</name><operator>&amp;</operator><name>SPELLFIX_IDXNUM_LANGID</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iLangTerm</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>idx</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iLangTerm</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iPlan</name><operator>&amp;</operator><name>SPELLFIX_IDXNUM_TOP</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iTopTerm</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>idx</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iTopTerm</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iPlan</name><operator>&amp;</operator><name>SPELLFIX_IDXNUM_SCOPE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iScopeTerm</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>idx</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iScopeTerm</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iPlan</name><operator>&amp;</operator><name>SPELLFIX_IDXNUM_DIST</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iDistTerm</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>idx</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iDistTerm</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1e5</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <name>SPELLFIX_IDXNUM_ROWID</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>SPELLFIX_IDXNUM_ROWID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iRowidTerm</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iRowidTerm</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1e50</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a new fuzzy-search cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Open</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>spellfix1_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>spellfix1_vtab</name><operator>*</operator><operator>)</operator><name>pVTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>spellfix1_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pVTab</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Adjust a distance measurement by the words rank in order to show
** preference to common words.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Score</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iDistance</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iRank</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iLog2</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>iLog2</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iRank</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>iLog2</name><operator>++</operator></expr><operator>,</operator> <expr><name>iRank</name><operator>&gt;&gt;=</operator><literal type="number">1</literal></expr></incr>)</control><block>{<block_content/>}</block></for>
  <return>return <expr><name>iDistance</name> <operator>+</operator> <literal type="number">32</literal> <operator>-</operator> <name>iLog2</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare two spellfix1_row objects for sorting purposes in qsort() such
** that they sort in order of increasing distance.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_CDECL</name></type> <name>spellfix1RowCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>A</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>spellfix1_row</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>spellfix1_row</name><operator>*</operator><operator>)</operator><name>A</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>spellfix1_row</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>spellfix1_row</name><operator>*</operator><operator>)</operator><name>B</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>a</name><operator>-&gt;</operator><name>iScore</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>iScore</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A structure used to pass information from spellfix1FilterForMatch()
** into spellfix1RunQuery().
*/</comment>
<typedef>typedef <type><struct>struct <name>MatchQuery</name> <block>{
  <decl_stmt><decl><type><name>spellfix1_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>          <comment type="block">/* The cursor being queried */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>             <comment type="block">/* shadow table query statment */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zHash</name><index>[<expr><name>SPELLFIX_MX_HASH</name></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* The current phonehash for zPattern */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>            <comment type="block">/* Transliterated input string */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPattern</name></decl>;</decl_stmt>                    <comment type="block">/* Length of zPattern */</comment>
  <decl_stmt><decl><type><name>EditDist3FromString</name> <modifier>*</modifier></type><name>pMatchStr3</name></decl>;</decl_stmt> <comment type="block">/* Original unicode string */</comment>
  <decl_stmt><decl><type><name>EditDist3Config</name> <modifier>*</modifier></type><name>pConfig3</name></decl>;</decl_stmt>       <comment type="block">/* Edit-distance cost coefficients */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>EditDist3Lang</name> <modifier>*</modifier></type><name>pLang</name></decl>;</decl_stmt>      <comment type="block">/* The selected language coefficients */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLang</name></decl>;</decl_stmt>                       <comment type="block">/* The language id */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iScope</name></decl>;</decl_stmt>                      <comment type="block">/* Default scope */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iMaxDist</name></decl>;</decl_stmt>                    <comment type="block">/* Maximum allowed edit distance, or -1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                          <comment type="block">/* Error code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRun</name></decl>;</decl_stmt>                  <comment type="block">/* Number of prior runs for the same zPattern */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>azPrior</name><index>[<expr><name>SPELLFIX_MX_RUN</name></expr>]</index><index>[<expr><name>SPELLFIX_MX_HASH</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Prior hashes */</comment>
}</block></struct></type> <name>MatchQuery</name>;</typedef>

<comment type="block">/*
** Run a query looking for the best matches against zPattern using
** zHash as the character class seed hash.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>spellfix1RunQuery</name><parameter_list>(<parameter><decl><type><name>MatchQuery</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zQuery</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nQuery</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zK1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWord</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iRank</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iScore</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iWorst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idxWorst</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iScope</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>iScope</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>spellfix1_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pCur</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zHash1</name><index>[<expr><name>SPELLFIX_MX_HASH</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zHash2</name><index>[<expr><name>SPELLFIX_MX_HASH</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zClass</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nClass</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>   <comment type="block">/* Prior memory allocation failure */</comment>
  <expr_stmt><expr><name>zClass</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>phoneticHash</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>zQuery</name></expr></argument>, <argument><expr><name>nQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zClass</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nClass</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nClass</name><operator>&gt;</operator><name>SPELLFIX_MX_HASH</name><operator>-</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nClass</name> <operator>=</operator> <name>SPELLFIX_MX_HASH</name><operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zClass</name><index>[<expr><name>nClass</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nClass</name><operator>&lt;=</operator><name>iScope</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nClass</name><operator>&gt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iScope</name> <operator>=</operator> <name>nClass</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iScope</name> <operator>=</operator> <name>nClass</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zHash1</name></expr></argument>, <argument><expr><name>zClass</name></expr></argument>, <argument><expr><name>iScope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zHash1</name><index>[<expr><name>iScope</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zHash2</name></expr></argument>, <argument><expr><name>zHash1</name></expr></argument>, <argument><expr><name>iScope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zHash2</name><index>[<expr><name>iScope</name></expr>]</index></name> <operator>=</operator> <literal type="char">'Z'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zHash2</name><index>[<expr><name>iScope</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SPELLFIX_MX_RUN</name><operator>&gt;</operator><literal type="number">1</literal></expr></cpp:if>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nRun</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>azPrior</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zHash1</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRun</name></name><operator>&lt;</operator><name>SPELLFIX_MX_RUN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>azPrior</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nRun</name></name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><name>zHash1</name></expr></argument>, <argument><expr><name>iScope</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zHash1</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NOMEM</name>
   <operator>||</operator> <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>zHash2</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NOMEM</name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SPELLFIX_MX_RUN</name><operator>&gt;</operator><literal type="number">1</literal></expr></cpp:if>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iScore</name><operator>&gt;</operator><name>iWorst</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iWorst</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iScore</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>idxWorst</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iMatchlen</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>iRank</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pMatchStr3</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nWord</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>zWord</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iDist</name> <operator>=</operator> <call><name>editDist3Core</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pMatchStr3</name></name></expr></argument>, <argument><expr><name>zWord</name></expr></argument>, <argument><expr><name>nWord</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLang</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iMatchlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zK1</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zK1</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>iDist</name> <operator>=</operator> <call><name>editdist1</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zPattern</name></name></expr></argument>, <argument><expr><name>zK1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDist</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nSearch</name></name><operator>++</operator></expr>;</expr_stmt>
    
    <comment type="block">/* If there is a "distance &lt; $dist" or "distance &lt;= $dist" constraint,
    ** check if this row meets it. If not, jump back up to the top of the
    ** loop to process the next row. Otherwise, if the row does match the
    ** distance constraint, check if the pCur-&gt;a[] array is already full.
    ** If it is and no explicit "top = ?" constraint was present in the
    ** query, grow the array to ensure there is room for the new entry. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iMaxDist</name></name><operator>&gt;=</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>&amp;</operator> <name>SPELLFIX_IDXNUM_DIST</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iMaxDist</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iDist</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>iMaxDist</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name><operator>&gt;=</operator><name><name>pCur</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>&amp;</operator> <name>SPELLFIX_IDXNUM_TOP</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>spellfix1ResizeCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>iScore</name> <operator>=</operator> <call><name>spellfix1Score</name><argument_list>(<argument><expr><name>iDist</name></expr></argument>,<argument><expr><name>iRank</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iScore</name><operator>&lt;</operator><name>iWorst</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>idxWorst</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>zWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>zWord</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>zWord</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>iRowid</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>iRank</name> <operator>=</operator> <name>iRank</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>iDistance</name> <operator>=</operator> <name>iDist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>iScore</name> <operator>=</operator> <name>iScore</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>iMatchlen</name> <operator>=</operator> <name>iMatchlen</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>zHash</name></expr></argument>, <argument><expr><name>zHash1</name></expr></argument>, <argument><expr><name>iScope</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iWorst</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iScore</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>idxWorst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>iScore</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iScore</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iWorst</name><operator>&lt;</operator><name>iScore</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iWorst</name> <operator>=</operator> <name>iScore</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>idxWorst</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This version of the xFilter method work if the MATCH term is present
** and we are doing a scan.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1FilterForMatch</name><parameter_list>(
  <parameter><decl><type><name>spellfix1_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>idxNum</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>idxNum</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zMatchThis</name></decl>;</decl_stmt>   <comment type="block">/* RHS of the MATCH operator */</comment>
  <decl_stmt><decl><type><name>EditDist3FromString</name> <modifier>*</modifier></type><name>pMatchStr3</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* zMatchThis as an editdist string */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>                    <comment type="block">/* Transliteration of zMatchThis */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPattern</name></decl>;</decl_stmt>                      <comment type="block">/* Length of zPattern */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLimit</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Max number of rows of output */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iScope</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Use this many characters of zClass */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLang</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                     <comment type="block">/* Language code */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>                        <comment type="block">/* SQL of shadow table query */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Shadow table query */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                            <comment type="block">/* Result code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                       <comment type="block">/* Next available filter parameter */</comment>
  <decl_stmt><decl><type><name>spellfix1_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pVTab</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The virtual table that owns pCur */</comment>
  <decl_stmt><decl><type><name>MatchQuery</name></type> <name>x</name></decl>;</decl_stmt>                      <comment type="block">/* For passing info to RunQuery() */</comment>

  <comment type="block">/* Load the cost table if we have not already done so */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zCostTable</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pConfig3</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pConfig3</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pConfig3</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pConfig3</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pConfig3</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pConfig3</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>editDist3ConfigLoad</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pConfig3</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zCostTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iScope</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>  <comment type="block">/* Default scope if none specified by "WHERE scope=N" */</comment>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iMaxDist</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>   <comment type="block">/* Maximum allowed edit distance */</comment>

  <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>&amp;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iLang</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>&amp;</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iLimit</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iLimit</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iLimit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>&amp;</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iScope</name></name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>iScope</name></name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iScope</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>iScope</name></name><operator>&gt;</operator><name>SPELLFIX_MX_HASH</name><operator>-</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iScope</name></name> <operator>=</operator> <name>SPELLFIX_MX_HASH</name><operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>&amp;</operator><operator>(</operator><literal type="number">16</literal><operator>|</operator><literal type="number">32</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iMaxDist</name></name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>&amp;</operator><literal type="number">16</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iMaxDist</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>iMaxDist</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iMaxDist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>spellfix1ResetCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>spellfix1ResizeCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zMatchThis</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zMatchThis</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pConfig3</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pLang</name></name> <operator>=</operator> <call><name>editDist3FindLang</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pConfig3</name></name></expr></argument>, <argument><expr><name>iLang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMatchStr3</name> <operator>=</operator> <call><name>editDist3FromStringNew</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>pLang</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>zMatchThis</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pMatchStr3</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      <goto>goto <name>filter_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pLang</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>zPattern</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>transliterate</name><argument_list>(<argument><expr><name>zMatchThis</name></expr></argument>, <argument><expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPattern</name></name> <operator>=</operator> <name>zPattern</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zPattern</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>filter_exit</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nPattern</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPattern</name><index>[<expr><name>nPattern</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nPattern</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
     <argument><expr><literal type="string">"SELECT id, word, rank, coalesce(k1,word)"</literal>
     <literal type="string">"  FROM \"%w\".\"%w_vocab\""</literal>
     <literal type="string">" WHERE langid=%d AND k2&gt;=?1 AND k2&lt;?2"</literal></expr></argument>,
     <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDbName</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>, <argument><expr><name>iLang</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <goto>goto <name>filter_exit</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iLang</name></name> <operator>=</operator> <name>iLang</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pCur</name></name> <operator>=</operator> <name>pCur</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pStmt</name></name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>zPattern</name></name> <operator>=</operator> <name>zPattern</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nPattern</name></name> <operator>=</operator> <name>nPattern</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pMatchStr3</name></name> <operator>=</operator> <name>pMatchStr3</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iLang</name></name> <operator>=</operator> <name>iLang</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pConfig3</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pConfig3</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>spellfix1RunQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><name>nPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>spellfix1RowCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iTop</name></name> <operator>=</operator> <name>iLimit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iScope</name></name> <operator>=</operator> <name>iScope</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<label><name>filter_exit</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>editDist3FromStringDelete</name><argument_list>(<argument><expr><name>pMatchStr3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>x</name><operator>.</operator><name>rc</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This version of xFilter handles a full-table scan case
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1FilterForFullScan</name><parameter_list>(
  <parameter><decl><type><name>spellfix1_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idxNum</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>idxNum</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>spellfix1_vtab</name> <modifier>*</modifier></type><name>pVTab</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pVTab</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>spellfix1ResetCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idxNum</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>idxNum</name><operator>==</operator><literal type="number">64</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
     <argument><expr><literal type="string">"SELECT word, rank, NULL, langid, id FROM \"%w\".\"%w_vocab\"%s"</literal></expr></argument>,
     <argument><expr><name><name>pVTab</name><operator>-&gt;</operator><name>zDbName</name></name></expr></argument>, <argument><expr><name><name>pVTab</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>,
     <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>idxNum</name> <operator>&amp;</operator> <literal type="number">64</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" WHERE rowid=?"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>pVTab</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pFullScan</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>idxNum</name> <operator>&amp;</operator> <literal type="number">64</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pFullScan</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pFullScan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Called to "rewind" a cursor back to the beginning so that
** it starts its output over again.  Always called at least once
** prior to any spellfix1Column, spellfix1Rowid, or spellfix1Eof call.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Filter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>spellfix1_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>spellfix1_cursor</name> <operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>idxNum</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>spellfix1FilterForMatch</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>spellfix1FilterForFullScan</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Advance a cursor to its next row of output
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Next</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>spellfix1_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>spellfix1_cursor</name> <operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name> <operator>&lt;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pFullScan</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pFullScan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if we are at the end-of-file
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Eof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>spellfix1_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>spellfix1_cursor</name> <operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name><operator>&gt;=</operator><name><name>pCur</name><operator>-&gt;</operator><name>nRow</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return columns from the current row.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Column</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>spellfix1_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>spellfix1_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pFullScan</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;=</operator><name>SPELLFIX_COL_LANGID</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pFullScan</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SPELLFIX_COL_WORD</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name></expr>]</index></name><operator>.</operator><name>zWord</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SPELLFIX_COL_RANK</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name></expr>]</index></name><operator>.</operator><name>iRank</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SPELLFIX_COL_DISTANCE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name></expr>]</index></name><operator>.</operator><name>iDistance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SPELLFIX_COL_LANGID</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iLang</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SPELLFIX_COL_SCORE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name></expr>]</index></name><operator>.</operator><name>iScore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SPELLFIX_COL_MATCHLEN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iMatchlen</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name></expr>]</index></name><operator>.</operator><name>iMatchlen</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iMatchlen</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nPattern</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPattern</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWord</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name></expr>]</index></name><operator>.</operator><name>zWord</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nWord</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zWord</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><name>nPattern</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>zPattern</name><index>[<expr><name>nPattern</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTranslit</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>zTranslit</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>transliterate</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zWord</name></expr></argument>, <argument><expr><name>nWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zTranslit</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>editdist1</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPattern</name></name></expr></argument>, <argument><expr><name>zTranslit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iMatchlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTranslit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>iMatchlen</name> <operator>=</operator> <call><name>translen_to_charlen</name><argument_list>(<argument><expr><name>zWord</name></expr></argument>, <argument><expr><name>nWord</name></expr></argument>, <argument><expr><name>iMatchlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>iMatchlen</name> <operator>=</operator> <call><name>utf8Charlen</name><argument_list>(<argument><expr><name>zWord</name></expr></argument>, <argument><expr><name>nWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>iMatchlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SPELLFIX_COL_PHONEHASH</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name></expr>]</index></name><operator>.</operator><name>zHash</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SPELLFIX_COL_TOP</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iTop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SPELLFIX_COL_SCOPE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iScope</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SPELLFIX_COL_SRCHCNT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nSearch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The rowid.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Rowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>spellfix1_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>spellfix1_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pFullScan</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pFullScan</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iRow</name></name></expr>]</index></name><operator>.</operator><name>iRowid</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called by the xUpdate() method. It returns a string
** containing the conflict mode that xUpdate() should use for the current
** operation. One of: "ROLLBACK", "IGNORE", "ABORT" or "REPLACE".
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spellfix1GetConflict</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azConflict</name><index>[]</index></name> <init>= <expr><block>{
    <comment type="block">/* Note: Instead of "FAIL" - "ABORT". */</comment>
    <expr><literal type="string">"ROLLBACK"</literal></expr>, <expr><literal type="string">"IGNORE"</literal></expr>, <expr><literal type="string">"ABORT"</literal></expr>, <expr><literal type="string">"ABORT"</literal></expr>, <expr><literal type="string">"REPLACE"</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eConflict</name> <init>= <expr><call><name>sqlite3_vtab_on_conflict</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eConflict</name><operator>==</operator><name>SQLITE_ROLLBACK</name> <operator>||</operator> <name>eConflict</name><operator>==</operator><name>SQLITE_IGNORE</name>
       <operator>||</operator> <name>eConflict</name><operator>==</operator><name>SQLITE_FAIL</name> <operator>||</operator> <name>eConflict</name><operator>==</operator><name>SQLITE_ABORT</name>
       <operator>||</operator> <name>eConflict</name><operator>==</operator><name>SQLITE_REPLACE</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_ROLLBACK</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_IGNORE</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_FAIL</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_ABORT</name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_REPLACE</name><operator>==</operator><literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name><name>azConflict</name><index>[<expr><name>eConflict</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The xUpdate() method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Update</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>rowid</name></decl>, <decl><type ref="prev"/><name>newRowid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>spellfix1_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>spellfix1_vtab</name><operator>*</operator><operator>)</operator><name>pVTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* A delete operation on the rowid given by argv[0] */</comment>
    <expr_stmt><expr><name>rowid</name> <operator>=</operator> <operator>*</operator><name>pRowid</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>spellfix1DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM \"%w\".\"%w_vocab\" "</literal>
                           <literal type="string">" WHERE id=%lld"</literal></expr></argument>,
                  <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDbName</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>, <argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zWord</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>SPELLFIX_COL_WORD</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nWord</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>SPELLFIX_COL_WORD</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iLang</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>SPELLFIX_COL_LANGID</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iRank</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>SPELLFIX_COL_RANK</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zSoundslike</name> <init>=
           <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>SPELLFIX_COL_SOUNDSLIKE</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nSoundslike</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>SPELLFIX_COL_SOUNDSLIKE</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zK1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zK2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zConflict</name> <init>= <expr><call><name>spellfix1GetConflict</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>zWord</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Inserts of the form:  INSERT INTO table(command) VALUES('xyzzy');
      ** cause zWord to be NULL, so we look at the "command" column to see
      ** what special actions to take */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCmd</name> <init>= 
         <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>SPELLFIX_COL_COMMAND</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zCmd</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pVTab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"NOT NULL constraint failed: %s.word"</literal></expr></argument>,
                                         <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_CONSTRAINT_NOTNULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>,<argument><expr><literal type="string">"reset"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Reset the  edit cost table (if there is one). */</comment>
        <expr_stmt><expr><call><name>editDist3ConfigDelete</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pConfig3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pConfig3</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>,<argument><expr><literal type="string">"edit_cost_table="</literal></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>editDist3ConfigDelete</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pConfig3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pConfig3</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zCostTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zCostTable</name></name> <operator>=</operator> <call><name>spellfix1Dequote</name><argument_list>(<argument><expr><name>zCmd</name><operator>+</operator><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zCostTable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zCostTable</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zCostTable</name></name></expr></argument>,<argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zCostTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zCostTable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pVTab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"unknown value for %s.command: \"%w\""</literal></expr></argument>,
                                       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>, <argument><expr><name>zCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iRank</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iRank</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zSoundslike</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zK1</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>transliterate</name><argument_list>(<argument><expr><name>zSoundslike</name></expr></argument>, <argument><expr><name>nSoundslike</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zK1</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>transliterate</name><argument_list>(<argument><expr><name>zWord</name></expr></argument>, <argument><expr><name>nWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zK1</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zK1</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
       <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'Z'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zK1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>zK2</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>phoneticHash</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>zK1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zK2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zK1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>spellfix1DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>,
               <argument><expr><literal type="string">"INSERT INTO \"%w\".\"%w_vocab\"(rank,langid,word,k1,k2) "</literal>
               <literal type="string">"VALUES(%d,%d,%Q,nullif(%Q,%Q),%Q)"</literal></expr></argument>,
               <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDbName</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>,
               <argument><expr><name>iRank</name></expr></argument>, <argument><expr><name>iLang</name></expr></argument>, <argument><expr><name>zWord</name></expr></argument>, <argument><expr><name>zK1</name></expr></argument>, <argument><expr><name>zWord</name></expr></argument>, <argument><expr><name>zK2</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>newRowid</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>spellfix1DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>,
            <argument><expr><literal type="string">"INSERT OR %s INTO \"%w\".\"%w_vocab\"(id,rank,langid,word,k1,k2) "</literal>
            <literal type="string">"VALUES(%lld,%d,%d,%Q,nullif(%Q,%Q),%Q)"</literal></expr></argument>,
            <argument><expr><name>zConflict</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDbName</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>,
            <argument><expr><name>newRowid</name></expr></argument>, <argument><expr><name>iRank</name></expr></argument>, <argument><expr><name>iLang</name></expr></argument>, <argument><expr><name>zWord</name></expr></argument>, <argument><expr><name>zK1</name></expr></argument>, <argument><expr><name>zWord</name></expr></argument>, <argument><expr><name>zK2</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <call><name>sqlite3_last_insert_rowid</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rowid</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>newRowid</name> <operator>=</operator> <operator>*</operator><name>pRowid</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>spellfix1DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>,
             <argument><expr><literal type="string">"UPDATE OR %s \"%w\".\"%w_vocab\" SET id=%lld, rank=%d, langid=%d,"</literal>
             <literal type="string">" word=%Q, k1=nullif(%Q,%Q), k2=%Q WHERE id=%lld"</literal></expr></argument>,
             <argument><expr><name>zConflict</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDbName</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>, <argument><expr><name>newRowid</name></expr></argument>, <argument><expr><name>iRank</name></expr></argument>, <argument><expr><name>iLang</name></expr></argument>,
             <argument><expr><name>zWord</name></expr></argument>, <argument><expr><name>zK1</name></expr></argument>, <argument><expr><name>zWord</name></expr></argument>, <argument><expr><name>zK2</name></expr></argument>, <argument><expr><name>rowid</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zK1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zK2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Rename the spellfix1 table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Rename</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNew</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>spellfix1_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>spellfix1_vtab</name><operator>*</operator><operator>)</operator><name>pVTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNewName</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zNew</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zNewName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>spellfix1DbExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, 
     <argument><expr><literal type="string">"ALTER TABLE \"%w\".\"%w_vocab\" RENAME TO \"%w_vocab\""</literal></expr></argument>,
     <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDbName</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>, <argument><expr><name>zNewName</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zTableName</name></name> <operator>=</operator> <name>zNewName</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zNewName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** A virtual table module that provides fuzzy search.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>spellfix1Module</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* iVersion */</comment>
  <expr><name>spellfix1Create</name></expr>,         <comment type="block">/* xCreate - handle CREATE VIRTUAL TABLE */</comment>
  <expr><name>spellfix1Connect</name></expr>,        <comment type="block">/* xConnect - reconnected to an existing table */</comment>
  <expr><name>spellfix1BestIndex</name></expr>,      <comment type="block">/* xBestIndex - figure out how to do a query */</comment>
  <expr><name>spellfix1Disconnect</name></expr>,     <comment type="block">/* xDisconnect - close a connection */</comment>
  <expr><name>spellfix1Destroy</name></expr>,        <comment type="block">/* xDestroy - handle DROP TABLE */</comment>
  <expr><name>spellfix1Open</name></expr>,           <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>spellfix1Close</name></expr>,          <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>spellfix1Filter</name></expr>,         <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>spellfix1Next</name></expr>,           <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>spellfix1Eof</name></expr>,            <comment type="block">/* xEof - check for end of scan */</comment>
  <expr><name>spellfix1Column</name></expr>,         <comment type="block">/* xColumn - read data */</comment>
  <expr><name>spellfix1Rowid</name></expr>,          <comment type="block">/* xRowid - read data */</comment>
  <expr><name>spellfix1Update</name></expr>,         <comment type="block">/* xUpdate */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xBegin */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xSync */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xCommit */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xRollback */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* xFindMethod */</comment>
  <expr><name>spellfix1Rename</name></expr>,         <comment type="block">/* xRename */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Register the various functions and the virtual table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>spellfix1Register</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"spellfix1_translit"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                               <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><name>transliterateSqlFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"spellfix1_editdist"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
                                 <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                  <argument><expr><name>editdistSqlFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"spellfix1_phonehash"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                                 <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                  <argument><expr><name>phoneticHashSqlFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"spellfix1_scriptcode"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                                  <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                  <argument><expr><name>scriptCodeSqlFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"spellfix1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>spellfix1Module</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>editDist3Install</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Verify sanity of the translit[] table */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>translit</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>translit</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>translit</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cFrom</name><operator>&lt;</operator><name><name>translit</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>cFrom</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block">/*
** Extension load function.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_spellfix_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <return>return <expr><call><name>spellfix1Register</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
</unit>
