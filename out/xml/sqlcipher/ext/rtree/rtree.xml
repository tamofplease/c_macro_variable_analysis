<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/rtree/rtree.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code for implementations of the r-tree and r*-tree
** algorithms packaged as an SQLite virtual table module.
*/</comment>

<comment type="block">/*
** Database Format of R-Tree Tables
** --------------------------------
**
** The data structure for a single virtual r-tree table is stored in three 
** native SQLite tables declared as follows. In each case, the '%' character
** in the table name is replaced with the user-supplied name of the r-tree
** table.
**
**   CREATE TABLE %_node(nodeno INTEGER PRIMARY KEY, data BLOB)
**   CREATE TABLE %_parent(nodeno INTEGER PRIMARY KEY, parentnode INTEGER)
**   CREATE TABLE %_rowid(rowid INTEGER PRIMARY KEY, nodeno INTEGER, ...)
**
** The data for each node of the r-tree structure is stored in the %_node
** table. For each node that is not the root node of the r-tree, there is
** an entry in the %_parent table associating the node with its parent.
** And for each row of data in the table, there is an entry in the %_rowid
** table that maps from the entries rowid to the id of the node that it
** is stored on.  If the r-tree contains auxiliary columns, those are stored
** on the end of the %_rowid table.
**
** The root node of an r-tree always exists, even if the r-tree table is
** empty. The nodeno of the root node is always 1. All other nodes in the
** table must be the same size as the root node. The content of each node
** is formatted as follows:
**
**   1. If the node is the root node (node 1), then the first 2 bytes
**      of the node contain the tree depth as a big-endian integer.
**      For non-root nodes, the first 2 bytes are left unused.
**
**   2. The next 2 bytes contain the number of entries currently 
**      stored in the node.
**
**   3. The remainder of the node contains the node entries. Each entry
**      consists of a single 8-byte integer followed by an even number
**      of 4-byte coordinates. For leaf nodes the integer is the rowid
**      of a record. For internal nodes it is the node number of a
**      child page.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call> \
  <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_RTREE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_CORE</name></cpp:ifndef>
  <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
  <function_decl><type><name>SQLITE_EXTENSION_INIT1</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>int</name></type> <name>sqlite3GetToken</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl> <comment type="block">/* In the SQLite core */</comment>

<comment type="block">/*
** If building separately, we will need some setup that is normally
** found in sqliteInt.h
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_AMALGAMATION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3rtree.h"</cpp:file></cpp:include>
<typedef>typedef <type><name>sqlite3_int64</name></type> <name>i64</name>;</typedef>
<typedef>typedef <type><name>sqlite3_uint64</name></type> <name>u64</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>u8</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>u16</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>u32</name>;</typedef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NDEBUG</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>NDEBUG</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_COVERAGE_TEST</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_MUTATION_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(0)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>((X)?1:(assert(0),0))</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>((X)?(assert(0),1):0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(X)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(X)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_AMALGAMATION) */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<comment type="block">/*  The following macro is used to suppress compiler warnings.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNUSED_PARAMETER</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED_PARAMETER</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(x)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name><name>struct</name> <name>Rtree</name></name></type> <name>Rtree</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>RtreeCursor</name></name></type> <name>RtreeCursor</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>RtreeNode</name></name></type> <name>RtreeNode</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>RtreeCell</name></name></type> <name>RtreeCell</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>RtreeConstraint</name></name></type> <name>RtreeConstraint</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>RtreeMatchArg</name></name></type> <name>RtreeMatchArg</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>RtreeGeomCallback</name></name></type> <name>RtreeGeomCallback</name>;</typedef>
<typedef>typedef <type><name><name>union</name> <name>RtreeCoord</name></name></type> <name>RtreeCoord</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>RtreeSearchPoint</name></name></type> <name>RtreeSearchPoint</name>;</typedef>

<comment type="block">/* The rtree may have between 1 and RTREE_MAX_DIMENSIONS dimensions. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_MAX_DIMENSIONS</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/* Maximum number of auxiliary columns */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_MAX_AUX_COLUMN</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<comment type="block">/* Size of hash table Rtree.aHash. This hash table is not expected to
** ever contain very many entries, so a fixed number of buckets is 
** used.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHSIZE</name></cpp:macro> <cpp:value>97</cpp:value></cpp:define>

<comment type="block">/* The xBestIndex method of this virtual table requires an estimate of
** the number of rows in the virtual table to calculate the costs of
** various strategies. If possible, this estimate is loaded from the
** sqlite_stat1 table (with RTREE_MIN_ROWEST as a hard-coded minimum).
** Otherwise, if no sqlite_stat1 entry is available, use 
** RTREE_DEFAULT_ROWEST.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_DEFAULT_ROWEST</name></cpp:macro> <cpp:value>1048576</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_MIN_ROWEST</name></cpp:macro>         <cpp:value>100</cpp:value></cpp:define>

<comment type="block">/* 
** An rtree virtual-table object.
*/</comment>
<struct>struct <name>Rtree</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>          <comment type="block">/* Base class.  Must be first */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                <comment type="block">/* Host database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iNodeSize</name></decl>;</decl_stmt>              <comment type="block">/* Size in bytes of each node in the node table */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nDim</name></decl>;</decl_stmt>                    <comment type="block">/* Number of dimensions */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nDim2</name></decl>;</decl_stmt>                   <comment type="block">/* Twice the number of dimensions */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>eCoordType</name></decl>;</decl_stmt>              <comment type="block">/* RTREE_COORD_REAL32 or RTREE_COORD_INT32 */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nBytesPerCell</name></decl>;</decl_stmt>           <comment type="block">/* Bytes consumed per cell */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>inWrTrans</name></decl>;</decl_stmt>               <comment type="block">/* True if inside write transaction */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nAux</name></decl>;</decl_stmt>                    <comment type="block">/* # of auxiliary columns in %_rowid */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_GEOPOLY</name></cpp:ifdef>
  <decl_stmt><decl><type><name>u8</name></type> <name>nAuxNotNull</name></decl>;</decl_stmt>             <comment type="block">/* Number of initial not-null aux columns */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>u8</name></type> <name>bCorrupt</name></decl>;</decl_stmt>                <comment type="block">/* Shadow table corruption detected */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>iDepth</name></decl>;</decl_stmt>                 <comment type="block">/* Current depth of the r-tree structure */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                  <comment type="block">/* Name of database containing r-tree table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>                <comment type="block">/* Name of r-tree table */</comment> 
  <decl_stmt><decl><type><name>u32</name></type> <name>nBusy</name></decl>;</decl_stmt>                  <comment type="block">/* Current number of users of this structure */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nRowEst</name></decl>;</decl_stmt>                <comment type="block">/* Estimated number of rows in this table */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nCursor</name></decl>;</decl_stmt>                <comment type="block">/* Number of open cursors */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nNodeRef</name></decl>;</decl_stmt>               <comment type="block">/* Number RtreeNodes with positive nRef */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zReadAuxSql</name></decl>;</decl_stmt>          <comment type="block">/* SQL for statement to read aux data */</comment>

  <comment type="block">/* List of nodes removed during a CondenseTree operation. List is
  ** linked together via the pointer normally used for hash chains -
  ** RtreeNode.pNext. RtreeNode.iNode stores the depth of the sub-tree 
  ** headed by the node (leaf nodes have RtreeNode.iNode==0).
  */</comment>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pDeleted</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iReinsertHeight</name></decl>;</decl_stmt>        <comment type="block">/* Height of sub-trees Reinsert() has run on */</comment>

  <comment type="block">/* Blob I/O on xxx_node */</comment>
  <decl_stmt><decl><type><name>sqlite3_blob</name> <modifier>*</modifier></type><name>pNodeBlob</name></decl>;</decl_stmt>

  <comment type="block">/* Statements to read/write/delete a record from xxx_node */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pWriteNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pDeleteNode</name></decl>;</decl_stmt>

  <comment type="block">/* Statements to read/write/delete a record from xxx_rowid */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pReadRowid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pWriteRowid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pDeleteRowid</name></decl>;</decl_stmt>

  <comment type="block">/* Statements to read/write/delete a record from xxx_parent */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pReadParent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pWriteParent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pDeleteParent</name></decl>;</decl_stmt>

  <comment type="block">/* Statement for writing to the "aux:" fields, if there are any */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pWriteAux</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name><name>aHash</name><index>[<expr><name>HASHSIZE</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Hash table of in-memory nodes. */</comment> 
}</block>;</struct>

<comment type="block">/* Possible values for Rtree.eCoordType: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_COORD_REAL32</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_COORD_INT32</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/*
** If SQLITE_RTREE_INT_ONLY is defined, then this virtual table will
** only deal with integer coordinates.  No floating point operations
** will be done.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_RTREE_INT_ONLY</name></cpp:ifdef>
  <typedef>typedef <type><name>sqlite3_int64</name></type> <name>RtreeDValue</name>;</typedef>       <comment type="block">/* High accuracy coordinate */</comment>
  <typedef>typedef <type><name>int</name></type> <name>RtreeValue</name>;</typedef>                  <comment type="block">/* Low accuracy coordinate */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_ZERO</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <typedef>typedef <type><name>double</name></type> <name>RtreeDValue</name>;</typedef>              <comment type="block">/* High accuracy coordinate */</comment>
  <typedef>typedef <type><name>float</name></type> <name>RtreeValue</name>;</typedef>                <comment type="block">/* Low accuracy coordinate */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_ZERO</name></cpp:macro> <cpp:value>0.0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Set the Rtree.bCorrupt flag
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_IS_CORRUPT</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((X)-&gt;bCorrupt = 1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_IS_CORRUPT</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** When doing a search of an r-tree, instances of the following structure
** record intermediate results from the tree walk.
**
** The id is always a node-id.  For iLevel&gt;=1 the id is the node-id of
** the node that the RtreeSearchPoint represents.  When iLevel==0, however,
** the id is of the parent node and the cell that RtreeSearchPoint
** represents is the iCell-th entry in the parent node.
*/</comment>
<struct>struct <name>RtreeSearchPoint</name> <block>{
  <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>rScore</name></decl>;</decl_stmt>    <comment type="block">/* The score for this node.  Smallest goes first. */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>id</name></decl>;</decl_stmt>      <comment type="block">/* Node ID */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>iLevel</name></decl>;</decl_stmt>             <comment type="block">/* 0=entries.  1=leaf node.  2+ for higher */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>eWithin</name></decl>;</decl_stmt>            <comment type="block">/* PARTLY_WITHIN or FULLY_WITHIN */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>iCell</name></decl>;</decl_stmt>              <comment type="block">/* Cell index within the node */</comment>
}</block>;</struct>

<comment type="block">/*
** The minimum number of cells allowed for a node is a third of the 
** maximum. In Gutman's notation:
**
**     m = M/3
**
** If an R*-tree "Reinsert" operation is required, the same number of
** cells are removed from the overfull node and reinserted into the tree.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_MINCELLS</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((p)-&gt;iNodeSize-4)/(p)-&gt;nBytesPerCell)/3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_REINSERT</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RTREE_MINCELLS(p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_MAXCELLS</name></cpp:macro> <cpp:value>51</cpp:value></cpp:define>

<comment type="block">/*
** The smallest possible node-size is (512-64)==448 bytes. And the largest
** supported cell size is 48 bytes (8 byte rowid + ten 4 byte coordinates).
** Therefore all non-root nodes must contain at least 3 entries. Since 
** 3^40 is greater than 2^64, an r-tree structure always has a depth of
** 40 or less.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_MAX_DEPTH</name></cpp:macro> <cpp:value>40</cpp:value></cpp:define>


<comment type="block">/*
** Number of entries in the cursor RtreeNode cache.  The first entry is
** used to cache the RtreeNode for RtreeCursor.sPoint.  The remaining
** entries cache the RtreeNode for the first elements of the priority queue.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_CACHE_SZ</name></cpp:macro>  <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/* 
** An rtree cursor object.
*/</comment>
<struct>struct <name>RtreeCursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>         <comment type="block">/* Base class.  Must be first */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>atEOF</name></decl>;</decl_stmt>                         <comment type="block">/* True if at end of search */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bPoint</name></decl>;</decl_stmt>                        <comment type="block">/* True if sPoint is valid */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bAuxValid</name></decl>;</decl_stmt>                     <comment type="block">/* True if pReadAux is valid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iStrategy</name></decl>;</decl_stmt>                    <comment type="block">/* Copy of idxNum search parameter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nConstraint</name></decl>;</decl_stmt>                  <comment type="block">/* Number of entries in aConstraint */</comment>
  <decl_stmt><decl><type><name>RtreeConstraint</name> <modifier>*</modifier></type><name>aConstraint</name></decl>;</decl_stmt>     <comment type="block">/* Search constraints. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPointAlloc</name></decl>;</decl_stmt>                  <comment type="block">/* Number of slots allocated for aPoint[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPoint</name></decl>;</decl_stmt>                       <comment type="block">/* Number of slots used in aPoint[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mxLevel</name></decl>;</decl_stmt>                      <comment type="block">/* iLevel value for root of the tree */</comment>
  <decl_stmt><decl><type><name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>aPoint</name></decl>;</decl_stmt>         <comment type="block">/* Priority queue for search points */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pReadAux</name></decl>;</decl_stmt>           <comment type="block">/* Statement to read aux-data */</comment>
  <decl_stmt><decl><type><name>RtreeSearchPoint</name></type> <name>sPoint</name></decl>;</decl_stmt>          <comment type="block">/* Cached next search point */</comment>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name><name>aNode</name><index>[<expr><name>RTREE_CACHE_SZ</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Rtree node cache */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name><name>anQueue</name><index>[<expr><name>RTREE_MAX_DEPTH</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* Number of queued entries by iLevel */</comment>
}</block>;</struct>

<comment type="block">/* Return the Rtree of a RtreeCursor */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_OF_CURSOR</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>((Rtree*)((X)-&gt;base.pVtab))</cpp:value></cpp:define>

<comment type="block">/*
** A coordinate can be either a floating point number or a integer.  All
** coordinates within a single R-Tree are always of the same time.
*/</comment>
<union>union <name>RtreeCoord</name> <block>{
  <decl_stmt><decl><type><name>RtreeValue</name></type> <name>f</name></decl>;</decl_stmt>      <comment type="block">/* Floating point value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>             <comment type="block">/* Integer value */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>u</name></decl>;</decl_stmt>             <comment type="block">/* Unsigned for byte-order conversions */</comment>
}</block>;</union>

<comment type="block">/*
** The argument is an RtreeCoord. Return the value stored within the RtreeCoord
** formatted as a RtreeDValue (double or int64). This macro assumes that local
** variable pRtree points to the Rtree structure associated with the
** RtreeCoord.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_RTREE_INT_ONLY</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>DCOORD</name><parameter_list>(<parameter><type><name>coord</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((RtreeDValue)coord.i)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>DCOORD</name><parameter_list>(<parameter><type><name>coord</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(                           \
    (pRtree-&gt;eCoordType==RTREE_COORD_REAL32) ?      \
      ((double)coord.f) :                           \
      ((double)coord.i)                             \
  )</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** A search constraint.
*/</comment>
<struct>struct <name>RtreeConstraint</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iCoord</name></decl>;</decl_stmt>                     <comment type="block">/* Index of constrained coordinate */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                         <comment type="block">/* Constraining operation */</comment>
  <union>union <block>{
    <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>rValue</name></decl>;</decl_stmt>             <comment type="block">/* Constraint value. */</comment>
    <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xGeom</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_rtree_geometry</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>RtreeDValue</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xQueryFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_rtree_query_info</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  }</block> <decl><name>u</name></decl>;</union>
  <decl_stmt><decl><type><name>sqlite3_rtree_query_info</name> <modifier>*</modifier></type><name>pInfo</name></decl>;</decl_stmt>  <comment type="block">/* xGeom and xQueryFunc argument */</comment>
}</block>;</struct>

<comment type="block">/* Possible values for RtreeConstraint.op */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_EQ</name></cpp:macro>    <cpp:value>0x41</cpp:value></cpp:define>  <comment type="block">/* A */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_LE</name></cpp:macro>    <cpp:value>0x42</cpp:value></cpp:define>  <comment type="block">/* B */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_LT</name></cpp:macro>    <cpp:value>0x43</cpp:value></cpp:define>  <comment type="block">/* C */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_GE</name></cpp:macro>    <cpp:value>0x44</cpp:value></cpp:define>  <comment type="block">/* D */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_GT</name></cpp:macro>    <cpp:value>0x45</cpp:value></cpp:define>  <comment type="block">/* E */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_MATCH</name></cpp:macro> <cpp:value>0x46</cpp:value></cpp:define>  <comment type="block">/* F: Old-style sqlite3_rtree_geometry_callback() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_QUERY</name></cpp:macro> <cpp:value>0x47</cpp:value></cpp:define>  <comment type="block">/* G: New-style sqlite3_rtree_query_callback() */</comment>

<comment type="block">/* Special operators available only on cursors.  Needs to be consecutive
** with the normal values above, but must be less than RTREE_MATCH.  These
** are used in the cursor for contraints such as x=NULL (RTREE_FALSE) or
** x&lt;'xyz' (RTREE_TRUE) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_TRUE</name></cpp:macro>  <cpp:value>0x3f</cpp:value></cpp:define>  <comment type="block">/* ? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_FALSE</name></cpp:macro> <cpp:value>0x40</cpp:value></cpp:define>  <comment type="block">/* @ */</comment>

<comment type="block">/* 
** An rtree structure node.
*/</comment>
<struct>struct <name>RtreeNode</name> <block>{
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pParent</name></decl>;</decl_stmt>         <comment type="block">/* Parent node */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iNode</name></decl>;</decl_stmt>                  <comment type="block">/* The node number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>                   <comment type="block">/* Number of references to this node */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isDirty</name></decl>;</decl_stmt>                <comment type="block">/* True if the node needs to be written to disk */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>zData</name></decl>;</decl_stmt>                  <comment type="block">/* Content of the node, as should be on disk */</comment>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>           <comment type="block">/* Next node in this hash collision chain */</comment>
}</block>;</struct>

<comment type="block">/* Return the number of cells in a node  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NCELL</name><parameter_list>(<parameter><type><name>pNode</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>readInt16(&amp;(pNode)-&gt;zData[2])</cpp:value></cpp:define>

<comment type="block">/* 
** A single cell from a node, deserialized
*/</comment>
<struct>struct <name>RtreeCell</name> <block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>iRowid</name></decl>;</decl_stmt>                                 <comment type="block">/* Node or entry ID */</comment>
  <decl_stmt><decl><type><name>RtreeCoord</name></type> <name><name>aCoord</name><index>[<expr><name>RTREE_MAX_DIMENSIONS</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Bounding box coordinates */</comment>
}</block>;</struct>


<comment type="block">/*
** This object becomes the sqlite3_user_data() for the SQL functions
** that are created by sqlite3_rtree_geometry_callback() and
** sqlite3_rtree_query_callback() and which appear on the right of MATCH
** operators in order to constrain a search.
**
** xGeom and xQueryFunc are the callback functions.  Exactly one of 
** xGeom and xQueryFunc fields is non-NULL, depending on whether the
** SQL function was created using sqlite3_rtree_geometry_callback() or
** sqlite3_rtree_query_callback().
** 
** This object is deleted automatically by the destructor mechanism in
** sqlite3_create_function_v2().
*/</comment>
<struct>struct <name>RtreeGeomCallback</name> <block>{
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xGeom</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_rtree_geometry</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>RtreeDValue</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xQueryFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_rtree_query_info</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestructor</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pContext</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** An instance of this structure (in the form of a BLOB) is returned by
** the SQL functions that sqlite3_rtree_geometry_callback() and
** sqlite3_rtree_query_callback() create, and is read as the right-hand
** operand to the MATCH operator of an R-Tree.
*/</comment>
<struct>struct <name>RtreeMatchArg</name> <block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>iSize</name></decl>;</decl_stmt>                  <comment type="block">/* Size of this object */</comment>
  <decl_stmt><decl><type><name>RtreeGeomCallback</name></type> <name>cb</name></decl>;</decl_stmt>       <comment type="block">/* Info about the callback functions */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nParam</name></decl>;</decl_stmt>                 <comment type="block">/* Number of parameters to the SQL function */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apSqlParam</name></decl>;</decl_stmt> <comment type="block">/* Original SQL parameter values */</comment>
  <decl_stmt><decl><type><name>RtreeDValue</name></type> <name><name>aParam</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>      <comment type="block">/* Values for parameters to the SQL function */</comment>
}</block>;</struct>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAX</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>MAX</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) &lt; (y) ? (y) : (x))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MIN</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) &gt; (y) ? (y) : (x))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* What version of GCC is being used.  0 means GCC is not being used .
** Note that the GCC_VERSION macro will also be set correctly when using
** clang, since clang works hard to be gcc compatible.  So the gcc
** optimizations will also work when compiling with clang.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GCC_VERSION</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DISABLE_INTRINSIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_VERSION</name></cpp:macro> <cpp:value>(__GNUC__*1000000+__GNUC_MINOR__*1000+__GNUC_PATCHLEVEL__)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_VERSION</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The testcase() macro should already be defined in the amalgamation.  If
** it is not, make it a no-op.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_COVERAGE_TEST</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sqlite3RtreeTestcase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>testcase</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>if( X ){ sqlite3RtreeTestcase += __LINE__; }</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>testcase</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Make sure that the compiler intrinsics we desire are enabled when
** compiling with an appropriate version of MSVC unless prevented by
** the SQLITE_DISABLE_INTRINSIC define.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DISABLE_INTRINSIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name><operator>&gt;=</operator><literal type="number">1400</literal></expr></cpp:if>
<cpp:if>#    <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#      <cpp:directive>include</cpp:directive> <cpp:file>&lt;intrin.h&gt;</cpp:file></cpp:include>
<cpp:pragma>#      <cpp:directive>pragma</cpp:directive> <name>intrinsic</name><name>(</name><name>_byteswap_ulong</name><name>)</name></cpp:pragma>
<cpp:pragma>#      <cpp:directive>pragma</cpp:directive> <name>intrinsic</name><name>(</name><name>_byteswap_uint64</name><name>)</name></cpp:pragma>
<cpp:else>#    <cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#      <cpp:directive>include</cpp:directive> <cpp:file>&lt;cmnintrin.h&gt;</cpp:file></cpp:include>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Macros to determine whether the machine is big or little endian,
** and whether or not that determination is run-time or compile-time.
**
** For best performance, an attempt is made to guess at the byte-order
** using C-preprocessor macros.  If that is unsuccessful, or if
** -DSQLITE_RUNTIME_BYTEORDER=1 is set, then byte-order is determined
** at run-time.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_BYTEORDER</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>i386</name></expr></argument>)</argument_list></call>     <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call>   <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_M_IX86</name></expr></argument>)</argument_list></call> <operator>||</operator>    \
    <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call>  <operator>||</operator>    \
    <call><name>defined</name><argument_list>(<argument><expr><name>_M_AMD64</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_M_ARM</name></expr></argument>)</argument_list></call>     <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86</name></expr></argument>)</argument_list></call>   <operator>||</operator>    \
    <call><name>defined</name><argument_list>(<argument><expr><name>__arm__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_BYTEORDER</name></cpp:macro>    <cpp:value>1234</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>sparc</name></expr></argument>)</argument_list></call>    <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_BYTEORDER</name></cpp:macro>    <cpp:value>4321</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_BYTEORDER</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>     <comment type="block">/* 0 means "unknown at compile-time" */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* What version of MSVC is being used.  0 means MSVC is not being used */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MSVC_VERSION</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DISABLE_INTRINSIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>MSVC_VERSION</name></cpp:macro> <cpp:value>_MSC_VER</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>MSVC_VERSION</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Functions to deserialize a 16 bit integer, 32 bit real number and
** 64 bit integer. The deserialized value is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>readInt16</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>readCoord</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>RtreeCoord</name> <modifier>*</modifier></type><name>pCoord</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal><operator>)</operator><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* p is always 4-byte aligned */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <name>MSVC_VERSION</name><operator>&gt;=</operator><literal type="number">1300</literal></expr></cpp:if>
  <expr_stmt><expr><name><name>pCoord</name><operator>-&gt;</operator><name>u</name></name> <operator>=</operator> <call><name>_byteswap_ulong</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">4003000</literal></expr></cpp:elif>
  <expr_stmt><expr><name><name>pCoord</name><operator>-&gt;</operator><name>u</name></name> <operator>=</operator> <call><name>__builtin_bswap32</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">4321</literal></expr></cpp:elif>
  <expr_stmt><expr><name><name>pCoord</name><operator>-&gt;</operator><name>u</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>pCoord</name><operator>-&gt;</operator><name>u</name></name> <operator>=</operator> <operator>(</operator>
    <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>+</operator> 
    <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> 
    <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">8</literal><operator>)</operator> <operator>+</operator> 
    <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">0</literal><operator>)</operator>
  <operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>i64</name></type> <name>readInt64</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <name>MSVC_VERSION</name><operator>&gt;=</operator><literal type="number">1300</literal></expr></cpp:if>
  <decl_stmt><decl><type><name>u64</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>i64</name><operator>)</operator><call><name>_byteswap_uint64</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">4003000</literal></expr></cpp:elif>
  <decl_stmt><decl><type><name>u64</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>i64</name><operator>)</operator><call><name>__builtin_bswap64</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">4321</literal></expr></cpp:elif>
  <decl_stmt><decl><type><name>i64</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>x</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator>
    <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">56</literal><operator>)</operator> <operator>+</operator> 
    <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">48</literal><operator>)</operator> <operator>+</operator> 
    <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">40</literal><operator>)</operator> <operator>+</operator> 
    <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>+</operator> 
    <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>+</operator> 
    <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> 
    <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">8</literal><operator>)</operator> <operator>+</operator> 
    <operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">0</literal><operator>)</operator>
  <operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Functions to serialize a 16 bit integer, 32 bit real number and
** 64 bit integer. The value returned is the number of bytes written
** to the argument buffer (always 2, 4 and 8 respectively).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>writeInt16</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>writeCoord</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>RtreeCoord</name> <modifier>*</modifier></type><name>pCoord</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal><operator>)</operator><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* p is always 4-byte aligned */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCoord</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">4003000</literal></expr></cpp:if>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>__builtin_bswap32</name><argument_list>(<argument><expr><name><name>pCoord</name><operator>-&gt;</operator><name>u</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <name>MSVC_VERSION</name><operator>&gt;=</operator><literal type="number">1300</literal></expr></cpp:elif>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>_byteswap_ulong</name><argument_list>(<argument><expr><name><name>pCoord</name><operator>-&gt;</operator><name>u</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">4321</literal></expr></cpp:elif>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pCoord</name><operator>-&gt;</operator><name>u</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pCoord</name><operator>-&gt;</operator><name>u</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><literal type="number">4</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>writeInt64</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">4003000</literal></expr></cpp:if>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><call><name>__builtin_bswap64</name><argument_list>(<argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <name>MSVC_VERSION</name><operator>&gt;=</operator><literal type="number">1300</literal></expr></cpp:elif>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><call><name>_byteswap_uint64</name><argument_list>(<argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">4321</literal></expr></cpp:elif>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">56</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">48</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">40</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&gt;&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xFF</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><literal type="number">8</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Increment the reference count of node p.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>nodeReference</name><parameter_list>(<parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Clear the content of node p (set all bytes to 0x00).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>nodeZero</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>isDirty</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Given a node number iNode, return the corresponding key to use
** in the Rtree.aHash table.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>nodeHash</name><parameter_list>(<parameter><decl><type><name>i64</name></type> <name>iNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>iNode</name><operator>)</operator> <operator>%</operator> <name>HASHSIZE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Search the node hash table for node iNode. If found, return a pointer
** to it. Otherwise, return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>RtreeNode</name> <modifier>*</modifier></type><name>nodeHashLookup</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pRtree</name><operator>-&gt;</operator><name>aHash</name><index>[<expr><call><name>nodeHash</name><argument_list>(<argument><expr><name>iNode</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iNode</name></name><operator>!=</operator><name>iNode</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add node pNode to the node hash table.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>nodeHashInsert</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iHash</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iHash</name> <operator>=</operator> <call><name>nodeHash</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>aHash</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>aHash</name><index>[<expr><name>iHash</name></expr>]</index></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Remove node pNode from the node hash table.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>nodeHashDelete</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>aHash</name><index>[<expr><call><name>nodeHash</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
    <for>for<control>( <init>;</init> <condition><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>!=</operator><name>pNode</name></expr>;</condition> <incr><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and return new r-tree node. Initially, (RtreeNode.iNode==0),
** indicating that node has not yet been assigned a node number. It is
** assigned a node number when nodeWrite() is called to write the
** node contents out to the database.
*/</comment>
<function><type><specifier>static</specifier> <name>RtreeNode</name> <modifier>*</modifier></type><name>nodeNew</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pParent</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>(</operator><name>RtreeNode</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeNode</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeNode</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>zData</name></name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nNodeRef</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pParent</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>isDirty</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodeReference</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Clear the Rtree.pNodeBlob object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>nodeBlobReset</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>pNodeBlob</name></name> <operator>&amp;&amp;</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>inWrTrans</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nCursor</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_blob</name> <modifier>*</modifier></type><name>pBlob</name> <init>= <expr><name><name>pRtree</name><operator>-&gt;</operator><name>pNodeBlob</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pNodeBlob</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_blob_close</name><argument_list>(<argument><expr><name>pBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Obtain a reference to an r-tree node.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nodeAcquire</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>,             <comment type="block">/* R-tree structure */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iNode</name></decl></parameter>,                 <comment type="block">/* Node number to load */</comment>
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pParent</name></decl></parameter>,        <comment type="block">/* Either the parent node or NULL */</comment>
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNode</name></decl></parameter>         <comment type="block">/* OUT: Acquired node */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check if the requested node is already in the hash table. If so,
  ** increase its reference count and return it.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pNode</name> <operator>=</operator> <call><name>nodeHashLookup</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>iNode</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pParent</name> <operator>&amp;&amp;</operator> <name>pParent</name><operator>!=</operator><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>RTREE_IS_CORRUPT</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_CORRUPT_VTAB</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppNode</name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>pNodeBlob</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_blob</name> <modifier>*</modifier></type><name>pBlob</name> <init>= <expr><name><name>pRtree</name><operator>-&gt;</operator><name>pNodeBlob</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pNodeBlob</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_blob_reopen</name><argument_list>(<argument><expr><name>pBlob</name></expr></argument>, <argument><expr><name>iNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pNodeBlob</name></name> <operator>=</operator> <name>pBlob</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>nodeBlobReset</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>pNodeBlob</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s_node"</literal></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_blob_open</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="string">"data"</literal></expr></argument>, <argument><expr><name>iNode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>pNodeBlob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>nodeBlobReset</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppNode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* If unable to open an sqlite3_blob on the desired row, that can only
    ** be because the shadow tables hold erroneous data. */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ERROR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_VTAB</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RTREE_IS_CORRUPT</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name><operator>==</operator><call><name>sqlite3_blob_bytes</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pNodeBlob</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>(</operator><name>RtreeNode</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeNode</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pNode</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pParent</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>zData</name></name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nNodeRef</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name> <operator>=</operator> <name>iNode</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>isDirty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_blob_read</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pNodeBlob</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>,
                             <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the root node was just loaded, set pRtree-&gt;iDepth to the height
  ** of the r-tree structure. A height of zero means all data is stored on
  ** the root node. A height of one means the children of the root node
  ** are the leaves, and so on. If the depth as specified on the root node
  ** is greater than RTREE_MAX_DEPTH, the r-tree structure must be corrupt.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pNode</name> <operator>&amp;&amp;</operator> <name>iNode</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name> <operator>=</operator> <call><name>readInt16</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name><operator>&gt;</operator><name>RTREE_MAX_DEPTH</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_VTAB</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RTREE_IS_CORRUPT</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If no error has occurred so far, check if the "number of entries"
  ** field on the node is too large. If so, set the return code to 
  ** SQLITE_CORRUPT_VTAB.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pNode</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>NCELL</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call><operator>&gt;</operator><operator>(</operator><operator>(</operator><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name><operator>-</operator><literal type="number">4</literal><operator>)</operator><operator>/</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_VTAB</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RTREE_IS_CORRUPT</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pNode</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>nodeReference</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodeHashInsert</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_VTAB</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RTREE_IS_CORRUPT</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppNode</name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nNodeRef</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppNode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Overwrite cell iCell of node pNode with the contents of pCell.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>nodeOverwriteCell</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>,             <comment type="block">/* The overall R-Tree */</comment>
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,          <comment type="block">/* The node into which the cell is to be written */</comment>
  <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,          <comment type="block">/* The cell to write */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>                  <comment type="block">/* Index into pNode into which pCell is written */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name><operator>*</operator><name>iCell</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>writeInt64</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>writeCoord</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCell</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>isDirty</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Remove the cell with index iCell from node pNode.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>nodeDeleteCell</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pDst</name> <init>= <expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name><operator>*</operator><name>iCell</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><operator>&amp;</operator><name><name>pDst</name><index>[<expr><name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><operator>(</operator><call><name>NCELL</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>iCell</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>pDst</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>writeInt16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>NCELL</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>isDirty</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Insert the contents of cell pCell into node pNode. If the insert
** is successful, return SQLITE_OK.
**
** If there is not enough free space in pNode, return SQLITE_FULL.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nodeInsertCell</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>,                <comment type="block">/* The overall R-Tree */</comment>
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,             <comment type="block">/* Write new cell into this node */</comment>
  <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>              <comment type="block">/* The cell to be inserted */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>                    <comment type="block">/* Current number of cells in pNode */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMaxCell</name></decl>;</decl_stmt>                 <comment type="block">/* Maximum number of cells for pNode */</comment>

  <expr_stmt><expr><name>nMaxCell</name> <operator>=</operator> <operator>(</operator><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name><operator>-</operator><literal type="number">4</literal><operator>)</operator><operator>/</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCell</name> <operator>=</operator> <call><name>NCELL</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCell</name><operator>&lt;=</operator><name>nMaxCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nCell</name><operator>&lt;</operator><name>nMaxCell</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>nodeOverwriteCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>nCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>writeInt16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nCell</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>isDirty</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><operator>(</operator><name>nCell</name><operator>==</operator><name>nMaxCell</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the node is dirty, write it out to the database.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nodeWrite</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>isDirty</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteNode</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>isDirty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name> <operator>=</operator> <call><name>sqlite3_last_insert_rowid</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodeHashInsert</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Release a reference to a node. If the node is dirty and the reference
** count drops to zero, the node data is written to the database.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nodeRelease</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nNodeRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nNodeRef</name></name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeWrite</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>nodeHashDelete</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the 64-bit integer value associated with cell iCell of
** node pNode. If pNode is a leaf node, this is a rowid. If it is
** an internal node, then the 64-bit integer is a child page number.
*/</comment>
<function><type><specifier>static</specifier> <name>i64</name></type> <name>nodeGetRowid</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>,       <comment type="block">/* The overall R-Tree */</comment>
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,    <comment type="block">/* The node from which to extract the ID */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>            <comment type="block">/* The cell index from which to extract the ID */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCell</name><operator>&lt;</operator><call><name>NCELL</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>readInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name><operator>*</operator><name>iCell</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return coordinate iCoord from cell iCell in node pNode.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>nodeGetCoord</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>,               <comment type="block">/* The overall R-Tree */</comment>
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,            <comment type="block">/* The node from which to extract a coordinate */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>,                   <comment type="block">/* The index of the cell within the node */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCoord</name></decl></parameter>,                  <comment type="block">/* Which coordinate to extract */</comment>
  <parameter><decl><type><name>RtreeCoord</name> <modifier>*</modifier></type><name>pCoord</name></decl></parameter>           <comment type="block">/* OUT: Space to write result to */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>zData</name><index>[<expr><literal type="number">12</literal> <operator>+</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name><operator>*</operator><name>iCell</name> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>iCoord</name></expr>]</index></name></expr></argument>, <argument><expr><name>pCoord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Deserialize cell iCell of node pNode. Populate the structure pointed
** to by pCell with the results.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>nodeGetCell</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>,               <comment type="block">/* The overall R-Tree */</comment>
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,            <comment type="block">/* The node containing the cell to be read */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>,                   <comment type="block">/* Index of the cell within the node */</comment>
  <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>             <comment type="block">/* OUT: Write the cell contents here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCoord</name> <modifier>*</modifier></type><name>pCoord</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <call><name>nodeGetRowid</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pData</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>zData</name></name> <operator>+</operator> <operator>(</operator><literal type="number">12</literal> <operator>+</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name><operator>*</operator><name>iCell</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCoord</name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>aCoord</name></name></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCoord</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pData</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCoord</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pData</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>ii</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>ii</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name></expr> )</condition>;</do>
</block_content>}</block></function>


<comment type="block">/* Forward declaration for the function that does the work of
** the virtual table module xCreate() and xConnect() methods.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>rtreeInit</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>
)</parameter_list>;</function_decl>

<comment type="block">/* 
** Rtree virtual table module xCreate method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeCreate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>rtreeInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ppVtab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Rtree virtual table module xConnect method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>rtreeInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ppVtab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Increment the r-tree reference count.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreeReference</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nBusy</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Decrement the r-tree reference count. When the reference count reaches
** zero the structure is deleted.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreeRelease</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nBusy</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>nBusy</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>inWrTrans</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nCursor</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodeBlobReset</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nNodeRef</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>bCorrupt</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteAux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zReadAuxSql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** Rtree virtual table module xDisconnect method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>rtreeRelease</name><argument_list>(<argument><expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Rtree virtual table module xDestroy method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeDestroy</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCreate</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(
    <argument><expr><literal type="string">"DROP TABLE '%q'.'%q_node';"</literal>
    <literal type="string">"DROP TABLE '%q'.'%q_rowid';"</literal>
    <literal type="string">"DROP TABLE '%q'.'%q_parent';"</literal></expr></argument>,
    <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, 
    <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
    <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
  )</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zCreate</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>nodeBlobReset</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zCreate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>rtreeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Rtree virtual table module xOpen method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_NOMEM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><name>pVTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <operator>(</operator><name>RtreeCursor</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name> <operator>=</operator> <name>pVTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nCursor</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab_cursor</name> <operator>*</operator><operator>)</operator><name>pCsr</name></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Reset a cursor back to its initial state.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>resetCursor</name><parameter_list>(<parameter><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aConstraint</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Used to iterate through constraint array */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_rtree_query_info</name> <modifier>*</modifier></type><name>pInfo</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pInfo</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pInfo</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>xDelUser</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>pInfo</name><operator>-&gt;</operator><name>xDelUser</name></name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pUser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aConstraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aConstraint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>RTREE_CACHE_SZ</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPoint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name><operator>*</operator><operator>)</operator><name>pRtree</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/* 
** Rtree virtual table module xClose method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>RtreeCursor</name> <operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nCursor</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>resetCursor</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nCursor</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodeBlobReset</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Rtree virtual table module xEof method.
**
** Return non-zero if the cursor does not currently point to a valid 
** record (i.e if the scan has finished), or zero otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>RtreeCursor</name> <operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCsr</name><operator>-&gt;</operator><name>atEOF</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert raw bits from the on-disk RTree record into a coordinate value.
** The on-disk format is big-endian and needs to be converted for little-
** endian platforms.  The on-disk record stores integer coordinates if
** eInt is true and it stores 32-bit floating point records if eInt is
** false.  a[] is the four bytes of the on-disk record to be decoded.
** Store the results in "r".
**
** There are five versions of this macro.  The last one is generic.  The
** other four are various architectures-specific optimizations.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <name>MSVC_VERSION</name><operator>&gt;=</operator><literal type="number">1300</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_DECODE_COORD</name><parameter_list>(<parameter><type><name>eInt</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                        \
    RtreeCoord c;    <comment type="block">/* Coordinate decoded */</comment>                   \
    c.u = _byteswap_ulong(*(u32*)a);                            \
    r = eInt ? (sqlite3_rtree_dbl)c.i : (sqlite3_rtree_dbl)c.f; \
}</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal> <operator>&amp;&amp;</operator> <name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">4003000</literal></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_DECODE_COORD</name><parameter_list>(<parameter><type><name>eInt</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                        \
    RtreeCoord c;    <comment type="block">/* Coordinate decoded */</comment>                   \
    c.u = __builtin_bswap32(*(u32*)a);                          \
    r = eInt ? (sqlite3_rtree_dbl)c.i : (sqlite3_rtree_dbl)c.f; \
}</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_DECODE_COORD</name><parameter_list>(<parameter><type><name>eInt</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                        \
    RtreeCoord c;    <comment type="block">/* Coordinate decoded */</comment>                   \
    memcpy(&amp;c.u,a,4);                                           \
    c.u = ((c.u&gt;&gt;24)&amp;0xff)|((c.u&gt;&gt;8)&amp;0xff00)|                   \
          ((c.u&amp;0xff)&lt;&lt;24)|((c.u&amp;0xff00)&lt;&lt;8);                   \
    r = eInt ? (sqlite3_rtree_dbl)c.i : (sqlite3_rtree_dbl)c.f; \
}</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_BYTEORDER</name><operator>==</operator><literal type="number">4321</literal></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_DECODE_COORD</name><parameter_list>(<parameter><type><name>eInt</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                        \
    RtreeCoord c;    <comment type="block">/* Coordinate decoded */</comment>                   \
    memcpy(&amp;c.u,a,4);                                           \
    r = eInt ? (sqlite3_rtree_dbl)c.i : (sqlite3_rtree_dbl)c.f; \
}</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_DECODE_COORD</name><parameter_list>(<parameter><type><name>eInt</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{                        \
    RtreeCoord c;    <comment type="block">/* Coordinate decoded */</comment>                   \
    c.u = ((u32)a[0]&lt;&lt;24) + ((u32)a[1]&lt;&lt;16)                     \
           +((u32)a[2]&lt;&lt;8) + a[3];                              \
    r = eInt ? (sqlite3_rtree_dbl)c.i : (sqlite3_rtree_dbl)c.f; \
}</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Check the RTree node or entry given by pCellData and p against the MATCH
** constraint pConstraint.  
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeCallbackConstraint</name><parameter_list>(
  <parameter><decl><type><name>RtreeConstraint</name> <modifier>*</modifier></type><name>pConstraint</name></decl></parameter>,  <comment type="block">/* The constraint to test */</comment>
  <parameter><decl><type><name>int</name></type> <name>eInt</name></decl></parameter>,                      <comment type="block">/* True if RTree holding integer coordinates */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCellData</name></decl></parameter>,                 <comment type="block">/* Raw cell content */</comment>
  <parameter><decl><type><name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>pSearch</name></decl></parameter>,     <comment type="block">/* Container of this cell */</comment>
  <parameter><decl><type><name>sqlite3_rtree_dbl</name> <modifier>*</modifier></type><name>prScore</name></decl></parameter>,    <comment type="block">/* OUT: score for the cell */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>peWithin</name></decl></parameter>                  <comment type="block">/* OUT: visibility of the cell */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_rtree_query_info</name> <modifier>*</modifier></type><name>pInfo</name> <init>= <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>pInfo</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Callback info */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCoord</name> <init>= <expr><name><name>pInfo</name><operator>-&gt;</operator><name>nCoord</name></name></expr></init></decl>;</decl_stmt>                           <comment type="block">/* No. of coordinates */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                                             <comment type="block">/* Callback return code */</comment>
  <decl_stmt><decl><type><name>RtreeCoord</name></type> <name>c</name></decl>;</decl_stmt>                                       <comment type="block">/* Translator union */</comment>
  <decl_stmt><decl><type><name>sqlite3_rtree_dbl</name></type> <name><name>aCoord</name><index>[<expr><name>RTREE_MAX_DIMENSIONS</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* Decoded coordinates */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_MATCH</name> <operator>||</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_QUERY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCoord</name><operator>==</operator><literal type="number">2</literal> <operator>||</operator> <name>nCoord</name><operator>==</operator><literal type="number">4</literal> <operator>||</operator> <name>nCoord</name><operator>==</operator><literal type="number">6</literal> <operator>||</operator> <name>nCoord</name><operator>==</operator><literal type="number">8</literal> <operator>||</operator> <name>nCoord</name><operator>==</operator><literal type="number">10</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_QUERY</name> <operator>&amp;&amp;</operator> <name><name>pSearch</name><operator>-&gt;</operator><name>iLevel</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <call><name>readInt64</name><argument_list>(<argument><expr><name>pCellData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pCellData</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_RTREE_INT_ONLY</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>eInt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <switch>switch<condition>( <expr><name>nCoord</name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">10</literal></expr>:</case>  <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">36</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>f</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>f</name></name></expr>;</expr_stmt>
      <case>case <expr><literal type="number">8</literal></expr>:</case>   <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">28</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>f</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">24</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>f</name></name></expr>;</expr_stmt>
      <case>case <expr><literal type="number">6</literal></expr>:</case>   <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">20</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>f</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">16</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>f</name></name></expr>;</expr_stmt>
      <case>case <expr><literal type="number">4</literal></expr>:</case>   <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">12</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>f</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">8</literal></expr></argument>,  <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>f</name></name></expr>;</expr_stmt>
      <default>default:</default>  <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">4</literal></expr></argument>,  <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>f</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>f</name></name></expr>;</expr_stmt>
    </block_content>}</block></switch>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <switch>switch<condition>( <expr><name>nCoord</name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">10</literal></expr>:</case>  <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">36</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
      <case>case <expr><literal type="number">8</literal></expr>:</case>   <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">28</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">24</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
      <case>case <expr><literal type="number">6</literal></expr>:</case>   <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">20</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">16</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
      <case>case <expr><literal type="number">4</literal></expr>:</case>   <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">12</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">8</literal></expr></argument>,  <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
      <default>default:</default>  <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name><operator>+</operator><literal type="number">4</literal></expr></argument>,  <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><name>pCellData</name></expr></argument>,    <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>aCoord</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    </block_content>}</block></switch>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_MATCH</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eWithin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pConstraint</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>xGeom</name></name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_rtree_geometry</name><operator>*</operator><operator>)</operator><name>pInfo</name></expr></argument>,
                              <argument><expr><name>nCoord</name></expr></argument>, <argument><expr><name>aCoord</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eWithin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eWithin</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>peWithin</name> <operator>=</operator> <name>NOT_WITHIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>prScore</name> <operator>=</operator> <name>RTREE_ZERO</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aCoord</name></name> <operator>=</operator> <name>aCoord</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>iLevel</name></name> <operator>=</operator> <name><name>pSearch</name><operator>-&gt;</operator><name>iLevel</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>rScore</name></name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>rParentScore</name></name> <operator>=</operator> <name><name>pSearch</name><operator>-&gt;</operator><name>rScore</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>eWithin</name></name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>eParentWithin</name></name> <operator>=</operator> <name><name>pSearch</name><operator>-&gt;</operator><name>eWithin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pConstraint</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>xQueryFunc</name></name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>eWithin</name></name><operator>&lt;</operator><operator>*</operator><name>peWithin</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>peWithin</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>eWithin</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>rScore</name></name><operator>&lt;</operator><operator>*</operator><name>prScore</name> <operator>||</operator> <operator>*</operator><name>prScore</name><operator>&lt;</operator><name>RTREE_ZERO</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>prScore</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>rScore</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Check the internal RTree node given by pCellData against constraint p.
** If this constraint cannot be satisfied by any child within the node,
** set *peWithin to NOT_WITHIN.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreeNonleafConstraint</name><parameter_list>(
  <parameter><decl><type><name>RtreeConstraint</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,        <comment type="block">/* The constraint to test */</comment>
  <parameter><decl><type><name>int</name></type> <name>eInt</name></decl></parameter>,                  <comment type="block">/* True if RTree holds integer coordinates */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCellData</name></decl></parameter>,             <comment type="block">/* Raw cell content as appears on disk */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>peWithin</name></decl></parameter>              <comment type="block">/* Adjust downward, as appropriate */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_rtree_dbl</name></type> <name>val</name></decl>;</decl_stmt>     <comment type="block">/* Coordinate value convert to a double */</comment>

  <comment type="block">/* p-&gt;iCoord might point to either a lower or upper bound coordinate
  ** in a coordinate pair.  But make pCellData point to the lower bound.
  */</comment>
  <expr_stmt><expr><name>pCellData</name> <operator>+=</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iCoord</name></name><operator>&amp;</operator><literal type="number">0xfe</literal><operator>)</operator></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_LE</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_LT</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_GE</name> 
      <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_GT</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_EQ</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_TRUE</name>
      <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_FALSE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pCellData</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal><operator>)</operator><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 4-byte aligned */</comment>
  <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>RTREE_TRUE</name></expr>:</case>  <return>return;</return>   <comment type="block">/* Always satisfied */</comment>
    <case>case <expr><name>RTREE_FALSE</name></expr>:</case> <break>break;</break>    <comment type="block">/* Never satisfied */</comment>
    <case>case <expr><name>RTREE_EQ</name></expr>:</case>
      <expr_stmt><expr><call><name>RTREE_DECODE_COORD</name><argument_list>(<argument><expr><name>eInt</name></expr></argument>, <argument><expr><name>pCellData</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* val now holds the lower bound of the coordinate pair */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name><operator>&gt;=</operator><name>val</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pCellData</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RTREE_DECODE_COORD</name><argument_list>(<argument><expr><name>eInt</name></expr></argument>, <argument><expr><name>pCellData</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* val now holds the upper bound of the coordinate pair */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name><operator>&lt;=</operator><name>val</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>RTREE_LE</name></expr>:</case>
    <case>case <expr><name>RTREE_LT</name></expr>:</case>
      <expr_stmt><expr><call><name>RTREE_DECODE_COORD</name><argument_list>(<argument><expr><name>eInt</name></expr></argument>, <argument><expr><name>pCellData</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* val now holds the lower bound of the coordinate pair */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name><operator>&gt;=</operator><name>val</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <break>break;</break>

    <default>default:</default>
      <expr_stmt><expr><name>pCellData</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RTREE_DECODE_COORD</name><argument_list>(<argument><expr><name>eInt</name></expr></argument>, <argument><expr><name>pCellData</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* val now holds the upper bound of the coordinate pair */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name><operator>&lt;=</operator><name>val</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><operator>*</operator><name>peWithin</name> <operator>=</operator> <name>NOT_WITHIN</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Check the leaf RTree cell given by pCellData against constraint p.
** If this constraint is not satisfied, set *peWithin to NOT_WITHIN.
** If the constraint is satisfied, leave *peWithin unchanged.
**
** The constraint is of the form:  xN op $val
**
** The op is given by p-&gt;op.  The xN is p-&gt;iCoord-th coordinate in
** pCellData.  $val is given by p-&gt;u.rValue.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreeLeafConstraint</name><parameter_list>(
  <parameter><decl><type><name>RtreeConstraint</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,        <comment type="block">/* The constraint to test */</comment>
  <parameter><decl><type><name>int</name></type> <name>eInt</name></decl></parameter>,                  <comment type="block">/* True if RTree holds integer coordinates */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCellData</name></decl></parameter>,             <comment type="block">/* Raw cell content as appears on disk */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>peWithin</name></decl></parameter>              <comment type="block">/* Adjust downward, as appropriate */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>xN</name></decl>;</decl_stmt>      <comment type="block">/* Coordinate value converted to a double */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_LE</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_LT</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_GE</name> 
      <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_GT</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_EQ</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_TRUE</name>
      <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_FALSE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCellData</name> <operator>+=</operator> <literal type="number">8</literal> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>iCoord</name></name><operator>*</operator><literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pCellData</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal><operator>)</operator><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 4-byte aligned */</comment>
  <expr_stmt><expr><call><name>RTREE_DECODE_COORD</name><argument_list>(<argument><expr><name>eInt</name></expr></argument>, <argument><expr><name>pCellData</name></expr></argument>, <argument><expr><name>xN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>RTREE_TRUE</name></expr>:</case>  <return>return;</return>   <comment type="block">/* Always satisfied */</comment>
    <case>case <expr><name>RTREE_FALSE</name></expr>:</case> <break>break;</break>    <comment type="block">/* Never satisfied */</comment>
    <case>case <expr><name>RTREE_LE</name></expr>:</case>    <if_stmt><if>if<condition>( <expr><name>xN</name> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <break>break;</break>
    <case>case <expr><name>RTREE_LT</name></expr>:</case>    <if_stmt><if>if<condition>( <expr><name>xN</name> <operator>&lt;</operator>  <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <break>break;</break>
    <case>case <expr><name>RTREE_GE</name></expr>:</case>    <if_stmt><if>if<condition>( <expr><name>xN</name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <break>break;</break>
    <case>case <expr><name>RTREE_GT</name></expr>:</case>    <if_stmt><if>if<condition>( <expr><name>xN</name> <operator>&gt;</operator>  <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <break>break;</break>
    <default>default:</default>          <if_stmt><if>if<condition>( <expr><name>xN</name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><operator>*</operator><name>peWithin</name> <operator>=</operator> <name>NOT_WITHIN</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** One of the cells in node pNode is guaranteed to have a 64-bit 
** integer value equal to iRowid. Return the index of this cell.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nodeRowidIndex</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, 
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, 
  <parameter><decl><type><name>i64</name></type> <name>iRowid</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piIndex</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name> <init>= <expr><call><name>NCELL</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCell</name><operator>&lt;</operator><literal type="number">200</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>nodeGetRowid</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call><operator>==</operator><name>iRowid</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piIndex</name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>RTREE_IS_CORRUPT</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_CORRUPT_VTAB</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the index of the cell containing a pointer to node pNode
** in its parent. If pNode is the root node, return -1.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nodeParentIndex</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piIndex</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pParent</name> <init>= <expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>nodeRowidIndex</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pParent</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr></argument>, <argument><expr><name>piIndex</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>piIndex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compare two search points.  Return negative, zero, or positive if the first
** is less than, equal to, or greater than the second.
**
** The rScore is the primary key.  Smaller rScore values come first.
** If the rScore is a tie, then use iLevel as the tie breaker with smaller
** iLevel values coming first.  In this way, if rScore is the same for all
** SearchPoints, then iLevel becomes the deciding factor and the result
** is a depth-first search, which is the desired default behavior.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeSearchPointCompare</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>rScore</name></name><operator>&lt;</operator><name><name>pB</name><operator>-&gt;</operator><name>rScore</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>rScore</name></name><operator>&gt;</operator><name><name>pB</name><operator>-&gt;</operator><name>rScore</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>iLevel</name></name><operator>&lt;</operator><name><name>pB</name><operator>-&gt;</operator><name>iLevel</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>iLevel</name></name><operator>&gt;</operator><name><name>pB</name><operator>-&gt;</operator><name>iLevel</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Interchange two search points in a cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreeSearchPointSwap</name><parameter_list>(<parameter><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeSearchPoint</name></type> <name>t</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><name>j</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>RTREE_CACHE_SZ</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><name>RTREE_CACHE_SZ</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>nodeRelease</name><argument_list>(<argument><expr><call><name>RTREE_OF_CURSOR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pTemp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>pTemp</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the search point with the lowest current score.
*/</comment>
<function><type><specifier>static</specifier> <name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>rtreeSearchPointFirst</name><parameter_list>(<parameter><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name><name>pCur</name><operator>-&gt;</operator><name>bPoint</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>sPoint</name></name></expr> </then><else>: <expr><ternary><condition><expr><name><name>pCur</name><operator>-&gt;</operator><name>nPoint</name></name></expr> ?</condition><then> <expr><name><name>pCur</name><operator>-&gt;</operator><name>aPoint</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Get the RtreeNode for the search point with the lowest score.
*/</comment>
<function><type><specifier>static</specifier> <name>RtreeNode</name> <modifier>*</modifier></type><name>rtreeNodeOfFirstSearchPoint</name><parameter_list>(<parameter><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">1</literal> <operator>-</operator> <name><name>pCur</name><operator>-&gt;</operator><name>bPoint</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>ii</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>ii</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>bPoint</name></name> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>nPoint</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>ii</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRC</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>id</name> <operator>=</operator> <ternary><condition><expr><name>ii</name></expr> ?</condition><then> <expr><name><name>pCur</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>id</name></expr> </then><else>: <expr><name><name>pCur</name><operator>-&gt;</operator><name>sPoint</name><operator>.</operator><name>id</name></name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <call><name>nodeAcquire</name><argument_list>(<argument><expr><call><name>RTREE_OF_CURSOR</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Push a new element onto the priority queue
*/</comment>
<function><type><specifier>static</specifier> <name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>rtreeEnqueue</name><parameter_list>(
  <parameter><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,    <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>RtreeDValue</name></type> <name>rScore</name></decl></parameter>,   <comment type="block">/* Score for the new search point */</comment>
  <parameter><decl><type><name>u8</name></type> <name>iLevel</name></decl></parameter>             <comment type="block">/* Level for the new search point */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nPoint</name></name><operator>&gt;=</operator><name><name>pCur</name><operator>-&gt;</operator><name>nPointAlloc</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>nPointAlloc</name></name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aPoint</name></name></expr></argument>, <argument><expr><name>nNew</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aPoint</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nPointAlloc</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>nPoint</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aPoint</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rScore</name></name> <operator>=</operator> <name>rScore</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iLevel</name></name> <operator>=</operator> <name>iLevel</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLevel</name><operator>&lt;=</operator><name>RTREE_MAX_DEPTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>pParent</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>(</operator><name>i</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParent</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aPoint</name></name> <operator>+</operator> <name>j</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>rtreeSearchPointCompare</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pParent</name></expr></argument>)</argument_list></call><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>rtreeSearchPointSwap</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name>pParent</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a new RtreeSearchPoint and return a pointer to it.  Return
** NULL if malloc fails.
*/</comment>
<function><type><specifier>static</specifier> <name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>rtreeSearchPointNew</name><parameter_list>(
  <parameter><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,    <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>RtreeDValue</name></type> <name>rScore</name></decl></parameter>,   <comment type="block">/* Score for the new search point */</comment>
  <parameter><decl><type><name>u8</name></type> <name>iLevel</name></decl></parameter>             <comment type="block">/* Level for the new search point */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>pNew</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pFirst</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pFirst</name> <operator>=</operator> <call><name>rtreeSearchPointFirst</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>anQueue</name><index>[<expr><name>iLevel</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFirst</name><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <name><name>pFirst</name><operator>-&gt;</operator><name>rScore</name></name><operator>&gt;</operator><name>rScore</name> 
   <operator>||</operator> <operator>(</operator><name><name>pFirst</name><operator>-&gt;</operator><name>rScore</name></name><operator>==</operator><name>rScore</name> <operator>&amp;&amp;</operator> <name><name>pFirst</name><operator>-&gt;</operator><name>iLevel</name></name><operator>&gt;</operator><name>iLevel</name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>bPoint</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>rtreeEnqueue</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>rScore</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>ii</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pNew</name> <operator>-</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aPoint</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>ii</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>ii</name><operator>&lt;</operator><name>RTREE_CACHE_SZ</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>ii</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>nodeRelease</name><argument_list>(<argument><expr><call><name>RTREE_OF_CURSOR</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pNew</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>sPoint</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>sPoint</name><operator>.</operator><name>rScore</name></name> <operator>=</operator> <name>rScore</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>sPoint</name><operator>.</operator><name>iLevel</name></name> <operator>=</operator> <name>iLevel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>bPoint</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>sPoint</name></name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>rtreeEnqueue</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>rScore</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* Tracing routines for the RtreeSearchPoint queue */</comment>
static void tracePoint(RtreeSearchPoint *p, int idx, RtreeCursor *pCur){
  if( idx&lt;0 ){ printf(" s"); }else{ printf("%2d", idx); }
  printf(" %d.%05lld.%02d %g %d",
    p-&gt;iLevel, p-&gt;id, p-&gt;iCell, p-&gt;rScore, p-&gt;eWithin
  );
  idx++;
  if( idx&lt;RTREE_CACHE_SZ ){
    printf(" %p\n", pCur-&gt;aNode[idx]);
  }else{
    printf("\n");
  }
}
static void traceQueue(RtreeCursor *pCur, const char *zPrefix){
  int ii;
  printf("=== %9s ", zPrefix);
  if( pCur-&gt;bPoint ){
    tracePoint(&amp;pCur-&gt;sPoint, -1, pCur);
  }
  for(ii=0; ii&lt;pCur-&gt;nPoint; ii++){
    if( ii&gt;0 || pCur-&gt;bPoint ) printf("              ");
    tracePoint(&amp;pCur-&gt;aPoint[ii], ii, pCur);
  }
}
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_QUEUE_TRACE</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>traceQueue(A,B)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_QUEUE_TRACE</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>   <comment type="block">/* no-op */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Remove the search point with the lowest current score.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreeSearchPointPop</name><parameter_list>(<parameter><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>bPoint</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>i</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>nodeRelease</name><argument_list>(<argument><expr><call><name>RTREE_OF_CURSOR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bPoint</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>anQueue</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>sPoint</name><operator>.</operator><name>iLevel</name></name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bPoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nPoint</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>anQueue</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iLevel</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>--</operator><name><name>p</name><operator>-&gt;</operator><name>nPoint</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><name>RTREE_CACHE_SZ</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>j</name> <operator>=</operator> <name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;</operator><name>n</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>k</name><operator>&lt;</operator><name>n</name> <operator>&amp;&amp;</operator> <call><name>rtreeSearchPointCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>rtreeSearchPointCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>rtreeSearchPointSwap</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>i</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>rtreeSearchPointCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>rtreeSearchPointSwap</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Continue the search on cursor pCur until the front of the queue
** contains an entry suitable for returning as a result-set row,
** or until the RtreeSearchPoint queue is empty, indicating that the
** query has completed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeStepToLeaf</name><parameter_list>(<parameter><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><call><name>RTREE_OF_CURSOR</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eWithin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nConstraint</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>nConstraint</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eInt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeSearchPoint</name></type> <name>x</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>eInt</name> <operator>=</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>eCoordType</name></name><operator>==</operator><name>RTREE_COORD_INT32</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>rtreeSearchPointFirst</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iLevel</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCellData</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>rtreeNodeOfFirstSearchPoint</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nCell</name> <operator>=</operator> <call><name>NCELL</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCell</name><operator>&lt;</operator><literal type="number">200</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCellData</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>zData</name></name> <operator>+</operator> <operator>(</operator><literal type="number">4</literal><operator>+</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name><operator>)</operator></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name><operator>&lt;</operator><name>nCell</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_rtree_dbl</name></type> <name>rScore</name> <init>= <expr><operator>(</operator><name>sqlite3_rtree_dbl</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>eWithin</name> <operator>=</operator> <name>FULLY_WITHIN</name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nConstraint</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>RtreeConstraint</name> <modifier>*</modifier></type><name>pConstraint</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>aConstraint</name></name> <operator>+</operator> <name>ii</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>&gt;=</operator><name>RTREE_MATCH</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeCallbackConstraint</name><argument_list>(<argument><expr><name>pConstraint</name></expr></argument>, <argument><expr><name>eInt</name></expr></argument>, <argument><expr><name>pCellData</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name>rScore</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eWithin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iLevel</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>rtreeLeafConstraint</name><argument_list>(<argument><expr><name>pConstraint</name></expr></argument>, <argument><expr><name>eInt</name></expr></argument>, <argument><expr><name>pCellData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eWithin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>rtreeNonleafConstraint</name><argument_list>(<argument><expr><name>pConstraint</name></expr></argument>, <argument><expr><name>eInt</name></expr></argument>, <argument><expr><name>pCellData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eWithin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>eWithin</name><operator>==</operator><name>NOT_WITHIN</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>pCellData</name> <operator>+=</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>eWithin</name><operator>==</operator><name>NOT_WITHIN</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iLevel</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iLevel</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>iLevel</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>x</name><operator>.</operator><name>id</name></name> <operator>=</operator> <call><name>readInt64</name><argument_list>(<argument><expr><name>pCellData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>nPoint</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>aPoint</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>id</name><operator>==</operator><name><name>x</name><operator>.</operator><name>id</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>RTREE_IS_CORRUPT</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>SQLITE_CORRUPT_VTAB</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iCell</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>x</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>x</name><operator>.</operator><name>iCell</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iCell</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name><operator>&gt;=</operator><name>nCell</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>RTREE_QUEUE_TRACE</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="string">"POP-S:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>rtreeSearchPointPop</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rScore</name><operator>&lt;</operator><name>RTREE_ZERO</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rScore</name> <operator>=</operator> <name>RTREE_ZERO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>rtreeSearchPointNew</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>rScore</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>iLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eWithin</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>eWithin</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name><name>x</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <name><name>x</name><operator>.</operator><name>iCell</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RTREE_QUEUE_TRACE</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="string">"PUSH-S:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name><operator>&gt;=</operator><name>nCell</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>RTREE_QUEUE_TRACE</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="string">"POP-Se:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>rtreeSearchPointPop</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>atEOF</name></name> <operator>=</operator> <name>p</name><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Rtree virtual table module xNext method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVtabCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>RtreeCursor</name> <operator>*</operator><operator>)</operator><name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Move to the next entry that matches the configured constraints. */</comment>
  <expr_stmt><expr><call><name>RTREE_QUEUE_TRACE</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"POP-Nx:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>bAuxValid</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bAuxValid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>rtreeSearchPointPop</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeStepToLeaf</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Rtree virtual table module xRowid method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVtabCursor</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>RtreeCursor</name> <operator>*</operator><operator>)</operator><name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>rtreeSearchPointFirst</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><call><name>rtreeNodeOfFirstSearchPoint</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <call><name>nodeGetRowid</name><argument_list>(<argument><expr><call><name>RTREE_OF_CURSOR</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Rtree virtual table module xColumn method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeColumn</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>RtreeCursor</name> <operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>rtreeSearchPointFirst</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCoord</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><call><name>rtreeNodeOfFirstSearchPoint</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>nodeGetRowid</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>i</name><operator>&lt;=</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>nodeGetCoord</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name></expr></argument>, <argument><expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_RTREE_INT_ONLY</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>eCoordType</name></name><operator>==</operator><name>RTREE_COORD_REAL32</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>c</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>eCoordType</name></name><operator>==</operator><name>RTREE_COORD_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>c</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCsr</name><operator>-&gt;</operator><name>bAuxValid</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v3</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zReadAuxSql</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, 
          <argument><expr><call><name>nodeGetRowid</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bAuxValid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,
         <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pReadAux</name></name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>  
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Use nodeAcquire() to obtain the leaf node containing the record with 
** rowid iRowid. If successful, set *ppLeaf to point to the node and
** return SQLITE_OK. If there is no such record in the table, set
** *ppLeaf to 0 and return SQLITE_OK. If an error occurs, set *ppLeaf
** to zero and return an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>findLeafNode</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>,              <comment type="block">/* RTree to search */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iRowid</name></decl></parameter>,                 <comment type="block">/* The rowid searching for */</comment>
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppLeaf</name></decl></parameter>,         <comment type="block">/* Write the node here */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piNode</name></decl></parameter>       <comment type="block">/* Write the node-id here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppLeaf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadRowid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadRowid</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iNode</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadRowid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>piNode</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piNode</name> <operator>=</operator> <name>iNode</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeAcquire</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>iNode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ppLeaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to configure the RtreeConstraint object passed
** as the second argument for a MATCH constraint. The value passed as the
** first argument to this function is the right-hand operand to the MATCH
** operator.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>deserializeGeometry</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>, <parameter><decl><type><name>RtreeConstraint</name> <modifier>*</modifier></type><name>pCons</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeMatchArg</name> <modifier>*</modifier></type><name>pBlob</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>       <comment type="block">/* BLOB returned by geometry function */</comment>
  <decl_stmt><decl><type><name>sqlite3_rtree_query_info</name> <modifier>*</modifier></type><name>pInfo</name></decl>;</decl_stmt>   <comment type="block">/* Callback information */</comment>

  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <call><name>sqlite3_value_pointer</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>, <argument><expr><literal type="string">"RtreeMatchArg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSrc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <operator>(</operator><name>sqlite3_rtree_query_info</name><operator>*</operator><operator>)</operator>
                <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pInfo</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pInfo</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBlob</name> <operator>=</operator> <operator>(</operator><name>RtreeMatchArg</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pInfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pBlob</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>iSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pContext</name></name> <operator>=</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>pContext</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nParam</name></name> <operator>=</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>nParam</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aParam</name></name> <operator>=</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>aParam</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>apSqlParam</name></name> <operator>=</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>apSqlParam</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pBlob</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>xGeom</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCons</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>xGeom</name></name> <operator>=</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>xGeom</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCons</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>RTREE_QUERY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCons</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>xQueryFunc</name></name> <operator>=</operator> <name><name>pBlob</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>xQueryFunc</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pCons</name><operator>-&gt;</operator><name>pInfo</name></name> <operator>=</operator> <name>pInfo</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Rtree virtual table module xFilter method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVtabCursor</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><name><name>pVtabCursor</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>RtreeCursor</name> <operator>*</operator><operator>)</operator><name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pRoot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCell</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>rtreeReference</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reset the cursor to the same state as rtreeOpen() leaves it in. */</comment>
  <expr_stmt><expr><call><name>resetCursor</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iStrategy</name></name> <operator>=</operator> <name>idxNum</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Special case - lookup by rowid. */</comment>
    <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pLeaf</name></decl>;</decl_stmt>        <comment type="block">/* Leaf on which the required cell resides */</comment>
    <decl_stmt><decl><type><name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>     <comment type="block">/* Search point for the leaf */</comment>
    <decl_stmt><decl><type><name>i64</name></type> <name>iRowid</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>iNode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><call><name>sqlite3_value_numeric_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name>
     <operator>||</operator> <operator>(</operator><name>eType</name><operator>==</operator><name>SQLITE_FLOAT</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>iRowid</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>findLeafNode</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLeaf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLeaf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pLeaf</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>rtreeSearchPointNew</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>RTREE_ZERO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Always returns pCsr-&gt;sPoint */</comment>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pLeaf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>iNode</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eWithin</name></name> <operator>=</operator> <name>PARTLY_WITHIN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeRowidIndex</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeaf</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>iCell</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RTREE_QUEUE_TRACE</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"PUSH-F1:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>atEOF</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Normal case - r-tree scan. Set up the RtreeCursor.aConstraint array 
    ** with the configured constraints. 
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeAcquire</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>argc</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aConstraint</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeConstraint</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nConstraint</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aConstraint</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aConstraint</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeConstraint</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>anQueue</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>idxStr</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>argc</name><operator>==</operator><literal type="number">0</literal><operator>)</operator>
                <operator>||</operator> <operator>(</operator><name>idxStr</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>idxStr</name></expr></argument>)</argument_list></call><operator>==</operator><name>argc</name><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>RtreeConstraint</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><call><name>sqlite3_value_numeric_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name><name>idxStr</name><index>[<expr><name>ii</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iCoord</name></name> <operator>=</operator> <name><name>idxStr</name><index>[<expr><name>ii</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-</operator><literal type="char">'0'</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>&gt;=</operator><name>RTREE_MATCH</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* A MATCH operator. The right-hand-side must be a blob that
            ** can be cast into an RtreeMatchArg object. One created using
            ** an sqlite3_rtree_geometry_callback() SQL user function.
            */</comment>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>deserializeGeometry</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pInfo</name><operator>-&gt;</operator><name>nCoord</name></name> <operator>=</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pInfo</name><operator>-&gt;</operator><name>anQueue</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>anQueue</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pInfo</name><operator>-&gt;</operator><name>mxLevel</name></name> <operator>=</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_INTEGER</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_FLOAT</name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_RTREE_INT_ONLY</name></cpp:ifdef>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name> <operator>=</operator> <call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rValue</name></name> <operator>=</operator> <name>RTREE_ZERO</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>RTREE_FALSE</name></expr>;</expr_stmt>
            </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_LT</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>RTREE_LE</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>RTREE_TRUE</name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>RTREE_FALSE</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>RtreeSearchPoint</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bPoint</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Due to the resetCursor() call above */</comment>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>rtreeSearchPointNew</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>RTREE_ZERO</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>       <comment type="block">/* Because pCsr-&gt;bPoint was FALSE */</comment>
        <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>eWithin</name></name> <operator>=</operator> <name>PARTLY_WITHIN</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bPoint</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pRoot</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RTREE_QUEUE_TRACE</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"PUSH-Fm:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeStepToLeaf</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rtreeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Rtree virtual table module xBestIndex method. There are three
** table scan strategies to choose from (in order from most to 
** least desirable):
**
**   idxNum     idxStr        Strategy
**   ------------------------------------------------
**     1        Unused        Direct lookup by rowid.
**     2        See below     R-tree query or full-table scan.
**   ------------------------------------------------
**
** If strategy 1 is used, then idxStr is not meaningful. If strategy
** 2 is used, idxStr is formatted to contain 2 bytes for each 
** constraint used. The first two bytes of idxStr correspond to 
** the constraint in sqlite3_index_info.aConstraintUsage[] with
** (argvIndex==1) etc.
**
** The first of each pair of bytes in idxStr identifies the constraint
** operator as follows:
**
**   Operator    Byte Value
**   ----------------------
**      =        0x41 ('A')
**     &lt;=        0x42 ('B')
**      &lt;        0x43 ('C')
**     &gt;=        0x44 ('D')
**      &gt;        0x45 ('E')
**   MATCH       0x46 ('F')
**   ----------------------
**
** The second of each pair of bytes identifies the coordinate column
** to which the constraint applies. The leftmost coordinate column
** is 'a', the second from the left 'b' etc.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeBestIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name><operator>*</operator><operator>)</operator><name>tab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bMatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* True if there exists a MATCH constraint */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nRow</name></decl>;</decl_stmt>                       <comment type="block">/* Estimated rows returned by this scan */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zIdxStr</name><index>[<expr><name>RTREE_MAX_DIMENSIONS</name><operator>*</operator><literal type="number">8</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>zIdxStr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zIdxStr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check if there exists a MATCH constraint - even an unusable one. If there
  ** is, do not consider the lookup-by-rowid plan as using such a plan would
  ** require the VDBE to evaluate the MATCH constraint, which is not currently
  ** possible. */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>op</name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_MATCH</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bMatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxStr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name> <operator>&amp;&amp;</operator> <name>iIdx</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zIdxStr</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>bMatch</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>usable</name></name> 
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> 
    )</condition><block>{<block_content>
      <comment type="block">/* We have an equality constraint on the rowid. Use strategy 1. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>jj</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name>ii</name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>jj</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>jj</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>jj</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <comment type="block">/* This strategy involves a two rowid lookups on an B-Tree structures
      ** and then a linear search of an R-Tree node. This should be 
      ** considered almost as quick as a direct rowid lookup (for which 
      ** sqlite uses an internal cost of 0.0). It is expected to return
      ** a single row.
      */</comment> 
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">30.0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxFlags</name></name> <operator>=</operator> <name>SQLITE_INDEX_SCAN_UNIQUE</name></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>usable</name></name>
    <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;=</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name><operator>)</operator>
        <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_MATCH</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name></type> <name>op</name></decl>;</decl_stmt>
      <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>:</case>    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>RTREE_EQ</name></expr>;</expr_stmt>    <break>break;</break>
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_GT</name></expr>:</case>    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>RTREE_GT</name></expr>;</expr_stmt>    <break>break;</break>
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_LE</name></expr>:</case>    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>RTREE_LE</name></expr>;</expr_stmt>    <break>break;</break>
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_LT</name></expr>:</case>    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>RTREE_LT</name></expr>;</expr_stmt>    <break>break;</break>
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_GE</name></expr>:</case>    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>RTREE_GE</name></expr>;</expr_stmt>    <break>break;</break>
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_MATCH</name></expr>:</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>RTREE_MATCH</name></expr>;</expr_stmt> <break>break;</break>
        <default>default:</default>                            <expr_stmt><expr><name>op</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>           <break>break;</break>
      </block_content>}</block></switch>
      <if_stmt><if>if<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>zIdxStr</name><index>[<expr><name>iIdx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zIdxStr</name><index>[<expr><name>iIdx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <operator>(</operator><name>iIdx</name><operator>/</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>needToFreeIdxStr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iIdx</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxStr</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zIdxStr</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>nRow</name> <operator>=</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nRowEst</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>iIdx</name><operator>/</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><literal type="number">6.0</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator><name>nRow</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <name>nRow</name></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the N-dimensional volumn of the cell stored in *p.
*/</comment>
<function><type><specifier>static</specifier> <name>RtreeDValue</name></type> <name>cellArea</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>area</name> <init>= <expr><operator>(</operator><name>RtreeDValue</name><operator>)</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name><operator>&lt;=</operator><literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_RTREE_INT_ONLY</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>eCoordType</name></name><operator>==</operator><name>RTREE_COORD_REAL32</name></expr> )</condition><block>{<block_content>
    <switch>switch<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">5</literal></expr>:</case>  <expr_stmt><expr><name>area</name>  <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">9</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
      <case>case <expr><literal type="number">4</literal></expr>:</case>  <expr_stmt><expr><name>area</name> <operator>*=</operator> <name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
      <case>case <expr><literal type="number">3</literal></expr>:</case>  <expr_stmt><expr><name>area</name> <operator>*=</operator> <name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
      <case>case <expr><literal type="number">2</literal></expr>:</case>  <expr_stmt><expr><name>area</name> <operator>*=</operator> <name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
      <default>default:</default> <expr_stmt><expr><name>area</name> <operator>*=</operator> <name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
    </block_content>}</block></switch>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <switch>switch<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">5</literal></expr>:</case>  <expr_stmt><expr><name>area</name>  <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">9</literal></expr>]</index></name><operator>.</operator><name>i</name> <operator>-</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>.</operator><name>i</name></expr>;</expr_stmt>
      <case>case <expr><literal type="number">4</literal></expr>:</case>  <expr_stmt><expr><name>area</name> <operator>*=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>.</operator><name>i</name> <operator>-</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>i</name></expr>;</expr_stmt>
      <case>case <expr><literal type="number">3</literal></expr>:</case>  <expr_stmt><expr><name>area</name> <operator>*=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>i</name> <operator>-</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>i</name></expr>;</expr_stmt>
      <case>case <expr><literal type="number">2</literal></expr>:</case>  <expr_stmt><expr><name>area</name> <operator>*=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>i</name> <operator>-</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>i</name></expr>;</expr_stmt>
      <default>default:</default> <expr_stmt><expr><name>area</name> <operator>*=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>i</name> <operator>-</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>i</name></expr>;</expr_stmt>
    </block_content>}</block></switch>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>area</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the margin length of cell p. The margin length is the sum
** of the objects size in each dimension.
*/</comment>
<function><type><specifier>static</specifier> <name>RtreeDValue</name></type> <name>cellMargin</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>margin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name> <operator>-</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><name>margin</name> <operator>+=</operator> <operator>(</operator><call><name>DCOORD</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>DCOORD</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>ii</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>ii</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <return>return <expr><name>margin</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Store the union of cells p1 and p2 in p1.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cellUnion</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>eCoordType</name></name><operator>==</operator><name>RTREE_COORD_REAL32</name></expr> )</condition><block>{<block_content>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>f</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>f</name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>f</name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ii</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>ii</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name></expr> )</condition>;</do>
  </block_content>}</block></if><else>else<block>{<block_content>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>i</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>i</name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>i</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>i</name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ii</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>ii</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name></expr> )</condition>;</do>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the area covered by p2 is a subset of the area covered
** by p1. False otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cellContains</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isInt</name> <init>= <expr><operator>(</operator><name><name>pRtree</name><operator>-&gt;</operator><name>eCoordType</name></name><operator>==</operator><name>RTREE_COORD_INT32</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>RtreeCoord</name> <modifier>*</modifier></type><name>a1</name> <init>= <expr><operator>&amp;</operator><name><name>p1</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeCoord</name> <modifier>*</modifier></type><name>a2</name> <init>= <expr><operator>&amp;</operator><name><name>p2</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>!</operator><name>isInt</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>a2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>f</name><operator>&lt;</operator><name><name>a1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>||</operator> <name><name>a2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>f</name><operator>&gt;</operator><name><name>a1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>f</name><operator>)</operator><operator>)</operator> 
     <operator>||</operator> <operator>(</operator> <name>isInt</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>a2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>i</name><operator>&lt;</operator><name><name>a1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>i</name> <operator>||</operator> <name><name>a2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>i</name><operator>&gt;</operator><name><name>a1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>i</name><operator>)</operator><operator>)</operator></expr> 
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the amount cell p would grow by if it were unioned with pCell.
*/</comment>
<function><type><specifier>static</specifier> <name>RtreeDValue</name></type> <name>cellGrowth</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>area</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCell</name></type> <name>cell</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>area</name> <operator>=</operator> <call><name>cellArea</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cellUnion</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><call><name>cellArea</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>)</argument_list></call><operator>-</operator><name>area</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RtreeDValue</name></type> <name>cellOverlap</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, 
  <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>aCell</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nCell</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>overlap</name> <init>= <expr><name>RTREE_ZERO</name></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>jj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>o</name> <init>= <expr><operator>(</operator><name>RtreeDValue</name><operator>)</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name></expr>;</condition> <incr><expr><name>jj</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>x1</name></decl>, <decl><type ref="prev"/><name>x2</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>x1</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><call><name>DCOORD</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>jj</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DCOORD</name><argument_list>(<argument><expr><name><name>aCell</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>aCoord</name><index>[<expr><name>jj</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>x2</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><call><name>DCOORD</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aCoord</name><index>[<expr><name>jj</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DCOORD</name><argument_list>(<argument><expr><name><name>aCell</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>aCoord</name><index>[<expr><name>jj</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>x2</name><operator>&lt;</operator><name>x1</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <operator>(</operator><name>RtreeDValue</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <name>o</name> <operator>*</operator> <operator>(</operator><name>x2</name><operator>-</operator><name>x1</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>overlap</name> <operator>+=</operator> <name>o</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>overlap</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function implements the ChooseLeaf algorithm from Gutman[84].
** ChooseSubTree in r*tree terminology.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ChooseLeaf</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>,               <comment type="block">/* Rtree table */</comment>
  <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,            <comment type="block">/* Cell to insert into rtree */</comment>
  <parameter><decl><type><name>int</name></type> <name>iHeight</name></decl></parameter>,                 <comment type="block">/* Height of sub-tree rooted at pCell */</comment>
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppLeaf</name></decl></parameter>           <comment type="block">/* OUT: Selected leaf page */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeAcquire</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>&lt;</operator><operator>(</operator><name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name><operator>-</operator><name>iHeight</name><operator>)</operator></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iBest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>fMinGrowth</name> <init>= <expr><name>RTREE_ZERO</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>fMinArea</name> <init>= <expr><name>RTREE_ZERO</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>nCell</name> <init>= <expr><call><name>NCELL</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeCell</name></type> <name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pChild</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>aCell</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Select the child node which will be enlarged the least if pCell
    ** is inserted into it. Resolve ties by choosing the entry with
    ** the smallest area.
    */</comment>
    <for>for<control>(<init><expr><name>iCell</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCell</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>iCell</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bBest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>growth</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>area</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodeGetCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>growth</name> <operator>=</operator> <call><name>cellGrowth</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>area</name> <operator>=</operator> <call><name>cellArea</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCell</name><operator>==</operator><literal type="number">0</literal><operator>||</operator><name>growth</name><operator>&lt;</operator><name>fMinGrowth</name><operator>||</operator><operator>(</operator><name>growth</name><operator>==</operator><name>fMinGrowth</name> <operator>&amp;&amp;</operator> <name>area</name><operator>&lt;</operator><name>fMinArea</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bBest</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>bBest</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>fMinGrowth</name> <operator>=</operator> <name>growth</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>fMinArea</name> <operator>=</operator> <name>area</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iBest</name> <operator>=</operator> <name><name>cell</name><operator>.</operator><name>iRowid</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeAcquire</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>iBest</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name>pChild</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><operator>*</operator><name>ppLeaf</name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A cell with the same content as pCell has just been inserted into
** the node pNode. This function updates the bounding box cells in
** all ancestor elements.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>AdjustTree</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>,                    <comment type="block">/* Rtree table */</comment>
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,                 <comment type="block">/* Adjust ancestry of this node. */</comment>
  <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>                  <comment type="block">/* This cell was just inserted */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>pNode</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pParent</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeCell</name></type> <name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>cnt</name><operator>&gt;</operator><literal type="number">100</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>RTREE_IS_CORRUPT</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_CORRUPT_VTAB</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeParentIndex</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>RTREE_IS_CORRUPT</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_CORRUPT_VTAB</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>nodeGetCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>cellContains</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>cellUnion</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodeOverwriteCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pParent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
 
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pParent</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write mapping (iRowid-&gt;iNode) to the &lt;rtree&gt;_rowid table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rowidWrite</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iRowid</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteRowid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteRowid</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteRowid</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write mapping (iNode-&gt;iPar) to the &lt;rtree&gt;_parent table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>parentWrite</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iNode</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iPar</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteParent</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteParent</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iPar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteParent</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>rtreeInsertCell</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
** Arguments aIdx, aDistance and aSpare all point to arrays of size
** nIdx. The aIdx array contains the set of integers from 0 to 
** (nIdx-1) in no particular order. This function sorts the values
** in aIdx according to the indexed values in aDistance. For
** example, assuming the inputs:
**
**   aIdx      = { 0,   1,   2,   3 }
**   aDistance = { 5.0, 2.0, 7.0, 6.0 }
**
** this function sets the aIdx array to contain:
**
**   aIdx      = { 0,   1,   2,   3 }
**
** The aSpare array is used as temporary working space by the
** sorting algorithm.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SortByDistance</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aIdx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nIdx</name></decl></parameter>, 
  <parameter><decl><type><name>RtreeDValue</name> <modifier>*</modifier></type><name>aDistance</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aSpare</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nIdx</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iLeft</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iRight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>nLeft</name> <init>= <expr><name>nIdx</name><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nRight</name> <init>= <expr><name>nIdx</name><operator>-</operator><name>nLeft</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aLeft</name> <init>= <expr><name>aIdx</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aRight</name> <init>= <expr><operator>&amp;</operator><name><name>aIdx</name><index>[<expr><name>nLeft</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SortByDistance</name><argument_list>(<argument><expr><name>aLeft</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>, <argument><expr><name>aDistance</name></expr></argument>, <argument><expr><name>aSpare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SortByDistance</name><argument_list>(<argument><expr><name>aRight</name></expr></argument>, <argument><expr><name>nRight</name></expr></argument>, <argument><expr><name>aDistance</name></expr></argument>, <argument><expr><name>aSpare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aSpare</name></expr></argument>, <argument><expr><name>aLeft</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aLeft</name> <operator>=</operator> <name>aSpare</name></expr>;</expr_stmt>

    <while>while<condition>( <expr><name>iLeft</name><operator>&lt;</operator><name>nLeft</name> <operator>||</operator> <name>iRight</name><operator>&lt;</operator><name>nRight</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iLeft</name><operator>==</operator><name>nLeft</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>aIdx</name><index>[<expr><name>iLeft</name><operator>+</operator><name>iRight</name></expr>]</index></name> <operator>=</operator> <name><name>aRight</name><index>[<expr><name>iRight</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iRight</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iRight</name><operator>==</operator><name>nRight</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>aIdx</name><index>[<expr><name>iLeft</name><operator>+</operator><name>iRight</name></expr>]</index></name> <operator>=</operator> <name><name>aLeft</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iLeft</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>fLeft</name> <init>= <expr><name><name>aDistance</name><index>[<expr><name><name>aLeft</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>fRight</name> <init>= <expr><name><name>aDistance</name><index>[<expr><name><name>aRight</name><index>[<expr><name>iRight</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>fLeft</name><operator>&lt;</operator><name>fRight</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>aIdx</name><index>[<expr><name>iLeft</name><operator>+</operator><name>iRight</name></expr>]</index></name> <operator>=</operator> <name><name>aLeft</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>iLeft</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>aIdx</name><index>[<expr><name>iLeft</name><operator>+</operator><name>iRight</name></expr>]</index></name> <operator>=</operator> <name><name>aRight</name><index>[<expr><name>iRight</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>iRight</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/* Check that the sort worked */</comment>
    {
      int jj;
      for(jj=1; jj&lt;nIdx; jj++){
        RtreeDValue left = aDistance[aIdx[jj-1]];
        RtreeDValue right = aDistance[aIdx[jj]];
        assert( left&lt;=right );
      }
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Arguments aIdx, aCell and aSpare all point to arrays of size
** nIdx. The aIdx array contains the set of integers from 0 to 
** (nIdx-1) in no particular order. This function sorts the values
** in aIdx according to dimension iDim of the cells in aCell. The
** minimum value of dimension iDim is considered first, the
** maximum used to break ties.
**
** The aSpare array is used as temporary working space by the
** sorting algorithm.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SortByDimension</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aIdx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nIdx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iDim</name></decl></parameter>, 
  <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>aCell</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aSpare</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nIdx</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>

    <decl_stmt><decl><type><name>int</name></type> <name>iLeft</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iRight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>nLeft</name> <init>= <expr><name>nIdx</name><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nRight</name> <init>= <expr><name>nIdx</name><operator>-</operator><name>nLeft</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aLeft</name> <init>= <expr><name>aIdx</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aRight</name> <init>= <expr><operator>&amp;</operator><name><name>aIdx</name><index>[<expr><name>nLeft</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SortByDimension</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>aLeft</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>, <argument><expr><name>iDim</name></expr></argument>, <argument><expr><name>aCell</name></expr></argument>, <argument><expr><name>aSpare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SortByDimension</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>aRight</name></expr></argument>, <argument><expr><name>nRight</name></expr></argument>, <argument><expr><name>iDim</name></expr></argument>, <argument><expr><name>aCell</name></expr></argument>, <argument><expr><name>aSpare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aSpare</name></expr></argument>, <argument><expr><name>aLeft</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aLeft</name> <operator>=</operator> <name>aSpare</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>iLeft</name><operator>&lt;</operator><name>nLeft</name> <operator>||</operator> <name>iRight</name><operator>&lt;</operator><name>nRight</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>xleft1</name> <init>= <expr><call><name>DCOORD</name><argument_list>(<argument><expr><name><name>aCell</name><index>[<expr><name><name>aLeft</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name><name>aCoord</name><index>[<expr><name>iDim</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>xleft2</name> <init>= <expr><call><name>DCOORD</name><argument_list>(<argument><expr><name><name>aCell</name><index>[<expr><name><name>aLeft</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name><name>aCoord</name><index>[<expr><name>iDim</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>xright1</name> <init>= <expr><call><name>DCOORD</name><argument_list>(<argument><expr><name><name>aCell</name><index>[<expr><name><name>aRight</name><index>[<expr><name>iRight</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name><name>aCoord</name><index>[<expr><name>iDim</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>xright2</name> <init>= <expr><call><name>DCOORD</name><argument_list>(<argument><expr><name><name>aCell</name><index>[<expr><name><name>aRight</name><index>[<expr><name>iRight</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name><name>aCoord</name><index>[<expr><name>iDim</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iLeft</name><operator>!=</operator><name>nLeft</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>iRight</name><operator>==</operator><name>nRight</name><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name>xleft1</name><operator>&lt;</operator><name>xright1</name><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name>xleft1</name><operator>==</operator><name>xright1</name> <operator>&amp;&amp;</operator> <name>xleft2</name><operator>&lt;</operator><name>xright2</name><operator>)</operator>
      <operator>)</operator></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><name><name>aIdx</name><index>[<expr><name>iLeft</name><operator>+</operator><name>iRight</name></expr>]</index></name> <operator>=</operator> <name><name>aLeft</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iLeft</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>aIdx</name><index>[<expr><name>iLeft</name><operator>+</operator><name>iRight</name></expr>]</index></name> <operator>=</operator> <name><name>aRight</name><index>[<expr><name>iRight</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iRight</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/* Check that the sort worked */</comment>
    {
      int jj;
      for(jj=1; jj&lt;nIdx; jj++){
        RtreeDValue xleft1 = aCell[aIdx[jj-1]].aCoord[iDim*2];
        RtreeDValue xleft2 = aCell[aIdx[jj-1]].aCoord[iDim*2+1];
        RtreeDValue xright1 = aCell[aIdx[jj]].aCoord[iDim*2];
        RtreeDValue xright2 = aCell[aIdx[jj]].aCoord[iDim*2+1];
        assert( xleft1&lt;=xright1 &amp;&amp; (xleft1&lt;xright1 || xleft2&lt;=xright2) );
      }
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the R*-tree variant of SplitNode from Beckman[1990].
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>splitNodeStartree</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>,
  <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>aCell</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nCell</name></decl></parameter>,
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>,
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>,
  <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>pBboxLeft</name></decl></parameter>,
  <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>pBboxRight</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>aaSorted</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aSpare</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>iBestDim</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iBestSplit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>fBestMargin</name> <init>= <expr><name>RTREE_ZERO</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name> <init>= <expr><operator>(</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>+</operator><name>nCell</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>aaSorted</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aaSorted</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>aSpare</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aaSorted</name><index>[<expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name></expr>]</index></name><operator>)</operator><index>[<expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name><operator>*</operator><name>nCell</name></expr>]</index></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aaSorted</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>jj</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>aaSorted</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aaSorted</name><index>[<expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name></expr>]</index></name><operator>)</operator><index>[<expr><name>ii</name><operator>*</operator><name>nCell</name></expr>]</index></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>aaSorted</name><index>[<expr><name>ii</name></expr>]</index><index>[<expr><name>jj</name></expr>]</index></name> <operator>=</operator> <name>jj</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>SortByDimension</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>aaSorted</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><name>nCell</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><name>aCell</name></expr></argument>, <argument><expr><name>aSpare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>margin</name> <init>= <expr><name>RTREE_ZERO</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>fBestOverlap</name> <init>= <expr><name>RTREE_ZERO</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>fBestArea</name> <init>= <expr><name>RTREE_ZERO</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iBestLeft</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nLeft</name></decl>;</decl_stmt>

    <for>for<control>(
      <init><expr><name>nLeft</name><operator>=</operator><call><name>RTREE_MINCELLS</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</init> 
      <condition><expr><name>nLeft</name><operator>&lt;=</operator><operator>(</operator><name>nCell</name><operator>-</operator><call><name>RTREE_MINCELLS</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition> 
      <incr><expr><name>nLeft</name><operator>++</operator></expr></incr>
    )</control><block>{<block_content>
      <decl_stmt><decl><type><name>RtreeCell</name></type> <name>left</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>RtreeCell</name></type> <name>right</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>kk</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>overlap</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>area</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name><name>aaSorted</name><index>[<expr><name>ii</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name><name>aaSorted</name><index>[<expr><name>ii</name></expr>]</index><index>[<expr><name>nCell</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>kk</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>kk</name><operator>&lt;</operator><operator>(</operator><name>nCell</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>kk</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>kk</name><operator>&lt;</operator><name>nLeft</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>cellUnion</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name><name>aaSorted</name><index>[<expr><name>ii</name></expr>]</index><index>[<expr><name>kk</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>cellUnion</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name><name>aaSorted</name><index>[<expr><name>ii</name></expr>]</index><index>[<expr><name>kk</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>margin</name> <operator>+=</operator> <call><name>cellMargin</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>margin</name> <operator>+=</operator> <call><name>cellMargin</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>overlap</name> <operator>=</operator> <call><name>cellOverlap</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>area</name> <operator>=</operator> <call><name>cellArea</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>cellArea</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nLeft</name><operator>==</operator><call><name>RTREE_MINCELLS</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name>overlap</name><operator>&lt;</operator><name>fBestOverlap</name><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name>overlap</name><operator>==</operator><name>fBestOverlap</name> <operator>&amp;&amp;</operator> <name>area</name><operator>&lt;</operator><name>fBestArea</name><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>iBestLeft</name> <operator>=</operator> <name>nLeft</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>fBestOverlap</name> <operator>=</operator> <name>overlap</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>fBestArea</name> <operator>=</operator> <name>area</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>ii</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>margin</name><operator>&lt;</operator><name>fBestMargin</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iBestDim</name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>fBestMargin</name> <operator>=</operator> <name>margin</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iBestSplit</name> <operator>=</operator> <name>iBestLeft</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pBboxLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name><name>aaSorted</name><index>[<expr><name>iBestDim</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pBboxRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name><name>aaSorted</name><index>[<expr><name>iBestDim</name></expr>]</index><index>[<expr><name>iBestSplit</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pTarget</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>ii</name><operator>&lt;</operator><name>iBestSplit</name><operator>)</operator></expr>?</condition><then><expr><name>pLeft</name></expr></then><else>:<expr><name>pRight</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>pBbox</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>ii</name><operator>&lt;</operator><name>iBestSplit</name><operator>)</operator></expr>?</condition><then><expr><name>pBboxLeft</name></expr></then><else>:<expr><name>pBboxRight</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>pCell</name> <init>= <expr><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name><name>aaSorted</name><index>[<expr><name>iBestDim</name></expr>]</index><index>[<expr><name>ii</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>nodeInsertCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pTarget</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cellUnion</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pBbox</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aaSorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>updateMapping</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, 
  <parameter><decl><type><name>i64</name></type> <name>iRowid</name></decl></parameter>, 
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iHeight</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xSetMapping</name>)<parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type></decl></parameter>)</parameter_list>;</function_decl>
  <expr_stmt><expr><name>xSetMapping</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>iHeight</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>?</condition><then><expr><name>rowidWrite</name></expr></then><else>:<expr><name>parentWrite</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iHeight</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pChild</name> <init>= <expr><call><name>nodeHashLookup</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pNode</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><name>pChild</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>pChild</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodeReference</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pChild</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pNode</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>xSetMapping</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>SplitNode</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>,
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,
  <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iHeight</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>newCellIsRight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name> <init>= <expr><call><name>NCELL</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>aCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aiUsed</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>RtreeCell</name></type> <name>leftbbox</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCell</name></type> <name>rightbbox</name></decl>;</decl_stmt>

  <comment type="block">/* Allocate an array and populate it with a copy of pCell and 
  ** all cells from node pLeft. Then zero the original node.
  */</comment>
  <expr_stmt><expr><name>aCell</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCell</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>*</operator><operator>(</operator><name>nCell</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aCell</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>splitnode_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>aiUsed</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name>nCell</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aiUsed</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nCell</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>nodeGetCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>nodeZero</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name>nCell</name></expr>]</index></name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCell</name><operator>++</operator></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pRight</name> <operator>=</operator> <call><name>nodeNew</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <call><name>nodeNew</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>isDirty</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>writeInt16</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRight</name> <operator>=</operator> <call><name>nodeNew</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLeft</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pLeft</name> <operator>||</operator> <operator>!</operator><name>pRight</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>splitnode_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>splitNodeStartree</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>aCell</name></expr></argument>, <argument><expr><name>nCell</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name>leftbbox</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightbbox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>splitnode_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Ensure both child nodes have node numbers assigned to them by calling
  ** nodeWrite(). Node pRight always needs a node number, as it was created
  ** by nodeNew() above. But node pLeft sometimes already has a node number.
  ** In this case avoid the all to nodeWrite().
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>nodeWrite</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>||</operator> <operator>(</operator><literal type="number">0</literal><operator>==</operator><name><name>pLeft</name><operator>-&gt;</operator><name>iNode</name></name> <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>nodeWrite</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <goto>goto <name>splitnode_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>rightbbox</name><operator>.</operator><name>iRowid</name></name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>iNode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>leftbbox</name><operator>.</operator><name>iRowid</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>iNode</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeInsertCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftbbox</name></expr></argument>, <argument><expr><name>iHeight</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>splitnode_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pParent</name> <init>= <expr><name><name>pLeft</name><operator>-&gt;</operator><name>pParent</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeParentIndex</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>nodeOverwriteCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pParent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftbbox</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>AdjustTree</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pParent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftbbox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>splitnode_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>rtreeInsertCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightbbox</name></expr></argument>, <argument><expr><name>iHeight</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <goto>goto <name>splitnode_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>NCELL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iRowid</name> <init>= <expr><call><name>nodeGetRowid</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>updateMapping</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>iHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iRowid</name><operator>==</operator><name><name>pCell</name><operator>-&gt;</operator><name>iRowid</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>newCellIsRight</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>splitnode_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>NCELL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iRowid</name> <init>= <expr><call><name>nodeGetRowid</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>updateMapping</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>iHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>splitnode_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>newCellIsRight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>updateMapping</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iRowid</name></name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>iHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRight</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>splitnode_out</name>:</label>
  <expr_stmt><expr><call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If node pLeaf is not the root of the r-tree and its pParent pointer is 
** still NULL, load all ancestor nodes of pLeaf into memory and populate
** the pLeaf-&gt;pParent chain all the way up to the root node.
**
** This operation is required when a row is deleted (or updated - an update
** is implemented as a delete followed by an insert). SQLite provides the
** rowid of the row to delete, which can be used to find the leaf on which
** the entry resides (argument pLeaf). Once the leaf is located, this 
** function is called to determine its ancestry.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fixLeafParent</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pLeaf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pChild</name> <init>= <expr><name>pLeaf</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pChild</name><operator>-&gt;</operator><name>iNode</name></name><operator>!=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pChild</name><operator>-&gt;</operator><name>pParent</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>          <comment type="block">/* sqlite3_reset() return code */</comment>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadParent</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>iNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pTest</name></decl>;</decl_stmt>           <comment type="block">/* Used to test for reference loops */</comment>
      <decl_stmt><decl><type><name>i64</name></type> <name>iNode</name></decl>;</decl_stmt>                  <comment type="block">/* Node number of parent node */</comment>

      <comment type="block">/* Before setting pChild-&gt;pParent, test that we are not creating a
      ** loop of references (as we would if, say, pChild==pParent). We don't
      ** want to do this as it leads to a memory leak when trying to delete
      ** the referenced counted node structures.
      */</comment>
      <expr_stmt><expr><name>iNode</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadParent</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>pTest</name><operator>=</operator><name>pLeaf</name></expr>;</init> <condition><expr><name>pTest</name> <operator>&amp;&amp;</operator> <name><name>pTest</name><operator>-&gt;</operator><name>iNode</name></name><operator>!=</operator><name>iNode</name></expr>;</condition> <incr><expr><name>pTest</name><operator>=</operator><name><name>pTest</name><operator>-&gt;</operator><name>pParent</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
      <if_stmt><if>if<condition>( <expr><name>pTest</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>nodeAcquire</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>iNode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pChild</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pChild</name><operator>-&gt;</operator><name>pParent</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>RTREE_IS_CORRUPT</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_VTAB</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pChild</name> <operator>=</operator> <name><name>pChild</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>deleteCell</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type> <name>removeNode</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iHeight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pParent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCell</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Remove the entry in the parent cell. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeParentIndex</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pParent</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>deleteCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>, <argument><expr><name>iHeight</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Remove the xxx_node entry. */</comment>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteNode</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteNode</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Remove the xxx_parent entry. */</comment>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteParent</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteParent</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Remove the node from the in-memory hash table and link it into
  ** the Rtree.pDeleted list. Its contents will be re-inserted later on.
  */</comment>
  <expr_stmt><expr><call><name>nodeHashDelete</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name> <operator>=</operator> <name>iHeight</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>pDeleted</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleted</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fixBoundingBox</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pParent</name> <init>= <expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt> 
  <if_stmt><if>if<condition>( <expr><name>pParent</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>int</name></type> <name>nCell</name> <init>= <expr><call><name>NCELL</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeCell</name></type> <name>box</name></decl>;</decl_stmt>                            <comment type="block">/* Bounding box for pNode */</comment>
    <expr_stmt><expr><call><name>nodeGetCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>RtreeCell</name></type> <name>cell</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodeGetCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>cellUnion</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>box</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>box</name><operator>.</operator><name>iRowid</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeParentIndex</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>nodeOverwriteCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pParent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>box</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fixBoundingBox</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete the cell at index iCell of node pNode. After removing the
** cell, adjust the r-tree data structure if required.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>deleteCell</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iHeight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pParent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>fixLeafParent</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Remove the cell from the node. This call just moves bytes around
  ** the in-memory node image, so it cannot fail.
  */</comment>
  <expr_stmt><expr><call><name>nodeDeleteCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the node is not the tree root and now has less than the minimum
  ** number of cells, remove it from the tree. Otherwise, update the
  ** cell in the parent node so that it tightly contains the updated
  ** node.
  */</comment>
  <expr_stmt><expr><name>pParent</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParent</name> <operator>||</operator> <name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pParent</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>NCELL</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>RTREE_MINCELLS</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>removeNode</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>iHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fixBoundingBox</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>Reinsert</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, 
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, 
  <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iHeight</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aOrder</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aSpare</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>aCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeDValue</name> <modifier>*</modifier></type><name>aDistance</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeDValue</name></type> <name><name>aCenterCoord</name><index>[<expr><name>RTREE_MAX_DIMENSIONS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDim</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aCenterCoord</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeDValue</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>RTREE_MAX_DIMENSIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>nCell</name> <operator>=</operator> <call><name>NCELL</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>nCell</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>(</operator><operator>~</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Allocate the buffers used by this operation. The allocation is
  ** relinquished before this function returns.
  */</comment>
  <expr_stmt><expr><name>aCell</name> <operator>=</operator> <operator>(</operator><name>RtreeCell</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>n</name> <operator>*</operator> <operator>(</operator>
    <sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCell</name></expr></argument>)</argument_list></sizeof>     <operator>+</operator>         <comment type="block">/* aCell array */</comment>
    <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof>           <operator>+</operator>         <comment type="block">/* aOrder array */</comment>
    <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof>           <operator>+</operator>         <comment type="block">/* aSpare array */</comment>
    <sizeof>sizeof<argument_list>(<argument><expr><name>RtreeDValue</name></expr></argument>)</argument_list></sizeof>             <comment type="block">/* aDistance array */</comment>
  <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aCell</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>aOrder</name>    <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aSpare</name>    <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aOrder</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aDistance</name> <operator>=</operator> <operator>(</operator><name>RtreeDValue</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aSpare</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>ii</name><operator>==</operator><operator>(</operator><name>nCell</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>nodeGetCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>aOrder</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>iDim</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iDim</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name></expr>;</condition> <incr><expr><name>iDim</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>aCenterCoord</name><index>[<expr><name>iDim</name></expr>]</index></name> <operator>+=</operator> <call><name>DCOORD</name><argument_list>(<argument><expr><name><name>aCell</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>aCoord</name><index>[<expr><name>iDim</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aCenterCoord</name><index>[<expr><name>iDim</name></expr>]</index></name> <operator>+=</operator> <call><name>DCOORD</name><argument_list>(<argument><expr><name><name>aCell</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>aCoord</name><index>[<expr><name>iDim</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>iDim</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iDim</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name></expr>;</condition> <incr><expr><name>iDim</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>aCenterCoord</name><index>[<expr><name>iDim</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>aCenterCoord</name><index>[<expr><name>iDim</name></expr>]</index></name><operator>/</operator><operator>(</operator><name>nCell</name><operator>*</operator><operator>(</operator><name>RtreeDValue</name><operator>)</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>aDistance</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <name>RTREE_ZERO</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>iDim</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iDim</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name></expr>;</condition> <incr><expr><name>iDim</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>RtreeDValue</name></type> <name>coord</name> <init>= <expr><operator>(</operator><call><name>DCOORD</name><argument_list>(<argument><expr><name><name>aCell</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>aCoord</name><index>[<expr><name>iDim</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> 
                               <call><name>DCOORD</name><argument_list>(<argument><expr><name><name>aCell</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>aCoord</name><index>[<expr><name>iDim</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>aDistance</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name>coord</name><operator>-</operator><name><name>aCenterCoord</name><index>[<expr><name>iDim</name></expr>]</index></name><operator>)</operator><operator>*</operator><operator>(</operator><name>coord</name><operator>-</operator><name><name>aCenterCoord</name><index>[<expr><name>iDim</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>SortByDistance</name><argument_list>(<argument><expr><name>aOrder</name></expr></argument>, <argument><expr><name>nCell</name></expr></argument>, <argument><expr><name>aDistance</name></expr></argument>, <argument><expr><name>aSpare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodeZero</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>&lt;</operator><operator>(</operator><name>nCell</name><operator>-</operator><operator>(</operator><call><name>RTREE_MINCELLS</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name><name>aOrder</name><index>[<expr><name>ii</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>nodeInsertCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name><operator>==</operator><name><name>pCell</name><operator>-&gt;</operator><name>iRowid</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iHeight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rowidWrite</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>parentWrite</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fixBoundingBox</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <comment type="block">/* Find a node to store this cell in. pNode-&gt;iNode currently contains
    ** the height of the sub-tree headed by the cell.
    */</comment>
    <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pInsert</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>aCell</name><index>[<expr><name><name>aOrder</name><index>[<expr><name>ii</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ChooseLeaf</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iHeight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeInsertCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pInsert</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Insert cell pCell into node pNode. Node pNode is the head of a 
** subtree iHeight high (leaf nodes have iHeight==0).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeInsertCell</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>,
  <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,
  <parameter><decl><type><name>RtreeCell</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iHeight</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iHeight</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pChild</name> <init>= <expr><call><name>nodeHashLookup</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pChild</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodeReference</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pChild</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>nodeInsertCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iHeight</name><operator>&lt;=</operator><name><name>pRtree</name><operator>-&gt;</operator><name>iReinsertHeight</name></name> <operator>||</operator> <name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name><operator>==</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SplitNode</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>iHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iReinsertHeight</name></name> <operator>=</operator> <name>iHeight</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>Reinsert</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>iHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>AdjustTree</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iHeight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rowidWrite</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iRowid</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>parentWrite</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>iRowid</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>reinsertNodeContent</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name> <init>= <expr><call><name>NCELL</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pInsert</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeCell</name></type> <name>cell</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>nodeGetCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Find a node to store this cell in. pNode-&gt;iNode currently contains
    ** the height of the sub-tree headed by the cell.
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ChooseLeaf</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeInsertCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pInsert</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pNode</name><operator>-&gt;</operator><name>iNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Select a currently unused rowid for a new r-tree record.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeNewRowid</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteRowid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteRowid</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piRowid</name> <operator>=</operator> <call><name>sqlite3_last_insert_rowid</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Remove the entry with rowid=iDelete from the r-tree structure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeDeleteRowid</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iDelete</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pLeaf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Leaf node containing record iDelete */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCell</name></decl>;</decl_stmt>                      <comment type="block">/* Index of iDelete cell in pLeaf */</comment>
  <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pRoot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Root node of rtree structure */</comment>


  <comment type="block">/* Obtain a reference to the root node to initialize Rtree.iDepth */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeAcquire</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Obtain a reference to the leaf node that contains the entry 
  ** about to be deleted. 
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>findLeafNode</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>iDelete</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLeaf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CORRUPT_DB</name></cpp:ifdef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeaf</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Delete the cell in question from the leaf node. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pLeaf</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeRowidIndex</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeaf</name></expr></argument>, <argument><expr><name>iDelete</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>deleteCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeaf</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Delete the corresponding entry in the &lt;rtree&gt;_rowid table. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteRowid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check if the root node now has exactly one child. If so, remove
  ** it, schedule the contents of the child for reinsertion and 
  ** reduce the tree height by one.
  **
  ** This is equivalent to copying the contents of the child into
  ** the root node (the operation that Gutman's paper says to perform 
  ** in this scenario).
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>NCELL</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pChild</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>iChild</name> <init>= <expr><call><name>nodeGetRowid</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeAcquire</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>iChild</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* tag-20210916a */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>removeNode</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pChild</name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>writeInt16</name><argument_list>(<argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>zData</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iDepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>isDirty</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Re-insert the contents of any underfull nodes removed from the tree. */</comment>
  <for>for<control>(<init><expr><name>pLeaf</name><operator>=</operator><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleted</name></name></expr>;</init> <condition><expr><name>pLeaf</name></expr>;</condition> <incr><expr><name>pLeaf</name><operator>=</operator><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleted</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>reinsertNodeContent</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleted</name></name> <operator>=</operator> <name><name>pLeaf</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nNodeRef</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pLeaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Release the reference to the root node. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Rounding constants for float-&gt;double conversion.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RNDTOWARDS</name></cpp:macro>  <cpp:value>(1.0 - 1.0/8388608.0)</cpp:value></cpp:define>  <comment type="block">/* Round towards zero */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RNDAWAY</name></cpp:macro>     <cpp:value>(1.0 + 1.0/8388608.0)</cpp:value></cpp:define>  <comment type="block">/* Round away from zero */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_RTREE_INT_ONLY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Convert an sqlite3_value into an RtreeValue (presumably a float)
** while taking care to round toward negative or positive, respectively.
*/</comment>
<function><type><specifier>static</specifier> <name>RtreeValue</name></type> <name>rtreeValueDown</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>d</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>f</name> <init>= <expr><operator>(</operator><name>float</name><operator>)</operator><name>d</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>f</name><operator>&gt;</operator><name>d</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>f</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><operator>(</operator><name>d</name><operator>*</operator><operator>(</operator><ternary><condition><expr><name>d</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>RNDAWAY</name></expr> </then><else>: <expr><name>RNDTOWARDS</name></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>f</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>RtreeValue</name></type> <name>rtreeValueUp</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>d</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>f</name> <init>= <expr><operator>(</operator><name>float</name><operator>)</operator><name>d</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>f</name><operator>&lt;</operator><name>d</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>f</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><operator>(</operator><name>d</name><operator>*</operator><operator>(</operator><ternary><condition><expr><name>d</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>RNDTOWARDS</name></expr> </then><else>: <expr><name>RNDAWAY</name></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>f</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_RTREE_INT_ONLY) */</comment>

<comment type="block">/*
** A constraint has failed while inserting a row into an rtree table. 
** Assuming no OOM error occurs, this function sets the error message 
** (at pRtree-&gt;base.zErrMsg) to an appropriate value and returns
** SQLITE_CONSTRAINT.
**
** Parameter iCol is the index of the leftmost column involved in the
** constraint failure. If it is 0, then the constraint that failed is
** the unique constraint on the id column. Otherwise, it is the rtree
** (c1&lt;=c2) constraint on columns iCol and iCol+1 that has failed.
**
** If an OOM occurs, SQLITE_NOMEM is returned instead of SQLITE_CONSTRAINT.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeConstraintError</name><parameter_list>(<parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iCol</name><operator>%</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT * FROM %Q.%Q"</literal></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name> <init>= <expr><call><name>sqlite3_column_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"UNIQUE constraint failed: %s.%s"</literal></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol1</name> <init>= <expr><call><name>sqlite3_column_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol2</name> <init>= <expr><call><name>sqlite3_column_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"rtree constraint failed: %s.(%s&lt;=%s)"</literal></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zCol1</name></expr></argument>, <argument><expr><name>zCol2</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> ?</condition><then> <expr><name>SQLITE_CONSTRAINT</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
** The xUpdate method for rtree module virtual tables.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeUpdate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>aData</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCell</name></type> <name>cell</name></decl>;</decl_stmt>                 <comment type="block">/* New cell to insert if nData&gt;1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bHaveRowid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Set to 1 after new rowid is determined */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>nNodeRef</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Unable to write to the btree while another cursor is reading from it,
    ** since the write might do a rebalance which would disrupt the read
    ** cursor. */</comment>
    <return>return <expr><name>SQLITE_LOCKED_VTAB</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>rtreeReference</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nData</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>cell</name><operator>.</operator><name>iRowid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Used only to suppress a compiler warning */</comment>

  <comment type="block">/* Constraint handling. A write operation on an r-tree table may return
  ** SQLITE_CONSTRAINT for two reasons:
  **
  **   1. A duplicate rowid value, or
  **   2. The supplied data violates the "x2&gt;=x1" constraint.
  **
  ** In the first case, if the conflict-handling mode is REPLACE, then
  ** the conflicting row can be removed before proceeding. In the second
  ** case, SQLITE_CONSTRAINT must be returned regardless of the
  ** conflict-handling mode specified by the user.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nData</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nn</name> <init>= <expr><name>nData</name> <operator>-</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>nn</name> <operator>&gt;</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nn</name> <operator>=</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Populate the cell.aCoord[] array. The first coordinate is aData[3].
    **
    ** NB: nData can only be less than nDim*2+3 if the rtree is mis-declared
    ** with "column" that are interpreted as table constraints.
    ** Example:  CREATE VIRTUAL TABLE bad USING rtree(x,y,CHECK(y&gt;5));
    ** This problem was discovered after years of use, so we silently ignore
    ** these kinds of misdeclared tables to avoid breaking any legacy.
    */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_RTREE_INT_ONLY</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>eCoordType</name></name><operator>==</operator><name>RTREE_COORD_REAL32</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nn</name></expr>;</condition> <incr><expr><name>ii</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>cell</name><operator>.</operator><name>aCoord</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>f</name> <operator>=</operator> <call><name>rtreeValueDown</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cell</name><operator>.</operator><name>aCoord</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>f</name> <operator>=</operator> <call><name>rtreeValueUp</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>cell</name><operator>.</operator><name>aCoord</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>f</name><operator>&gt;</operator><name><name>cell</name><operator>.</operator><name>aCoord</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>f</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeConstraintError</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>constraint</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nn</name></expr>;</condition> <incr><expr><name>ii</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>cell</name><operator>.</operator><name>aCoord</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>i</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cell</name><operator>.</operator><name>aCoord</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>i</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>cell</name><operator>.</operator><name>aCoord</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>i</name><operator>&gt;</operator><name><name>cell</name><operator>.</operator><name>aCoord</name><index>[<expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>i</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeConstraintError</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>ii</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>constraint</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* If a rowid value was supplied, check if it is already present in 
    ** the table. If so, the constraint has failed. */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>cell</name><operator>.</operator><name>iRowid</name></name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name>
       <operator>||</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name><name>cell</name><operator>.</operator><name>iRowid</name></name></expr>
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>steprc</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadRowid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>cell</name><operator>.</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>steprc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>pReadRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><name>steprc</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3_vtab_on_conflict</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_REPLACE</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeDeleteRowid</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name><name>cell</name><operator>.</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeConstraintError</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>constraint</name>;</goto>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>bHaveRowid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If aData[0] is not an SQL NULL value, it is the rowid of a
  ** record to delete from the r-tree table. The following block does
  ** just that.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeDeleteRowid</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the aData[] array contains more than one element, elements
  ** (aData[2]..aData[argc-1]) contain a new record to insert into
  ** the r-tree structure.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nData</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Insert the new record into the r-tree */</comment>
    <decl_stmt><decl><type><name>RtreeNode</name> <modifier>*</modifier></type><name>pLeaf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Figure out the rowid of the new row. */</comment>
    <if_stmt><if>if<condition>( <expr><name>bHaveRowid</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeNewRowid</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cell</name><operator>.</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>cell</name><operator>.</operator><name>iRowid</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ChooseLeaf</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLeaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iReinsertHeight</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeInsertCell</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeaf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>nodeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>pLeaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nAux</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pUp</name> <init>= <expr><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteAux</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>jj</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>*</operator><name>pRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nAux</name></name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>, <argument><expr><name>jj</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>aData</name><index>[<expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name><operator>+</operator><literal type="number">3</literal><operator>+</operator><name>jj</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pUp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>constraint</name>:</label>
  <expr_stmt><expr><call><name>rtreeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Called when a transaction starts.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeBeginTransaction</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>inWrTrans</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>inWrTrans</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Called when a transaction completes (either by COMMIT or ROLLBACK).
** The sqlite3_blob object should be released at this point.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeEndTransaction</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>inWrTrans</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodeBlobReset</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The xRename method for rtree module virtual tables.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeRename</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNewName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_NOMEM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(
    <argument><expr><literal type="string">"ALTER TABLE %Q.'%q_node'   RENAME TO \"%w_node\";"</literal>
    <literal type="string">"ALTER TABLE %Q.'%q_parent' RENAME TO \"%w_parent\";"</literal>
    <literal type="string">"ALTER TABLE %Q.'%q_rowid'  RENAME TO \"%w_rowid\";"</literal></expr></argument>
    , <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zNewName</name></expr></argument> 
    , <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zNewName</name></expr></argument> 
    , <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zNewName</name></expr></argument>
  )</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>nodeBlobReset</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The xSavepoint method.
**
** This module does not need to do anything to support savepoints. However,
** it uses this hook to close any open blob handle. This is done because a 
** DROP TABLE command - which fortunately always opens a savepoint - cannot 
** succeed if there are any open blob handles. i.e. if the blob handle were
** not closed here, the following would fail:
**
**   BEGIN;
**     INSERT INTO rtree...
**     DROP TABLE &lt;tablename&gt;;    -- Would fail with SQLITE_LOCKED
**   COMMIT;
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeSavepoint</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSavepoint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name> <init>= <expr><operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>iwt</name> <init>= <expr><name><name>pRtree</name><operator>-&gt;</operator><name>inWrTrans</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>inWrTrans</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodeBlobReset</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>inWrTrans</name></name> <operator>=</operator> <name>iwt</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function populates the pRtree-&gt;nRowEst variable with an estimate
** of the number of rows in the virtual table. If possible, this is based
** on sqlite_stat1 data. Otherwise, use RTREE_DEFAULT_ROWEST.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeQueryStat1</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name> <init>= <expr><literal type="string">"SELECT stat FROM %Q.sqlite_stat1 WHERE tbl = '%q_rowid'"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nRow</name> <init>= <expr><name>RTREE_MIN_ROWEST</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_table_column_metadata</name><argument_list>(
      <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><literal type="string">"sqlite_stat1"</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nRowEst</name></name> <operator>=</operator> <name>RTREE_DEFAULT_ROWEST</name></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_ERROR</name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nRow</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nRowEst</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>nRow</name></expr></argument>, <argument><expr><name>RTREE_MIN_ROWEST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Return true if zName is the extension on one of the shadow tables used
** by this module.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeShadowName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azName</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"node"</literal></expr>, <expr><literal type="string">"parent"</literal></expr>, <expr><literal type="string">"rowid"</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>azName</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>azName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>azName</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>rtreeModule</name> <init>= <expr><block>{
  <expr><literal type="number">3</literal></expr>,                          <comment type="block">/* iVersion */</comment>
  <expr><name>rtreeCreate</name></expr>,                <comment type="block">/* xCreate - create a table */</comment>
  <expr><name>rtreeConnect</name></expr>,               <comment type="block">/* xConnect - connect to an existing table */</comment>
  <expr><name>rtreeBestIndex</name></expr>,             <comment type="block">/* xBestIndex - Determine search strategy */</comment>
  <expr><name>rtreeDisconnect</name></expr>,            <comment type="block">/* xDisconnect - Disconnect from a table */</comment>
  <expr><name>rtreeDestroy</name></expr>,               <comment type="block">/* xDestroy - Drop a table */</comment>
  <expr><name>rtreeOpen</name></expr>,                  <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>rtreeClose</name></expr>,                 <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>rtreeFilter</name></expr>,                <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>rtreeNext</name></expr>,                  <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>rtreeEof</name></expr>,                   <comment type="block">/* xEof */</comment>
  <expr><name>rtreeColumn</name></expr>,                <comment type="block">/* xColumn - read data */</comment>
  <expr><name>rtreeRowid</name></expr>,                 <comment type="block">/* xRowid - read data */</comment>
  <expr><name>rtreeUpdate</name></expr>,                <comment type="block">/* xUpdate - write data */</comment>
  <expr><name>rtreeBeginTransaction</name></expr>,      <comment type="block">/* xBegin - begin transaction */</comment>
  <expr><name>rtreeEndTransaction</name></expr>,        <comment type="block">/* xSync - sync transaction */</comment>
  <expr><name>rtreeEndTransaction</name></expr>,        <comment type="block">/* xCommit - commit transaction */</comment>
  <expr><name>rtreeEndTransaction</name></expr>,        <comment type="block">/* xRollback - rollback transaction */</comment>
  <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* xFindFunction - function overloading */</comment>
  <expr><name>rtreeRename</name></expr>,                <comment type="block">/* xRename - rename the table */</comment>
  <expr><name>rtreeSavepoint</name></expr>,             <comment type="block">/* xSavepoint */</comment>
  <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* xRelease */</comment>
  <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* xRollbackTo */</comment>
  <expr><name>rtreeShadowName</name></expr>             <comment type="block">/* xShadowName */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeSqlInit</name><parameter_list>(
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPrefix</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>isCreate</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_STATEMENT</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azSql</name><index>[<expr><name>N_STATEMENT</name></expr>]</index></name> <init>= <expr><block>{
    <comment type="block">/* Write the xxx_node table */</comment>
    <expr><literal type="string">"INSERT OR REPLACE INTO '%q'.'%q_node' VALUES(?1, ?2)"</literal></expr>,
    <expr><literal type="string">"DELETE FROM '%q'.'%q_node' WHERE nodeno = ?1"</literal></expr>,

    <comment type="block">/* Read and write the xxx_rowid table */</comment>
    <expr><literal type="string">"SELECT nodeno FROM '%q'.'%q_rowid' WHERE rowid = ?1"</literal></expr>,
    <expr><literal type="string">"INSERT OR REPLACE INTO '%q'.'%q_rowid' VALUES(?1, ?2)"</literal></expr>,
    <expr><literal type="string">"DELETE FROM '%q'.'%q_rowid' WHERE rowid = ?1"</literal></expr>,

    <comment type="block">/* Read and write the xxx_parent table */</comment>
    <expr><literal type="string">"SELECT parentnode FROM '%q'.'%q_parent' WHERE nodeno = ?1"</literal></expr>,
    <expr><literal type="string">"INSERT OR REPLACE INTO '%q'.'%q_parent' VALUES(?1, ?2)"</literal></expr>,
    <expr><literal type="string">"DELETE FROM '%q'.'%q_parent' WHERE nodeno = ?1"</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name><name>appStmt</name><index>[<expr><name>N_STATEMENT</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>f</name> <init>= <expr><name>SQLITE_PREPARE_PERSISTENT</name><operator>|</operator><name>SQLITE_PREPARE_NO_VTAB</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>isCreate</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCreate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3_str_new</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
       <argument><expr><literal type="string">"CREATE TABLE \"%w\".\"%w_rowid\"(rowid INTEGER PRIMARY KEY,nodeno"</literal></expr></argument>,
       <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nAux</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="string">",a%d"</literal></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
      <argument><expr><literal type="string">");CREATE TABLE \"%w\".\"%w_node\"(nodeno INTEGER PRIMARY KEY,data);"</literal></expr></argument>,
      <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
    <argument><expr><literal type="string">"CREATE TABLE \"%w\".\"%w_parent\"(nodeno INTEGER PRIMARY KEY,parentnode);"</literal></expr></argument>,
      <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
       <argument><expr><literal type="string">"INSERT INTO \"%w\".\"%w_node\"VALUES(1,zeroblob(%d))"</literal></expr></argument>,
       <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCreate</name> <operator>=</operator> <call><name>sqlite3_str_finish</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zCreate</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zCreate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>appStmt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteNode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>appStmt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteNode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>appStmt</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>pReadRowid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>appStmt</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteRowid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>appStmt</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteRowid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>appStmt</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>pReadParent</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>appStmt</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteParent</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>appStmt</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>pDeleteParent</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeQueryStat1</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>N_STATEMENT</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><literal type="number">3</literal> <operator>||</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nAux</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><name>zFormat</name> <operator>=</operator> <name><name>azSql</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else <block>{<block_content>
       <comment type="block">/* An UPSERT is very slightly slower than REPLACE, but it is needed
       ** if there are auxiliary columns */</comment>
       <expr_stmt><expr><name>zFormat</name> <operator>=</operator> <literal type="string">"INSERT INTO\"%w\".\"%w_rowid\"(rowid,nodeno)VALUES(?1,?2)"</literal>
                  <literal type="string">"ON CONFLICT(rowid)DO UPDATE SET nodeno=excluded.nodeno"</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v3</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>appStmt</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>nAux</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zReadAuxSql</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
       <argument><expr><literal type="string">"SELECT * FROM \"%w\".\"%w_rowid\" WHERE rowid=?1"</literal></expr></argument>,
       <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>zReadAuxSql</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3_str_new</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"UPDATE \"%w\".\"%w_rowid\"SET "</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nAux</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>ii</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_GEOPOLY</name></cpp:ifdef>
        <if_stmt><if>if<condition>( <expr><name>ii</name><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nAuxNotNull</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="string">"a%d=coalesce(?%d,a%d)"</literal></expr></argument>,<argument><expr><name>ii</name></expr></argument>,<argument><expr><name>ii</name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="string">"a%d=?%d"</literal></expr></argument>,<argument><expr><name>ii</name></expr></argument>,<argument><expr><name>ii</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">" WHERE rowid=?1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_str_finish</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v3</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>pWriteAux</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The second argument to this function contains the text of an SQL statement
** that returns a single integer value. The statement is compiled and executed
** using database connection db. If successful, the integer value returned
** is written to *piVal and SQLITE_OK returned. Otherwise, an SQLite error
** code is returned and the value of *piVal after returning is not defined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getIntFromStmt</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_NOMEM</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called from within the xConnect() or xCreate() method to
** determine the node-size used by the rtree table being created or connected
** to. If successful, pRtree-&gt;iNodeSize is populated and SQLITE_OK returned.
** Otherwise, an SQLite error code is returned.
**
** If this function is being called as part of an xConnect(), then the rtree
** table already exists. In this case the node-size is determined by inspecting
** the root node of the tree.
**
** Otherwise, for an xCreate(), use 64 bytes less than the database page-size. 
** This ensures that each node is stored on a single database page. If the 
** database page-size is so large that more than RTREE_MAXCELLS entries 
** would fit in a single node, use a smaller node-size.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getNodeSize</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl></parameter>,                  <comment type="block">/* Rtree handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>isCreate</name></decl></parameter>,                   <comment type="block">/* True for xCreate, false for xConnect */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message, if any */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>isCreate</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iPageSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"PRAGMA %Q.page_size"</literal></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getIntFromStmt</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name> <operator>=</operator> <name>iPageSize</name><operator>-</operator><literal type="number">64</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><literal type="number">4</literal><operator>+</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name><operator>*</operator><name>RTREE_MAXCELLS</name><operator>)</operator><operator>&lt;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name> <operator>=</operator> <literal type="number">4</literal><operator>+</operator><name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name><operator>*</operator><name>RTREE_MAXCELLS</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
        <argument><expr><literal type="string">"SELECT length(data) FROM '%q'.'%q_node' WHERE nodeno = 1"</literal></expr></argument>,
        <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getIntFromStmt</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>iNodeSize</name></name><operator>&lt;</operator><operator>(</operator><literal type="number">512</literal><operator>-</operator><literal type="number">64</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_VTAB</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RTREE_IS_CORRUPT</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"undersize RTree blobs in \"%q_node\""</literal></expr></argument>,
                               <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the length of a token
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeTokenLength</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>dummy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sqlite3GetToken</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>z</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** This function is the implementation of both the xConnect and xCreate
** methods of the r-tree virtual table.
**
**   argv[0]   -&gt; module name
**   argv[1]   -&gt; database name
**   argv[2]   -&gt; table name
**   argv[...] -&gt; column names...
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeInit</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                        <comment type="block">/* Database connection */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,                         <comment type="block">/* One of the RTREE_COORD_* constants */</comment>
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,   <comment type="block">/* Parameters to CREATE TABLE statement */</comment>
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,              <comment type="block">/* OUT: New virtual table */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>,                       <comment type="block">/* OUT: Error message, if any */</comment>
  <parameter><decl><type><name>int</name></type> <name>isCreate</name></decl></parameter>                        <comment type="block">/* True for xCreate, false for xConnect */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Rtree</name> <modifier>*</modifier></type><name>pRtree</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDb</name></decl>;</decl_stmt>              <comment type="block">/* Length of string argv[1] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>            <comment type="block">/* Length of string argv[2] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eCoordType</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>pAux</name></expr> ?</condition><then> <expr><name>RTREE_COORD_INT32</name></expr> </then><else>: <expr><name>RTREE_COORD_REAL32</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>pSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iErr</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>aErrMsg</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>,                                                    <comment type="block">/* 0 */</comment>
    <expr><literal type="string">"Wrong number of columns for an rtree table"</literal></expr>,         <comment type="block">/* 1 */</comment>
    <expr><literal type="string">"Too few columns for an rtree table"</literal></expr>,                 <comment type="block">/* 2 */</comment>
    <expr><literal type="string">"Too many columns for an rtree table"</literal></expr>,                <comment type="block">/* 3 */</comment>
    <expr><literal type="string">"Auxiliary rtree columns must be last"</literal></expr>                <comment type="block">/* 4 */</comment>
  }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>RTREE_MAX_AUX_COLUMN</name><operator>&lt;</operator><literal type="number">256</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Aux columns counted by a u8 */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>argc</name><argument_list type="generic">&lt;<argument><expr><literal type="number">6</literal> <operator>||</operator> <name>argc</name></expr></argument>&gt;</argument_list></name><name>RTREE_MAX_AUX_COLUMN</name><operator>+</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>aErrMsg</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name>argc</name><operator>&gt;=</operator><literal type="number">6</literal><operator>)</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_VTAB_CONSTRAINT_SUPPORT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate the sqlite3_vtab structure */</comment>
  <expr_stmt><expr><name>nDb</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nName</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRtree</name> <operator>=</operator> <operator>(</operator><name>Rtree</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Rtree</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>nDb</name><operator>+</operator><name>nName</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pRtree</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Rtree</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>nDb</name><operator>+</operator><name>nName</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nBusy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pModule</name></name> <operator>=</operator> <operator>&amp;</operator><name>rtreeModule</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pRtree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name><index>[<expr><name>nDb</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>eCoordType</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>eCoordType</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Create/Connect to the underlying relational database schema. If
  ** that is successful, call sqlite3_declare_vtab() to configure
  ** the r-tree table schema.
  */</comment>
  <expr_stmt><expr><name>pSql</name> <operator>=</operator> <call><name>sqlite3_str_new</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE x(%.*s INT"</literal></expr></argument>, 
                      <argument><expr><call><name>rtreeTokenLength</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">4</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name> <init>= <expr><name><name>argv</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nAux</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">",%.*s"</literal></expr></argument>, <argument><expr><call><name>rtreeTokenLength</name><argument_list>(<argument><expr><name>zArg</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zArg</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>nAux</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azFormat</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">",%.*s REAL"</literal></expr>, <expr><literal type="string">",%.*s INT"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><name><name>azFormat</name><index>[<expr><name>eCoordType</name></expr>]</index></name></expr></argument>,
                          <argument><expr><call><name>rtreeTokenLength</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">");"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_str_finish</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zSql</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>ii</name><operator>&lt;</operator><name>argc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>aErrMsg</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>rtreeInit_fail</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name> <operator>=</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim</name></name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iErr</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name><operator>&gt;</operator><name>RTREE_MAX_DIMENSIONS</name><operator>*</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iErr</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name> <operator>%</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iErr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iErr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iErr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>aErrMsg</name><index>[<expr><name>iErr</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>rtreeInit_fail</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nBytesPerCell</name></name> <operator>=</operator> <literal type="number">8</literal> <operator>+</operator> <name><name>pRtree</name><operator>-&gt;</operator><name>nDim2</name></name><operator>*</operator><literal type="number">4</literal></expr>;</expr_stmt>

  <comment type="block">/* Figure out the node size to use. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getNodeSize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>isCreate</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>rtreeInit_fail</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeSqlInit</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>isCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>rtreeInit_fail</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name> <operator>*</operator><operator>)</operator><name>pRtree</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

<label><name>rtreeInit_fail</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>ppVtab</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRtree</name><operator>-&gt;</operator><name>nBusy</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rtreeRelease</name><argument_list>(<argument><expr><name>pRtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Implementation of a scalar function that decodes r-tree nodes to
** human readable strings. This can be used for debugging and analysis.
**
** The scalar function takes two arguments: (1) the number of dimensions
** to the rtree (between 1 and 5, inclusive) and (2) a blob of data containing
** an r-tree node.  For a two-dimensional r-tree structure called "rt", to
** deserialize all nodes, a statement like:
**
**   SELECT rtreenode(2, data) FROM rt_node;
**
** The human readable string takes the form of a Tcl list with one
** entry for each cell in the r-tree node. Each entry is itself a
** list, containing the 8-byte rowid/pageno followed by the 
** &lt;num-dimension&gt;*2 coordinates.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreenode</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeNode</name></type> <name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Rtree</name></type> <name>tree</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>errCode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>pOut</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Rtree</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree</name><operator>.</operator><name>nDim</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>tree</name><operator>.</operator><name>nDim</name></name><operator>&lt;</operator><literal type="number">1</literal> <operator>||</operator> <name><name>tree</name><operator>.</operator><name>nDim</name></name><operator>&gt;</operator><literal type="number">5</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>tree</name><operator>.</operator><name>nDim2</name></name> <operator>=</operator> <name><name>tree</name><operator>.</operator><name>nDim</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree</name><operator>.</operator><name>nBytesPerCell</name></name> <operator>=</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <name><name>tree</name><operator>.</operator><name>nDim</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>node</name><operator>.</operator><name>zData</name></name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>node</name><operator>.</operator><name>zData</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nData</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nData</name><operator>&lt;</operator><literal type="number">4</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nData</name><operator>&lt;</operator><call><name>NCELL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>node</name></expr></argument>)</argument_list></call><operator>*</operator><name><name>tree</name><operator>.</operator><name>nBytesPerCell</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>pOut</name> <operator>=</operator> <call><name>sqlite3_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><call><name>NCELL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>RtreeCell</name></type> <name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>jj</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>nodeGetCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>ii</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"{%lld"</literal></expr></argument>, <argument><expr><name><name>cell</name><operator>.</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name><name>tree</name><operator>.</operator><name>nDim2</name></name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_RTREE_INT_ONLY</name></cpp:ifndef>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">" %g"</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name><name>cell</name><operator>.</operator><name>aCoord</name><index>[<expr><name>jj</name></expr>]</index></name><operator>.</operator><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>cell</name><operator>.</operator><name>aCoord</name><index>[<expr><name>jj</name></expr>]</index></name><operator>.</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>errCode</name> <operator>=</operator> <call><name>sqlite3_str_errcode</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>sqlite3_str_finish</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>errCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This routine implements an SQL function that returns the "depth" parameter
** from the front of a blob that is an r-tree node.  For example:
**
**     SELECT rtreedepth(data) FROM rt_node WHERE nodeno=1;
**
** The depth value is 0 for all nodes other than the root node, and the root
** node always has nodeno=1, so the example above is the primary use for this
** routine.  This routine is intended for testing and analysis only.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreedepth</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_BLOB</name> 
   <operator>||</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">2</literal></expr>

  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"Invalid argument to rtreedepth()"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>zBlob</name> <init>= <expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zBlob</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>readInt16</name><argument_list>(<argument><expr><name>zBlob</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Context object passed between the various routines that make up the
** implementation of integrity-check function rtreecheck().
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>RtreeCheck</name></name></type> <name>RtreeCheck</name>;</typedef>
<struct>struct <name>RtreeCheck</name> <block>{
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                    <comment type="block">/* Database handle */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                <comment type="block">/* Database containing rtree table */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl>;</decl_stmt>               <comment type="block">/* Name of rtree table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bInt</name></decl>;</decl_stmt>                       <comment type="block">/* True for rtree_i32 table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nDim</name></decl>;</decl_stmt>                       <comment type="block">/* Number of dimensions for this rtree tbl */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pGetNode</name></decl>;</decl_stmt>         <comment type="block">/* Statement used to retrieve nodes */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name><name>aCheckMapping</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Statements to query %_parent/%_rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLeaf</name></decl>;</decl_stmt>                      <comment type="block">/* Number of leaf cells in table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nNonLeaf</name></decl>;</decl_stmt>                   <comment type="block">/* Number of non-leaf cells in table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zReport</name></decl>;</decl_stmt>                  <comment type="block">/* Message to report */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nErr</name></decl>;</decl_stmt>                       <comment type="block">/* Number of lines in zReport */</comment>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTREE_CHECK_MAX_ERROR</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<comment type="block">/*
** Reset SQL statement pStmt. If the sqlite3_reset() call returns an error,
** and RtreeCheck.rc==SQLITE_OK, set RtreeCheck.rc to the error code.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreeCheckReset</name><parameter_list>(<parameter><decl><type><name>RtreeCheck</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The second and subsequent arguments to this function are a format string
** and printf style arguments. This function formats the string and attempts
** to compile it as an SQL statement.
**
** If successful, a pointer to the new SQL statement is returned. Otherwise,
** NULL is returned and an error code left in RtreeCheck.rc.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>rtreeCheckPrepare</name><parameter_list>(
  <parameter><decl><type><name>RtreeCheck</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>,             <comment type="block">/* RtreeCheck object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>           <comment type="block">/* Format string and trailing args */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The second and subsequent arguments to this function are a printf()
** style format string and arguments. This function formats the string and
** appends it to the report being accumuated in pCheck.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreeCheckAppendMsg</name><parameter_list>(<parameter><decl><type><name>RtreeCheck</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pCheck</name><operator>-&gt;</operator><name>nErr</name></name><operator>&lt;</operator><name>RTREE_CHECK_MAX_ERROR</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zReport</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z%s%z"</literal></expr></argument>, 
          <argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zReport</name></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zReport</name></name></expr> ?</condition><then> <expr><literal type="string">"\n"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>z</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>zReport</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if there is already an error code stored
** in the RtreeCheck object indicated by the first argument. NULL is
** returned in this case.
**
** Otherwise, the contents of rtree table node iNode are loaded from
** the database and copied into a buffer obtained from sqlite3_malloc().
** If no error occurs, a pointer to the buffer is returned and (*pnNode)
** is set to the size of the buffer in bytes.
**
** Or, if an error does occur, NULL is returned and an error code left
** in the RtreeCheck object. The final value of *pnNode is undefined in
** this case.
*/</comment>
<function><type><specifier>static</specifier> <name>u8</name> <modifier>*</modifier></type><name>rtreeCheckGetNode</name><parameter_list>(<parameter><decl><type><name>RtreeCheck</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iNode</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Return value */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pCheck</name><operator>-&gt;</operator><name>pGetNode</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>pGetNode</name></name> <operator>=</operator> <call><name>rtreeCheckPrepare</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>,
        <argument><expr><literal type="string">"SELECT data FROM %Q.'%q_node' WHERE nodeno=?"</literal></expr></argument>, 
        <argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>pGetNode</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>pGetNode</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nNode</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>pGetNode</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>pGetNode</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pRet</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>nNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pnNode</name> <operator>=</operator> <name>nNode</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>rtreeCheckReset</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>pGetNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pRet</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>rtreeCheckAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="string">"Node %lld missing from database"</literal></expr></argument>, <argument><expr><name>iNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to check that the %_parent (if bLeaf==0) or %_rowid
** (if bLeaf==1) table contains a specified entry. The schemas of the
** two tables are:
**
**   CREATE TABLE %_parent(nodeno INTEGER PRIMARY KEY, parentnode INTEGER)
**   CREATE TABLE %_rowid(rowid INTEGER PRIMARY KEY, nodeno INTEGER, ...)
**
** In both cases, this function checks that there exists an entry with
** IPK value iKey and the second column set to iVal.
**
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreeCheckMapping</name><parameter_list>(
  <parameter><decl><type><name>RtreeCheck</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>,             <comment type="block">/* RtreeCheck object */</comment>
  <parameter><decl><type><name>int</name></type> <name>bLeaf</name></decl></parameter>,                      <comment type="block">/* True for a leaf cell, false for interior */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iKey</name></decl></parameter>,                       <comment type="block">/* Key for mapping */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iVal</name></decl></parameter>                        <comment type="block">/* Expected value for mapping */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azSql</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"SELECT parentnode FROM %Q.'%q_parent' WHERE nodeno=?1"</literal></expr>,
    <expr><literal type="string">"SELECT nodeno FROM %Q.'%q_rowid' WHERE rowid=?1"</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bLeaf</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>bLeaf</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>aCheckMapping</name><index>[<expr><name>bLeaf</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>aCheckMapping</name><index>[<expr><name>bLeaf</name></expr>]</index></name> <operator>=</operator> <call><name>rtreeCheckPrepare</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>,
        <argument><expr><name><name>azSql</name><index>[<expr><name>bLeaf</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <name><name>pCheck</name><operator>-&gt;</operator><name>aCheckMapping</name><index>[<expr><name>bLeaf</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>rtreeCheckAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="string">"Mapping (%lld -&gt; %lld) missing from %s table"</literal></expr></argument>,
        <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>bLeaf</name></expr> ?</condition><then> <expr><literal type="string">"%_rowid"</literal></expr> </then><else>: <expr><literal type="string">"%_parent"</literal></expr></else></ternary><operator>)</operator></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>ii</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>ii</name><operator>!=</operator><name>iVal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>rtreeCheckAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, 
          <argument><expr><literal type="string">"Found (%lld -&gt; %lld) in %s table, expected (%lld -&gt; %lld)"</literal></expr></argument>,
          <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>bLeaf</name></expr> ?</condition><then> <expr><literal type="string">"%_rowid"</literal></expr> </then><else>: <expr><literal type="string">"%_parent"</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>rtreeCheckReset</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Argument pCell points to an array of coordinates stored on an rtree page.
** This function checks that the coordinates are internally consistent (no
** x1&gt;x2 conditions) and adds an error message to the RtreeCheck object
** if they are not.
**
** Additionally, if pParent is not NULL, then it is assumed to point to
** the array of coordinates on the parent page that bound the page 
** containing pCell. In this case it is also verified that the two
** sets of coordinates are mutually consistent and an error message added
** to the RtreeCheck object if they are not.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreeCheckCellCoord</name><parameter_list>(
  <parameter><decl><type><name>RtreeCheck</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>, 
  <parameter><decl><type><name>i64</name></type> <name>iNode</name></decl></parameter>,                      <comment type="block">/* Node id to use in error messages */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCell</name></decl></parameter>,                      <comment type="block">/* Cell number to use in error messages */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name></decl></parameter>,                      <comment type="block">/* Pointer to cell coordinates */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pParent</name></decl></parameter>                     <comment type="block">/* Pointer to parent coordinates */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeCoord</name></type> <name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeCoord</name></type> <name>p1</name></decl>, <decl><type ref="prev"/><name>p2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCheck</name><operator>-&gt;</operator><name>nDim</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><index>[<expr><literal type="number">4</literal><operator>*</operator><literal type="number">2</literal><operator>*</operator><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCell</name><index>[<expr><literal type="number">4</literal><operator>*</operator><operator>(</operator><literal type="number">2</literal><operator>*</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* printf("%e, %e\n", c1.u.f, c2.u.f); */</comment>
    <if_stmt><if>if<condition>( <expr><ternary><condition><expr><name><name>pCheck</name><operator>-&gt;</operator><name>bInt</name></name></expr> ?</condition><then> <expr><name><name>c1</name><operator>.</operator><name>i</name></name><operator>&gt;</operator><name><name>c2</name><operator>.</operator><name>i</name></name></expr> </then><else>: <expr><name><name>c1</name><operator>.</operator><name>f</name></name><operator>&gt;</operator><name><name>c2</name><operator>.</operator><name>f</name></name></expr></else></ternary></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>rtreeCheckAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, 
          <argument><expr><literal type="string">"Dimension %d of cell %d on node %lld is corrupt"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>, <argument><expr><name>iNode</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>pParent</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pParent</name><index>[<expr><literal type="number">4</literal><operator>*</operator><literal type="number">2</literal><operator>*</operator><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>readCoord</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pParent</name><index>[<expr><literal type="number">4</literal><operator>*</operator><operator>(</operator><literal type="number">2</literal><operator>*</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><operator>(</operator><ternary><condition><expr><name><name>pCheck</name><operator>-&gt;</operator><name>bInt</name></name></expr> ?</condition><then> <expr><name><name>c1</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><name><name>p1</name><operator>.</operator><name>i</name></name></expr> </then><else>: <expr><name><name>c1</name><operator>.</operator><name>f</name></name><operator>&lt;</operator><name><name>p1</name><operator>.</operator><name>f</name></name></expr></else></ternary><operator>)</operator> 
       <operator>||</operator> <operator>(</operator><ternary><condition><expr><name><name>pCheck</name><operator>-&gt;</operator><name>bInt</name></name></expr> ?</condition><then> <expr><name><name>c2</name><operator>.</operator><name>i</name></name><operator>&gt;</operator><name><name>p2</name><operator>.</operator><name>i</name></name></expr> </then><else>: <expr><name><name>c2</name><operator>.</operator><name>f</name></name><operator>&gt;</operator><name><name>p2</name><operator>.</operator><name>f</name></name></expr></else></ternary><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>rtreeCheckAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, 
            <argument><expr><literal type="string">"Dimension %d of cell %d on node %lld is corrupt relative to parent"</literal></expr></argument>
            , <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>, <argument><expr><name>iNode</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Run rtreecheck() checks on node iNode, which is at depth iDepth within
** the r-tree structure. Argument aParent points to the array of coordinates
** that bound node iNode on the parent node.
**
** If any problems are discovered, an error message is appended to the
** report accumulated in the RtreeCheck object.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreeCheckNode</name><parameter_list>(
  <parameter><decl><type><name>RtreeCheck</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iDepth</name></decl></parameter>,                     <comment type="block">/* Depth of iNode (0==leaf) */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aParent</name></decl></parameter>,                    <comment type="block">/* Buffer containing parent coords */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iNode</name></decl></parameter>                       <comment type="block">/* Node to check */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aNode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nNode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iNode</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>aParent</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>nDim</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>aNode</name> <operator>=</operator> <call><name>rtreeCheckGetNode</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aNode</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nNode</name><operator>&lt;</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>rtreeCheckAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, 
          <argument><expr><literal type="string">"Node %lld is too small (%d bytes)"</literal></expr></argument>, <argument><expr><name>iNode</name></expr></argument>, <argument><expr><name>nNode</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>                  <comment type="block">/* Number of cells on page */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                      <comment type="block">/* Used to iterate through cells */</comment>
      <if_stmt><if>if<condition>( <expr><name>aParent</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iDepth</name> <operator>=</operator> <call><name>readInt16</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iDepth</name><operator>&gt;</operator><name>RTREE_MAX_DEPTH</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>rtreeCheckAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="string">"Rtree depth out of range (%d)"</literal></expr></argument>, <argument><expr><name>iDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nCell</name> <operator>=</operator> <call><name>readInt16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aNode</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><literal type="number">4</literal> <operator>+</operator> <name>nCell</name><operator>*</operator><operator>(</operator><literal type="number">8</literal> <operator>+</operator> <name><name>pCheck</name><operator>-&gt;</operator><name>nDim</name></name><operator>*</operator><literal type="number">2</literal><operator>*</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator><operator>&gt;</operator><name>nNode</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>rtreeCheckAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, 
            <argument><expr><literal type="string">"Node %lld is too small for cell count of %d (%d bytes)"</literal></expr></argument>, 
            <argument><expr><name>iNode</name></expr></argument>, <argument><expr><name>nCell</name></expr></argument>, <argument><expr><name>nNode</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pCell</name> <init>= <expr><operator>&amp;</operator><name><name>aNode</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <name>i</name><operator>*</operator><operator>(</operator><literal type="number">8</literal> <operator>+</operator> <name><name>pCheck</name><operator>-&gt;</operator><name>nDim</name></name><operator>*</operator><literal type="number">2</literal><operator>*</operator><literal type="number">4</literal><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>i64</name></type> <name>iVal</name> <init>= <expr><call><name>readInt64</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>rtreeCheckCellCoord</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iNode</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCell</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name>aParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if_stmt><if>if<condition>( <expr><name>iDepth</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>rtreeCheckMapping</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iVal</name></expr></argument>, <argument><expr><name>iNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rtreeCheckNode</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iDepth</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCell</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>nNonLeaf</name></name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>rtreeCheckMapping</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iVal</name></expr></argument>, <argument><expr><name>iNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>nLeaf</name></name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The second argument to this function must be either "_rowid" or
** "_parent". This function checks that the number of entries in the
** %_rowid or %_parent table is exactly nExpect. If not, it adds
** an error message to the report in the RtreeCheck object indicated
** by the first argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreeCheckCount</name><parameter_list>(<parameter><decl><type><name>RtreeCheck</name> <modifier>*</modifier></type><name>pCheck</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTbl</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nExpect</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pCount</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pCount</name> <operator>=</operator> <call><name>rtreeCheckPrepare</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="string">"SELECT count(*) FROM %Q.'%q%s'"</literal></expr></argument>,
        <argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>pCheck</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pCount</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pCount</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>i64</name></type> <name>nActual</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pCount</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>nActual</name><operator>!=</operator><name>nExpect</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>rtreeCheckAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="string">"Wrong number of entries in %%%s table"</literal>
              <literal type="string">" - expected %lld, actual %lld"</literal></expr></argument> , <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><name>nExpect</name></expr></argument>, <argument><expr><name>nActual</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pCheck</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function does the bulk of the work for the rtree integrity-check.
** It is called by rtreecheck(), which is the SQL function implementation.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtreeCheckTable</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle to access db through */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,                <comment type="block">/* Name of db ("main", "temp" etc.) */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,               <comment type="block">/* Name of rtree table to check */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzReport</name></decl></parameter>                 <comment type="block">/* OUT: sqlite3_malloc'd report text */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeCheck</name></type> <name>check</name></decl>;</decl_stmt>               <comment type="block">/* Common context for various routines */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Used to find column count of rtree table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* True if transaction should be closed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAux</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Number of extra columns. */</comment>

  <comment type="block">/* Initialize the context object */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>check</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>check</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>check</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>check</name><operator>.</operator><name>zDb</name></name> <operator>=</operator> <name>zDb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>check</name><operator>.</operator><name>zTab</name></name> <operator>=</operator> <name>zTab</name></expr>;</expr_stmt>

  <comment type="block">/* If there is not already an open transaction, open one now. This is
  ** to ensure that the queries run as part of this integrity-check operate
  ** on a consistent snapshot.  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_get_autocommit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>check</name><operator>.</operator><name>rc</name></name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bEnd</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Find the number of auxiliary columns */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>check</name><operator>.</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>rtreeCheckPrepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>check</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM %Q.'%q_rowid'"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nAux</name> <operator>=</operator> <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else 
    if<condition>( <expr><name><name>check</name><operator>.</operator><name>rc</name></name><operator>!=</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>check</name><operator>.</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Find number of dimensions in the rtree table. */</comment>
  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>rtreeCheckPrepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>check</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM %Q.%Q"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>check</name><operator>.</operator><name>nDim</name></name> <operator>=</operator> <operator>(</operator><call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>nAux</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>check</name><operator>.</operator><name>nDim</name></name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>rtreeCheckAppendMsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>check</name></expr></argument>, <argument><expr><literal type="string">"Schema corrupt or not an rtree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>check</name><operator>.</operator><name>bInt</name></name> <operator>=</operator> <operator>(</operator><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_INTEGER</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_CORRUPT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>check</name><operator>.</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Do the actual integrity-check */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>check</name><operator>.</operator><name>nDim</name></name><operator>&gt;=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>check</name><operator>.</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>rtreeCheckNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>check</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>rtreeCheckCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name>check</name></expr></argument>, <argument><expr><literal type="string">"_rowid"</literal></expr></argument>, <argument><expr><name><name>check</name><operator>.</operator><name>nLeaf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rtreeCheckCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name>check</name></expr></argument>, <argument><expr><literal type="string">"_parent"</literal></expr></argument>, <argument><expr><name><name>check</name><operator>.</operator><name>nNonLeaf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Finalize SQL statements used by the integrity-check */</comment>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>check</name><operator>.</operator><name>pGetNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>check</name><operator>.</operator><name>aCheckMapping</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>check</name><operator>.</operator><name>aCheckMapping</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If one was opened, close the transaction */</comment>
  <if_stmt><if>if<condition>( <expr><name>bEnd</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"END"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>check</name><operator>.</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>check</name><operator>.</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pzReport</name> <operator>=</operator> <name><name>check</name><operator>.</operator><name>zReport</name></name></expr>;</expr_stmt>
  <return>return <expr><name><name>check</name><operator>.</operator><name>rc</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Usage:
**
**   rtreecheck(&lt;rtree-table&gt;);
**   rtreecheck(&lt;database&gt;, &lt;rtree-table&gt;);
**
** Invoking this SQL function runs an integrity-check on the named rtree
** table. The integrity-check verifies the following:
**
**   1. For each cell in the r-tree structure (%_node table), that:
**
**       a) for each dimension, (coord1 &lt;= coord2).
**
**       b) unless the cell is on the root node, that the cell is bounded
**          by the parent cell on the parent node.
**
**       c) for leaf nodes, that there is an entry in the %_rowid 
**          table corresponding to the cell's rowid value that 
**          points to the correct node.
**
**       d) for cells on non-leaf nodes, that there is an entry in the 
**          %_parent table mapping from the cell's child node to the
**          node that it resides on.
**
**   2. That there are the same number of entries in the %_rowid table
**      as there are leaf cells in the r-tree structure, and that there
**      is a leaf cell that corresponds to each entry in the %_rowid table.
**
**   3. That there are the same number of entries in the %_parent table
**      as there are non-leaf cells in the r-tree structure, and that 
**      there is a non-leaf cell that corresponds to each entry in the 
**      %_parent table.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreecheck</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nArg</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, 
        <argument><expr><literal type="string">"wrong number of arguments to function rtreecheck()"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zReport</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zTab</name> <operator>=</operator> <name>zDb</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zDb</name> <operator>=</operator> <literal type="string">"main"</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zTab</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rtreeCheckTable</name><argument_list>(<argument><expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zReport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><ternary><condition><expr><name>zReport</name></expr> ?</condition><then> <expr><name>zReport</name></expr> </then><else>: <expr><literal type="string">"ok"</literal></expr></else></ternary></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zReport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Conditionally include the geopoly code */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_GEOPOLY</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"geopoly.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Register the r-tree module with database handle db. This creates the
** virtual table module "rtree" and the debugging/analysis scalar 
** function "rtreenode".
*/</comment>
<function><type><name>int</name></type> <name>sqlite3RtreeInit</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>utf8</name> <init>= <expr><name>SQLITE_UTF8</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"rtreenode"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>utf8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rtreenode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"rtreedepth"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>utf8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>rtreedepth</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"rtreecheck"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>utf8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>rtreecheck</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_RTREE_INT_ONLY</name></cpp:ifdef>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>RTREE_COORD_INT32</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>RTREE_COORD_REAL32</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"rtree"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtreeModule</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>RTREE_COORD_INT32</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"rtree_i32"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtreeModule</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_GEOPOLY</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_geopoly_init</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine deletes the RtreeGeomCallback object that was attached
** one of the SQL functions create by sqlite3_rtree_geometry_callback()
** or sqlite3_rtree_query_callback().  In other words, this routine is the
** destructor for an RtreeGeomCallback objecct.  This routine is called when
** the corresponding SQL function is deleted.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreeFreeCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeGeomCallback</name> <modifier>*</modifier></type><name>pInfo</name> <init>= <expr><operator>(</operator><name>RtreeGeomCallback</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>xDestructor</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>pInfo</name><operator>-&gt;</operator><name>xDestructor</name></name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine frees the BLOB that is returned by geomCallback().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rtreeMatchArgFree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeMatchArg</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>RtreeMatchArg</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nParam</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_value_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>apSqlParam</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Each call to sqlite3_rtree_geometry_callback() or
** sqlite3_rtree_query_callback() creates an ordinary SQLite
** scalar function that is implemented by this routine.
**
** All this function does is construct an RtreeMatchArg object that
** contains the geometry-checking callback routines and a list of
** parameters to this function, then return that RtreeMatchArg object
** as a BLOB.
**
** The R-Tree MATCH operator will read the returned BLOB, deserialize
** the RtreeMatchArg object, and use the RtreeMatchArg object to figure
** out which elements of the R-Tree should be returned by the query.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>geomCallback</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>aArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeGeomCallback</name> <modifier>*</modifier></type><name>pGeomCtx</name> <init>= <expr><operator>(</operator><name>RtreeGeomCallback</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RtreeMatchArg</name> <modifier>*</modifier></type><name>pBlob</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nBlob</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>memErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>nBlob</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RtreeMatchArg</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeDValue</name></expr></argument>)</argument_list></sizeof>
           <operator>+</operator> <name>nArg</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBlob</name> <operator>=</operator> <operator>(</operator><name>RtreeMatchArg</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pBlob</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>iSize</name></name> <operator>=</operator> <name>nBlob</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>cb</name></name> <operator>=</operator> <name><name>pGeomCtx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>apSqlParam</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pBlob</name><operator>-&gt;</operator><name>aParam</name><index>[<expr><name>nArg</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nParam</name></name> <operator>=</operator> <name>nArg</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>apSqlParam</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_value_dup</name><argument_list>(<argument><expr><name><name>aArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pBlob</name><operator>-&gt;</operator><name>apSqlParam</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>memErr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_RTREE_INT_ONLY</name></cpp:ifdef>
      <expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>aParam</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>aArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>aParam</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>aArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>memErr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>rtreeMatchArgFree</name><argument_list>(<argument><expr><name>pBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_pointer</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>, <argument><expr><literal type="string">"RtreeMatchArg"</literal></expr></argument>, <argument><expr><name>rtreeMatchArgFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Register a new geometry function for use with the r-tree MATCH operator.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_rtree_geometry_callback</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                  <comment type="block">/* Register SQL function on this connection */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zGeom</name></decl></parameter>,            <comment type="block">/* Name of the new SQL function */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xGeom</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_rtree_geometry</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>RtreeDValue</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* Callback */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>                <comment type="block">/* Extra data associated with the callback */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeGeomCallback</name> <modifier>*</modifier></type><name>pGeomCtx</name></decl>;</decl_stmt>      <comment type="block">/* Context object for new user-function */</comment>

  <comment type="block">/* Allocate and populate the context object. */</comment>
  <expr_stmt><expr><name>pGeomCtx</name> <operator>=</operator> <operator>(</operator><name>RtreeGeomCallback</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeGeomCallback</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pGeomCtx</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pGeomCtx</name><operator>-&gt;</operator><name>xGeom</name></name> <operator>=</operator> <name>xGeom</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pGeomCtx</name><operator>-&gt;</operator><name>xQueryFunc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pGeomCtx</name><operator>-&gt;</operator><name>xDestructor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pGeomCtx</name><operator>-&gt;</operator><name>pContext</name></name> <operator>=</operator> <name>pContext</name></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3_create_function_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zGeom</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_ANY</name></expr></argument>, 
      <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pGeomCtx</name></expr></argument>, <argument><expr><name>geomCallback</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rtreeFreeCallback</name></expr></argument>
  )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Register a new 2nd-generation geometry function for use with the
** r-tree MATCH operator.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_rtree_query_callback</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                 <comment type="block">/* Register SQL function on this connection */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zQueryFunc</name></decl></parameter>,      <comment type="block">/* Name of new SQL function */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xQueryFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_rtree_query_info</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* Callback */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,              <comment type="block">/* Extra data passed into the callback */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestructor</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>   <comment type="block">/* Destructor for the extra data */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RtreeGeomCallback</name> <modifier>*</modifier></type><name>pGeomCtx</name></decl>;</decl_stmt>      <comment type="block">/* Context object for new user-function */</comment>

  <comment type="block">/* Allocate and populate the context object. */</comment>
  <expr_stmt><expr><name>pGeomCtx</name> <operator>=</operator> <operator>(</operator><name>RtreeGeomCallback</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RtreeGeomCallback</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pGeomCtx</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>xDestructor</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xDestructor</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pGeomCtx</name><operator>-&gt;</operator><name>xGeom</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pGeomCtx</name><operator>-&gt;</operator><name>xQueryFunc</name></name> <operator>=</operator> <name>xQueryFunc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pGeomCtx</name><operator>-&gt;</operator><name>xDestructor</name></name> <operator>=</operator> <name>xDestructor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pGeomCtx</name><operator>-&gt;</operator><name>pContext</name></name> <operator>=</operator> <name>pContext</name></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3_create_function_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zQueryFunc</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_ANY</name></expr></argument>, 
      <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pGeomCtx</name></expr></argument>, <argument><expr><name>geomCallback</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rtreeFreeCallback</name></expr></argument>
  )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_CORE</name></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_rtree_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <macro><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument>pApi</argument>)</argument_list></macro>
  <return>return <expr><call><name>sqlite3RtreeInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
