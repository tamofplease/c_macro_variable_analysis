<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/wal.c"><comment type="block">/*
** 2010 February 1
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains the implementation of a write-ahead log (WAL) used in 
** "journal_mode=WAL" mode.
**
** WRITE-AHEAD LOG (WAL) FILE FORMAT
**
** A WAL file consists of a header followed by zero or more "frames".
** Each frame records the revised content of a single page from the
** database file.  All changes to the database are recorded by writing
** frames into the WAL.  Transactions commit when a frame is written that
** contains a commit marker.  A single WAL can and usually does record 
** multiple transactions.  Periodically, the content of the WAL is
** transferred back into the database file in an operation called a
** "checkpoint".
**
** A single WAL file can be used multiple times.  In other words, the
** WAL can fill up with frames and then be checkpointed and then new
** frames can overwrite the old ones.  A WAL always grows from beginning
** toward the end.  Checksums and counters attached to each frame are
** used to determine which frames within the WAL are valid and which
** are leftovers from prior checkpoints.
**
** The WAL header is 32 bytes in size and consists of the following eight
** big-endian 32-bit unsigned integer values:
**
**     0: Magic number.  0x377f0682 or 0x377f0683
**     4: File format version.  Currently 3007000
**     8: Database page size.  Example: 1024
**    12: Checkpoint sequence number
**    16: Salt-1, random integer incremented with each checkpoint
**    20: Salt-2, a different random integer changing with each ckpt
**    24: Checksum-1 (first part of checksum for first 24 bytes of header).
**    28: Checksum-2 (second part of checksum for first 24 bytes of header).
**
** Immediately following the wal-header are zero or more frames. Each
** frame consists of a 24-byte frame-header followed by a &lt;page-size&gt; bytes
** of page data. The frame-header is six big-endian 32-bit unsigned 
** integer values, as follows:
**
**     0: Page number.
**     4: For commit records, the size of the database image in pages 
**        after the commit. For all other records, zero.
**     8: Salt-1 (copied from the header)
**    12: Salt-2 (copied from the header)
**    16: Checksum-1.
**    20: Checksum-2.
**
** A frame is considered valid if and only if the following conditions are
** true:
**
**    (1) The salt-1 and salt-2 values in the frame-header match
**        salt values in the wal-header
**
**    (2) The checksum values in the final 8 bytes of the frame-header
**        exactly match the checksum computed consecutively on the
**        WAL header and the first 8 bytes and the content of all frames
**        up to and including the current frame.
**
** The checksum is computed using 32-bit big-endian integers if the
** magic number in the first 4 bytes of the WAL is 0x377f0683 and it
** is computed using little-endian if the magic number is 0x377f0682.
** The checksum values are always stored in the frame header in a
** big-endian format regardless of which byte order is used to compute
** the checksum.  The checksum is computed by interpreting the input as
** an even number of unsigned 32-bit integers: x[0] through x[N].  The
** algorithm used for the checksum is as follows:
** 
**   for i from 0 to n-1 step 2:
**     s0 += x[i] + s1;
**     s1 += x[i+1] + s0;
**   endfor
**
** Note that s0 and s1 are both weighted checksums using fibonacci weights
** in reverse order (the largest fibonacci weight occurs on the first element
** of the sequence being summed.)  The s1 value spans all 32-bit 
** terms of the sequence whereas s0 omits the final term.
**
** On a checkpoint, the WAL is first VFS.xSync-ed, then valid content of the
** WAL is transferred into the database, then the database is VFS.xSync-ed.
** The VFS.xSync operations serve as write barriers - all writes launched
** before the xSync must complete before any write that launches after the
** xSync begins.
**
** After each checkpoint, the salt-1 value is incremented and the salt-2
** value is randomized.  This prevents old and new frames in the WAL from
** being considered valid at the same time and being checkpointing together
** following a crash.
**
** READER ALGORITHM
**
** To read a page from the database (call it page number P), a reader
** first checks the WAL to see if it contains page P.  If so, then the
** last valid instance of page P that is a followed by a commit frame
** or is a commit frame itself becomes the value read.  If the WAL
** contains no copies of page P that are valid and which are a commit
** frame or are followed by a commit frame, then page P is read from
** the database file.
**
** To start a read transaction, the reader records the index of the last
** valid frame in the WAL.  The reader uses this recorded "mxFrame" value
** for all subsequent read operations.  New transactions can be appended
** to the WAL, but as long as the reader uses its original mxFrame value
** and ignores the newly appended content, it will see a consistent snapshot
** of the database from a single point in time.  This technique allows
** multiple concurrent readers to view different versions of the database
** content simultaneously.
**
** The reader algorithm in the previous paragraphs works correctly, but 
** because frames for page P can appear anywhere within the WAL, the
** reader has to scan the entire WAL looking for page P frames.  If the
** WAL is large (multiple megabytes is typical) that scan can be slow,
** and read performance suffers.  To overcome this problem, a separate
** data structure called the wal-index is maintained to expedite the
** search for frames of a particular page.
** 
** WAL-INDEX FORMAT
**
** Conceptually, the wal-index is shared memory, though VFS implementations
** might choose to implement the wal-index using a mmapped file.  Because
** the wal-index is shared memory, SQLite does not support journal_mode=WAL 
** on a network filesystem.  All users of the database must be able to
** share memory.
**
** In the default unix and windows implementation, the wal-index is a mmapped
** file whose name is the database name with a "-shm" suffix added.  For that
** reason, the wal-index is sometimes called the "shm" file.
**
** The wal-index is transient.  After a crash, the wal-index can (and should
** be) reconstructed from the original WAL file.  In fact, the VFS is required
** to either truncate or zero the header of the wal-index when the last
** connection to it closes.  Because the wal-index is transient, it can
** use an architecture-specific format; it does not have to be cross-platform.
** Hence, unlike the database and WAL file formats which store all values
** as big endian, the wal-index can store multi-byte values in the native
** byte order of the host computer.
**
** The purpose of the wal-index is to answer this question quickly:  Given
** a page number P and a maximum frame index M, return the index of the 
** last frame in the wal before frame M for page P in the WAL, or return
** NULL if there are no frames for page P in the WAL prior to M.
**
** The wal-index consists of a header region, followed by an one or
** more index blocks.  
**
** The wal-index header contains the total number of frames within the WAL
** in the mxFrame field.
**
** Each index block except for the first contains information on 
** HASHTABLE_NPAGE frames. The first index block contains information on
** HASHTABLE_NPAGE_ONE frames. The values of HASHTABLE_NPAGE_ONE and 
** HASHTABLE_NPAGE are selected so that together the wal-index header and
** first index block are the same size as all other index blocks in the
** wal-index.  The values are:
**
**   HASHTABLE_NPAGE      4096
**   HASHTABLE_NPAGE_ONE  4062
**
** Each index block contains two sections, a page-mapping that contains the
** database page number associated with each wal frame, and a hash-table 
** that allows readers to query an index block for a specific page number.
** The page-mapping is an array of HASHTABLE_NPAGE (or HASHTABLE_NPAGE_ONE
** for the first index block) 32-bit page numbers. The first entry in the 
** first index-block contains the database page number corresponding to the
** first frame in the WAL file. The first entry in the second index block
** in the WAL file corresponds to the (HASHTABLE_NPAGE_ONE+1)th frame in
** the log, and so on.
**
** The last index block in a wal-index usually contains less than the full
** complement of HASHTABLE_NPAGE (or HASHTABLE_NPAGE_ONE) page-numbers,
** depending on the contents of the WAL file. This does not change the
** allocated size of the page-mapping array - the page-mapping array merely
** contains unused entries.
**
** Even without using the hash table, the last frame for page P
** can be found by scanning the page-mapping sections of each index block
** starting with the last index block and moving toward the first, and
** within each index block, starting at the end and moving toward the
** beginning.  The first entry that equals P corresponds to the frame
** holding the content for that page.
**
** The hash table consists of HASHTABLE_NSLOT 16-bit unsigned integers.
** HASHTABLE_NSLOT = 2*HASHTABLE_NPAGE, and there is one entry in the
** hash table for each page number in the mapping section, so the hash 
** table is never more than half full.  The expected number of collisions 
** prior to finding a match is 1.  Each entry of the hash table is an
** 1-based index of an entry in the mapping section of the same
** index block.   Let K be the 1-based index of the largest entry in
** the mapping section.  (For index blocks other than the last, K will
** always be exactly HASHTABLE_NPAGE (4096) and for the last index block
** K will be (mxFrame%HASHTABLE_NPAGE).)  Unused slots of the hash table
** contain a value of 0.
**
** To look for page P in the hash table, first compute a hash iKey on
** P as follows:
**
**      iKey = (P * 383) % HASHTABLE_NSLOT
**
** Then start scanning entries of the hash table, starting with iKey
** (wrapping around to the beginning when the end of the hash table is
** reached) until an unused hash slot is found. Let the first unused slot
** be at index iUnused.  (iUnused might be less than iKey if there was
** wrap-around.) Because the hash table is never more than half full,
** the search is guaranteed to eventually hit an unused entry.  Let 
** iMax be the value between iKey and iUnused, closest to iUnused,
** where aHash[iMax]==P.  If there is no iMax entry (if there exists
** no hash slot such that aHash[i]==p) then page P is not in the
** current index block.  Otherwise the iMax-th mapping entry of the
** current index block corresponds to the last entry that references 
** page P.
**
** A hash search begins with the last index block and moves toward the
** first index block, looking for entries corresponding to page P.  On
** average, only two or three slots in each index block need to be
** examined in order to either find the last entry for page P, or to
** establish that no such entry exists in the block.  Each index block
** holds over 4000 entries.  So two or three index blocks are sufficient
** to cover a typical 10 megabyte WAL file, assuming 1K pages.  8 or 10
** comparisons (on average) suffice to either locate a frame in the
** WAL or to establish that the frame does not exist in the WAL.  This
** is much faster than scanning the entire 10MB WAL.
**
** Note that entries are added in order of increasing K.  Hence, one
** reader might be using some value K0 and a second reader that started
** at a later time (after additional transactions were added to the WAL
** and to the wal-index) might be using a different value K1, where K1&gt;K0.
** Both readers can use the same hash table and mapping section to get
** the correct result.  There may be entries in the hash table with
** K&gt;K0 but to the first reader, those entries will appear to be unused
** slots in the hash table and so the first reader will get an answer as
** if no values greater than K0 had ever been inserted into the hash table
** in the first place - which is what reader one wants.  Meanwhile, the
** second reader using K1 will see additional values that were inserted
** later, which is exactly what reader two wants.  
**
** When a rollback occurs, the value of K is decreased. Hash table entries
** that correspond to frames greater than the new K value are removed
** from the hash table at this point.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"wal.h"</cpp:file></cpp:include>

<comment type="block">/*
** Trace output macros
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3WalTrace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>WALTRACE</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>if(sqlite3WalTrace) sqlite3DebugPrintf X</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>WALTRACE</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The maximum (and only) versions of the wal and wal-index formats
** that may be interpreted by this version of SQLite.
**
** If a client begins recovering a WAL file and finds that (a) the checksum
** values in the wal-header are correct and (b) the version field is not
** WAL_MAX_VERSION, recovery fails and SQLite returns SQLITE_CANTOPEN.
**
** Similarly, if a client successfully reads a wal-index header (i.e. the 
** checksum test is successful) and finds that the version field is not
** WALINDEX_MAX_VERSION, then no read-transaction is opened and SQLite
** returns SQLITE_CANTOPEN.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_MAX_VERSION</name></cpp:macro>      <cpp:value>3007000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WALINDEX_MAX_VERSION</name></cpp:macro> <cpp:value>3007000</cpp:value></cpp:define>

<comment type="block">/*
** Index numbers for various locking bytes.   WAL_NREADER is the number
** of available reader locks and should be at least 3.  The default
** is SQLITE_SHM_NLOCK==8 and  WAL_NREADER==5.
**
** Technically, the various VFSes are free to implement these locks however
** they see fit.  However, compatibility is encouraged so that VFSes can
** interoperate.  The standard implemention used on both unix and windows
** is for the index number to indicate a byte offset into the
** WalCkptInfo.aLock[] array in the wal-index header.  In other words, all
** locks are on the shm file.  The WALINDEX_LOCK_OFFSET constant (which
** should be 120) is the location in the shm file for the first locking
** byte.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_WRITE_LOCK</name></cpp:macro>         <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_ALL_BUT_WRITE</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_CKPT_LOCK</name></cpp:macro>          <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_RECOVER_LOCK</name></cpp:macro>       <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_READ_LOCK</name><parameter_list>(<parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(3+(I))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_NREADER</name></cpp:macro>            <cpp:value>(SQLITE_SHM_NLOCK-3)</cpp:value></cpp:define>


<comment type="block">/* Object declarations */</comment>
<typedef>typedef <type><name><name>struct</name> <name>WalIndexHdr</name></name></type> <name>WalIndexHdr</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>WalIterator</name></name></type> <name>WalIterator</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>WalCkptInfo</name></name></type> <name>WalCkptInfo</name>;</typedef>


<comment type="block">/*
** The following object holds a copy of the wal-index header content.
**
** The actual header in the wal-index consists of two copies of this
** object followed by one instance of the WalCkptInfo object.
** For all versions of SQLite through 3.10.0 and probably beyond,
** the locking bytes (WalCkptInfo.aLock) start at offset 120 and
** the total header size is 136 bytes.
**
** The szPage value can be any power of 2 between 512 and 32768, inclusive.
** Or it can be 1 to represent a 65536-byte page.  The latter case was
** added in 3.7.1 when support for 64K pages was added.  
*/</comment>
<struct>struct <name>WalIndexHdr</name> <block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>iVersion</name></decl>;</decl_stmt>                   <comment type="block">/* Wal-index version */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>unused</name></decl>;</decl_stmt>                     <comment type="block">/* Unused (padding) field */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iChange</name></decl>;</decl_stmt>                    <comment type="block">/* Counter incremented each transaction */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>isInit</name></decl>;</decl_stmt>                      <comment type="block">/* 1 when initialized */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bigEndCksum</name></decl>;</decl_stmt>                 <comment type="block">/* True if checksums in WAL are big-endian */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>szPage</name></decl>;</decl_stmt>                     <comment type="block">/* Database page size in bytes. 1==64K */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>mxFrame</name></decl>;</decl_stmt>                    <comment type="block">/* Index of last valid frame in the WAL */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nPage</name></decl>;</decl_stmt>                      <comment type="block">/* Size of database in pages */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aFrameCksum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>             <comment type="block">/* Checksum of last frame in log */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aSalt</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>                   <comment type="block">/* Two salt values copied from WAL header */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aCksum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>                  <comment type="block">/* Checksum over all prior fields */</comment>
}</block>;</struct>

<comment type="block">/*
** A copy of the following object occurs in the wal-index immediately
** following the second copy of the WalIndexHdr.  This object stores
** information used by checkpoint.
**
** nBackfill is the number of frames in the WAL that have been written
** back into the database. (We call the act of moving content from WAL to
** database "backfilling".)  The nBackfill number is never greater than
** WalIndexHdr.mxFrame.  nBackfill can only be increased by threads
** holding the WAL_CKPT_LOCK lock (which includes a recovery thread).
** However, a WAL_WRITE_LOCK thread can move the value of nBackfill from
** mxFrame back to zero when the WAL is reset.
**
** nBackfillAttempted is the largest value of nBackfill that a checkpoint
** has attempted to achieve.  Normally nBackfill==nBackfillAtempted, however
** the nBackfillAttempted is set before any backfilling is done and the
** nBackfill is only set after all backfilling completes.  So if a checkpoint
** crashes, nBackfillAttempted might be larger than nBackfill.  The
** WalIndexHdr.mxFrame must never be less than nBackfillAttempted.
**
** The aLock[] field is a set of bytes used for locking.  These bytes should
** never be read or written.
**
** There is one entry in aReadMark[] for each reader lock.  If a reader
** holds read-lock K, then the value in aReadMark[K] is no greater than
** the mxFrame for that reader.  The value READMARK_NOT_USED (0xffffffff)
** for any aReadMark[] means that entry is unused.  aReadMark[0] is 
** a special case; its value is never used and it exists as a place-holder
** to avoid having to offset aReadMark[] indexs by one.  Readers holding
** WAL_READ_LOCK(0) always ignore the entire WAL and read all content
** directly from the database.
**
** The value of aReadMark[K] may only be changed by a thread that
** is holding an exclusive lock on WAL_READ_LOCK(K).  Thus, the value of
** aReadMark[K] cannot changed while there is a reader is using that mark
** since the reader will be holding a shared lock on WAL_READ_LOCK(K).
**
** The checkpointer may only transfer frames from WAL to database where
** the frame numbers are less than or equal to every aReadMark[] that is
** in use (that is, every aReadMark[j] for which there is a corresponding
** WAL_READ_LOCK(j)).  New readers (usually) pick the aReadMark[] with the
** largest value and will increase an unused aReadMark[] to mxFrame if there
** is not already an aReadMark[] equal to mxFrame.  The exception to the
** previous sentence is when nBackfill equals mxFrame (meaning that everything
** in the WAL has been backfilled into the database) then new readers
** will choose aReadMark[0] which has value 0 and hence such reader will
** get all their all content directly from the database file and ignore 
** the WAL.
**
** Writers normally append new frames to the end of the WAL.  However,
** if nBackfill equals mxFrame (meaning that all WAL content has been
** written back into the database) and if no readers are using the WAL
** (in other words, if there are no WAL_READ_LOCK(i) where i&gt;0) then
** the writer will first "reset" the WAL back to the beginning and start
** writing new content beginning at frame 1.
**
** We assume that 32-bit loads are atomic and so no locks are needed in
** order to read from any aReadMark[] entries.
*/</comment>
<struct>struct <name>WalCkptInfo</name> <block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>nBackfill</name></decl>;</decl_stmt>                  <comment type="block">/* Number of WAL frames backfilled into DB */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aReadMark</name><index>[<expr><name>WAL_NREADER</name></expr>]</index></name></decl>;</decl_stmt>     <comment type="block">/* Reader marks */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>aLock</name><index>[<expr><name>SQLITE_SHM_NLOCK</name></expr>]</index></name></decl>;</decl_stmt>     <comment type="block">/* Reserved space for locks */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nBackfillAttempted</name></decl>;</decl_stmt>         <comment type="block">/* WAL frames perhaps written, or maybe not */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>notUsed0</name></decl>;</decl_stmt>                   <comment type="block">/* Available for future enhancements */</comment>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READMARK_NOT_USED</name></cpp:macro>  <cpp:value>0xffffffff</cpp:value></cpp:define>

<comment type="block">/*
** This is a schematic view of the complete 136-byte header of the
** wal-index file (also known as the -shm file):
**
**      +-----------------------------+
**   0: | iVersion                    | \
**      +-----------------------------+  |
**   4: | (unused padding)            |  |
**      +-----------------------------+  |
**   8: | iChange                     |  |
**      +-------+-------+-------------+  |
**  12: | bInit |  bBig |   szPage    |  |
**      +-------+-------+-------------+  |
**  16: | mxFrame                     |  |  First copy of the
**      +-----------------------------+  |  WalIndexHdr object
**  20: | nPage                       |  |
**      +-----------------------------+  |
**  24: | aFrameCksum                 |  |
**      |                             |  |
**      +-----------------------------+  |
**  32: | aSalt                       |  |
**      |                             |  |
**      +-----------------------------+  |
**  40: | aCksum                      |  |
**      |                             | /
**      +-----------------------------+
**  48: | iVersion                    | \
**      +-----------------------------+  |
**  52: | (unused padding)            |  |
**      +-----------------------------+  |
**  56: | iChange                     |  |
**      +-------+-------+-------------+  |
**  60: | bInit |  bBig |   szPage    |  |
**      +-------+-------+-------------+  |  Second copy of the
**  64: | mxFrame                     |  |  WalIndexHdr
**      +-----------------------------+  |
**  68: | nPage                       |  |
**      +-----------------------------+  |
**  72: | aFrameCksum                 |  |
**      |                             |  |
**      +-----------------------------+  |
**  80: | aSalt                       |  |
**      |                             |  |
**      +-----------------------------+  |
**  88: | aCksum                      |  |
**      |                             | /
**      +-----------------------------+
**  96: | nBackfill                   |
**      +-----------------------------+
** 100: | 5 read marks                |
**      |                             |
**      |                             |
**      |                             |
**      |                             |
**      +-------+-------+------+------+
** 120: | Write | Ckpt  | Rcvr | Rd0  | \
**      +-------+-------+------+------+  ) 8 lock bytes
**      | Read1 | Read2 | Rd3  | Rd4  | /
**      +-------+-------+------+------+
** 128: | nBackfillAttempted          |
**      +-----------------------------+
** 132: | (unused padding)            |
**      +-----------------------------+
*/</comment>

<comment type="block">/* A block of WALINDEX_LOCK_RESERVED bytes beginning at
** WALINDEX_LOCK_OFFSET is reserved for locks. Since some systems
** only support mandatory file-locks, we do not read or write data
** from the region of the file on which locks are applied.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WALINDEX_LOCK_OFFSET</name></cpp:macro> <cpp:value>(sizeof(WalIndexHdr)*2+offsetof(WalCkptInfo,aLock))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WALINDEX_HDR_SIZE</name></cpp:macro>    <cpp:value>(sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))</cpp:value></cpp:define>

<comment type="block">/* Size of header before each frame in wal */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_FRAME_HDRSIZE</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define>

<comment type="block">/* Size of write ahead log header, including checksum. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_HDRSIZE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<comment type="block">/* WAL magic value. Either this value, or the same value with the least
** significant bit also set (WAL_MAGIC | 0x00000001) is stored in 32-bit
** big-endian format in the first 4 bytes of a WAL file.
**
** If the LSB is set, then the checksums for each frame within the WAL
** file are calculated by treating all data as an array of 32-bit 
** big-endian words. Otherwise, they are calculated by interpreting 
** all data as 32-bit little-endian words.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_MAGIC</name></cpp:macro> <cpp:value>0x377f0682</cpp:value></cpp:define>

<comment type="block">/*
** Return the offset of frame iFrame in the write-ahead log file, 
** assuming a database page size of szPage bytes. The offset returned
** is to the start of the write-ahead log frame-header.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>walFrameOffset</name><parameter_list>(<parameter><type><name>iFrame</name></type></parameter>, <parameter><type><name>szPage</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(                               \
  WAL_HDRSIZE + ((iFrame)-1)*(i64)((szPage)+WAL_FRAME_HDRSIZE)         \
)</cpp:value></cpp:define>

<comment type="block">/*
** An open write-ahead log file is represented by an instance of the
** following object.
*/</comment>
<struct>struct <name>Wal</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl>;</decl_stmt>         <comment type="block">/* The VFS used to create pDbFd */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pDbFd</name></decl>;</decl_stmt>       <comment type="block">/* File handle for the database file */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pWalFd</name></decl>;</decl_stmt>      <comment type="block">/* File handle for WAL file */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iCallback</name></decl>;</decl_stmt>             <comment type="block">/* Value to pass to log callback (or 0) */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>mxWalSize</name></decl>;</decl_stmt>             <comment type="block">/* Truncate WAL to this size upon reset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nWiData</name></decl>;</decl_stmt>               <comment type="block">/* Size of array apWiData */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szFirstBlock</name></decl>;</decl_stmt>          <comment type="block">/* Size of first block written to WAL file */</comment>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>u32</name> <modifier>*</modifier><modifier>*</modifier></type><name>apWiData</name></decl>;</decl_stmt>   <comment type="block">/* Pointer to wal-index content in memory */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>szPage</name></decl>;</decl_stmt>                <comment type="block">/* Database page size */</comment>
  <decl_stmt><decl><type><name>i16</name></type> <name>readLock</name></decl>;</decl_stmt>              <comment type="block">/* Which read lock is being held.  -1 for none */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>syncFlags</name></decl>;</decl_stmt>              <comment type="block">/* Flags to use to sync header writes */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>exclusiveMode</name></decl>;</decl_stmt>          <comment type="block">/* Non-zero if connection is in exclusive mode */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>writeLock</name></decl>;</decl_stmt>              <comment type="block">/* True if in a write transaction */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>ckptLock</name></decl>;</decl_stmt>               <comment type="block">/* True if holding a checkpoint lock */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>readOnly</name></decl>;</decl_stmt>               <comment type="block">/* WAL_RDWR, WAL_RDONLY, or WAL_SHM_RDONLY */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>truncateOnCommit</name></decl>;</decl_stmt>       <comment type="block">/* True to truncate WAL file on commit */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>syncHeader</name></decl>;</decl_stmt>             <comment type="block">/* Fsync the WAL header if true */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>padToSectorBoundary</name></decl>;</decl_stmt>    <comment type="block">/* Pad transactions out to the next sector */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bShmUnreliable</name></decl>;</decl_stmt>         <comment type="block">/* SHM content is read-only and unreliable */</comment>
  <decl_stmt><decl><type><name>WalIndexHdr</name></type> <name>hdr</name></decl>;</decl_stmt>           <comment type="block">/* Wal-index header for current transaction */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>minFrame</name></decl>;</decl_stmt>              <comment type="block">/* Ignore wal frames before this one */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iReCksum</name></decl>;</decl_stmt>              <comment type="block">/* On commit, recalculate checksums from here */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWalName</name></decl>;</decl_stmt>      <comment type="block">/* Name of WAL file */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nCkpt</name></decl>;</decl_stmt>                 <comment type="block">/* Checkpoint sequence counter in the wal-header */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>u8</name></type> <name>lockError</name></decl>;</decl_stmt>              <comment type="block">/* True if a locking error has occurred */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SNAPSHOT</name></cpp:ifdef>
  <decl_stmt><decl><type><name>WalIndexHdr</name> <modifier>*</modifier></type><name>pSnapshot</name></decl>;</decl_stmt>    <comment type="block">/* Start transaction here if not NULL */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SETLK_TIMEOUT</name></cpp:ifdef>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<comment type="block">/*
** Candidate values for Wal.exclusiveMode.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_NORMAL_MODE</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_EXCLUSIVE_MODE</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>     
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_HEAPMEMORY_MODE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/*
** Possible values for WAL.readOnly
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_RDWR</name></cpp:macro>        <cpp:value>0</cpp:value></cpp:define>    <comment type="block">/* Normal read/write connection */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_RDONLY</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>    <comment type="block">/* The WAL file is readonly */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_SHM_RDONLY</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>    <comment type="block">/* The SHM file is readonly */</comment>

<comment type="block">/*
** Each page of the wal-index mapping contains a hash-table made up of
** an array of HASHTABLE_NSLOT elements of the following type.
*/</comment>
<typedef>typedef <type><name>u16</name></type> <name>ht_slot</name>;</typedef>

<comment type="block">/*
** This structure is used to implement an iterator that loops through
** all frames in the WAL in database page order. Where two or more frames
** correspond to the same database page, the iterator visits only the 
** frame most recently written to the WAL (in other words, the frame with
** the largest index).
**
** The internals of this structure are only accessed by:
**
**   walIteratorInit() - Create a new iterator,
**   walIteratorNext() - Step an iterator,
**   walIteratorFree() - Free an iterator.
**
** This functionality is used by the checkpoint code (see walCheckpoint()).
*/</comment>
<struct>struct <name>WalIterator</name> <block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>iPrior</name></decl>;</decl_stmt>                     <comment type="block">/* Last result returned from the iterator */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSegment</name></decl>;</decl_stmt>                   <comment type="block">/* Number of entries in aSegment[] */</comment>
  <struct>struct <name>WalSegment</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>iNext</name></decl>;</decl_stmt>                    <comment type="block">/* Next slot in aIndex[] not yet returned */</comment>
    <decl_stmt><decl><type><name>ht_slot</name> <modifier>*</modifier></type><name>aIndex</name></decl>;</decl_stmt>              <comment type="block">/* i0, i1, i2... such that aPgno[iN] ascend */</comment>
    <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aPgno</name></decl>;</decl_stmt>                   <comment type="block">/* Array of page numbers. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name></decl>;</decl_stmt>                   <comment type="block">/* Nr. of entries in aPgno[] and aIndex[] */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iZero</name></decl>;</decl_stmt>                    <comment type="block">/* Frame number associated with aPgno[0] */</comment>
  }</block> <decl><name><name>aSegment</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</struct>                  <comment type="block">/* One for every 32KB page in the wal-index */</comment>
}</block>;</struct>

<comment type="block">/*
** Define the parameters of the hash tables in the wal-index file. There
** is a hash-table following every HASHTABLE_NPAGE page numbers in the
** wal-index.
**
** Changing any of these constants will alter the wal-index format and
** create incompatibilities.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHTABLE_NPAGE</name></cpp:macro>      <cpp:value>4096</cpp:value></cpp:define>                 <comment type="block">/* Must be power of 2 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHTABLE_HASH_1</name></cpp:macro>     <cpp:value>383</cpp:value></cpp:define>                  <comment type="block">/* Should be prime */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHTABLE_NSLOT</name></cpp:macro>      <cpp:value>(HASHTABLE_NPAGE*2)</cpp:value></cpp:define>  <comment type="block">/* Must be a power of 2 */</comment>

<comment type="block">/* 
** The block of page numbers associated with the first hash-table in a
** wal-index is smaller than usual. This is so that there is a complete
** hash-table on each aligned 32KB page of the wal-index.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHTABLE_NPAGE_ONE</name></cpp:macro>  <cpp:value>(HASHTABLE_NPAGE - (WALINDEX_HDR_SIZE/sizeof(u32)))</cpp:value></cpp:define>

<comment type="block">/* The wal-index is divided into pages of WALINDEX_PGSZ bytes each. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WALINDEX_PGSZ</name></cpp:macro>   <cpp:value>(                                         \
    sizeof(ht_slot)*HASHTABLE_NSLOT + HASHTABLE_NPAGE*sizeof(u32) \
)</cpp:value></cpp:define>

<comment type="block">/*
** Obtain a pointer to the iPage'th page of the wal-index. The wal-index
** is broken into pages of WALINDEX_PGSZ bytes. Wal-index pages are
** numbered from zero.
**
** If the wal-index is currently smaller the iPage pages then the size
** of the wal-index might be increased, but only if it is safe to do
** so.  It is safe to enlarge the wal-index if pWal-&gt;writeLock is true
** or pWal-&gt;exclusiveMode==WAL_HEAPMEMORY_MODE.
**
** Three possible result scenarios:
**
**   (1)  rc==SQLITE_OK    and *ppPage==Requested-Wal-Index-Page
**   (2)  rc&gt;=SQLITE_ERROR and *ppPage==NULL
**   (3)  rc==SQLITE_OK    and *ppPage==NULL  // only if iPage==0 
**
** Scenario (3) can only occur when pWal-&gt;writeLock is false and iPage==0
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>walIndexPageRealloc</name><parameter_list>(
  <parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>,               <comment type="block">/* The WAL context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iPage</name></decl></parameter>,               <comment type="block">/* The page we seek */</comment>
  <parameter><decl><type><specifier>volatile</specifier> <name>u32</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>    <comment type="block">/* Write the page pointer here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Enlarge the pWal-&gt;apWiData[] array if required */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>nWiData</name></name><operator>&lt;=</operator><name>iPage</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>iPage</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>u32</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator><specifier>volatile</specifier> <name>u32</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3Realloc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>apNew</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>apNew</name><index>[<expr><name><name>pWal</name><operator>-&gt;</operator><name>nWiData</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>iPage</name><operator>+</operator><literal type="number">1</literal><operator>-</operator><name><name>pWal</name><operator>-&gt;</operator><name>nWiData</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>nWiData</name></name> <operator>=</operator> <name>iPage</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Request a pointer to the required page from the VFS */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>iPage</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name><operator>==</operator><name>WAL_HEAPMEMORY_MODE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>iPage</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u32</name> <specifier>volatile</specifier> <operator>*</operator><operator>)</operator><call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><name>WALINDEX_PGSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>iPage</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsShmMap</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><name>WALINDEX_PGSZ</name></expr></argument>, 
        <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <specifier>volatile</specifier> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>iPage</name></expr>]</index></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>iPage</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal>
         <operator>||</operator> <name>rc</name><operator>!=</operator><name>SQLITE_OK</name>
         <operator>||</operator> <operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iPage</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>iPage</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iPage</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3FaultSim</name><argument_list>(<argument><expr><literal type="number">600</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_READONLY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>|=</operator> <name>WAL_SHM_RDONLY</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_READONLY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPage</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>ppPage</name> <operator>||</operator> <name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walIndexPage</name><parameter_list>(
  <parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>,               <comment type="block">/* The WAL context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iPage</name></decl></parameter>,               <comment type="block">/* The page we seek */</comment>
  <parameter><decl><type><specifier>volatile</specifier> <name>u32</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>    <comment type="block">/* Write the page pointer here */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>nWiData</name></name><operator>&lt;=</operator><name>iPage</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>ppPage</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>iPage</name></expr>]</index></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>walIndexPageRealloc</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><name>ppPage</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the WalCkptInfo structure in the wal-index.
*/</comment>
<function><type><specifier>static</specifier> <specifier>volatile</specifier> <name>WalCkptInfo</name> <modifier>*</modifier></type><name>walCkptInfo</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>nWiData</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><specifier>volatile</specifier> <name>WalCkptInfo</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof><operator>/</operator><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the WalIndexHdr structure in the wal-index.
*/</comment>
<function><type><specifier>static</specifier> <specifier>volatile</specifier> <name>WalIndexHdr</name> <modifier>*</modifier></type><name>walIndexHdr</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>nWiData</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><specifier>volatile</specifier> <name>WalIndexHdr</name><operator>*</operator><operator>)</operator><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The argument to this macro must be of type u32. On a little-endian
** architecture, it returns the u32 value that results from interpreting
** the 4 bytes as a big-endian value. On a big-endian architecture, it
** returns the value that would be produced by interpreting the 4 bytes
** of the input value as a little-endian integer.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTESWAP32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( \
    (((x)&amp;0x000000FF)&lt;&lt;24) + (((x)&amp;0x0000FF00)&lt;&lt;8)  \
  + (((x)&amp;0x00FF0000)&gt;&gt;8)  + (((x)&amp;0xFF000000)&gt;&gt;24) \
)</cpp:value></cpp:define>

<comment type="block">/*
** Generate or extend an 8 byte checksum based on the data in 
** array aByte[] and the initial values of aIn[0] and aIn[1] (or
** initial values of 0 and 0 if aIn==NULL).
**
** The checksum is written back into aOut[] before returning.
**
** nByte must be a positive multiple of 8.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>walChecksumBytes</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nativeCksum</name></decl></parameter>, <comment type="block">/* True for native byte-order, false for non-native */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,           <comment type="block">/* Content to be checksummed */</comment>
  <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>,       <comment type="block">/* Bytes of content in a[].  Must be a multiple of 8. */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>u32</name> <modifier>*</modifier></type><name>aIn</name></decl></parameter>,  <comment type="block">/* Initial checksum value input */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>aOut</name></decl></parameter>        <comment type="block">/* OUT: Final checksum value output */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>s1</name></decl>, <decl><type ref="prev"/><name>s2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aData</name> <init>= <expr><operator>(</operator><name>u32</name> <operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aEnd</name> <init>= <expr><operator>(</operator><name>u32</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>a</name><index>[<expr><name>nByte</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>aIn</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>s1</name> <operator>=</operator> <name><name>aIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s2</name> <operator>=</operator> <name><name>aIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>s1</name> <operator>=</operator> <name>s2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;=</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>nByte</name><operator>&amp;</operator><literal type="number">0x00000007</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&lt;=</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nativeCksum</name></expr> )</condition><block>{<block_content>
    <do>do <block>{<block_content>
      <expr_stmt><expr><name>s1</name> <operator>+=</operator> <operator>*</operator><name>aData</name><operator>++</operator> <operator>+</operator> <name>s2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>s2</name> <operator>+=</operator> <operator>*</operator><name>aData</name><operator>++</operator> <operator>+</operator> <name>s1</name></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>aData</name><operator>&lt;</operator><name>aEnd</name></expr> )</condition>;</do>
  </block_content>}</block></if><else>else<block>{<block_content>
    <do>do <block>{<block_content>
      <expr_stmt><expr><name>s1</name> <operator>+=</operator> <call><name>BYTESWAP32</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>s2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>s2</name> <operator>+=</operator> <call><name>BYTESWAP32</name><argument_list>(<argument><expr><name><name>aData</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>s1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>aData</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>aData</name><operator>&lt;</operator><name>aEnd</name></expr> )</condition>;</do>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>s1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aOut</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>s2</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If there is the possibility of concurrent access to the SHM file
** from multiple threads and/or processes, then do a memory barrier.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>walShmBarrier</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name><operator>!=</operator><name>WAL_HEAPMEMORY_MODE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OsShmBarrier</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add the SQLITE_NO_TSAN as part of the return-type of a function
** definition as a hint that the function contains constructs that
** might give false-positive TSAN warnings.
**
** See tag-20200519-1.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_NO_TSAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_NO_TSAN</name></cpp:macro> <cpp:value>__attribute__((no_sanitize_thread))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_NO_TSAN</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Write the header information in pWal-&gt;hdr into the wal-index.
**
** The checksum on pWal-&gt;hdr is updated before it is written.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NO_TSAN</name> <name>void</name></type> <name>walIndexWriteHdr</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>WalIndexHdr</name> <modifier>*</modifier></type><name>aHdr</name> <init>= <expr><call><name>walIndexHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nCksum</name> <init>= <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>, <argument><expr><name>aCksum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>iVersion</name></name> <operator>=</operator> <name>WALINDEX_MAX_VERSION</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>walChecksumBytes</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><name>nCksum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aCksum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Possible TSAN false-positive.  See tag-20200519-1 */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aHdr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>walShmBarrier</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aHdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function encodes a single frame header and writes it to a buffer
** supplied by the caller. A frame-header is made up of a series of 
** 4-byte big-endian integers, as follows:
**
**     0: Page number.
**     4: For commit records, the size of the database image in pages 
**        after the commit. For all other records, zero.
**     8: Salt-1 (copied from the wal-header)
**    12: Salt-2 (copied from the wal-header)
**    16: Checksum-1.
**    20: Checksum-2.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>walEncodeFrame</name><parameter_list>(
  <parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>,                      <comment type="block">/* The write-ahead log */</comment>
  <parameter><decl><type><name>u32</name></type> <name>iPage</name></decl></parameter>,                      <comment type="block">/* Database page number for frame */</comment>
  <parameter><decl><type><name>u32</name></type> <name>nTruncate</name></decl></parameter>,                  <comment type="block">/* New db size (or 0 for non-commit frames) */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>,                      <comment type="block">/* Pointer to page data */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aFrame</name></decl></parameter>                      <comment type="block">/* OUT: Write encoded frame here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nativeCksum</name></decl>;</decl_stmt>                <comment type="block">/* True for native byte-order checksums */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aCksum</name> <init>= <expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WAL_FRAME_HDRSIZE</name><operator>==</operator><literal type="number">24</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aFrame</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aFrame</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nTruncate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>iReCksum</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aFrame</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aSalt</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nativeCksum</name> <operator>=</operator> <operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>bigEndCksum</name></name><operator>==</operator><name>SQLITE_BIGENDIAN</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>walChecksumBytes</name><argument_list>(<argument><expr><name>nativeCksum</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>aCksum</name></expr></argument>, <argument><expr><name>aCksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>walChecksumBytes</name><argument_list>(<argument><expr><name>nativeCksum</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name></expr></argument>, <argument><expr><name>aCksum</name></expr></argument>, <argument><expr><name>aCksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3Put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aFrame</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>aCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aFrame</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>aCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aFrame</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if the frame with header in aFrame[] and content
** in aData[] is valid.  If it is a valid frame, fill *piPage and
** *pnTruncate and return true.  Return if the frame is not valid.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walDecodeFrame</name><parameter_list>(
  <parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>,                      <comment type="block">/* The write-ahead log */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>piPage</name></decl></parameter>,                    <comment type="block">/* OUT: Database page number for frame */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pnTruncate</name></decl></parameter>,                <comment type="block">/* OUT: New db size (or 0 if not commit) */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>,                      <comment type="block">/* Pointer to page data (for checksum) */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aFrame</name></decl></parameter>                      <comment type="block">/* Frame data */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nativeCksum</name></decl>;</decl_stmt>                <comment type="block">/* True for native byte-order checksums */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aCksum</name> <init>= <expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>pgno</name></decl>;</decl_stmt>                       <comment type="block">/* Page number of the frame */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WAL_FRAME_HDRSIZE</name><operator>==</operator><literal type="number">24</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* A frame is only valid if the salt values in the frame-header
  ** match the salt values in the wal-header. 
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aSalt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aFrame</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* A frame is only valid if the page number is creater than zero.
  */</comment>
  <expr_stmt><expr><name>pgno</name> <operator>=</operator> <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aFrame</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* A frame is only valid if a checksum of the WAL header,
  ** all prior frams, the first 16 bytes of this frame-header, 
  ** and the frame-data matches the checksum in the last 8 
  ** bytes of this frame-header.
  */</comment>
  <expr_stmt><expr><name>nativeCksum</name> <operator>=</operator> <operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>bigEndCksum</name></name><operator>==</operator><name>SQLITE_BIGENDIAN</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>walChecksumBytes</name><argument_list>(<argument><expr><name>nativeCksum</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>aCksum</name></expr></argument>, <argument><expr><name>aCksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>walChecksumBytes</name><argument_list>(<argument><expr><name>nativeCksum</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name></expr></argument>, <argument><expr><name>aCksum</name></expr></argument>, <argument><expr><name>aCksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>aCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aFrame</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call> 
   <operator>||</operator> <name><name>aCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aFrame</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> 
  )</condition><block>{<block_content>
    <comment type="block">/* Checksum failed. */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we reach this point, the frame is valid.  Return the page number
  ** and the new database size.
  */</comment>
  <expr_stmt><expr><operator>*</operator><name>piPage</name> <operator>=</operator> <name>pgno</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnTruncate</name> <operator>=</operator> <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aFrame</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Names of locks.  This routine is used to provide debugging output and is not
** a part of an ordinary build.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>walLockName</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lockIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>lockIdx</name><operator>==</operator><name>WAL_WRITE_LOCK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="string">"WRITE-LOCK"</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>lockIdx</name><operator>==</operator><name>WAL_CKPT_LOCK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="string">"CKPT-LOCK"</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>lockIdx</name><operator>==</operator><name>WAL_RECOVER_LOCK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="string">"RECOVER-LOCK"</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>zName</name><index>[<expr><literal type="number">15</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"READ-LOCK[%d]"</literal></expr></argument>,
                     <argument><expr><name>lockIdx</name><operator>-</operator><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>zName</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*defined(SQLITE_TEST) || defined(SQLITE_DEBUG) */</comment>
    

<comment type="block">/*
** Set or release locks on the WAL.  Locks are either shared or exclusive.
** A lock cannot be moved directly between shared and exclusive - it must go
** through the unlocked state first.
**
** In locking_mode=EXCLUSIVE, all of these routines become no-ops.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walLockShared</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lockIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsShmLock</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>lockIdx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                        <argument><expr><name>SQLITE_SHM_LOCK</name> <operator>|</operator> <name>SQLITE_SHM_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WALTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WAL%p: acquire SHARED-%s %s\n"</literal><operator>,</operator> <name>pWal</name><operator>,</operator>
            <call><name>walLockName</name><argument_list>(<argument><expr><name>lockIdx</name></expr></argument>)</argument_list></call><operator>,</operator> <ternary><condition><expr><name>rc</name></expr> ?</condition><then> <expr><literal type="string">"failed"</literal></expr> </then><else>: <expr><literal type="string">"ok"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>VVA_ONLY</name><argument_list>( <argument>pWal-&gt;lockError = (u8)(rc!=SQLITE_OK &amp;&amp; (rc&amp;<literal type="number">0xFF</literal>)!=SQLITE_BUSY);</argument> )</argument_list></macro>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>walUnlockShared</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lockIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>sqlite3OsShmLock</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>lockIdx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                         <argument><expr><name>SQLITE_SHM_UNLOCK</name> <operator>|</operator> <name>SQLITE_SHM_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WALTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WAL%p: release SHARED-%s\n"</literal><operator>,</operator> <name>pWal</name><operator>,</operator> <call><name>walLockName</name><argument_list>(<argument><expr><name>lockIdx</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walLockExclusive</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lockIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsShmLock</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>lockIdx</name></expr></argument>, <argument><expr><name>n</name></expr></argument>,
                        <argument><expr><name>SQLITE_SHM_LOCK</name> <operator>|</operator> <name>SQLITE_SHM_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WALTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WAL%p: acquire EXCLUSIVE-%s cnt=%d %s\n"</literal><operator>,</operator> <name>pWal</name><operator>,</operator>
            <call><name>walLockName</name><argument_list>(<argument><expr><name>lockIdx</name></expr></argument>)</argument_list></call><operator>,</operator> <name>n</name><operator>,</operator> <ternary><condition><expr><name>rc</name></expr> ?</condition><then> <expr><literal type="string">"failed"</literal></expr> </then><else>: <expr><literal type="string">"ok"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>VVA_ONLY</name><argument_list>( <argument>pWal-&gt;lockError = (u8)(rc!=SQLITE_OK &amp;&amp; (rc&amp;<literal type="number">0xFF</literal>)!=SQLITE_BUSY);</argument> )</argument_list></macro>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>walUnlockExclusive</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lockIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>sqlite3OsShmLock</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>lockIdx</name></expr></argument>, <argument><expr><name>n</name></expr></argument>,
                         <argument><expr><name>SQLITE_SHM_UNLOCK</name> <operator>|</operator> <name>SQLITE_SHM_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WALTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WAL%p: release EXCLUSIVE-%s cnt=%d\n"</literal><operator>,</operator> <name>pWal</name><operator>,</operator>
             <call><name>walLockName</name><argument_list>(<argument><expr><name>lockIdx</name></expr></argument>)</argument_list></call><operator>,</operator> <name>n</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compute a hash on a page number.  The resulting hash value must land
** between 0 and (HASHTABLE_NSLOT-1).  The walHashNext() function advances
** the hash to the next value in the event of a collision.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walHash</name><parameter_list>(<parameter><decl><type><name>u32</name></type> <name>iPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPage</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>HASHTABLE_NSLOT</name> <operator>&amp;</operator> <operator>(</operator><name>HASHTABLE_NSLOT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>iPage</name><operator>*</operator><name>HASHTABLE_HASH_1</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>HASHTABLE_NSLOT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walNextHash</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iPriorHash</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>iPriorHash</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>HASHTABLE_NSLOT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** An instance of the WalHashLoc object is used to describe the location
** of a page hash table in the wal-index.  This becomes the return value
** from walHashGet().
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>WalHashLoc</name></name></type> <name>WalHashLoc</name>;</typedef>
<struct>struct <name>WalHashLoc</name> <block>{
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>ht_slot</name> <modifier>*</modifier></type><name>aHash</name></decl>;</decl_stmt>  <comment type="block">/* Start of the wal-index hash table */</comment>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>u32</name> <modifier>*</modifier></type><name>aPgno</name></decl>;</decl_stmt>      <comment type="block">/* aPgno[1] is the page of first frame indexed */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iZero</name></decl>;</decl_stmt>                <comment type="block">/* One less than the frame number of first indexed*/</comment>
}</block>;</struct>

<comment type="block">/* 
** Return pointers to the hash table and page number array stored on
** page iHash of the wal-index. The wal-index is broken into 32KB pages
** numbered starting from 0.
**
** Set output variable pLoc-&gt;aHash to point to the start of the hash table
** in the wal-index file. Set pLoc-&gt;iZero to one less than the frame 
** number of the first frame indexed by this hash table. If a
** slot in the hash table is set to N, it refers to frame number 
** (pLoc-&gt;iZero+N) in the log.
**
** Finally, set pLoc-&gt;aPgno so that pLoc-&gt;aPgno[0] is the page number of the
** first frame indexed by the hash table, frame (pLoc-&gt;iZero).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walHashGet</name><parameter_list>(
  <parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>,                      <comment type="block">/* WAL handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>iHash</name></decl></parameter>,                      <comment type="block">/* Find the iHash'th table */</comment>
  <parameter><decl><type><name>WalHashLoc</name> <modifier>*</modifier></type><name>pLoc</name></decl></parameter>                <comment type="block">/* OUT: Hash table location */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walIndexPage</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pLoc</name><operator>-&gt;</operator><name>aPgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>iHash</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pLoc</name><operator>-&gt;</operator><name>aPgno</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pLoc</name><operator>-&gt;</operator><name>aHash</name></name> <operator>=</operator> <operator>(</operator><specifier>volatile</specifier> <name>ht_slot</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pLoc</name><operator>-&gt;</operator><name>aPgno</name><index>[<expr><name>HASHTABLE_NPAGE</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iHash</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLoc</name><operator>-&gt;</operator><name>aPgno</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pLoc</name><operator>-&gt;</operator><name>aPgno</name><index>[<expr><name>WALINDEX_HDR_SIZE</name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLoc</name><operator>-&gt;</operator><name>iZero</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pLoc</name><operator>-&gt;</operator><name>iZero</name></name> <operator>=</operator> <name>HASHTABLE_NPAGE_ONE</name> <operator>+</operator> <operator>(</operator><name>iHash</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>HASHTABLE_NPAGE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of the wal-index page that contains the hash-table
** and page-number array that contain entries corresponding to WAL frame
** iFrame. The wal-index is broken up into 32KB pages. Wal-index pages 
** are numbered starting from 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walFramePage</name><parameter_list>(<parameter><decl><type><name>u32</name></type> <name>iFrame</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iHash</name> <init>= <expr><operator>(</operator><name>iFrame</name><operator>+</operator><name>HASHTABLE_NPAGE</name><operator>-</operator><name>HASHTABLE_NPAGE_ONE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>HASHTABLE_NPAGE</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>iHash</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iFrame</name><operator>&gt;</operator><name>HASHTABLE_NPAGE_ONE</name><operator>)</operator>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>iHash</name><operator>&gt;=</operator><literal type="number">1</literal> <operator>||</operator> <name>iFrame</name><operator>&lt;=</operator><name>HASHTABLE_NPAGE_ONE</name><operator>)</operator>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>iHash</name><operator>&lt;=</operator><literal type="number">1</literal> <operator>||</operator> <name>iFrame</name><operator>&gt;</operator><operator>(</operator><name>HASHTABLE_NPAGE_ONE</name><operator>+</operator><name>HASHTABLE_NPAGE</name><operator>)</operator><operator>)</operator>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>iHash</name><operator>&gt;=</operator><literal type="number">2</literal> <operator>||</operator> <name>iFrame</name><operator>&lt;=</operator><name>HASHTABLE_NPAGE_ONE</name><operator>+</operator><name>HASHTABLE_NPAGE</name><operator>)</operator>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>iHash</name><operator>&lt;=</operator><literal type="number">2</literal> <operator>||</operator> <name>iFrame</name><operator>&gt;</operator><operator>(</operator><name>HASHTABLE_NPAGE_ONE</name><operator>+</operator><literal type="number">2</literal><operator>*</operator><name>HASHTABLE_NPAGE</name><operator>)</operator><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iHash</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>iHash</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the page number associated with frame iFrame in this WAL.
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>walFramePgno</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iFrame</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iHash</name> <init>= <expr><call><name>walFramePage</name><argument_list>(<argument><expr><name>iFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iHash</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>WALINDEX_HDR_SIZE</name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>iFrame</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>iHash</name></expr>]</index><index>[<expr><operator>(</operator><name>iFrame</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>HASHTABLE_NPAGE_ONE</name><operator>)</operator><operator>%</operator><name>HASHTABLE_NPAGE</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Remove entries from the hash table that point to WAL slots greater
** than pWal-&gt;hdr.mxFrame.
**
** This function is called whenever pWal-&gt;hdr.mxFrame is decreased due
** to a rollback or savepoint.
**
** At most only the hash table containing pWal-&gt;hdr.mxFrame needs to be
** updated.  Any later hash tables will be automatically cleared when
** pWal-&gt;hdr.mxFrame advances to the point where those hash tables are
** actually needed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>walCleanupHash</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WalHashLoc</name></type> <name>sLoc</name></decl>;</decl_stmt>                <comment type="block">/* Hash table location */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Zero values greater than this */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                      <comment type="block">/* Number of bytes to zero in aPgno[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Used to iterate through aHash[] */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name><operator>==</operator><name>HASHTABLE_NPAGE_ONE</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name><operator>==</operator><name>HASHTABLE_NPAGE_ONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name><operator>==</operator><name>HASHTABLE_NPAGE_ONE</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Obtain pointers to the hash-table and page-number array containing 
  ** the entry that corresponds to frame pWal-&gt;hdr.mxFrame. It is guaranteed
  ** that the page said hash-table and array reside on is already mapped.(1)
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>nWiData</name></name><operator>&gt;</operator><call><name>walFramePage</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><call><name>walFramePage</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>walHashGet</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>walFramePage</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* Defense-in-depth, in case (1) above is wrong */</comment>

  <comment type="block">/* Zero all hash-table entries that correspond to frame numbers greater
  ** than pWal-&gt;hdr.mxFrame.
  */</comment>
  <expr_stmt><expr><name>iLimit</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name> <operator>-</operator> <name><name>sLoc</name><operator>.</operator><name>iZero</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLimit</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>HASHTABLE_NSLOT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>sLoc</name><operator>.</operator><name>aHash</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;</operator><name>iLimit</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sLoc</name><operator>.</operator><name>aHash</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  
  <comment type="block">/* Zero the entries in the aPgno array that correspond to frames with
  ** frame numbers greater than pWal-&gt;hdr.mxFrame. 
  */</comment>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>sLoc</name><operator>.</operator><name>aHash</name></name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>sLoc</name><operator>.</operator><name>aPgno</name><index>[<expr><name>iLimit</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>sLoc</name><operator>.</operator><name>aPgno</name><index>[<expr><name>iLimit</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPENSIVE_ASSERT</name></cpp:ifdef>
  <comment type="block">/* Verify that the every entry in the mapping region is still reachable
  ** via the hash table even after the cleanup.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>iLimit</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>           <comment type="block">/* Loop counter */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iKey</name></decl>;</decl_stmt>        <comment type="block">/* Hash key */</comment>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>iLimit</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <for>for<control>(<init><expr><name>iKey</name><operator>=</operator><call><name>walHash</name><argument_list>(<argument><expr><name><name>sLoc</name><operator>.</operator><name>aPgno</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</init><condition><expr><name><name>sLoc</name><operator>.</operator><name>aHash</name><index>[<expr><name>iKey</name></expr>]</index></name></expr>;</condition><incr><expr><name>iKey</name><operator>=</operator><call><name>walNextHash</name><argument_list>(<argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>sLoc</name><operator>.</operator><name>aHash</name><index>[<expr><name>iKey</name></expr>]</index></name><operator>==</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>sLoc</name><operator>.</operator><name>aHash</name><index>[<expr><name>iKey</name></expr>]</index></name><operator>==</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_EXPENSIVE_ASSERT */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Set an entry in the wal-index that will map database page number
** pPage into WAL frame iFrame.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walIndexAppend</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iFrame</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>WalHashLoc</name></type> <name>sLoc</name></decl>;</decl_stmt>                <comment type="block">/* Wal-index hash table location */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walHashGet</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>walFramePage</name><argument_list>(<argument><expr><name>iFrame</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Assuming the wal-index file was successfully mapped, populate the
  ** page number array and hash table entry.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iKey</name></decl>;</decl_stmt>                     <comment type="block">/* Hash table key */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>                      <comment type="block">/* Value to write to hash-table slot */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nCollide</name></decl>;</decl_stmt>                 <comment type="block">/* Number of hash collisions */</comment>

    <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>iFrame</name> <operator>-</operator> <name><name>sLoc</name><operator>.</operator><name>iZero</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name> <operator>&lt;=</operator> <name>HASHTABLE_NSLOT</name><operator>/</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* If this is the first entry to be added to this hash-table, zero the
    ** entire hash table and aPgno[] array before proceeding. 
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>idx</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>sLoc</name><operator>.</operator><name>aHash</name><index>[<expr><name>HASHTABLE_NSLOT</name></expr>]</index></name> <operator>-</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>sLoc</name><operator>.</operator><name>aPgno</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>sLoc</name><operator>.</operator><name>aPgno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the entry in aPgno[] is already set, then the previous writer
    ** must have exited unexpectedly in the middle of a transaction (after
    ** writing one or more dirty pages to the WAL to free up memory). 
    ** Remove the remnants of that writers uncommitted transaction from 
    ** the hash-table before writing any new entries.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>sLoc</name><operator>.</operator><name>aPgno</name><index>[<expr><name>idx</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>walCleanupHash</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>sLoc</name><operator>.</operator><name>aPgno</name><index>[<expr><name>idx</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Write the aPgno[] array entry and the hash-table slot. */</comment>
    <expr_stmt><expr><name>nCollide</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>iKey</name><operator>=</operator><call><name>walHash</name><argument_list>(<argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name><name>sLoc</name><operator>.</operator><name>aHash</name><index>[<expr><name>iKey</name></expr>]</index></name></expr>;</condition> <incr><expr><name>iKey</name><operator>=</operator><call><name>walNextHash</name><argument_list>(<argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nCollide</name><operator>--</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>sLoc</name><operator>.</operator><name>aPgno</name><index>[<expr><name>idx</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>iPage</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AtomicStore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sLoc</name><operator>.</operator><name>aHash</name><index>[<expr><name>iKey</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>ht_slot</name><operator>)</operator><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPENSIVE_ASSERT</name></cpp:ifdef>
    <comment type="block">/* Verify that the number of entries in the hash table exactly equals
    ** the number of entries in the mapping region.
    */</comment>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>           <comment type="block">/* Loop counter */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Number of entries in the hash table */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>HASHTABLE_NSLOT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> <if_stmt><if>if<condition>( <expr><name><name>sLoc</name><operator>.</operator><name>aHash</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nEntry</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt> </block_content>}</block></for>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nEntry</name><operator>==</operator><name>idx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Verify that the every entry in the mapping region is reachable
    ** via the hash table.  This turns out to be a really, really expensive
    ** thing to check, so only do this occasionally - not on every
    ** iteration.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>idx</name><operator>&amp;</operator><literal type="number">0x3ff</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>           <comment type="block">/* Loop counter */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>idx</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <for>for<control>(<init><expr><name>iKey</name><operator>=</operator><call><name>walHash</name><argument_list>(<argument><expr><name><name>sLoc</name><operator>.</operator><name>aPgno</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</init>
            <condition><expr><name><name>sLoc</name><operator>.</operator><name>aHash</name><index>[<expr><name>iKey</name></expr>]</index></name></expr>;</condition>
            <incr><expr><name>iKey</name><operator>=</operator><call><name>walNextHash</name><argument_list>(<argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>sLoc</name><operator>.</operator><name>aHash</name><index>[<expr><name>iKey</name></expr>]</index></name><operator>==</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>sLoc</name><operator>.</operator><name>aHash</name><index>[<expr><name>iKey</name></expr>]</index></name><operator>==</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_EXPENSIVE_ASSERT */</comment>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Recover the wal-index by reading the write-ahead log file. 
**
** This routine first tries to establish an exclusive lock on the
** wal-index to prevent other threads/processes from doing anything
** with the WAL or wal-index while recovery is running.  The
** WAL_RECOVER_LOCK is also held so that other threads will know
** that this thread is running recovery.  If unable to establish
** the necessary locks, this routine returns SQLITE_BUSY.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walIndexRecover</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nSize</name></decl>;</decl_stmt>                      <comment type="block">/* Size of log file */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aFrameCksum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLock</name></decl>;</decl_stmt>                      <comment type="block">/* Lock offset to lock for checkpoint */</comment>

  <comment type="block">/* Obtain an exclusive lock on all byte in the locking range not already
  ** locked by the caller. The caller is guaranteed to have locked the
  ** WAL_WRITE_LOCK byte, and may have also locked the WAL_CKPT_LOCK byte.
  ** If successful, the same bytes that are locked here are unlocked before
  ** this function returns.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>ckptLock</name></name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name><name>pWal</name><operator>-&gt;</operator><name>ckptLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WAL_ALL_BUT_WRITE</name><operator>==</operator><name>WAL_WRITE_LOCK</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WAL_CKPT_LOCK</name><operator>==</operator><name>WAL_ALL_BUT_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iLock</name> <operator>=</operator> <name>WAL_ALL_BUT_WRITE</name> <operator>+</operator> <name><name>pWal</name><operator>-&gt;</operator><name>ckptLock</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iLock</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-</operator><name>iLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>WALTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WAL%p: recovery begin...\n"</literal><operator>,</operator> <name>pWal</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>recovery_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nSize</name><operator>&gt;</operator><name>WAL_HDRSIZE</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name><name>aBuf</name><index>[<expr><name>WAL_HDRSIZE</name></expr>]</index></name></decl>;</decl_stmt>         <comment type="block">/* Buffer to load WAL header into */</comment>
    <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aPrivate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Heap copy of *-shm hash being populated */</comment>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aFrame</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Malloc'd buffer to load entire frame */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>szFrame</name></decl>;</decl_stmt>                  <comment type="block">/* Number of bytes in buffer aFrame[] */</comment>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                    <comment type="block">/* Pointer to data part of aFrame buffer */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>szPage</name></decl>;</decl_stmt>                   <comment type="block">/* Page size according to the log */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>magic</name></decl>;</decl_stmt>                    <comment type="block">/* Magic value read from WAL header */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>version</name></decl>;</decl_stmt>                  <comment type="block">/* Magic value read from WAL header */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>isValid</name></decl>;</decl_stmt>                  <comment type="block">/* True if this frame is valid */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>iPg</name></decl>;</decl_stmt>                      <comment type="block">/* Current 32KB wal-index page */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>iLastFrame</name></decl>;</decl_stmt>               <comment type="block">/* Last frame in wal, based on nSize alone */</comment>

    <comment type="block">/* Read in the WAL header. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>WAL_HDRSIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>recovery_error</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the database page size is not a power of two, or is greater than
    ** SQLITE_MAX_PAGE_SIZE, conclude that the WAL file contains no valid 
    ** data. Similarly, if the 'magic' value is invalid, ignore the whole
    ** WAL file.
    */</comment>
    <expr_stmt><expr><name>magic</name> <operator>=</operator> <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>szPage</name> <operator>=</operator> <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>magic</name><operator>&amp;</operator><literal type="number">0xFFFFFFFE</literal><operator>)</operator><operator>!=</operator><name>WAL_MAGIC</name> 
     <operator>||</operator> <name>szPage</name><operator>&amp;</operator><operator>(</operator><name>szPage</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> 
     <operator>||</operator> <name>szPage</name><operator>&gt;</operator><name>SQLITE_MAX_PAGE_SIZE</name> 
     <operator>||</operator> <name>szPage</name><operator>&lt;</operator><literal type="number">512</literal></expr> 
    )</condition><block>{<block_content>
      <goto>goto <name>finished</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>bigEndCksum</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>magic</name><operator>&amp;</operator><literal type="number">0x00000001</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name> <operator>=</operator> <name>szPage</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>nCkpt</name></name> <operator>=</operator> <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aSalt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Verify that the WAL header checksum is correct */</comment>
    <expr_stmt><expr><call><name>walChecksumBytes</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>bigEndCksum</name></name><operator>==</operator><name>SQLITE_BIGENDIAN</name></expr></argument>, 
        <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>WAL_HDRSIZE</name><operator>-</operator><literal type="number">2</literal><operator>*</operator><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>)</argument_list></call>
     <operator>||</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <goto>goto <name>finished</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Verify that the version number on the WAL format is one that
    ** are able to understand */</comment>
    <expr_stmt><expr><name>version</name> <operator>=</operator> <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>version</name><operator>!=</operator><name>WAL_MAX_VERSION</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>finished</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Malloc a buffer to read frames into. */</comment>
    <expr_stmt><expr><name>szFrame</name> <operator>=</operator> <name>szPage</name> <operator>+</operator> <name>WAL_FRAME_HDRSIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aFrame</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>szFrame</name> <operator>+</operator> <name>WALINDEX_PGSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aFrame</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>recovery_error</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>aData</name> <operator>=</operator> <operator>&amp;</operator><name><name>aFrame</name><index>[<expr><name>WAL_FRAME_HDRSIZE</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aPrivate</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>szPage</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* Read all frames from the log file. */</comment>
    <expr_stmt><expr><name>iLastFrame</name> <operator>=</operator> <operator>(</operator><name>nSize</name> <operator>-</operator> <name>WAL_HDRSIZE</name><operator>)</operator> <operator>/</operator> <name>szFrame</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>iPg</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iPg</name><operator>&lt;=</operator><operator>(</operator><name>u32</name><operator>)</operator><call><name>walFramePage</name><argument_list>(<argument><expr><name>iLastFrame</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>iPg</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aShare</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>iFrame</name></decl>;</decl_stmt>                 <comment type="block">/* Index of last frame read */</comment>
      <decl_stmt><decl><type><name>u32</name></type> <name>iLast</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>iLastFrame</name></expr></argument>, <argument><expr><name>HASHTABLE_NPAGE_ONE</name><operator>+</operator><name>iPg</name><operator>*</operator><name>HASHTABLE_NPAGE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>iFirst</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>iPg</name><operator>==</operator><literal type="number">0</literal></expr>?</condition><then><expr><literal type="number">0</literal></expr></then><else>:<expr><name>HASHTABLE_NPAGE_ONE</name><operator>+</operator><operator>(</operator><name>iPg</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>HASHTABLE_NPAGE</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>nHdr</name></decl>, <decl><type ref="prev"/><name>nHdr32</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walIndexPage</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><operator>(</operator><specifier>volatile</specifier> <name>u32</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>aShare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aShare</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>aShare</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>iPg</name></expr>]</index></name> <operator>=</operator> <name>aPrivate</name></expr>;</expr_stmt>
      
      <for>for<control>(<init><expr><name>iFrame</name><operator>=</operator><name>iFirst</name></expr>;</init> <condition><expr><name>iFrame</name><operator>&lt;=</operator><name>iLast</name></expr>;</condition> <incr><expr><name>iFrame</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>i64</name></type> <name>iOffset</name> <init>= <expr><call><name>walFrameOffset</name><argument_list>(<argument><expr><name>iFrame</name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u32</name></type> <name>pgno</name></decl>;</decl_stmt>                 <comment type="block">/* Database page number for frame */</comment>
        <decl_stmt><decl><type><name>u32</name></type> <name>nTruncate</name></decl>;</decl_stmt>            <comment type="block">/* dbsize field from frame header */</comment>

        <comment type="block">/* Read and decode the next log frame. */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>szFrame</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>isValid</name> <operator>=</operator> <call><name>walDecodeFrame</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nTruncate</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isValid</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walIndexAppend</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iFrame</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* If nTruncate is non-zero, this is a commit record. */</comment>
        <if_stmt><if>if<condition>( <expr><name>nTruncate</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name> <operator>=</operator> <name>iFrame</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nPage</name></name> <operator>=</operator> <name>nTruncate</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>szPage</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><operator>(</operator><name>szPage</name><operator>&amp;</operator><literal type="number">0xff00</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>szPage</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>szPage</name><operator>&lt;=</operator><literal type="number">32768</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>szPage</name><operator>&gt;=</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aFrameCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aFrameCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>iPg</name></expr>]</index></name> <operator>=</operator> <name>aShare</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nHdr</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>iPg</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>WALINDEX_HDR_SIZE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>nHdr32</name> <operator>=</operator> <name>nHdr</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SAFER_WALINDEX_RECOVERY</name></cpp:ifndef>
      <comment type="block">/* Memcpy() should work fine here, on all reasonable implementations.
      ** Technically, memcpy() might change the destination to some
      ** intermediate value before setting to the final value, and that might
      ** cause a concurrent reader to malfunction.  Memcpy() is allowed to
      ** do that, according to the spec, but no memcpy() implementation that
      ** we know of actually does that, which is why we say that memcpy()
      ** is safe for this.  Memcpy() is certainly a lot faster.
      */</comment>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aShare</name><index>[<expr><name>nHdr32</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aPrivate</name><index>[<expr><name>nHdr32</name></expr>]</index></name></expr></argument>, <argument><expr><name>WALINDEX_PGSZ</name><operator>-</operator><name>nHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* In the event that some platform is found for which memcpy()
      ** changes the destination to some intermediate value before
      ** setting the final value, this alternative copy routine is
      ** provided.
      */</comment>
      <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nHdr32</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>WALINDEX_PGSZ</name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>aShare</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name><name>aPrivate</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
            <comment type="block">/* Atomic memory operations are not required here because if
            ** the value needs to be changed, that means it is not being
            ** accessed concurrently. */</comment>
            <expr_stmt><expr><name><name>aShare</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>aPrivate</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if<condition>( <expr><name>iFrame</name><operator>&lt;=</operator><name>iLast</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>finished</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>WalCkptInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>aFrameCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>aFrameCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>walIndexWriteHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset the checkpoint-header. This is safe because this thread is 
    ** currently holding locks that exclude all other writers and 
    ** checkpointers. Then set the values of read-mark slots 1 through N.
    */</comment>
    <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <call><name>walCkptInfo</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfill</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfillAttempted</name></name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aReadMark</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>WAL_NREADER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aReadMark</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aReadMark</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>READMARK_NOT_USED</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>walUnlockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>recovery_error</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If more than one frame was recovered from the log file, report an
    ** event via sqlite3_log(). This is to help with identifying performance
    ** problems caused by applications routinely shutting down without
    ** checkpointing the log file.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nPage</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_NOTICE_RECOVER_WAL</name></expr></argument>,
          <argument><expr><literal type="string">"recovered %d frames from WAL file %s"</literal></expr></argument>,
          <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr></argument>, <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>zWalName</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>recovery_error</name>:</label>
  <expr_stmt><expr><call><name>WALTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WAL%p: recovery %s\n"</literal><operator>,</operator> <name>pWal</name><operator>,</operator> <ternary><condition><expr><name>rc</name></expr> ?</condition><then> <expr><literal type="string">"failed"</literal></expr> </then><else>: <expr><literal type="string">"ok"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>walUnlockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iLock</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-</operator><name>iLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close an open wal-index.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>walIndexClose</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isDelete</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name><operator>==</operator><name>WAL_HEAPMEMORY_MODE</name> <operator>||</operator> <name><name>pWal</name><operator>-&gt;</operator><name>bShmUnreliable</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWal</name><operator>-&gt;</operator><name>nWiData</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name><operator>!=</operator><name>WAL_HEAPMEMORY_MODE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OsShmUnmap</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>isDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** Open a connection to the WAL file zWalName. The database file must 
** already be opened on connection pDbFd. The buffer that zWalName points
** to must remain valid for the lifetime of the returned Wal* handle.
**
** A SHARED lock should be held on the database file when this function
** is called. The purpose of this SHARED lock is to prevent any other
** client from unlinking the WAL or wal-index file. If another process
** were to do this just after this client opened one of these files, the
** system would be badly broken.
**
** If the log file is successfully opened, SQLITE_OK is returned and 
** *ppWal is set to point to a new WAL handle. If an error occurs,
** an SQLite error code is returned and *ppWal is left unmodified.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalOpen</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,              <comment type="block">/* vfs module to open wal and wal-index */</comment>
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pDbFd</name></decl></parameter>,            <comment type="block">/* The open database file */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWalName</name></decl></parameter>,           <comment type="block">/* Name of the WAL file */</comment>
  <parameter><decl><type><name>int</name></type> <name>bNoShm</name></decl></parameter>,                     <comment type="block">/* True to run in heap-memory mode */</comment>
  <parameter><decl><type><name>i64</name></type> <name>mxWalSize</name></decl></parameter>,                  <comment type="block">/* Truncate WAL to this size on reset */</comment>
  <parameter><decl><type><name>Wal</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppWal</name></decl></parameter>                     <comment type="block">/* OUT: Allocated Wal handle */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>                      <comment type="block">/* Object to allocate and return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>                      <comment type="block">/* Flags passed to OsOpen() */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zWalName</name> <operator>&amp;&amp;</operator> <name><name>zWalName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDbFd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Verify the values of various constants.  Any changes to the values
  ** of these constants would result in an incompatible on-disk format
  ** for the -shm file.  Any change that causes one of these asserts to
  ** fail is a backward compatibility problem, even if the change otherwise
  ** works.
  **
  ** This table also serves as a helpful cross-reference when trying to
  ** interpret hex dumps of the -shm file.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(    <argument><expr><literal type="number">48</literal> <operator>==</operator>  <sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(    <argument><expr><literal type="number">40</literal> <operator>==</operator>  <sizeof>sizeof<argument_list>(<argument><expr><name>WalCkptInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(   <argument><expr><literal type="number">120</literal> <operator>==</operator>  <name>WALINDEX_LOCK_OFFSET</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(   <argument><expr><literal type="number">136</literal> <operator>==</operator>  <name>WALINDEX_HDR_SIZE</name></expr></argument>    )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(  <argument><expr><literal type="number">4096</literal> <operator>==</operator>  <name>HASHTABLE_NPAGE</name></expr></argument>      )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(  <argument><expr><literal type="number">4062</literal> <operator>==</operator>  <name>HASHTABLE_NPAGE_ONE</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(  <argument><expr><literal type="number">8192</literal> <operator>==</operator>  <name>HASHTABLE_NSLOT</name></expr></argument>      )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(   <argument><expr><literal type="number">383</literal> <operator>==</operator>  <name>HASHTABLE_HASH_1</name></expr></argument>     )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">32768</literal> <operator>==</operator>  <name>WALINDEX_PGSZ</name></expr></argument>        )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(     <argument><expr><literal type="number">8</literal> <operator>==</operator>  <name>SQLITE_SHM_NLOCK</name></expr></argument>     )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(     <argument><expr><literal type="number">5</literal> <operator>==</operator>  <name>WAL_NREADER</name></expr></argument>          )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(    <argument><expr><literal type="number">24</literal> <operator>==</operator>  <name>WAL_FRAME_HDRSIZE</name></expr></argument>    )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(    <argument><expr><literal type="number">32</literal> <operator>==</operator>  <name>WAL_HDRSIZE</name></expr></argument>          )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(   <argument><expr><literal type="number">120</literal> <operator>==</operator>  <name>WALINDEX_LOCK_OFFSET</name> <operator>+</operator> <name>WAL_WRITE_LOCK</name></expr></argument>   )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(   <argument><expr><literal type="number">121</literal> <operator>==</operator>  <name>WALINDEX_LOCK_OFFSET</name> <operator>+</operator> <name>WAL_CKPT_LOCK</name></expr></argument>    )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(   <argument><expr><literal type="number">122</literal> <operator>==</operator>  <name>WALINDEX_LOCK_OFFSET</name> <operator>+</operator> <name>WAL_RECOVER_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(   <argument><expr><literal type="number">123</literal> <operator>==</operator>  <name>WALINDEX_LOCK_OFFSET</name> <operator>+</operator> <call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(   <argument><expr><literal type="number">124</literal> <operator>==</operator>  <name>WALINDEX_LOCK_OFFSET</name> <operator>+</operator> <call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(   <argument><expr><literal type="number">125</literal> <operator>==</operator>  <name>WALINDEX_LOCK_OFFSET</name> <operator>+</operator> <call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(   <argument><expr><literal type="number">126</literal> <operator>==</operator>  <name>WALINDEX_LOCK_OFFSET</name> <operator>+</operator> <call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(   <argument><expr><literal type="number">127</literal> <operator>==</operator>  <name>WALINDEX_LOCK_OFFSET</name> <operator>+</operator> <call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* In the amalgamation, the os_unix.c and os_win.c source files come before
  ** this source file.  Verify that the #defines of the locking byte offsets
  ** in os_unix.c and os_win.c agree with the WALINDEX_LOCK_OFFSET value.
  ** For that matter, if the lock offset ever changes from its initial design
  ** value of 120, we need to know that so there is an assert() to check it.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN_SHM_BASE</name></cpp:ifdef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WIN_SHM_BASE</name><operator>==</operator><name>WALINDEX_LOCK_OFFSET</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNIX_SHM_BASE</name></cpp:ifdef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>UNIX_SHM_BASE</name><operator>==</operator><name>WALINDEX_LOCK_OFFSET</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


  <comment type="block">/* Allocate an instance of struct Wal to return. */</comment>
  <expr_stmt><expr><operator>*</operator><name>ppWal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <operator>(</operator><name>Wal</name><operator>*</operator><operator>)</operator><call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Wal</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pRet</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pVfs</name></name> <operator>=</operator> <name>pVfs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pWalFd</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_file</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pRet</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pDbFd</name></name> <operator>=</operator> <name>pDbFd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>readLock</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>mxWalSize</name></name> <operator>=</operator> <name>mxWalSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>zWalName</name></name> <operator>=</operator> <name>zWalName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>syncHeader</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>padToSectorBoundary</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>bNoShm</name></expr> ?</condition><then> <expr><name>WAL_HEAPMEMORY_MODE</name></expr></then><else>: <expr><name>WAL_NORMAL_MODE</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Open file handle on the write-ahead log file. */</comment>
  <expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>(</operator><name>SQLITE_OPEN_READWRITE</name><operator>|</operator><name>SQLITE_OPEN_CREATE</name><operator>|</operator><name>SQLITE_OPEN_WAL</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zWalName</name></expr></argument>, <argument><expr><name><name>pRet</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>flags</name><operator>&amp;</operator><name>SQLITE_OPEN_READONLY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>=</operator> <name>WAL_RDONLY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>walIndexClose</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pRet</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iDC</name> <init>= <expr><call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name>pDbFd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDC</name> <operator>&amp;</operator> <name>SQLITE_IOCAP_SEQUENTIAL</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>syncHeader</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDC</name> <operator>&amp;</operator> <name>SQLITE_IOCAP_POWERSAFE_OVERWRITE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>padToSectorBoundary</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppWal</name> <operator>=</operator> <name>pRet</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WALTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WAL%d: opened\n"</literal><operator>,</operator> <name>pRet</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change the size to which the WAL file is trucated on each reset.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WalLimit</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iLimit</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pWal</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>mxWalSize</name></name> <operator>=</operator> <name>iLimit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Find the smallest page number out of all pages held in the WAL that
** has not been returned by any prior invocation of this method on the
** same WalIterator object.   Write into *piFrame the frame index where
** that page was last written into the WAL.  Write into *piPage the page
** number.
**
** Return 0 on success.  If there are no pages in the WAL with a page
** number larger than *piPage, then return 1.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walIteratorNext</name><parameter_list>(
  <parameter><decl><type><name>WalIterator</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,               <comment type="block">/* Iterator */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>piPage</name></decl></parameter>,                  <comment type="block">/* OUT: The page number of the next page */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>piFrame</name></decl></parameter>                  <comment type="block">/* OUT: Wal frame index of next page */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>iMin</name></decl>;</decl_stmt>                     <comment type="block">/* Result pgno must be greater than iMin */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iRet</name> <init>= <expr><literal type="number">0xFFFFFFFF</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* 0xffffffff is never a valid page number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* For looping through segments */</comment>

  <expr_stmt><expr><name>iMin</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iPrior</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iMin</name><operator>&lt;</operator><literal type="number">0xffffffff</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>nSegment</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>WalSegment</name></name> <modifier>*</modifier></type><name>pSegment</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aSegment</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name><name>pSegment</name><operator>-&gt;</operator><name>iNext</name></name><operator>&lt;</operator><name><name>pSegment</name><operator>-&gt;</operator><name>nEntry</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iPg</name> <init>= <expr><name><name>pSegment</name><operator>-&gt;</operator><name>aPgno</name><index>[<expr><name><name>pSegment</name><operator>-&gt;</operator><name>aIndex</name><index>[<expr><name><name>pSegment</name><operator>-&gt;</operator><name>iNext</name></name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iPg</name><operator>&gt;</operator><name>iMin</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iPg</name><operator>&lt;</operator><name>iRet</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iRet</name> <operator>=</operator> <name>iPg</name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>piFrame</name> <operator>=</operator> <name><name>pSegment</name><operator>-&gt;</operator><name>iZero</name></name> <operator>+</operator> <name><name>pSegment</name><operator>-&gt;</operator><name>aIndex</name><index>[<expr><name><name>pSegment</name><operator>-&gt;</operator><name>iNext</name></name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pSegment</name><operator>-&gt;</operator><name>iNext</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></for>

  <expr_stmt><expr><operator>*</operator><name>piPage</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iPrior</name></name> <operator>=</operator> <name>iRet</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>iRet</name><operator>==</operator><literal type="number">0xFFFFFFFF</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function merges two sorted lists into a single sorted list.
**
** aLeft[] and aRight[] are arrays of indices.  The sort key is
** aContent[aLeft[]] and aContent[aRight[]].  Upon entry, the following
** is guaranteed for all J&lt;K:
**
**        aContent[aLeft[J]] &lt; aContent[aLeft[K]]
**        aContent[aRight[J]] &lt; aContent[aRight[K]]
**
** This routine overwrites aRight[] with a new (probably longer) sequence
** of indices such that the aRight[] contains every index that appears in
** either aLeft[] or the old aRight[] and such that the second condition
** above is still met.
**
** The aContent[aLeft[X]] values will be unique for all X.  And the
** aContent[aRight[X]] values will be unique too.  But there might be
** one or more combinations of X and Y such that
**
**      aLeft[X]!=aRight[Y]  &amp;&amp;  aContent[aLeft[X]] == aContent[aRight[Y]]
**
** When that happens, omit the aLeft[X] and use the aRight[Y] index.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>walMerge</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>u32</name> <modifier>*</modifier></type><name>aContent</name></decl></parameter>,            <comment type="block">/* Pages in wal - keys for the sort */</comment>
  <parameter><decl><type><name>ht_slot</name> <modifier>*</modifier></type><name>aLeft</name></decl></parameter>,                 <comment type="block">/* IN: Left hand input list */</comment>
  <parameter><decl><type><name>int</name></type> <name>nLeft</name></decl></parameter>,                      <comment type="block">/* IN: Elements in array *paLeft */</comment>
  <parameter><decl><type><name>ht_slot</name> <modifier>*</modifier><modifier>*</modifier></type><name>paRight</name></decl></parameter>,              <comment type="block">/* IN/OUT: Right hand input list */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnRight</name></decl></parameter>,                   <comment type="block">/* IN/OUT: Elements in *paRight */</comment>
  <parameter><decl><type><name>ht_slot</name> <modifier>*</modifier></type><name>aTmp</name></decl></parameter>                   <comment type="block">/* Temporary buffer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iLeft</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Current index in aLeft */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iRight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Current index in aRight */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Current index in output buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRight</name> <init>= <expr><operator>*</operator><name>pnRight</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ht_slot</name> <modifier>*</modifier></type><name>aRight</name> <init>= <expr><operator>*</operator><name>paRight</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nLeft</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nRight</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>iRight</name><operator>&lt;</operator><name>nRight</name> <operator>||</operator> <name>iLeft</name><operator>&lt;</operator><name>nLeft</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ht_slot</name></type> <name>logpage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>dbpage</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iLeft</name><operator>&lt;</operator><name>nLeft</name><operator>)</operator> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name>iRight</name><operator>&gt;=</operator><name>nRight</name> <operator>||</operator> <name><name>aContent</name><index>[<expr><name><name>aLeft</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>]</index></name><operator>&lt;</operator><name><name>aContent</name><index>[<expr><name><name>aRight</name><index>[<expr><name>iRight</name></expr>]</index></name></expr>]</index></name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>logpage</name> <operator>=</operator> <name><name>aLeft</name><index>[<expr><name>iLeft</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>logpage</name> <operator>=</operator> <name><name>aRight</name><index>[<expr><name>iRight</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>dbpage</name> <operator>=</operator> <name><name>aContent</name><index>[<expr><name>logpage</name></expr>]</index></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>aTmp</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>logpage</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iLeft</name><operator>&lt;</operator><name>nLeft</name> <operator>&amp;&amp;</operator> <name><name>aContent</name><index>[<expr><name><name>aLeft</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>]</index></name><operator>==</operator><name>dbpage</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iLeft</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLeft</name><operator>&gt;=</operator><name>nLeft</name> <operator>||</operator> <name><name>aContent</name><index>[<expr><name><name>aLeft</name><index>[<expr><name>iLeft</name></expr>]</index></name></expr>]</index></name><operator>&gt;</operator><name>dbpage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iRight</name><operator>&gt;=</operator><name>nRight</name> <operator>||</operator> <name><name>aContent</name><index>[<expr><name><name>aRight</name><index>[<expr><name>iRight</name></expr>]</index></name></expr>]</index></name><operator>&gt;</operator><name>dbpage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><operator>*</operator><name>paRight</name> <operator>=</operator> <name>aLeft</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnRight</name> <operator>=</operator> <name>iOut</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aLeft</name></expr></argument>, <argument><expr><name>aTmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>aTmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>iOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Sort the elements in list aList using aContent[] as the sort key.
** Remove elements with duplicate keys, preferring to keep the
** larger aList[] values.
**
** The aList[] entries are indices into aContent[].  The values in
** aList[] are to be sorted so that for all J&lt;K:
**
**      aContent[aList[J]] &lt; aContent[aList[K]]
**
** For any X and Y such that
**
**      aContent[aList[X]] == aContent[aList[Y]]
**
** Keep the larger of the two values aList[X] and aList[Y] and discard
** the smaller.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>walMergesort</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>u32</name> <modifier>*</modifier></type><name>aContent</name></decl></parameter>,            <comment type="block">/* Pages in wal */</comment>
  <parameter><decl><type><name>ht_slot</name> <modifier>*</modifier></type><name>aBuffer</name></decl></parameter>,               <comment type="block">/* Buffer of at least *pnList items to use */</comment>
  <parameter><decl><type><name>ht_slot</name> <modifier>*</modifier></type><name>aList</name></decl></parameter>,                 <comment type="block">/* IN/OUT: List to sort */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnList</name></decl></parameter>                     <comment type="block">/* IN/OUT: Number of elements in aList[] */</comment>
)</parameter_list><block>{<block_content>
  <struct>struct <name>Sublist</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nList</name></decl>;</decl_stmt>                    <comment type="block">/* Number of elements in aList */</comment>
    <decl_stmt><decl><type><name>ht_slot</name> <modifier>*</modifier></type><name>aList</name></decl>;</decl_stmt>               <comment type="block">/* Pointer to sub-list content */</comment>
  }</block>;</struct>

  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nList</name> <init>= <expr><operator>*</operator><name>pnList</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Size of input list */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMerge</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Number of elements in list aMerge */</comment>
  <decl_stmt><decl><type><name>ht_slot</name> <modifier>*</modifier></type><name>aMerge</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* List to be merged */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iList</name></decl>;</decl_stmt>                      <comment type="block">/* Index into input list */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iSub</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Index into aSub array */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>Sublist</name></name></type> <name><name>aSub</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* Array of sub-lists */</comment>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aSub</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aSub</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nList</name><operator>&lt;=</operator><name>HASHTABLE_NPAGE</name> <operator>&amp;&amp;</operator> <name>nList</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>HASHTABLE_NPAGE</name><operator>==</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aSub</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>iList</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iList</name><operator>&lt;</operator><name>nList</name></expr>;</condition> <incr><expr><name>iList</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>nMerge</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>aMerge</name> <operator>=</operator> <operator>&amp;</operator><name><name>aList</name><index>[<expr><name>iList</name></expr>]</index></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>iSub</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iList</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>iSub</name><operator>)</operator></expr>;</condition> <incr><expr><name>iSub</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>Sublist</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSub</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aSub</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>aSub</name><index>[<expr><name>iSub</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aList</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nList</name></name><operator>&lt;=</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>iSub</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aList</name></name><operator>==</operator><operator>&amp;</operator><name><name>aList</name><index>[<expr><name>iList</name><operator>&amp;</operator><operator>~</operator><operator>(</operator><operator>(</operator><literal type="number">2</literal><operator>&lt;&lt;</operator><name>iSub</name><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>walMerge</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aList</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aMerge</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nMerge</name></expr></argument>, <argument><expr><name>aBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>aSub</name><index>[<expr><name>iSub</name></expr>]</index></name><operator>.</operator><name>aList</name> <operator>=</operator> <name>aMerge</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aSub</name><index>[<expr><name>iSub</name></expr>]</index></name><operator>.</operator><name>nList</name> <operator>=</operator> <name>nMerge</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <for>for<control>(<init><expr><name>iSub</name><operator>++</operator></expr>;</init> <condition><expr><name>iSub</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aSub</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>iSub</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nList</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>iSub</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>Sublist</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSub</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aSub</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>aSub</name><index>[<expr><name>iSub</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nList</name></name><operator>&lt;=</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>iSub</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aList</name></name><operator>==</operator><operator>&amp;</operator><name><name>aList</name><index>[<expr><name>nList</name><operator>&amp;</operator><operator>~</operator><operator>(</operator><operator>(</operator><literal type="number">2</literal><operator>&lt;&lt;</operator><name>iSub</name><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>walMerge</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aList</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aMerge</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nMerge</name></expr></argument>, <argument><expr><name>aBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aMerge</name><operator>==</operator><name>aList</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnList</name> <operator>=</operator> <name>nMerge</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>*</operator><name>pnList</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aContent</name><index>[<expr><name><name>aList</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>&gt;</operator> <name><name>aContent</name><index>[<expr><name><name>aList</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* 
** Free an iterator allocated by walIteratorInit().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>walIteratorFree</name><parameter_list>(<parameter><decl><type><name>WalIterator</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Construct a WalInterator object that can be used to loop over all 
** pages in the WAL following frame nBackfill in ascending order. Frames
** nBackfill or earlier may be included - excluding them is an optimization
** only. The caller must hold the checkpoint lock.
**
** On success, make *pp point to the newly allocated WalInterator object
** return SQLITE_OK. Otherwise, return an error code. If this routine
** returns an error, the value of *pp is undefined.
**
** The calling routine should invoke walIteratorFree() to destroy the
** WalIterator object when it has finished with it.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walIteratorInit</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>nBackfill</name></decl></parameter>, <parameter><decl><type><name>WalIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WalIterator</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                 <comment type="block">/* Return value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSegment</name></decl>;</decl_stmt>                   <comment type="block">/* Number of segments to merge */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iLast</name></decl>;</decl_stmt>                      <comment type="block">/* Last frame in log */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl>;</decl_stmt>            <comment type="block">/* Number of bytes to allocate */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Iterator variable */</comment>
  <decl_stmt><decl><type><name>ht_slot</name> <modifier>*</modifier></type><name>aTmp</name></decl>;</decl_stmt>                  <comment type="block">/* Temp space used by merge-sort */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>

  <comment type="block">/* This routine only runs while holding the checkpoint lock. And
  ** it only runs if there is actually content in the log (mxFrame&gt;0).
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>ckptLock</name></name> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iLast</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr>;</expr_stmt>

  <comment type="block">/* Allocate space for the WalIterator object. */</comment>
  <expr_stmt><expr><name>nSegment</name> <operator>=</operator> <call><name>walFramePage</name><argument_list>(<argument><expr><name>iLast</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WalIterator</name></expr></argument>)</argument_list></sizeof> 
        <operator>+</operator> <operator>(</operator><name>nSegment</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>WalSegment</name></expr></argument>)</argument_list></sizeof>
        <operator>+</operator> <name>iLast</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ht_slot</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>WalIterator</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSegment</name></name> <operator>=</operator> <name>nSegment</name></expr>;</expr_stmt>

  <comment type="block">/* Allocate temporary space used by the merge-sort routine. This block
  ** of memory will be freed before this function returns.
  */</comment>
  <expr_stmt><expr><name>aTmp</name> <operator>=</operator> <operator>(</operator><name>ht_slot</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(
      <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ht_slot</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>iLast</name><operator>&gt;</operator><name>HASHTABLE_NPAGE</name></expr>?</condition><then><expr><name>HASHTABLE_NPAGE</name></expr></then><else>:<expr><name>iLast</name></expr></else></ternary><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aTmp</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><call><name>walFramePage</name><argument_list>(<argument><expr><name>nBackfill</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nSegment</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>WalHashLoc</name></type> <name>sLoc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walHashGet</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>                      <comment type="block">/* Counter variable */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name></decl>;</decl_stmt>                 <comment type="block">/* Number of entries in this segment */</comment>
      <decl_stmt><decl><type><name>ht_slot</name> <modifier>*</modifier></type><name>aIndex</name></decl>;</decl_stmt>            <comment type="block">/* Sorted index for this segment */</comment>

      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><name>nSegment</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nEntry</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>iLast</name> <operator>-</operator> <name><name>sLoc</name><operator>.</operator><name>iZero</name></name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nEntry</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><name><name>sLoc</name><operator>.</operator><name>aHash</name></name> <operator>-</operator> <operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><name><name>sLoc</name><operator>.</operator><name>aPgno</name></name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>aIndex</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>ht_slot</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aSegment</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nSegment</name></name></expr>]</index></name><operator>)</operator><index>[<expr><name><name>sLoc</name><operator>.</operator><name>iZero</name></name></expr>]</index></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sLoc</name><operator>.</operator><name>iZero</name></name><operator>++</operator></expr>;</expr_stmt>
  
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nEntry</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>aIndex</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>ht_slot</name><operator>)</operator><name>j</name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>walMergesort</name><argument_list>(<argument><expr><operator>(</operator><name>u32</name> <operator>*</operator><operator>)</operator><name><name>sLoc</name><operator>.</operator><name>aPgno</name></name></expr></argument>, <argument><expr><name>aTmp</name></expr></argument>, <argument><expr><name>aIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aSegment</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iZero</name> <operator>=</operator> <name><name>sLoc</name><operator>.</operator><name>iZero</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aSegment</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nEntry</name> <operator>=</operator> <name>nEntry</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aSegment</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>aIndex</name> <operator>=</operator> <name>aIndex</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aSegment</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>aPgno</name> <operator>=</operator> <operator>(</operator><name>u32</name> <operator>*</operator><operator>)</operator><name><name>sLoc</name><operator>.</operator><name>aPgno</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>walIteratorFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SETLK_TIMEOUT</name></cpp:ifdef>
<comment type="block">/*
** Attempt to enable blocking locks. Blocking locks are enabled only if (a)
** they are supported by the VFS, and (b) the database handle is configured 
** with a busy-timeout. Return 1 if blocking locks are successfully enabled, 
** or 0 otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walEnableBlocking</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>db</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>tmout</name> <init>= <expr><name><name>pWal</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>busyTimeout</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>tmout</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileControl</name><argument_list>(
          <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_LOCK_TIMEOUT</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tmout</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_OK</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Disable blocking locks.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>walDisableBlocking</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>tmout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3OsFileControl</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_LOCK_TIMEOUT</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tmout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If parameter bLock is true, attempt to enable blocking locks, take
** the WRITER lock, and then disable blocking locks. If blocking locks
** cannot be enabled, no attempt to obtain the WRITER lock is made. Return 
** an SQLite error code if an error occurs, or SQLITE_OK otherwise. It is not
** an error if blocking locks can not be enabled.
**
** If the bLock parameter is false and the WRITER lock is held, release it.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalWriteLock</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>bLock</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bLock</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>db</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>walEnableBlocking</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_WRITE_LOCK</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>walDisableBlocking</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>walUnlockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_WRITE_LOCK</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the database handle used to determine if blocking locks are required.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WalDb</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Take an exclusive WRITE lock. Blocking if so configured.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walLockWriter</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>walEnableBlocking</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_WRITE_LOCK</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>walDisableBlocking</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>walEnableBlocking</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>walDisableBlocking</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>walLockWriter</name><parameter_list>(<parameter><type><name>pWal</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>walLockExclusive((pWal), WAL_WRITE_LOCK, 1)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3WalDb</name><parameter_list>(<parameter><type><name>pWal</name></type></parameter>, <parameter><type><name>db</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* ifdef SQLITE_ENABLE_SETLK_TIMEOUT */</comment>


<comment type="block">/*
** Attempt to obtain the exclusive WAL lock defined by parameters lockIdx and
** n. If the attempt fails and parameter xBusy is not NULL, then it is a
** busy-handler function. Invoke it and retry the lock until either the
** lock is successfully obtained or the busy-handler returns 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walBusyLock</name><parameter_list>(
  <parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>,                      <comment type="block">/* WAL connection */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xBusy</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,            <comment type="block">/* Function to call when busy */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBusyArg</name></decl></parameter>,                 <comment type="block">/* Context argument for xBusyHandler */</comment>
  <parameter><decl><type><name>int</name></type> <name>lockIdx</name></decl></parameter>,                    <comment type="block">/* Offset of first byte to lock */</comment>
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>                           <comment type="block">/* Number of bytes to lock */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>lockIdx</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>xBusy</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_BUSY</name> <operator>&amp;&amp;</operator> <call><name>xBusy</name><argument_list>(<argument><expr><name>pBusyArg</name></expr></argument>)</argument_list></call></expr> )</condition>;</do>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SETLK_TIMEOUT</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY_TIMEOUT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>walDisableBlocking</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The cache of the wal-index header must be valid to call this function.
** Return the page-size in bytes used by the database.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walPagesize</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>szPage</name></name><operator>&amp;</operator><literal type="number">0xfe00</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>szPage</name></name><operator>&amp;</operator><literal type="number">0x0001</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following is guaranteed when this function is called:
**
**   a) the WRITER lock is held,
**   b) the entire log file has been checkpointed, and
**   c) any existing readers are reading exclusively from the database
**      file - there are no readers that may attempt to read a frame from
**      the log file.
**
** This function updates the shared-memory structures so that the next
** client to write to the database (which may be this one) does so by
** writing frames into the start of the log file.
**
** The value of parameter salt1 is used as the aSalt[1] value in the 
** new wal-index header. It should be passed a pseudo-random value (i.e. 
** one obtained from sqlite3_randomness()).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>walRestartHdr</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>salt1</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>WalCkptInfo</name> <modifier>*</modifier></type><name>pInfo</name> <init>= <expr><call><name>walCkptInfo</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aSalt</name> <init>= <expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aSalt</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Big-endian salt values */</comment>
  <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>nCkpt</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Put4byte</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aSalt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aSalt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aSalt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>salt1</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>walIndexWriteHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AtomicStore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfill</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfillAttempted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aReadMark</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>WAL_NREADER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aReadMark</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>READMARK_NOT_USED</name></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aReadMark</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Copy as much content as we can from the WAL back into the database file
** in response to an sqlite3_wal_checkpoint() request or the equivalent.
**
** The amount of information copies from WAL to database might be limited
** by active readers.  This routine will never overwrite a database page
** that a concurrent reader might be using.
**
** All I/O barrier operations (a.k.a fsyncs) occur in this routine when
** SQLite is in WAL-mode in synchronous=NORMAL.  That means that if 
** checkpoints are always run by a background thread or background 
** process, foreground threads will never block on a lengthy fsync call.
**
** Fsync is called on the WAL before writing content out of the WAL and
** into the database.  This ensures that if the new content is persistent
** in the WAL and can be recovered following a power-loss or hard reset.
**
** Fsync is also called on the database file if (and only if) the entire
** WAL content is copied into the database file.  This second fsync makes
** it safe to delete the WAL since the new content will persist in the
** database file.
**
** This routine uses and updates the nBackfill field of the wal-index header.
** This is the only routine that will increase the value of nBackfill.  
** (A WAL reset or recovery will revert nBackfill to zero, but not increase
** its value.)
**
** The caller must be holding sufficient locks to ensure that no other
** checkpoint is running (in any other thread or process) at the same
** time.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walCheckpoint</name><parameter_list>(
  <parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>,                      <comment type="block">/* Wal connection */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Check for interrupts on this handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>,                      <comment type="block">/* One of PASSIVE, FULL or RESTART */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xBusy</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,            <comment type="block">/* Function to call when busy */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBusyArg</name></decl></parameter>,                 <comment type="block">/* Context argument for xBusyHandler */</comment>
  <parameter><decl><type><name>int</name></type> <name>sync_flags</name></decl></parameter>,                 <comment type="block">/* Flags for OsSync() (or 0) */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>                        <comment type="block">/* Temporary buffer to use */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szPage</name></decl>;</decl_stmt>                     <comment type="block">/* Database page-size */</comment>
  <decl_stmt><decl><type><name>WalIterator</name> <modifier>*</modifier></type><name>pIter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Wal iterator context */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iDbpage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Next database page to write */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iFrame</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Wal frame containing data for iDbpage */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>mxSafeFrame</name></decl>;</decl_stmt>                <comment type="block">/* Max frame that can be backfilled */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>mxPage</name></decl>;</decl_stmt>                     <comment type="block">/* Max database page to write */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>WalCkptInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl>;</decl_stmt>    <comment type="block">/* The checkpoint status information */</comment>

  <expr_stmt><expr><name>szPage</name> <operator>=</operator> <call><name>walPagesize</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>szPage</name><operator>&lt;=</operator><literal type="number">32768</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>szPage</name><operator>&gt;=</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <call><name>walCkptInfo</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfill</name></name><operator>&lt;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr> )</condition><block>{<block_content>

    <comment type="block">/* EVIDENCE-OF: R-62920-47450 The busy-handler callback is never invoked
    ** in the SQLITE_CHECKPOINT_PASSIVE mode. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMode</name><operator>!=</operator><name>SQLITE_CHECKPOINT_PASSIVE</name> <operator>||</operator> <name>xBusy</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compute in mxSafeFrame the index of the last frame of the WAL that is
    ** safe to write into the database.  Frames beyond mxSafeFrame might
    ** overwrite database pages that are in use by active readers and thus
    ** cannot be backfilled from the WAL.
    */</comment>
    <expr_stmt><expr><name>mxSafeFrame</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mxPage</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nPage</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>WAL_NREADER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>y</name> <init>= <expr><call><name>AtomicLoad</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aReadMark</name></name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>mxSafeFrame</name><operator>&gt;</operator><name>y</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>y</name><operator>&lt;=</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walBusyLock</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>xBusy</name></expr></argument>, <argument><expr><name>pBusyArg</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>u32</name></type> <name>iMark</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>i</name><operator>==</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>mxSafeFrame</name></expr> </then><else>: <expr><name>READMARK_NOT_USED</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>AtomicStore</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aReadMark</name></name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>iMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>walUnlockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>mxSafeFrame</name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>xBusy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <goto>goto <name>walcheckpoint_out</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Allocate the iterator */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfill</name></name><operator>&lt;</operator><name>mxSafeFrame</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walIteratorInit</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfill</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>pIter</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>pIter</name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>walBusyLock</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>,<argument><expr><name>xBusy</name></expr></argument>,<argument><expr><name>pBusyArg</name></expr></argument>,<argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_OK</name></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>nBackfill</name> <init>= <expr><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfill</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfillAttempted</name></name> <operator>=</operator> <name>mxSafeFrame</name></expr>;</expr_stmt>

      <comment type="block">/* Sync the WAL to disk */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><call><name>CKPT_SYNC_FLAGS</name><argument_list>(<argument><expr><name>sync_flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If the database may grow as a result of this checkpoint, hint
      ** about the eventual size of the db file to the VFS layer.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>i64</name></type> <name>nReq</name> <init>= <expr><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>mxPage</name> <operator>*</operator> <name>szPage</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>i64</name></type> <name>nSize</name></decl>;</decl_stmt>                    <comment type="block">/* Current size of database file */</comment>
        <expr_stmt><expr><call><name>sqlite3OsFileControl</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_CKPT_START</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nSize</name><operator>&lt;</operator><name>nReq</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nSize</name><operator>+</operator><literal type="number">65536</literal><operator>+</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name><operator>*</operator><name>szPage</name><operator>)</operator><operator>&lt;</operator><name>nReq</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* If the size of the final database is larger than the current
            ** database plus the amount of data in the wal file, plus the
            ** maximum size of the pending-byte page (65536 bytes), then 
            ** must be corruption somewhere.  */</comment>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3OsFileControlHint</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_SIZE_HINT</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nReq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Iterate through the contents of the WAL, copying data to the db file */</comment>
      <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>walIteratorNext</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDbpage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iFrame</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>i64</name></type> <name>iOffset</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>walFramePgno</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iFrame</name></expr></argument>)</argument_list></call><operator>==</operator><name>iDbpage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>AtomicLoad</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> ?</condition><then> <expr><name>SQLITE_NOMEM_BKPT</name></expr> </then><else>: <expr><name>SQLITE_INTERRUPT</name></expr></else></ternary></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iFrame</name><operator>&lt;=</operator><name>nBackfill</name> <operator>||</operator> <name>iFrame</name><operator>&gt;</operator><name>mxSafeFrame</name> <operator>||</operator> <name>iDbpage</name><operator>&gt;</operator><name>mxPage</name></expr> )</condition><block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>iOffset</name> <operator>=</operator> <call><name>walFrameOffset</name><argument_list>(<argument><expr><name>iFrame</name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>WAL_FRAME_HDRSIZE</name></expr>;</expr_stmt>
        <comment type="block">/* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL file */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>iOffset</name> <operator>=</operator> <operator>(</operator><name>iDbpage</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><name>szPage</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>IS_BIG_INT</name><argument_list>(<argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><call><name>sqlite3OsFileControl</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_CKPT_DONE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If work was actually accomplished... */</comment>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>mxSafeFrame</name><operator>==</operator><call><name>walIndexHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>mxFrame</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>i64</name></type> <name>szDb</name> <init>= <expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nPage</name></name><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><name>szPage</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>IS_BIG_INT</name><argument_list>(<argument><expr><name>szDb</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>szDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><call><name>CKPT_SYNC_FLAGS</name><argument_list>(<argument><expr><name>sync_flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>AtomicStore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfill</name></name></expr></argument>, <argument><expr><name>mxSafeFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Release the reader lock held while backfilling */</comment>
      <expr_stmt><expr><call><name>walUnlockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Reset the return code so as not to report a checkpoint failure
      ** just because there are active readers.  */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If this is an SQLITE_CHECKPOINT_RESTART or TRUNCATE operation, and the
  ** entire wal file has been copied into the database file, then block 
  ** until all readers have finished using the wal file. This ensures that 
  ** the next process to write to the database restarts the wal file.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>eMode</name><operator>!=</operator><name>SQLITE_CHECKPOINT_PASSIVE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfill</name></name><operator>&lt;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eMode</name><operator>&gt;=</operator><name>SQLITE_CHECKPOINT_RESTART</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>salt1</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>salt1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfill</name></name><operator>==</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walBusyLock</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>xBusy</name></expr></argument>, <argument><expr><name>pBusyArg</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>WAL_NREADER</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>eMode</name><operator>==</operator><name>SQLITE_CHECKPOINT_TRUNCATE</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* IMPLEMENTATION-OF: R-44699-57140 This mode works the same way as
          ** SQLITE_CHECKPOINT_RESTART with the addition that it also
          ** truncates the log file to zero bytes just prior to a
          ** successful return.
          **
          ** In theory, it might be safe to do this without updating the
          ** wal-index header in shared memory, as all subsequent reader or
          ** writer clients should see that the entire log file has been
          ** checkpointed and behave accordingly. This seems unsafe though,
          ** as it would leave the system in a state where the contents of
          ** the wal-index header do not match the contents of the 
          ** file-system. To avoid this, update the wal-index header to
          ** indicate that the log file contains zero valid frames.  */</comment>
          <expr_stmt><expr><call><name>walRestartHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>salt1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>walUnlockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>WAL_NREADER</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

 <label><name>walcheckpoint_out</name>:</label>
  <expr_stmt><expr><call><name>walIteratorFree</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the WAL file is currently larger than nMax bytes in size, truncate
** it to exactly nMax bytes. If an error occurs while doing so, ignore it.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>walLimitSize</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nMax</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rx</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rx</name> <operator>=</operator> <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rx</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sz</name> <operator>&gt;</operator> <name>nMax</name> <operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rx</name> <operator>=</operator> <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><name>nMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rx</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>rx</name></expr></argument>, <argument><expr><literal type="string">"cannot limit WAL size: %s"</literal></expr></argument>, <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>zWalName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close a connection to a log file.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalClose</name><parameter_list>(
  <parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>,                      <comment type="block">/* Wal to close */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* For interrupt flag */</comment>
  <parameter><decl><type><name>int</name></type> <name>sync_flags</name></decl></parameter>,                 <comment type="block">/* Flags to pass to OsSync() (or 0) */</comment>
  <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>,
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>                        <comment type="block">/* Buffer of at least nBuf bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pWal</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>isDelete</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* True to unlink wal and wal-index files */</comment>

    <comment type="block">/* If an EXCLUSIVE lock can be obtained on the database file (using the
    ** ordinary, rollback-mode locking methods, this guarantees that the
    ** connection associated with this log file is the only connection to
    ** the database. In this case checkpoint the database and unlink both
    ** the wal and wal-index files.
    **
    ** The EXCLUSIVE lock is not released before returning.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>zBuf</name><operator>!=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3OsLock</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>SQLITE_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name><operator>==</operator><name>WAL_NORMAL_MODE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>=</operator> <name>WAL_EXCLUSIVE_MODE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalCheckpoint</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, 
          <argument><expr><name>SQLITE_CHECKPOINT_PASSIVE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sync_flags</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bPersist</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3OsFileControlHint</name><argument_list>(
            <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_PERSIST_WAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bPersist</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bPersist</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Try to delete the WAL file if the checkpoint completed and
          ** fsyned (rc==SQLITE_OK) and if we are not in persistent-wal
          ** mode (!bPersist) */</comment>
          <expr_stmt><expr><name>isDelete</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>mxWalSize</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Try to truncate the WAL file to zero bytes if the checkpoint
          ** completed and fsynced (rc==SQLITE_OK) and we are in persistent
          ** WAL mode (bPersist) and if the PRAGMA journal_size_limit is a
          ** non-negative value (pWal-&gt;mxWalSize&gt;=0).  Note that we truncate
          ** to zero bytes as truncating to the journal_size_limit might
          ** leave a corrupt WAL file on disk. */</comment>
          <expr_stmt><expr><call><name>walLimitSize</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>walIndexClose</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>isDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>isDelete</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>zWalName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>WALTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WAL%p: closed\n"</literal><operator>,</operator> <name>pWal</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Try to read the wal-index header.  Return 0 on success and 1 if
** there is a problem.
**
** The wal-index is in shared memory.  Another thread or process might
** be writing the header at the same time this procedure is trying to
** read it, which might result in inconsistency.  A dirty read is detected
** by verifying that both copies of the header are the same and also by
** a checksum on the header.
**
** If and only if the read is consistent and the header is different from
** pWal-&gt;hdr, then pWal-&gt;hdr is updated to the content of the new header
** and *pChanged is set to 1.
**
** If the checksum cannot be verified return non-zero. If the header
** is read successfully and the checksum verified, return zero.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NO_TSAN</name> <name>int</name></type> <name>walIndexTryHdr</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pChanged</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aCksum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>                  <comment type="block">/* Checksum on the header content */</comment>
  <decl_stmt><decl><type><name>WalIndexHdr</name></type> <name>h1</name></decl>, <decl><type ref="prev"/><name>h2</name></decl>;</decl_stmt>             <comment type="block">/* Two copies of the header content */</comment>
  <decl_stmt><decl><type><name>WalIndexHdr</name> <specifier>volatile</specifier> <modifier>*</modifier></type><name>aHdr</name></decl>;</decl_stmt>     <comment type="block">/* Header in shared memory */</comment>

  <comment type="block">/* The first page of the wal-index must be mapped at this point. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>nWiData</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read the header. This might happen concurrently with a write to the
  ** same area of shared memory on a different CPU in a SMP,
  ** meaning it is possible that an inconsistent snapshot is read
  ** from the file. If this happens, return non-zero.
  **
  ** tag-20200519-1:
  ** There are two copies of the header at the beginning of the wal-index.
  ** When reading, read [0] first then [1].  Writes are in the reverse order.
  ** Memory barriers are used to prevent the compiler or the hardware from
  ** reordering the reads and writes.  TSAN and similar tools can sometimes
  ** give false-positive warnings about these accesses because the tools do not
  ** account for the double-read and the memory barrier. The use of mutexes
  ** here would be problematic as the memory being accessed is potentially
  ** shared among multiple processes and not all mutex implementions work
  ** reliably in that environment.
  */</comment>
  <expr_stmt><expr><name>aHdr</name> <operator>=</operator> <call><name>walIndexHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h1</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aHdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Possible TSAN false-positive */</comment>
  <expr_stmt><expr><call><name>walShmBarrier</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h2</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aHdr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>   <comment type="block">/* Dirty read */</comment>
  </block_content>}</block></if></if_stmt>  
  <if_stmt><if>if<condition>( <expr><name><name>h1</name><operator>.</operator><name>isInit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>   <comment type="block">/* Malformed header - probably all zeros */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>walChecksumBytes</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>h1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h1</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>h1</name><operator>.</operator><name>aCksum</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aCksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>aCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><name><name>h1</name><operator>.</operator><name>aCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>aCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><name><name>h1</name><operator>.</operator><name>aCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>   <comment type="block">/* Checksum does not match */</comment>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pChanged</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name> <operator>=</operator> <operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>szPage</name></name><operator>&amp;</operator><literal type="number">0xfe00</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>szPage</name></name><operator>&amp;</operator><literal type="number">0x0001</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name><operator>&lt;=</operator><literal type="number">32768</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name><operator>&gt;=</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The header was successfully read. Return zero. */</comment>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the value that walTryBeginRead returns when it needs to
** be retried.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_RETRY</name></cpp:macro>  <cpp:value>(-1)</cpp:value></cpp:define>

<comment type="block">/*
** Read the wal-index header from the wal-index and into pWal-&gt;hdr.
** If the wal-header appears to be corrupt, try to reconstruct the
** wal-index from the WAL before returning.
**
** Set *pChanged to 1 if the wal-index header value in pWal-&gt;hdr is
** changed by this operation.  If pWal-&gt;hdr is unchanged, set *pChanged
** to 0.
**
** If the wal-index header is successfully read, return SQLITE_OK. 
** Otherwise an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walIndexReadHdr</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pChanged</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>badHdr</name></decl>;</decl_stmt>                     <comment type="block">/* True if a header read failed */</comment>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>u32</name> <modifier>*</modifier></type><name>page0</name></decl>;</decl_stmt>            <comment type="block">/* Chunk of wal-index containing header */</comment>

  <comment type="block">/* Ensure that page 0 of the wal-index (the page that contains the 
  ** wal-index header) is mapped. Return early if an error occurs here.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pChanged</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walIndexPage</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>page0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_READONLY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* READONLY changed to OK in walIndexPage */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_READONLY_CANTINIT</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The SQLITE_READONLY_CANTINIT return means that the shared-memory
      ** was openable but is not writable, and this thread is unable to
      ** confirm that another write-capable connection has the shared-memory
      ** open, and hence the content of the shared-memory is unreliable,
      ** since the shared-memory might be inconsistent with the WAL file
      ** and there is no writer on hand to fix it. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>page0</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>&amp;</operator> <name>WAL_SHM_RDONLY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>bShmUnreliable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>=</operator> <name>WAL_HEAPMEMORY_MODE</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pChanged</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return> <comment type="block">/* Any other non-OK return is just an error */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* page0 can be NULL if the SHM is zero bytes in size and pWal-&gt;writeLock
    ** is zero, which prevents the SHM from growing */</comment>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>page0</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>page0</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the first page of the wal-index has been mapped, try to read the
  ** wal-index header immediately, without holding any lock. This usually
  ** works, but may fail if the wal-index header is corrupt or currently 
  ** being modified by another thread or process.
  */</comment>
  <expr_stmt><expr><name>badHdr</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>page0</name></expr> ?</condition><then> <expr><call><name>walIndexTryHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>pChanged</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* If the first attempt failed, it might have been due to a race
  ** with a writer.  So get a WRITE lock and try again.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>badHdr</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>bShmUnreliable</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>&amp;</operator> <name>WAL_SHM_RDONLY</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>walLockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_WRITE_LOCK</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>walUnlockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_WRITE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_READONLY_RECOVERY</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bWriteLock</name> <init>= <expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>bWriteLock</name> <operator>||</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>walLockWriter</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>walIndexPage</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>page0</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>badHdr</name> <operator>=</operator> <call><name>walIndexTryHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>pChanged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>badHdr</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* If the wal-index header is still malformed even while holding
            ** a WRITE lock, it can only mean that the header is corrupted and
            ** needs to be reconstructed.  So run recovery to do exactly that.
            */</comment>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walIndexRecover</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>pChanged</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>bWriteLock</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>walUnlockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_WRITE_LOCK</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the header is read successfully, check the version number to make
  ** sure the wal-index was not constructed with some future format that
  ** this version of SQLite cannot understand.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>badHdr</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>iVersion</name></name><operator>!=</operator><name>WALINDEX_MAX_VERSION</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>bShmUnreliable</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>walIndexClose</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>bShmUnreliable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>nWiData</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* walIndexRecover() might have returned SHORT_READ if a concurrent
      ** writer truncated the WAL out from under it.  If that happens, it
      ** indicates that a writer has fixed the SHM file for us, so retry */</comment>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_IOERR_SHORT_READ</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>WAL_RETRY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>=</operator> <name>WAL_NORMAL_MODE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a transaction in a connection where the shared-memory is read-only
** and where we cannot verify that there is a separate write-capable connection
** on hand to keep the shared-memory up-to-date with the WAL file.
**
** This can happen, for example, when the shared-memory is implemented by
** memory-mapping a *-shm file, where a prior writer has shut down and
** left the *-shm file on disk, and now the present connection is trying
** to use that database but lacks write permission on the *-shm file.
** Other scenarios are also possible, depending on the VFS implementation.
**
** Precondition:
**
**    The *-wal file has been read and an appropriate wal-index has been
**    constructed in pWal-&gt;apWiData[] using heap memory instead of shared
**    memory. 
**
** If this function returns SQLITE_OK, then the read transaction has
** been successfully opened. In this case output variable (*pChanged) 
** is set to true before returning if the caller should discard the
** contents of the page cache before proceeding. Or, if it returns 
** WAL_RETRY, then the heap memory wal-index has been discarded and 
** the caller should retry opening the read transaction from the 
** beginning (including attempting to map the *-shm file). 
**
** If an error occurs, an SQLite error code is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walBeginShmUnreliable</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pChanged</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>szWal</name></decl>;</decl_stmt>                      <comment type="block">/* Size of wal file on disk in bytes */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iOffset</name></decl>;</decl_stmt>                    <comment type="block">/* Current offset when reading wal file */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>aBuf</name><index>[<expr><name>WAL_HDRSIZE</name></expr>]</index></name></decl>;</decl_stmt>           <comment type="block">/* Buffer to load WAL header into */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aFrame</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Malloc'd buffer to load entire frame */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szFrame</name></decl>;</decl_stmt>                    <comment type="block">/* Number of bytes in buffer aFrame[] */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                      <comment type="block">/* Pointer to data part of aFrame buffer */</comment>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>void</name> <modifier>*</modifier></type><name>pDummy</name></decl>;</decl_stmt>          <comment type="block">/* Dummy argument for xShmMap */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aSaveCksum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>              <comment type="block">/* Saved copy of pWal-&gt;hdr.aFrameCksum */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>bShmUnreliable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>&amp;</operator> <name>WAL_SHM_RDONLY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>nWiData</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Take WAL_READ_LOCK(0). This has the effect of preventing any
  ** writers from running a checkpoint, but does not stop them
  ** from running recovery.  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>WAL_RETRY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <goto>goto <name>begin_unreliable_shm_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Check to see if a separate writer has attached to the shared-memory area,
  ** thus making the shared-memory "reliable" again.  Do this by invoking
  ** the xShmMap() routine of the VFS and looking to see if the return
  ** is SQLITE_READONLY instead of SQLITE_READONLY_CANTINIT.
  **
  ** If the shared-memory is now "reliable" return WAL_RETRY, which will
  ** cause the heap-memory WAL-index to be discarded and the actual
  ** shared memory to be used in its place.
  **
  ** This step is important because, even though this connection is holding
  ** the WAL_READ_LOCK(0) which prevents a checkpoint, a writer might
  ** have already checkpointed the WAL file and, while the current
  ** is active, wrap the WAL and start overwriting frames that this
  ** process wants to use.
  **
  ** Once sqlite3OsShmMap() has been called for an sqlite3_file and has
  ** returned any SQLITE_READONLY value, it must return only SQLITE_READONLY
  ** or SQLITE_READONLY_CANTINIT or some error for all subsequent invocations,
  ** even if some external agent does a "chmod" to make the shared-memory
  ** writable by us, until sqlite3OsShmUnmap() has been called.
  ** This is a requirement on the VFS implementation.
   */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsShmMap</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WALINDEX_PGSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* SQLITE_OK not possible for read-only connection */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_READONLY_CANTINIT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_READONLY</name></expr> ?</condition><then> <expr><name>WAL_RETRY</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <goto>goto <name>begin_unreliable_shm_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* We reach this point only if the real shared-memory is still unreliable.
  ** Assume the in-memory WAL-index substitute is correct and load it
  ** into pWal-&gt;hdr.
  */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><call><name>walIndexHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure some writer hasn't come in and changed the WAL file out
  ** from under us, then disconnected, while we were not looking.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>szWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>begin_unreliable_shm_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>szWal</name><operator>&lt;</operator><name>WAL_HDRSIZE</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If the wal file is too small to contain a wal-header and the
    ** wal-index header has mxFrame==0, then it must be safe to proceed
    ** reading the database file only. However, the page cache cannot
    ** be trusted, as a read/write connection may have connected, written
    ** the db, run a checkpoint, truncated the wal file and disconnected
    ** since this client's last read transaction.  */</comment>
    <expr_stmt><expr><operator>*</operator><name>pChanged</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>WAL_RETRY</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <goto>goto <name>begin_unreliable_shm_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the salt keys at the start of the wal file still match. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>WAL_HDRSIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>begin_unreliable_shm_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aSalt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Some writer has wrapped the WAL file while we were not looking.
    ** Return WAL_RETRY which will cause the in-memory WAL-index to be
    ** rebuilt. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>WAL_RETRY</name></expr>;</expr_stmt>
    <goto>goto <name>begin_unreliable_shm_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Allocate a buffer to read frames into */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name><operator>&gt;=</operator><literal type="number">512</literal> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name><operator>&lt;=</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>szFrame</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name> <operator>+</operator> <name>WAL_FRAME_HDRSIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aFrame</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>szFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aFrame</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
    <goto>goto <name>begin_unreliable_shm_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>aData</name> <operator>=</operator> <operator>&amp;</operator><name><name>aFrame</name><index>[<expr><name>WAL_FRAME_HDRSIZE</name></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* Check to see if a complete transaction has been appended to the
  ** wal file since the heap-memory wal-index was created. If so, the
  ** heap-memory wal-index is discarded and WAL_RETRY returned to
  ** the caller.  */</comment>
  <expr_stmt><expr><name><name>aSaveCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aSaveCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>iOffset</name><operator>=</operator><call><name>walFrameOffset</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name></expr></argument>)</argument_list></call></expr>;</init> 
      <condition><expr><name>iOffset</name><operator>+</operator><name>szFrame</name><operator>&lt;=</operator><name>szWal</name></expr>;</condition> 
      <incr><expr><name>iOffset</name><operator>+=</operator><name>szFrame</name></expr></incr>
  )</control><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>pgno</name></decl>;</decl_stmt>                   <comment type="block">/* Database page number for frame */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>nTruncate</name></decl>;</decl_stmt>              <comment type="block">/* dbsize field from frame header */</comment>

    <comment type="block">/* Read and decode the next log frame. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>szFrame</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>walDecodeFrame</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nTruncate</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <comment type="block">/* If nTruncate is non-zero, then a complete transaction has been
    ** appended to this wal file. Set rc to WAL_RETRY and break out of
    ** the loop.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>nTruncate</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>WAL_RETRY</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>aSaveCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>aSaveCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

 <label><name>begin_unreliable_shm_out</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWal</name><operator>-&gt;</operator><name>nWiData</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>bShmUnreliable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalEndReadTransaction</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pChanged</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to start a read transaction.  This might fail due to a race or
** other transient condition.  When that happens, it returns WAL_RETRY to
** indicate to the caller that it is safe to retry immediately.
**
** On success return SQLITE_OK.  On a permanent failure (such an
** I/O error or an SQLITE_BUSY because another process is running
** recovery) return a positive error code.
**
** The useWal parameter is true to force the use of the WAL and disable
** the case where the WAL is bypassed because it has been completely
** checkpointed.  If useWal==0 then this routine calls walIndexReadHdr() 
** to make a copy of the wal-index header into pWal-&gt;hdr.  If the 
** wal-index header has changed, *pChanged is set to 1 (as an indication 
** to the caller that the local page cache is obsolete and needs to be 
** flushed.)  When useWal==1, the wal-index header is assumed to already
** be loaded and the pChanged parameter is unused.
**
** The caller must set the cnt parameter to the number of prior calls to
** this routine during the current read attempt that returned WAL_RETRY.
** This routine will start taking more aggressive measures to clear the
** race conditions after multiple WAL_RETRY returns, and after an excessive
** number of errors will ultimately return SQLITE_PROTOCOL.  The
** SQLITE_PROTOCOL return indicates that some other process has gone rogue
** and is not honoring the locking protocol.  There is a vanishingly small
** chance that SQLITE_PROTOCOL could be returned because of a run of really
** bad luck when there is lots of contention for the wal-index, but that
** possibility is so small that it can be safely neglected, we believe.
**
** On success, this routine obtains a read lock on 
** WAL_READ_LOCK(pWal-&gt;readLock).  The pWal-&gt;readLock integer is
** in the range 0 &lt;= pWal-&gt;readLock &lt; WAL_NREADER.  If pWal-&gt;readLock==(-1)
** that means the Wal does not hold any read lock.  The reader must not
** access any database page that is modified by a WAL frame up to and
** including frame number aReadMark[pWal-&gt;readLock].  The reader will
** use WAL frames up to and including pWal-&gt;hdr.mxFrame if pWal-&gt;readLock&gt;0
** Or if pWal-&gt;readLock==0, then the reader will ignore the WAL
** completely and get all content directly from the database file.
** If the useWal parameter is 1 then the WAL will never be ignored and
** this routine will always set pWal-&gt;readLock&gt;0 on success.
** When the read transaction is completed, the caller must release the
** lock on WAL_READ_LOCK(pWal-&gt;readLock) and set pWal-&gt;readLock to -1.
**
** This routine uses the nBackfill and aReadMark[] fields of the header
** to select a particular WAL_READ_LOCK() that strives to let the
** checkpoint process do as much work as possible.  This routine might
** update values of the aReadMark[] array in the header, but if it does
** so it takes care to hold an exclusive lock on the corresponding
** WAL_READ_LOCK() while changing values.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walTryBeginRead</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pChanged</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>useWal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>WalCkptInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl>;</decl_stmt>    <comment type="block">/* Checkpoint information in wal-index */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>mxReadMark</name></decl>;</decl_stmt>                 <comment type="block">/* Largest aReadMark[] value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mxI</name></decl>;</decl_stmt>                        <comment type="block">/* Index of largest aReadMark[] value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code  */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>mxFrame</name></decl>;</decl_stmt>                    <comment type="block">/* Wal frame to lock to */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* Not currently locked */</comment>

  <comment type="block">/* useWal may only be set for read/write connections */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>&amp;</operator> <name>WAL_SHM_RDONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>useWal</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Take steps to avoid spinning forever if there is a protocol error.
  **
  ** Circumstances that cause a RETRY should only last for the briefest
  ** instances of time.  No I/O or other system calls are done while the
  ** locks are held, so the locks should not be held for very long. But 
  ** if we are unlucky, another process that is holding a lock might get
  ** paged out or take a page-fault that is time-consuming to resolve, 
  ** during the few nanoseconds that it is holding the lock.  In that case,
  ** it might take longer than normal for the lock to free.
  **
  ** After 5 RETRYs, we begin calling sqlite3OsSleep().  The first few
  ** calls to sqlite3OsSleep() have a delay of 1 microsecond.  Really this
  ** is more of a scheduler yield than an actual delay.  But on the 10th
  ** an subsequent retries, the delays start becoming longer and longer, 
  ** so that on the 100th (and last) RETRY we delay for 323 milliseconds.
  ** The total delay time before giving up is less than 10 seconds.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>&gt;</operator><literal type="number">5</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nDelay</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                      <comment type="block">/* Pause time in microseconds */</comment>
    <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>&gt;</operator><literal type="number">100</literal></expr> )</condition><block>{<block_content>
      <macro><name>VVA_ONLY</name><argument_list>( <argument>pWal-&gt;lockError = <literal type="number">1</literal>;</argument> )</argument_list></macro>
      <return>return <expr><name>SQLITE_PROTOCOL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>&gt;=</operator><literal type="number">10</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nDelay</name> <operator>=</operator> <operator>(</operator><name>cnt</name><operator>-</operator><literal type="number">9</literal><operator>)</operator><operator>*</operator><operator>(</operator><name>cnt</name><operator>-</operator><literal type="number">9</literal><operator>)</operator><operator>*</operator><literal type="number">39</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3OsSleep</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name>nDelay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>useWal</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>bShmUnreliable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walIndexReadHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>pChanged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If there is not a recovery running in another thread or process
      ** then convert BUSY errors to WAL_RETRY.  If recovery is known to
      ** be running, convert BUSY to BUSY_RECOVERY.  There is a race here
      ** which might cause WAL_RETRY to be returned even if BUSY_RECOVERY
      ** would be technically correct.  But the race is benign since with
      ** WAL_RETRY this routine will be called again and will probably be
      ** right on the second iteration.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* This branch is taken when the xShmMap() method returns SQLITE_BUSY.
        ** We assume this is a transient condition, so return WAL_RETRY. The
        ** xShmMap() implementation used by the default unix and win32 VFS 
        ** modules may return SQLITE_BUSY due to a race condition in the 
        ** code that determines whether or not the shared-memory region 
        ** must be zeroed before the requested page is returned.
        */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>WAL_RETRY</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>walLockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_RECOVER_LOCK</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>walUnlockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_RECOVER_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>WAL_RETRY</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY_RECOVERY</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>bShmUnreliable</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>walBeginShmUnreliable</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>pChanged</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>nWiData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>apWiData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <call><name>walCkptInfo</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>useWal</name> <operator>&amp;&amp;</operator> <call><name>AtomicLoad</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfill</name></name></expr></argument>)</argument_list></call><operator>==</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SNAPSHOT</name></cpp:ifdef>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>pSnapshot</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  )</condition><block>{<block_content>
    <comment type="block">/* The WAL has been completely backfilled (or it is empty).
    ** and can be safely ignored.
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>walShmBarrier</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>walIndexHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* It is not safe to allow the reader to continue here if frames
        ** may have been appended to the log before READ_LOCK(0) was obtained.
        ** When holding READ_LOCK(0), the reader ignores the entire log file,
        ** which implies that the database file contains a trustworthy
        ** snapshot. Since holding READ_LOCK(0) prevents a checkpoint from
        ** happening, this is usually correct.
        **
        ** However, if frames have been appended to the log (or if the log 
        ** is wrapped and written for that matter) before the READ_LOCK(0)
        ** is obtained, that is not necessarily true. A checkpointer may
        ** have started to backfill the appended frames but crashed before
        ** it finished. Leaving a corrupt image in the database file.
        */</comment>
        <expr_stmt><expr><call><name>walUnlockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>WAL_RETRY</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we get this far, it means that the reader will want to use
  ** the WAL to get at content from recent commits.  The job now is
  ** to select one of the aReadMark[] entries that is closest to
  ** but not exceeding pWal-&gt;hdr.mxFrame and lock that entry.
  */</comment>
  <expr_stmt><expr><name>mxReadMark</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>mxI</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>mxFrame</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SNAPSHOT</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>pSnapshot</name></name> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>pSnapshot</name><operator>-&gt;</operator><name>mxFrame</name></name><operator>&lt;</operator><name>mxFrame</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>mxFrame</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>pSnapshot</name><operator>-&gt;</operator><name>mxFrame</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>WAL_NREADER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>thisMark</name> <init>= <expr><call><name>AtomicLoad</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aReadMark</name></name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>mxReadMark</name><operator>&lt;=</operator><name>thisMark</name> <operator>&amp;&amp;</operator> <name>thisMark</name><operator>&lt;=</operator><name>mxFrame</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>thisMark</name><operator>!=</operator><name>READMARK_NOT_USED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mxReadMark</name> <operator>=</operator> <name>thisMark</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mxI</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>&amp;</operator> <name>WAL_SHM_RDONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>mxReadMark</name><operator>&lt;</operator><name>mxFrame</name> <operator>||</operator> <name>mxI</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>WAL_NREADER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>AtomicStore</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aReadMark</name></name><operator>+</operator><name>i</name></expr></argument>,<argument><expr><name>mxFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mxReadMark</name> <operator>=</operator> <name>mxFrame</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mxI</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>walUnlockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>mxI</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name> <operator>||</operator> <operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>&amp;</operator> <name>WAL_SHM_RDONLY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> ?</condition><then> <expr><name>WAL_RETRY</name></expr> </then><else>: <expr><name>SQLITE_READONLY_CANTINIT</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><name>mxI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> ?</condition><then> <expr><name>WAL_RETRY</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Now that the read-lock has been obtained, check that neither the
  ** value in the aReadMark[] array or the contents of the wal-index
  ** header have changed.
  **
  ** It is necessary to check that the wal-index header did not change
  ** between the time it was read and when the shared-lock was obtained
  ** on WAL_READ_LOCK(mxI) was obtained to account for the possibility
  ** that the log file may have been wrapped by a writer, or that frames
  ** that occur later in the log than pWal-&gt;hdr.mxFrame may have been
  ** copied into the database by a checkpointer. If either of these things
  ** happened, then reading the database with the current value of
  ** pWal-&gt;hdr.mxFrame risks reading a corrupted snapshot. So, retry
  ** instead.
  **
  ** Before checking that the live wal-index header has not changed
  ** since it was read, set Wal.minFrame to the first frame in the wal
  ** file that has not yet been checkpointed. This client will not need
  ** to read any frames earlier than minFrame from the wal file - they
  ** can be safely read directly from the database file.
  **
  ** Because a ShmBarrier() call is made between taking the copy of 
  ** nBackfill and checking that the wal-header in shared-memory still
  ** matches the one cached in pWal-&gt;hdr, it is guaranteed that the 
  ** checkpointer that set nBackfill was not working with a wal-index
  ** header newer than that cached in pWal-&gt;hdr. If it were, that could
  ** cause a problem. The checkpointer could omit to checkpoint
  ** a version of page X that lies before pWal-&gt;minFrame (call that version
  ** A) on the basis that there is a newer version (version B) of the same
  ** page later in the wal file. But if version B happens to like past
  ** frame pWal-&gt;hdr.mxFrame - then the client would incorrectly assume
  ** that it can read version A from the database file. However, since
  ** we can guarantee that the checkpointer that set nBackfill could not
  ** see any pages past pWal-&gt;hdr.mxFrame, this problem does not come up.
  */</comment>
  <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>minFrame</name></name> <operator>=</operator> <call><name>AtomicLoad</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfill</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>walShmBarrier</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>AtomicLoad</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aReadMark</name></name><operator>+</operator><name>mxI</name></expr></argument>)</argument_list></call><operator>!=</operator><name>mxReadMark</name>
   <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>walIndexHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>walUnlockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><name>mxI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>WAL_RETRY</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>mxReadMark</name><operator>&lt;=</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name> <operator>=</operator> <operator>(</operator><name>i16</name><operator>)</operator><name>mxI</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SNAPSHOT</name></cpp:ifdef>
<comment type="block">/*
** Attempt to reduce the value of the WalCkptInfo.nBackfillAttempted 
** variable so that older snapshots can be accessed. To do this, loop
** through all wal frames from nBackfillAttempted to (nBackfill+1), 
** comparing their content to the corresponding page with the database
** file, if any. Set nBackfillAttempted to the frame number of the
** first frame for which the wal file content matches the db file.
**
** This is only really safe if the file-system is such that any page 
** writes made by earlier checkpointers were atomic operations, which 
** is not always true. It is also possible that nBackfillAttempted
** may be left set to a value larger than expected, if a wal frame
** contains content that duplicate of an earlier version of the same
** page.
**
** SQLITE_OK is returned if successful, or an SQLite error code if an
** error occurs. It is not an error if nBackfillAttempted cannot be
** decreased at all.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalSnapshotRecover</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_CKPT_LOCK</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>WalCkptInfo</name> <modifier>*</modifier></type><name>pInfo</name> <init>= <expr><call><name>walCkptInfo</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>szPage</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>szDb</name></decl>;</decl_stmt>                   <comment type="block">/* Size of db file in bytes */</comment>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>szDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf1</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>szPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf2</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>szPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBuf1</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pBuf2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>u32</name></type> <name>i</name> <init>= <expr><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfillAttempted</name></name></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfillAttempted</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><call><name>AtomicLoad</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfill</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>WalHashLoc</name></type> <name>sLoc</name></decl>;</decl_stmt>          <comment type="block">/* Hash table location */</comment>
          <decl_stmt><decl><type><name>u32</name></type> <name>pgno</name></decl>;</decl_stmt>                 <comment type="block">/* Page number in db file */</comment>
          <decl_stmt><decl><type><name>i64</name></type> <name>iDbOff</name></decl>;</decl_stmt>               <comment type="block">/* Offset of db file entry */</comment>
          <decl_stmt><decl><type><name>i64</name></type> <name>iWalOff</name></decl>;</decl_stmt>              <comment type="block">/* Offset of wal file entry */</comment>

          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walHashGet</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>walFramePage</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name> <operator>-</operator> <name><name>sLoc</name><operator>.</operator><name>iZero</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pgno</name> <operator>=</operator> <name><name>sLoc</name><operator>.</operator><name>aPgno</name><index>[<expr><name>i</name><operator>-</operator><name><name>sLoc</name><operator>.</operator><name>iZero</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>iDbOff</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><name>pgno</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>szPage</name></expr>;</expr_stmt>

          <if_stmt><if>if<condition>( <expr><name>iDbOff</name><operator>+</operator><name>szPage</name><operator>&lt;=</operator><name>szDb</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>iWalOff</name> <operator>=</operator> <call><name>walFrameOffset</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>WAL_FRAME_HDRSIZE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><name>pBuf1</name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>, <argument><expr><name>iWalOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><name>pBuf2</name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>, <argument><expr><name>iDbOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>pBuf1</name></expr></argument>, <argument><expr><name>pBuf2</name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfillAttempted</name></name> <operator>=</operator> <name>i</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pBuf1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pBuf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>walUnlockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_CKPT_LOCK</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_SNAPSHOT */</comment>

<comment type="block">/*
** Begin a read transaction on the database.
**
** This routine used to be called sqlite3OpenSnapshot() and with good reason:
** it takes a snapshot of the state of the WAL and wal-index for the current
** instant in time.  The current thread will continue to use this snapshot.
** Other threads might append new content to the WAL and wal-index but
** that extra content is ignored by the current thread.
**
** If the database contents have changes since the previous read
** transaction, then *pChanged is set to 1 before returning.  The
** Pager layer will use this to know that its cache is stale and
** needs to be flushed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalBeginReadTransaction</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pChanged</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Number of TryBeginRead attempts */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SNAPSHOT</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>bChanged</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WalIndexHdr</name> <modifier>*</modifier></type><name>pSnapshot</name> <init>= <expr><name><name>pWal</name><operator>-&gt;</operator><name>pSnapshot</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>ckptLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SNAPSHOT</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>pSnapshot</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>pSnapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bChanged</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* It is possible that there is a checkpointer thread running 
    ** concurrent with this code. If this is the case, it may be that the
    ** checkpointer has already determined that it will checkpoint 
    ** snapshot X, where X is later in the wal file than pSnapshot, but 
    ** has not yet set the pInfo-&gt;nBackfillAttempted variable to indicate 
    ** its intent. To avoid the race condition this leads to, ensure that
    ** there is no checkpointer process by taking a shared CKPT lock 
    ** before checking pInfo-&gt;nBackfillAttempted.  */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>walEnableBlocking</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_CKPT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>walDisableBlocking</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>ckptLock</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <do>do<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walTryBeginRead</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>pChanged</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>++</operator><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>WAL_RETRY</name></expr> )</condition>;</do>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_BUSY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_IOERR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_PROTOCOL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SNAPSHOT</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pSnapshot</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>pSnapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* At this point the client has a lock on an aReadMark[] slot holding
      ** a value equal to or smaller than pSnapshot-&gt;mxFrame, but pWal-&gt;hdr
      ** is populated with the wal-index header corresponding to the head
      ** of the wal file. Verify that pSnapshot is still valid before
      ** continuing.  Reasons why pSnapshot might no longer be valid:
      **
      **    (1)  The WAL file has been reset since the snapshot was taken.
      **         In this case, the salt will have changed.
      **
      **    (2)  A checkpoint as been attempted that wrote frames past
      **         pSnapshot-&gt;mxFrame into the database file.  Note that the
      **         checkpoint need not have completed for this to cause problems.
      */</comment>
      <decl_stmt><decl><type><specifier>volatile</specifier> <name>WalCkptInfo</name> <modifier>*</modifier></type><name>pInfo</name> <init>= <expr><call><name>walCkptInfo</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aReadMark</name><index>[<expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name></expr>]</index></name><operator>&lt;=</operator><name><name>pSnapshot</name><operator>-&gt;</operator><name>mxFrame</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Check that the wal file has not been wrapped. Assuming that it has
      ** not, also check that no checkpointer has attempted to checkpoint any
      ** frames beyond pSnapshot-&gt;mxFrame. If either of these conditions are
      ** true, return SQLITE_ERROR_SNAPSHOT. Otherwise, overwrite pWal-&gt;hdr
      ** with *pSnapshot and set *pChanged as appropriate for opening the
      ** snapshot.  */</comment>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>pSnapshot</name><operator>-&gt;</operator><name>aSalt</name></name></expr></argument>, <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aSalt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aSalt</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
       <operator>&amp;&amp;</operator> <name><name>pSnapshot</name><operator>-&gt;</operator><name>mxFrame</name></name><operator>&gt;=</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfillAttempted</name></name></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><name>pSnapshot</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pChanged</name> <operator>=</operator> <name>bChanged</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR_SNAPSHOT</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* A client using a non-current snapshot may not ignore any frames
      ** from the start of the wal file. This is because, for a system
      ** where (minFrame &lt; iSnapshot &lt; maxFrame), a checkpointer may
      ** have omitted to checkpoint a frame earlier than minFrame in 
      ** the file because there exists a frame after iSnapshot that
      ** is the same database page.  */</comment>
      <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>minFrame</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3WalEndReadTransaction</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Release the shared CKPT lock obtained above. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>ckptLock</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSnapshot</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>walUnlockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_CKPT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>ckptLock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Finish with a read transaction.  All this does is release the
** read-lock.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WalEndReadTransaction</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3WalEndWriteTransaction</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>walUnlockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Search the wal file for page pgno. If found, set *piRead to the frame that
** contains the page. Otherwise, if pgno is not in the wal file, set *piRead
** to zero.
**
** Return SQLITE_OK if successful, or an error code if an error occurs. If an
** error does occur, the final value of *piRead is undefined.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalFindFrame</name><parameter_list>(
  <parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>,                      <comment type="block">/* WAL handle */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>,                      <comment type="block">/* Database page number to read data for */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>piRead</name></decl></parameter>                     <comment type="block">/* OUT: Frame number (or zero) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>iRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* If !=0, WAL frame to return data from */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iLast</name> <init>= <expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Last page in WAL for this reader */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iHash</name></decl>;</decl_stmt>                      <comment type="block">/* Used to loop through N hash tables */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iMinHash</name></decl>;</decl_stmt>

  <comment type="block">/* This routine is only be called from within a read transaction. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pWal</name><operator>-&gt;</operator><name>lockError</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the "last page" field of the wal-index header snapshot is 0, then
  ** no data will be read from the wal under any circumstances. Return early
  ** in this case as an optimization.  Likewise, if pWal-&gt;readLock==0, 
  ** then the WAL is ignored by the reader so return early, as if the 
  ** WAL were empty.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>iLast</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>bShmUnreliable</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>piRead</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Search the hash table or tables for an entry matching page number
  ** pgno. Each iteration of the following for() loop searches one
  ** hash table (each hash table indexes up to HASHTABLE_NPAGE frames).
  **
  ** This code might run concurrently to the code in walIndexAppend()
  ** that adds entries to the wal-index (and possibly to this hash 
  ** table). This means the value just read from the hash 
  ** slot (aHash[iKey]) may have been added before or after the 
  ** current read transaction was opened. Values added after the
  ** read transaction was opened may have been written incorrectly -
  ** i.e. these slots may contain garbage data. However, we assume
  ** that any slots written before the current read transaction was
  ** opened remain unmodified.
  **
  ** For the reasons above, the if(...) condition featured in the inner
  ** loop of the following block is more stringent that would be required 
  ** if we had exclusive access to the hash-table:
  **
  **   (aPgno[iFrame]==pgno): 
  **     This condition filters out normal hash-table collisions.
  **
  **   (iFrame&lt;=iLast): 
  **     This condition filters out entries that were added to the hash
  **     table after the current read-transaction had started.
  */</comment>
  <expr_stmt><expr><name>iMinHash</name> <operator>=</operator> <call><name>walFramePage</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>minFrame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>iHash</name><operator>=</operator><call><name>walFramePage</name><argument_list>(<argument><expr><name>iLast</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>iHash</name><operator>&gt;=</operator><name>iMinHash</name></expr>;</condition> <incr><expr><name>iHash</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>WalHashLoc</name></type> <name>sLoc</name></decl>;</decl_stmt>              <comment type="block">/* Hash table location */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iKey</name></decl>;</decl_stmt>                     <comment type="block">/* Hash slot index */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nCollide</name></decl>;</decl_stmt>                 <comment type="block">/* Number of hash collisions remaining */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                       <comment type="block">/* Error code */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>iH</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walHashGet</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nCollide</name> <operator>=</operator> <name>HASHTABLE_NSLOT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iKey</name> <operator>=</operator> <call><name>walHash</name><argument_list>(<argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>iH</name> <operator>=</operator> <call><name>AtomicLoad</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sLoc</name><operator>.</operator><name>aHash</name><index>[<expr><name>iKey</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iFrame</name> <init>= <expr><name>iH</name> <operator>+</operator> <name><name>sLoc</name><operator>.</operator><name>iZero</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iFrame</name><operator>&lt;=</operator><name>iLast</name> <operator>&amp;&amp;</operator> <name>iFrame</name><operator>&gt;=</operator><name><name>pWal</name><operator>-&gt;</operator><name>minFrame</name></name> <operator>&amp;&amp;</operator> <name><name>sLoc</name><operator>.</operator><name>aPgno</name><index>[<expr><name>iH</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>pgno</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iFrame</name><operator>&gt;</operator><name>iRead</name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iRead</name> <operator>=</operator> <name>iFrame</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nCollide</name><operator>--</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>iKey</name> <operator>=</operator> <call><name>walNextHash</name><argument_list>(<argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>iRead</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPENSIVE_ASSERT</name></cpp:ifdef>
  <comment type="block">/* If expensive assert() statements are available, do a linear search
  ** of the wal-index file content. Make sure the results agree with the
  ** result obtained using the hash indexes above.  */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>iRead2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>iTest</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>bShmUnreliable</name></name> <operator>||</operator> <name><name>pWal</name><operator>-&gt;</operator><name>minFrame</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>iTest</name><operator>=</operator><name>iLast</name></expr>;</init> <condition><expr><name>iTest</name><operator>&gt;=</operator><name><name>pWal</name><operator>-&gt;</operator><name>minFrame</name></name> <operator>&amp;&amp;</operator> <name>iTest</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>iTest</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>walFramePgno</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iTest</name></expr></argument>)</argument_list></call><operator>==</operator><name>pgno</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iRead2</name> <operator>=</operator> <name>iTest</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iRead</name><operator>==</operator><name>iRead2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><operator>*</operator><name>piRead</name> <operator>=</operator> <name>iRead</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read the contents of frame iRead from the wal file into buffer pOut
** (which is nOut bytes in size). Return SQLITE_OK if successful, or an
** error code otherwise.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalReadFrame</name><parameter_list>(
  <parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>,                      <comment type="block">/* WAL handle */</comment>
  <parameter><decl><type><name>u32</name></type> <name>iRead</name></decl></parameter>,                      <comment type="block">/* Frame to read */</comment>
  <parameter><decl><type><name>int</name></type> <name>nOut</name></decl></parameter>,                       <comment type="block">/* Size of buffer pOut in bytes */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>                        <comment type="block">/* Buffer to write page data to */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iOffset</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>szPage</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sz</name> <operator>=</operator> <operator>(</operator><name>sz</name><operator>&amp;</operator><literal type="number">0xfe00</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>sz</name><operator>&amp;</operator><literal type="number">0x0001</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>sz</name><operator>&lt;=</operator><literal type="number">32768</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>sz</name><operator>&gt;=</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iOffset</name> <operator>=</operator> <call><name>walFrameOffset</name><argument_list>(<argument><expr><name>iRead</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>WAL_FRAME_HDRSIZE</name></expr>;</expr_stmt>
  <comment type="block">/* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL */</comment>
  <return>return <expr><call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>nOut</name><operator>&gt;</operator><name>sz</name></expr> ?</condition><then> <expr><name>sz</name></expr> </then><else>: <expr><name>nOut</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Return the size of the database in pages (or zero, if unknown).
*/</comment>
<function><type><name>Pgno</name></type> <name>sqlite3WalDbsize</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pWal</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nPage</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* 
** This function starts a write transaction on the WAL.
**
** A read transaction must have already been started by a prior call
** to sqlite3WalBeginReadTransaction().
**
** If another thread or process has written into the database since
** the read transaction was started, then it is not possible for this
** thread to write as doing so would cause a fork.  So this routine
** returns SQLITE_BUSY in that case and no write transaction is started.
**
** There can only be a single writer active at a time.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalBeginWriteTransaction</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SETLK_TIMEOUT</name></cpp:ifdef>
  <comment type="block">/* If the write-lock is already held, then it was obtained before the
  ** read-transaction was even opened, making this call a no-op.
  ** Return early. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>,<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>walIndexHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Cannot start a write transaction without first holding a read
  ** transaction. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>iReCksum</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>readOnly</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_READONLY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Only one writer allowed at a time.  Get the write lock.  Return
  ** SQLITE_BUSY if unable.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_WRITE_LOCK</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <comment type="block">/* If another connection has written to the database file since the
  ** time the read transaction on this connection was started, then
  ** the write is disallowed.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>walIndexHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>walUnlockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_WRITE_LOCK</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY_SNAPSHOT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** End a write transaction.  The commit has already been done.  This
** routine merely releases the lock.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalEndWriteTransaction</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>walUnlockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_WRITE_LOCK</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>iReCksum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>truncateOnCommit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If any data has been written (but not committed) to the log file, this
** function moves the write-pointer back to the start of the transaction.
**
** Additionally, the callback function is invoked for each frame written
** to the WAL since the start of the transaction. If the callback returns
** other than SQLITE_OK, it is not invoked again and the error code is
** returned to the caller.
**
** Otherwise, if the callback function does not return an error, this
** function returns SQLITE_OK.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalUndo</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xUndo</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Pgno</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUndoCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>iMax</name> <init>= <expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>iFrame</name></decl>;</decl_stmt>
  
    <comment type="block">/* Restore the clients cache of the wal-index header to the state it
    ** was in before the client began writing to the database. 
    */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>walIndexHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>iFrame</name><operator>=</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name><operator>+</operator><literal type="number">1</literal></expr>;</init> 
        <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>iFrame</name><operator>&lt;=</operator><name>iMax</name></expr>;</condition> 
        <incr><expr><name>iFrame</name><operator>++</operator></expr></incr>
    )</control><block>{<block_content>
      <comment type="block">/* This call cannot fail. Unless the page for which the page number
      ** is passed as the second argument is (a) in the cache and 
      ** (b) has an outstanding reference, then xUndo is either a no-op
      ** (if (a) is false) or simply expels the page from the cache (if (b)
      ** is false).
      **
      ** If the upper layer is doing a rollback, it is guaranteed that there
      ** are no outstanding references to any page other than page 1. And
      ** page 1 is never written to the log until the transaction is
      ** committed. As a result, the call to xUndo may not fail.
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>walFramePgno</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iFrame</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xUndo</name><argument_list>(<argument><expr><name>pUndoCtx</name></expr></argument>, <argument><expr><call><name>walFramePgno</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>iMax</name><operator>!=</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>walCleanupHash</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Argument aWalData must point to an array of WAL_SAVEPOINT_NDATA u32 
** values. This function populates the array with values required to 
** "rollback" the write position of the WAL handle back to the current 
** point in the event of a savepoint rollback (via WalSavepointUndo()).
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WalSavepoint</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>aWalData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aWalData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aWalData</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aWalData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aWalData</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>nCkpt</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** Move the write position of the WAL back to the point identified by
** the values in the aWalData[] array. aWalData must point to an array
** of WAL_SAVEPOINT_NDATA u32 values that has been previously populated
** by a call to WalSavepoint().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalSavepointUndo</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>aWalData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aWalData</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>!=</operator><name><name>pWal</name><operator>-&gt;</operator><name>nCkpt</name></name> <operator>||</operator> <name><name>aWalData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;=</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>aWalData</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>!=</operator><name><name>pWal</name><operator>-&gt;</operator><name>nCkpt</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This savepoint was opened immediately after the write-transaction
    ** was started. Right after that, the writer decided to wrap around
    ** to the start of the log. Update the savepoint values to match.
    */</comment>
    <expr_stmt><expr><name><name>aWalData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aWalData</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>nCkpt</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>aWalData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name> <operator>=</operator> <name><name>aWalData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>aWalData</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>aWalData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>walCleanupHash</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called just before writing a set of frames to the log
** file (see sqlite3WalFrames()). It checks to see if, instead of appending
** to the current log file, it is possible to overwrite the start of the
** existing log file with the new frames (i.e. "reset" the log). If so,
** it sets pWal-&gt;hdr.mxFrame to 0. Otherwise, pWal-&gt;hdr.mxFrame is left
** unchanged.
**
** SQLITE_OK is returned if no error is encountered (regardless of whether
** or not pWal-&gt;hdr.mxFrame is modified). An SQLite error code is returned
** if an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walRestartLog</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>WalCkptInfo</name> <modifier>*</modifier></type><name>pInfo</name> <init>= <expr><call><name>walCkptInfo</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfill</name></name><operator>==</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>nBackfill</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>salt1</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>salt1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>WAL_NREADER</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* If all readers are using WAL_READ_LOCK(0) (in other words if no
        ** readers are currently using the WAL), then the transactions
        ** frames will overwrite the start of the existing log. Update the
        ** wal-index header to reflect this.
        **
        ** In theory it would be Ok to update the cache of the header only
        ** at this point. But updating the actual wal-index header is also
        ** safe and means there is no special case for sqlite3WalUndo()
        ** to handle if this transaction is rolled back.  */</comment>
        <expr_stmt><expr><call><name>walRestartHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>salt1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>walUnlockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>WAL_NREADER</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>walUnlockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>notUsed</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walTryBeginRead</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>notUsed</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>++</operator><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>WAL_RETRY</name></expr> )</condition>;</do>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>!=</operator><name>SQLITE_BUSY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* BUSY not possible when useWal==1 */</comment>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_IOERR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_PROTOCOL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Information about the current state of the WAL file and where
** the next fsync should occur - passed from sqlite3WalFrames() into
** walWriteToLog().
*/</comment>
<typedef>typedef <type><struct>struct <name>WalWriter</name> <block>{
  <decl_stmt><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl>;</decl_stmt>                   <comment type="block">/* The complete WAL information */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl>;</decl_stmt>           <comment type="block">/* The WAL file to which we write */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iSyncPoint</name></decl>;</decl_stmt>    <comment type="block">/* Fsync at this offset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>syncFlags</name></decl>;</decl_stmt>               <comment type="block">/* Flags for the fsync */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szPage</name></decl>;</decl_stmt>                  <comment type="block">/* Size of one page */</comment>
}</block></struct></type> <name>WalWriter</name>;</typedef>

<comment type="block">/*
** Write iAmt bytes of content into the WAL file beginning at iOffset.
** Do a sync when crossing the p-&gt;iSyncPoint boundary.
**
** In other words, if iSyncPoint is in between iOffset and iOffset+iAmt,
** first write the part before iSyncPoint, then sync, then write the
** rest.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walWriteToLog</name><parameter_list>(
  <parameter><decl><type><name>WalWriter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,              <comment type="block">/* WAL to write to */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pContent</name></decl></parameter>,            <comment type="block">/* Content to be written */</comment>
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>,                  <comment type="block">/* Number of bytes to write */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOffset</name></decl></parameter>      <comment type="block">/* Start writing at this offset */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iOffset</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>iSyncPoint</name></name> <operator>&amp;&amp;</operator> <name>iOffset</name><operator>+</operator><name>iAmt</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>iSyncPoint</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iFirstAmt</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iSyncPoint</name></name> <operator>-</operator> <name>iOffset</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFd</name></name></expr></argument>, <argument><expr><name>pContent</name></expr></argument>, <argument><expr><name>iFirstAmt</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>iOffset</name> <operator>+=</operator> <name>iFirstAmt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iAmt</name> <operator>-=</operator> <name>iFirstAmt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pContent</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>iFirstAmt</name> <operator>+</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pContent</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>WAL_SYNC_FLAGS</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>syncFlags</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFd</name></name></expr></argument>, <argument><expr><call><name>WAL_SYNC_FLAGS</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>syncFlags</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iAmt</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFd</name></name></expr></argument>, <argument><expr><name>pContent</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write out a single frame of the WAL
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walWriteOneFrame</name><parameter_list>(
  <parameter><decl><type><name>WalWriter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,               <comment type="block">/* Where to write the frame */</comment>
  <parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>,               <comment type="block">/* The page of the frame to be written */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTruncate</name></decl></parameter>,              <comment type="block">/* The commit flag.  Usually 0.  &gt;0 for commit */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOffset</name></decl></parameter>       <comment type="block">/* Byte offset at which to write */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Result code from subfunctions */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>                    <comment type="block">/* Data actually written */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>aFrame</name><index>[<expr><name>WAL_FRAME_HDRSIZE</name></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* Buffer to assemble frame-header in */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAS_CODEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pData</name> <operator>=</operator> <call><name>sqlcipherPagerCodec</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>pData</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pData</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>walEncodeFrame</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><name>nTruncate</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walWriteToLog</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <comment type="block">/* Write the page data */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walWriteToLog</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>szPage</name></name></expr></argument>, <argument><expr><name>iOffset</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called as part of committing a transaction within which
** one or more frames have been overwritten. It updates the checksums for
** all frames written to the wal file by the current transaction starting
** with the earliest to have been overwritten.
**
** SQLITE_OK is returned if successful, or an SQLite error code otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walRewriteChecksums</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iLast</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>szPage</name> <init>= <expr><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name></expr></init></decl>;</decl_stmt><comment type="block">/* Database page size */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl>;</decl_stmt>                       <comment type="block">/* Buffer to load data from wal file into */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>aFrame</name><index>[<expr><name>WAL_FRAME_HDRSIZE</name></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* Buffer to assemble frame-headers in */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iRead</name></decl>;</decl_stmt>                      <comment type="block">/* Next frame to read from wal file */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iCksumOff</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>aBuf</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>szPage</name> <operator>+</operator> <name>WAL_FRAME_HDRSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Find the checksum values to use as input for the recalculating the
  ** first checksum. If the first frame is frame 1 (implying that the current
  ** transaction restarted the wal file), these values must be read from the
  ** wal-file header. Otherwise, read them from the frame header of the
  ** previous frame.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>iReCksum</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>iReCksum</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iCksumOff</name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iCksumOff</name> <operator>=</operator> <call><name>walFrameOffset</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>iReCksum</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>szPage</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">16</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>iCksumOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iRead</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>iReCksum</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>iReCksum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iRead</name><operator>&lt;=</operator><name>iLast</name></expr>;</condition> <incr><expr><name>iRead</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name> <init>= <expr><call><name>walFrameOffset</name><argument_list>(<argument><expr><name>iRead</name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>szPage</name><operator>+</operator><name>WAL_FRAME_HDRSIZE</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iPgno</name></decl>, <decl><type ref="prev"/><name>nDbSize</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>iPgno</name> <operator>=</operator> <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nDbSize</name> <operator>=</operator> <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>walEncodeFrame</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iPgno</name></expr></argument>, <argument><expr><name>nDbSize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><name>WAL_FRAME_HDRSIZE</name></expr>]</index></name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Write a set of frames to the log. The caller must hold the write-lock
** on the log file (obtained using sqlite3WalBeginWriteTransaction()).
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalFrames</name><parameter_list>(
  <parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>,                      <comment type="block">/* Wal handle to write to */</comment>
  <parameter><decl><type><name>int</name></type> <name>szPage</name></decl></parameter>,                     <comment type="block">/* Database page-size in bytes */</comment>
  <parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,                   <comment type="block">/* List of dirty pages to write */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>nTruncate</name></decl></parameter>,                 <comment type="block">/* Database size after this commit */</comment>
  <parameter><decl><type><name>int</name></type> <name>isCommit</name></decl></parameter>,                   <comment type="block">/* True if this is a commit */</comment>
  <parameter><decl><type><name>int</name></type> <name>sync_flags</name></decl></parameter>                  <comment type="block">/* Flags to pass to OsSync() (or 0) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Used to catch return codes */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iFrame</name></decl>;</decl_stmt>                     <comment type="block">/* Next frame address */</comment>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                       <comment type="block">/* Iterator to run through pList with. */</comment>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pLast</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Last frame in list */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nExtra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Number of extra copies of last page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szFrame</name></decl>;</decl_stmt>                    <comment type="block">/* The size of a single frame */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iOffset</name></decl>;</decl_stmt>                    <comment type="block">/* Next byte to write in WAL file */</comment>
  <decl_stmt><decl><type><name>WalWriter</name></type> <name>w</name></decl>;</decl_stmt>                    <comment type="block">/* The writer */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iFirst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* First frame that may be overwritten */</comment>
  <decl_stmt><decl><type><name>WalIndexHdr</name> <modifier>*</modifier></type><name>pLive</name></decl>;</decl_stmt>             <comment type="block">/* Pointer to shared header */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this frame set completes a transaction, then nTruncate&gt;0.  If
  ** nTruncate==0 then this frame set does not complete the transaction. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>isCommit</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>nTruncate</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <block>{<block_content> <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt> <for>for<control>(<init><expr><name>cnt</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name><operator>=</operator><name>pList</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr><operator>,</operator> <expr><name>cnt</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <expr_stmt><expr><call><name>WALTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WAL%p: frame write begin. %d frames. mxFrame=%d. %s\n"</literal><operator>,</operator>
              <name>pWal</name><operator>,</operator> <name>cnt</name><operator>,</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name><operator>,</operator> <ternary><condition><expr><name>isCommit</name></expr> ?</condition><then> <expr><literal type="string">"Commit"</literal></expr> </then><else>: <expr><literal type="string">"Spill"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>pLive</name> <operator>=</operator> <operator>(</operator><name>WalIndexHdr</name><operator>*</operator><operator>)</operator><call><name>walIndexHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pLive</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iFirst</name> <operator>=</operator> <name><name>pLive</name><operator>-&gt;</operator><name>mxFrame</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* See if it is possible to write these frames into the start of the
  ** log file, instead of appending to it at pWal-&gt;hdr.mxFrame.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>walRestartLog</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If this is the first frame written into the log, write the WAL
  ** header to the start of the WAL file. See comments at the top of
  ** this source file for a description of the WAL header format.
  */</comment>
  <expr_stmt><expr><name>iFrame</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iFrame</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name><name>aWalHdr</name><index>[<expr><name>WAL_HDRSIZE</name></expr>]</index></name></decl>;</decl_stmt>      <comment type="block">/* Buffer to assemble wal-header in */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name><name>aCksum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>                <comment type="block">/* Checksum for wal-header */</comment>

    <expr_stmt><expr><call><name>sqlite3Put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aWalHdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>WAL_MAGIC</name> <operator>|</operator> <name>SQLITE_BIGENDIAN</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aWalHdr</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>WAL_MAX_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aWalHdr</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aWalHdr</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>nCkpt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>nCkpt</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aSalt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aWalHdr</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aSalt</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>walChecksumBytes</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>aWalHdr</name></expr></argument>, <argument><expr><name>WAL_HDRSIZE</name><operator>-</operator><literal type="number">2</literal><operator>*</operator><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aCksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aWalHdr</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>aCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Put4byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aWalHdr</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>aCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name> <operator>=</operator> <name>szPage</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>bigEndCksum</name></name> <operator>=</operator> <name>SQLITE_BIGENDIAN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>aCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>aCksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>truncateOnCommit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><name>aWalHdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aWalHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WALTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WAL%p: wal-header write %s\n"</literal><operator>,</operator> <name>pWal</name><operator>,</operator> <ternary><condition><expr><name>rc</name></expr> ?</condition><then> <expr><literal type="string">"failed"</literal></expr> </then><else>: <expr><literal type="string">"ok"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Sync the header (unless SQLITE_IOCAP_SEQUENTIAL is true or unless
    ** all syncing is turned off by PRAGMA synchronous=OFF).  Otherwise
    ** an out-of-order write following a WAL restart could result in
    ** database corruption.  See the ticket:
    **
    **     https://sqlite.org/src/info/ff5be73dee
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>syncHeader</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><call><name>CKPT_SYNC_FLAGS</name><argument_list>(<argument><expr><name>sync_flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name><operator>==</operator><name>szPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Setup information needed to write frames into the WAL */</comment>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pWal</name></name> <operator>=</operator> <name>pWal</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>pFd</name></name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>iSyncPoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>syncFlags</name></name> <operator>=</operator> <name>sync_flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>szPage</name></name> <operator>=</operator> <name>szPage</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iOffset</name> <operator>=</operator> <call><name>walFrameOffset</name><argument_list>(<argument><expr><name>iFrame</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>szPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>szFrame</name> <operator>=</operator> <name>szPage</name> <operator>+</operator> <name>WAL_FRAME_HDRSIZE</name></expr>;</expr_stmt>

  <comment type="block">/* Write all frames into the log file exactly once */</comment>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pList</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nDbSize</name></decl>;</decl_stmt>   <comment type="block">/* 0 normally.  Positive == commit flag */</comment>

    <comment type="block">/* Check if this page has already been written into the wal file by
    ** the current transaction. If so, overwrite the existing frame and
    ** set Wal.writeLock to WAL_WRITELOCK_RECKSUM - indicating that 
    ** checksums must be recomputed when the transaction is committed.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>iFirst</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>||</operator> <name>isCommit</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <macro><name>VVA_ONLY</name><argument_list>(<argument>rc =</argument>)</argument_list></macro> <expr_stmt><expr><call><name>sqlite3WalFindFrame</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>iWrite</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iWrite</name><operator>&gt;=</operator><name>iFirst</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name> <init>= <expr><call><name>walFrameOffset</name><argument_list>(<argument><expr><name>iWrite</name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>WAL_FRAME_HDRSIZE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>iReCksum</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iWrite</name><operator>&lt;</operator><name><name>pWal</name><operator>-&gt;</operator><name>iReCksum</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>iReCksum</name></name> <operator>=</operator> <name>iWrite</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAS_CODEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pData</name> <operator>=</operator> <call><name>sqlcipherPagerCodec</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>pData</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pData</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PGHDR_WAL_APPEND</name></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>iFrame</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iOffset</name><operator>==</operator><call><name>walFrameOffset</name><argument_list>(<argument><expr><name>iFrame</name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nDbSize</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>isCommit</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>nTruncate</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walWriteOneFrame</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nDbSize</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pLast</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOffset</name> <operator>+=</operator> <name>szFrame</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PGHDR_WAL_APPEND</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Recalculate checksums within the wal file if required. */</comment>
  <if_stmt><if>if<condition>( <expr><name>isCommit</name> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>iReCksum</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walRewriteChecksums</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If this is the end of a transaction, then we might need to pad
  ** the transaction and/or sync the WAL file.
  **
  ** Padding and syncing only occur if this set of frames complete a
  ** transaction and if PRAGMA synchronous=FULL.  If synchronous==NORMAL
  ** or synchronous==OFF, then no padding or syncing are needed.
  **
  ** If SQLITE_IOCAP_POWERSAFE_OVERWRITE is defined, then padding is not
  ** needed and only the sync is done.  If padding is needed, then the
  ** final frame is repeated (with its commit mark) until the next sector
  ** boundary is crossed.  Only the part of the WAL prior to the last
  ** sector boundary is synced; the part of the last frame that extends
  ** past the sector boundary is written after the sync.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isCommit</name> <operator>&amp;&amp;</operator> <call><name>WAL_SYNC_FLAGS</name><argument_list>(<argument><expr><name>sync_flags</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bSync</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>padToSectorBoundary</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>sectorSize</name> <init>= <expr><call><name>sqlite3SectorSize</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>w</name><operator>.</operator><name>iSyncPoint</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>iOffset</name><operator>+</operator><name>sectorSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><name>sectorSize</name><operator>)</operator><operator>*</operator><name>sectorSize</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>bSync</name> <operator>=</operator> <operator>(</operator><name><name>w</name><operator>.</operator><name>iSyncPoint</name></name><operator>==</operator><name>iOffset</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>bSync</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>iOffset</name><operator>&lt;</operator><name><name>w</name><operator>.</operator><name>iSyncPoint</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walWriteOneFrame</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pLast</name></expr></argument>, <argument><expr><name>nTruncate</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>iOffset</name> <operator>+=</operator> <name>szFrame</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nExtra</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLast</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>bSync</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name><name>w</name><operator>.</operator><name>pFd</name></name></expr></argument>, <argument><expr><call><name>WAL_SYNC_FLAGS</name><argument_list>(<argument><expr><name>sync_flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If this frame set completes the first transaction in the WAL and
  ** if PRAGMA journal_size_limit is set, then truncate the WAL to the
  ** journal size limit, if possible.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isCommit</name> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>truncateOnCommit</name></name> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>mxWalSize</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>sz</name> <init>= <expr><name><name>pWal</name><operator>-&gt;</operator><name>mxWalSize</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>walFrameOffset</name><argument_list>(<argument><expr><name>iFrame</name><operator>+</operator><name>nExtra</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>szPage</name></expr></argument>)</argument_list></call><operator>&gt;</operator><name><name>pWal</name><operator>-&gt;</operator><name>mxWalSize</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>walFrameOffset</name><argument_list>(<argument><expr><name>iFrame</name><operator>+</operator><name>nExtra</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>szPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>walLimitSize</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>truncateOnCommit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Append data to the wal-index. It is not necessary to lock the 
  ** wal-index to do this as the SQLITE_SHM_WRITE lock held on the wal-index
  ** guarantees that there are no other writers, and no data that may
  ** be in use by existing readers is being overwritten.
  */</comment>
  <expr_stmt><expr><name>iFrame</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pList</name></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_WAL_APPEND</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>iFrame</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walIndexAppend</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iFrame</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLast</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>nExtra</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nExtra</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iFrame</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>nExtra</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walIndexAppend</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>iFrame</name></expr></argument>, <argument><expr><name><name>pLast</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Update the private copy of the header. */</comment>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>szPage</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><operator>(</operator><name>szPage</name><operator>&amp;</operator><literal type="number">0xff00</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>szPage</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>szPage</name><operator>&lt;=</operator><literal type="number">32768</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>szPage</name><operator>&gt;=</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name> <operator>=</operator> <name>iFrame</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>isCommit</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>iChange</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nPage</name></name> <operator>=</operator> <name>nTruncate</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* If this is a commit, update the wal-index header too. */</comment>
    <if_stmt><if>if<condition>( <expr><name>isCommit</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>walIndexWriteHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>iCallback</name></name> <operator>=</operator> <name>iFrame</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>WALTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WAL%p: frame write %s\n"</literal><operator>,</operator> <name>pWal</name><operator>,</operator> <ternary><condition><expr><name>rc</name></expr> ?</condition><then> <expr><literal type="string">"failed"</literal></expr> </then><else>: <expr><literal type="string">"ok"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** This routine is called to implement sqlite3_wal_checkpoint() and
** related interfaces.
**
** Obtain a CHECKPOINT lock and then backfill as much information as
** we can from WAL into the database.
**
** If parameter xBusy is not NULL, it is a pointer to a busy-handler
** callback. In this case this function runs a blocking checkpoint.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalCheckpoint</name><parameter_list>(
  <parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>,                      <comment type="block">/* Wal connection */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Check this handle's interrupt flag */</comment>
  <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>,                      <comment type="block">/* PASSIVE, FULL, RESTART, or TRUNCATE */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xBusy</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,            <comment type="block">/* Function to call when busy */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBusyArg</name></decl></parameter>,                 <comment type="block">/* Context argument for xBusyHandler */</comment>
  <parameter><decl><type><name>int</name></type> <name>sync_flags</name></decl></parameter>,                 <comment type="block">/* Flags to sync db file with (or 0) */</comment>
  <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>,                       <comment type="block">/* Size of temporary buffer */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>,                       <comment type="block">/* Temporary buffer to use */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnLog</name></decl></parameter>,                     <comment type="block">/* OUT: Number of frames in WAL */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnCkpt</name></decl></parameter>                     <comment type="block">/* OUT: Number of backfilled frames in WAL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isChanged</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* True if a new wal-index header is loaded */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eMode2</name> <init>= <expr><name>eMode</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Mode to pass to walCheckpoint() */</comment>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xBusy2</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><name>xBusy</name></expr></init>;</function_decl>   <comment type="block">/* Busy handler for eMode2 */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>ckptLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* EVIDENCE-OF: R-62920-47450 The busy-handler callback is never invoked
  ** in the SQLITE_CHECKPOINT_PASSIVE mode. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMode</name><operator>!=</operator><name>SQLITE_CHECKPOINT_PASSIVE</name> <operator>||</operator> <name>xBusy</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>readOnly</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_READONLY</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>WALTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WAL%p: checkpoint begins\n"</literal><operator>,</operator> <name>pWal</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable blocking locks, if possible. If blocking locks are successfully
  ** enabled, set xBusy2=0 so that the busy-handler is never invoked. */</comment>
  <expr_stmt><expr><call><name>sqlite3WalDb</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>walEnableBlocking</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* IMPLEMENTATION-OF: R-62028-47212 All calls obtain an exclusive 
  ** "checkpoint" lock on the database file.
  ** EVIDENCE-OF: R-10421-19736 If any other process is running a
  ** checkpoint operation at the same time, the lock cannot be obtained and
  ** SQLITE_BUSY is returned.
  ** EVIDENCE-OF: R-53820-33897 Even if there is a busy-handler configured,
  ** it will not be invoked in this case.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_CKPT_LOCK</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>xBusy2</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>ckptLock</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* IMPLEMENTATION-OF: R-59782-36818 The SQLITE_CHECKPOINT_FULL, RESTART and
    ** TRUNCATE modes also obtain the exclusive "writer" lock on the database
    ** file.
    **
    ** EVIDENCE-OF: R-60642-04082 If the writer lock cannot be obtained
    ** immediately, and a busy-handler is configured, it is invoked and the
    ** writer lock retried until either the busy-handler returns 0 or the
    ** lock is successfully obtained.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>eMode</name><operator>!=</operator><name>SQLITE_CHECKPOINT_PASSIVE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walBusyLock</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>xBusy2</name></expr></argument>, <argument><expr><name>pBusyArg</name></expr></argument>, <argument><expr><name>WAL_WRITE_LOCK</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>eMode2</name> <operator>=</operator> <name>SQLITE_CHECKPOINT_PASSIVE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>xBusy2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>


  <comment type="block">/* Read the wal-index header. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>walDisableBlocking</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walIndexReadHdr</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isChanged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>walEnableBlocking</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>isChanged</name> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OsUnfetch</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>pDbFd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Copy data from the log to the database file. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>

    <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name> <operator>&amp;&amp;</operator> <call><name>walPagesize</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call><operator>!=</operator><name>nBuf</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walCheckpoint</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>eMode2</name></expr></argument>, <argument><expr><name>xBusy2</name></expr></argument>, <argument><expr><name>pBusyArg</name></expr></argument>, <argument><expr><name>sync_flags</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* If no error occurred, set the output variables. */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pnLog</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnLog</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>mxFrame</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pnCkpt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnCkpt</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>walCkptInfo</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nBackfill</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>isChanged</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If a new wal-index header was loaded before the checkpoint was 
    ** performed, then the pager-cache associated with pWal is now
    ** out of date. So zero the cached wal-index header to ensure that
    ** next time the pager opens a snapshot on this database it knows that
    ** the cache needs to be reset.
    */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>walDisableBlocking</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalDb</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Release the locks. */</comment>
  <expr_stmt><expr><call><name>sqlite3WalEndWriteTransaction</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>ckptLock</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>walUnlockExclusive</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_CKPT_LOCK</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>ckptLock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>WALTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WAL%p: checkpoint %s\n"</literal><operator>,</operator> <name>pWal</name><operator>,</operator> <ternary><condition><expr><name>rc</name></expr> ?</condition><then> <expr><literal type="string">"failed"</literal></expr> </then><else>: <expr><literal type="string">"ok"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SETLK_TIMEOUT</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY_TIMEOUT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>eMode</name><operator>!=</operator><name>eMode2</name></expr> ?</condition><then> <expr><name>SQLITE_BUSY</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the value to pass to a sqlite3_wal_hook callback, the
** number of frames in the WAL at the point of the last commit since
** sqlite3WalCallback() was called.  If no commits have occurred since
** the last call, then return 0.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalCallback</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pWal</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>iCallback</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>iCallback</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to change the WAL subsystem into or out
** of locking_mode=EXCLUSIVE.
**
** If op is zero, then attempt to change from locking_mode=EXCLUSIVE
** into locking_mode=NORMAL.  This means that we must acquire a lock
** on the pWal-&gt;readLock byte.  If the WAL is already in locking_mode=NORMAL
** or if the acquisition of the lock fails, then return 0.  If the
** transition out of exclusive-mode is successful, return 1.  This
** operation must occur while the pager is still holding the exclusive
** lock on the main database file.
**
** If op is one, then change from locking_mode=NORMAL into 
** locking_mode=EXCLUSIVE.  This means that the pWal-&gt;readLock must
** be released.  Return 1 if the transition is made and 0 if the
** WAL is already in exclusive-locking mode - meaning that this
** routine is a no-op.  The pager must already hold the exclusive lock
** on the main database file before invoking this operation.
**
** If op is negative, then do a dry-run of the op==1 case but do
** not actually change anything. The pager uses this to see if it
** should acquire the database exclusive lock prior to invoking
** the op==1 case.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalExclusiveMode</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name><operator>!=</operator><name>WAL_HEAPMEMORY_MODE</name> <operator>||</operator> <name>op</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* pWal-&gt;readLock is usually set, but might be -1 if there was a 
  ** prior error while attempting to acquire are read-lock. This cannot 
  ** happen if the connection is actually in exclusive mode (as no xShmLock
  ** locks are taken in this case). Nor should the pager attempt to
  ** upgrade to exclusive-mode following such an error.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pWal</name><operator>-&gt;</operator><name>lockError</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>op</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name><operator>!=</operator><name>WAL_NORMAL_MODE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>=</operator> <name>WAL_NORMAL_MODE</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>walLockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>=</operator> <name>WAL_EXCLUSIVE_MODE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name><operator>==</operator><name>WAL_NORMAL_MODE</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Already in locking_mode=NORMAL */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name><operator>==</operator><name>WAL_NORMAL_MODE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>walUnlockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><call><name>WAL_READ_LOCK</name><argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>=</operator> <name>WAL_EXCLUSIVE_MODE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name><operator>==</operator><name>WAL_NORMAL_MODE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Return true if the argument is non-NULL and the WAL module is using
** heap-memory for the wal-index. Otherwise, if the argument is NULL or the
** WAL module is using shared-memory, return false. 
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalHeapMemory</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>pWal</name> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>exclusiveMode</name></name><operator>==</operator><name>WAL_HEAPMEMORY_MODE</name> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SNAPSHOT</name></cpp:ifdef>
<comment type="block">/* Create a snapshot object.  The content of a snapshot is opaque to
** every other subsystem, so the WAL module can put whatever it needs
** in the object.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalSnapshotGet</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>sqlite3_snapshot</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppSnapshot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WalIndexHdr</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u32</name></type> <name><name>aZero</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pWal</name><operator>-&gt;</operator><name>writeLock</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aFrameCksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name>aZero</name></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppSnapshot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <operator>(</operator><name>WalIndexHdr</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRet</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalIndexHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppSnapshot</name> <operator>=</operator> <operator>(</operator><name>sqlite3_snapshot</name><operator>*</operator><operator>)</operator><name>pRet</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Try to open on pSnapshot when the next read-transaction starts
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WalSnapshotOpen</name><parameter_list>(
  <parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_snapshot</name> <modifier>*</modifier></type><name>pSnapshot</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pWal</name><operator>-&gt;</operator><name>pSnapshot</name></name> <operator>=</operator> <operator>(</operator><name>WalIndexHdr</name><operator>*</operator><operator>)</operator><name>pSnapshot</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** Return a +ve value if snapshot p1 is newer than p2. A -ve value if
** p1 is older than p2 and zero if p1 and p2 are the same snapshot.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_snapshot_cmp</name><parameter_list>(<parameter><decl><type><name>sqlite3_snapshot</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>sqlite3_snapshot</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WalIndexHdr</name> <modifier>*</modifier></type><name>pHdr1</name> <init>= <expr><operator>(</operator><name>WalIndexHdr</name><operator>*</operator><operator>)</operator><name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WalIndexHdr</name> <modifier>*</modifier></type><name>pHdr2</name> <init>= <expr><operator>(</operator><name>WalIndexHdr</name><operator>*</operator><operator>)</operator><name>p2</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* aSalt[0] is a copy of the value stored in the wal file header. It
  ** is incremented each time the wal file is restarted.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pHdr1</name><operator>-&gt;</operator><name>aSalt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;</operator><name><name>pHdr2</name><operator>-&gt;</operator><name>aSalt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pHdr1</name><operator>-&gt;</operator><name>aSalt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;</operator><name><name>pHdr2</name><operator>-&gt;</operator><name>aSalt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pHdr1</name><operator>-&gt;</operator><name>mxFrame</name></name><operator>&lt;</operator><name><name>pHdr2</name><operator>-&gt;</operator><name>mxFrame</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pHdr1</name><operator>-&gt;</operator><name>mxFrame</name></name><operator>&gt;</operator><name><name>pHdr2</name><operator>-&gt;</operator><name>mxFrame</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The caller currently has a read transaction open on the database.
** This function takes a SHARED lock on the CHECKPOINTER slot and then
** checks if the snapshot passed as the second argument is still 
** available. If so, SQLITE_OK is returned.
**
** If the snapshot is not available, SQLITE_ERROR is returned. Or, if
** the CHECKPOINTER lock cannot be obtained, SQLITE_BUSY. If any error
** occurs (any value other than SQLITE_OK is returned), the CHECKPOINTER
** lock is released before returning.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalSnapshotCheck</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>, <parameter><decl><type><name>sqlite3_snapshot</name> <modifier>*</modifier></type><name>pSnapshot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>walLockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_CKPT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>WalIndexHdr</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><operator>(</operator><name>WalIndexHdr</name><operator>*</operator><operator>)</operator><name>pSnapshot</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aSalt</name></name></expr></argument>, <argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aSalt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pWal</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>aSalt</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
     <operator>||</operator> <name><name>pNew</name><operator>-&gt;</operator><name>mxFrame</name></name><operator>&lt;</operator><call><name>walCkptInfo</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nBackfillAttempted</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR_SNAPSHOT</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>walUnlockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_CKPT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Release a lock obtained by an earlier successful call to
** sqlite3WalSnapshotCheck().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WalSnapshotUnlock</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pWal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>walUnlockShared</name><argument_list>(<argument><expr><name>pWal</name></expr></argument>, <argument><expr><name>WAL_CKPT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_SNAPSHOT */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ZIPVFS</name></cpp:ifdef>
<comment type="block">/*
** If the argument is not NULL, it points to a Wal object that holds a
** read-lock. This function returns the database page-size if it is known,
** or zero if it is not (or if pWal is NULL).
*/</comment>
<function><type><name>int</name></type> <name>sqlite3WalFramesize</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pWal</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pWal</name><operator>-&gt;</operator><name>readLock</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>pWal</name></expr> ?</condition><then> <expr><name><name>pWal</name><operator>-&gt;</operator><name>szPage</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Return the sqlite3_file object for the WAL file
*/</comment>
<function><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>sqlite3WalFile</name><parameter_list>(<parameter><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pWal</name><operator>-&gt;</operator><name>pWalFd</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* #ifndef SQLITE_OMIT_WAL */</comment>
</unit>
