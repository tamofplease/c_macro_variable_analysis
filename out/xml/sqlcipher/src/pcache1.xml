<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/pcache1.c"><comment type="block">/*
** 2008 November 05
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file implements the default page cache implementation (the
** sqlite3_pcache interface). It also contains part of the implementation
** of the SQLITE_CONFIG_PAGECACHE and sqlite3_release_memory() features.
** If the default page cache implementation is overridden, then neither of
** these two features are available.
**
** A Page cache line looks like this:
**
**  -------------------------------------------------------------
**  |  database page content   |  PgHdr1  |  MemPage  |  PgHdr  |
**  -------------------------------------------------------------
**
** The database page content is up front (so that buffer overreads tend to
** flow harmlessly into the PgHdr1, MemPage, and PgHdr extensions).   MemPage
** is the extension added by the btree.c module containing information such
** as the database page number and how that database page is used.  PgHdr
** is added by the pcache.c layer and contains information used to keep track
** of which pages are "dirty".  PgHdr1 is an extension added by this
** module (pcache1.c).  The PgHdr1 header is a subclass of sqlite3_pcache_page.
** PgHdr1 contains information needed to look up a page by its page number.
** The superclass sqlite3_pcache_page.pBuf points to the start of the
** database page content and sqlite3_pcache_page.pExtra points to PgHdr.
**
** The size of the extension (MemPage+PgHdr+PgHdr1) can be determined at
** runtime using sqlite3_config(SQLITE_CONFIG_PCACHE_HDRSZ, &amp;size).  The
** sizes of the extensions sum to 272 bytes on x64 for 3.8.10, but this
** size can vary according to architecture, compile-time options, and
** SQLite library version number.
**
** If SQLITE_PCACHE_SEPARATE_HEADER is defined, then the extension is obtained
** using a separate memory allocation from the database page content.  This
** seeks to overcome the "clownshoe" problem (also called "internal
** fragmentation" in academic literature) of allocating a few bytes more
** than a power of two with the memory allocator rounding up to the next
** power of two, and leaving the rounded-up space unused.
**
** This module tracks pointers to PgHdr1 objects.  Only pcache.c communicates
** with this module.  Information is passed back and forth as PgHdr1 pointers.
**
** The pcache.c and pager.c modules deal pointers to PgHdr objects.
** The btree.c module deals with pointers to MemPage objects.
**
** SOURCE OF PAGE CACHE MEMORY:
**
** Memory for a page might come from any of three sources:
**
**    (1)  The general-purpose memory allocator - sqlite3Malloc()
**    (2)  Global page-cache memory provided using sqlite3_config() with
**         SQLITE_CONFIG_PAGECACHE.
**    (3)  PCache-local bulk allocation.
**
** The third case is a chunk of heap memory (defaulting to 100 pages worth)
** that is allocated when the page cache is created.  The size of the local
** bulk allocation can be adjusted using 
**
**     sqlite3_config(SQLITE_CONFIG_PAGECACHE, (void*)0, 0, N).
**
** If N is positive, then N pages worth of memory are allocated using a single
** sqlite3Malloc() call and that memory is used for the first N pages allocated.
** Or if N is negative, then -1024*N bytes of memory are allocated and used
** for as many pages as can be accomodated.
**
** Only one of (2) or (3) can be used.  Once the memory available to (2) or
** (3) is exhausted, subsequent allocations fail over to the general-purpose
** memory allocator (1).
**
** Earlier versions of SQLite used only methods (1) and (2).  But experiments
** show that method (3) with N==100 provides about a 5% performance boost for
** common workloads.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<typedef>typedef <type><name><name>struct</name> <name>PCache1</name></name></type> <name>PCache1</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>PgHdr1</name></name></type> <name>PgHdr1</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>PgFreeslot</name></name></type> <name>PgFreeslot</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>PGroup</name></name></type> <name>PGroup</name>;</typedef>

<comment type="block">/*
** Each cache entry is represented by an instance of the following 
** structure. Unless SQLITE_PCACHE_SEPARATE_HEADER is defined, a buffer of
** PgHdr1.pCache-&gt;szPage bytes is allocated directly before this structure 
** in memory.
**
** Note: Variables isBulkLocal and isAnchor were once type "u8". That works,
** but causes a 2-byte gap in the structure for most architectures (since 
** pointers must be either 4 or 8-byte aligned). As this structure is located
** in memory directly after the associated page data, if the database is
** corrupt, code at the b-tree layer may overread the page buffer and 
** read part of this structure before the corruption is detected. This
** can cause a valgrind error if the unitialized gap is accessed. Using u16
** ensures there is no such gap, and therefore no bytes of unitialized memory
** in the structure.
*/</comment>
<struct>struct <name>PgHdr1</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_pcache_page</name></type> <name>page</name></decl>;</decl_stmt>      <comment type="block">/* Base class. Must be first. pBuf &amp; pExtra */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>iKey</name></decl>;</decl_stmt>             <comment type="block">/* Key value (page number) */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>isBulkLocal</name></decl>;</decl_stmt>               <comment type="block">/* This page from bulk local storage */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>isAnchor</name></decl>;</decl_stmt>                  <comment type="block">/* This is the PGroup.lru element */</comment>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>                 <comment type="block">/* Next in hash table chain */</comment>
  <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name></decl>;</decl_stmt>               <comment type="block">/* Cache that currently owns this page */</comment>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pLruNext</name></decl>;</decl_stmt>              <comment type="block">/* Next in LRU list of unpinned pages */</comment>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pLruPrev</name></decl>;</decl_stmt>              <comment type="block">/* Previous in LRU list of unpinned pages */</comment>
                                 <comment type="block">/* NB: pLruPrev is only valid if pLruNext!=0 */</comment>
}</block>;</struct>

<comment type="block">/*
** A page is pinned if it is not on the LRU list.  To be "pinned" means
** that the page is in active use and must not be deallocated.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_IS_PINNED</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>((p)-&gt;pLruNext==0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_IS_UNPINNED</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((p)-&gt;pLruNext!=0)</cpp:value></cpp:define>

<comment type="block">/* Each page cache (or PCache) belongs to a PGroup.  A PGroup is a set 
** of one or more PCaches that are able to recycle each other's unpinned
** pages when they are under memory pressure.  A PGroup is an instance of
** the following object.
**
** This page cache implementation works in one of two modes:
**
**   (1)  Every PCache is the sole member of its own PGroup.  There is
**        one PGroup per PCache.
**
**   (2)  There is a single global PGroup that all PCaches are a member
**        of.
**
** Mode 1 uses more memory (since PCache instances are not able to rob
** unused pages from other PCaches) but it also operates without a mutex,
** and is therefore often faster.  Mode 2 requires a mutex in order to be
** threadsafe, but recycles pages more efficiently.
**
** For mode (1), PGroup.mutex is NULL.  For mode (2) there is only a single
** PGroup which is the pcache1.grp global variable and its mutex is
** SQLITE_MUTEX_STATIC_LRU.
*/</comment>
<struct>struct <name>PGroup</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_mutex</name> <modifier>*</modifier></type><name>mutex</name></decl>;</decl_stmt>          <comment type="block">/* MUTEX_STATIC_LRU or NULL */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nMaxPage</name></decl>;</decl_stmt>         <comment type="block">/* Sum of nMax for purgeable caches */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nMinPage</name></decl>;</decl_stmt>         <comment type="block">/* Sum of nMin for purgeable caches */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mxPinned</name></decl>;</decl_stmt>         <comment type="block">/* nMaxpage + 10 - nMinPage */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nPurgeable</name></decl>;</decl_stmt>       <comment type="block">/* Number of purgeable pages allocated */</comment>
  <decl_stmt><decl><type><name>PgHdr1</name></type> <name>lru</name></decl>;</decl_stmt>                    <comment type="block">/* The beginning and end of the LRU list */</comment>
}</block>;</struct>

<comment type="block">/* Each page cache is an instance of the following object.  Every
** open database file (including each in-memory database and each
** temporary or transient database) has a single page cache which
** is an instance of this object.
**
** Pointers to structures of this type are cast and returned as 
** opaque sqlite3_pcache* handles.
*/</comment>
<struct>struct <name>PCache1</name> <block>{
  <comment type="block">/* Cache configuration parameters. Page size (szPage) and the purgeable
  ** flag (bPurgeable) and the pnPurgeable pointer are all set when the
  ** cache is created and are never changed thereafter. nMax may be 
  ** modified at any time by a call to the pcache1Cachesize() method.
  ** The PGroup mutex must be held when accessing nMax.
  */</comment>
  <decl_stmt><decl><type><name>PGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>                     <comment type="block">/* PGroup this cache belongs to */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>pnPurgeable</name></decl>;</decl_stmt>          <comment type="block">/* Pointer to pGroup-&gt;nPurgeable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szPage</name></decl>;</decl_stmt>                         <comment type="block">/* Size of database content section */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szExtra</name></decl>;</decl_stmt>                        <comment type="block">/* sizeof(MemPage)+sizeof(PgHdr) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szAlloc</name></decl>;</decl_stmt>                        <comment type="block">/* Total size of one pcache line */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bPurgeable</name></decl>;</decl_stmt>                     <comment type="block">/* True if cache is purgeable */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nMin</name></decl>;</decl_stmt>                  <comment type="block">/* Minimum number of pages reserved */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nMax</name></decl>;</decl_stmt>                  <comment type="block">/* Configured "cache_size" value */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n90pct</name></decl>;</decl_stmt>                <comment type="block">/* nMax*9/10 */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>iMaxKey</name></decl>;</decl_stmt>               <comment type="block">/* Largest key seen since xTruncate() */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nPurgeableDummy</name></decl>;</decl_stmt>       <comment type="block">/* pnPurgeable points here when not used*/</comment>

  <comment type="block">/* Hash table of all pages. The following variables may only be accessed
  ** when the accessor is holding the PGroup mutex.
  */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nRecyclable</name></decl>;</decl_stmt>           <comment type="block">/* Number of pages in the LRU list */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nPage</name></decl>;</decl_stmt>                 <comment type="block">/* Total number of pages in apHash */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nHash</name></decl>;</decl_stmt>                 <comment type="block">/* Number of slots in apHash[] */</comment>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier><modifier>*</modifier></type><name>apHash</name></decl>;</decl_stmt>                    <comment type="block">/* Hash table for fast lookup by key */</comment>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pFree</name></decl>;</decl_stmt>                      <comment type="block">/* List of unused pcache-local pages */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pBulk</name></decl>;</decl_stmt>                        <comment type="block">/* Bulk memory used by pcache-local */</comment>
}</block>;</struct>

<comment type="block">/*
** Free slots in the allocator used to divide up the global page cache
** buffer provided using the SQLITE_CONFIG_PAGECACHE mechanism.
*/</comment>
<struct>struct <name>PgFreeslot</name> <block>{
  <decl_stmt><decl><type><name>PgFreeslot</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>  <comment type="block">/* Next free slot */</comment>
}</block>;</struct>

<comment type="block">/*
** Global data used by this cache.
*/</comment>
<expr_stmt><expr><specifier>static</specifier> <name>SQLITE_WSD</name> struct <name>PCacheGlobal</name> <block>{
  <expr><name>PGroup</name> <name>grp</name></expr>;                    <comment type="block">/* The global PGroup for mode (2) */</comment>

  <comment type="block">/* Variables related to SQLITE_CONFIG_PAGECACHE settings.  The
  ** szSlot, nSlot, pStart, pEnd, nReserve, and isInit values are all
  ** fixed at sqlite3_initialize() time and do not require mutex protection.
  ** The nFreeSlot and pFree values do require mutex protection.
  */</comment>
  <expr><name>int</name> <name>isInit</name></expr>;                    <comment type="block">/* True if initialized */</comment>
  <expr><name>int</name> <name>separateCache</name></expr>;             <comment type="block">/* Use a new PGroup for each PCache */</comment>
  <expr><name>int</name> <name>nInitPage</name></expr>;                 <comment type="block">/* Initial bulk allocation size */</comment>   
  <expr><name>int</name> <name>szSlot</name></expr>;                    <comment type="block">/* Size of each free slot */</comment>
  <expr><name>int</name> <name>nSlot</name></expr>;                     <comment type="block">/* The number of pcache slots */</comment>
  <expr><name>int</name> <name>nReserve</name></expr>;                  <comment type="block">/* Try to keep nFreeSlot above this */</comment>
  <expr><name>void</name> <operator>*</operator><name>pStart</name></expr>, <expr><operator>*</operator><name>pEnd</name></expr>;           <comment type="block">/* Bounds of global page cache memory */</comment>
  <comment type="block">/* Above requires no mutex.  Use mutex below for variable that follow. */</comment>
  <expr><name>sqlite3_mutex</name> <operator>*</operator><name>mutex</name></expr>;          <comment type="block">/* Mutex for accessing the following: */</comment>
  <expr><name>PgFreeslot</name> <operator>*</operator><name>pFree</name></expr>;             <comment type="block">/* Free page blocks */</comment>
  <expr><name>int</name> <name>nFreeSlot</name></expr>;                 <comment type="block">/* Number of unused pcache slots */</comment>
  <comment type="block">/* The following value requires a mutex to change.  We skip the mutex on
  ** reading because (1) most platforms read a 32-bit integer atomically and
  ** (2) even if an incorrect value is read, no great harm is done since this
  ** is really just an optimization. */</comment>
  <expr><name>int</name> <name>bUnderPressure</name></expr>;            <comment type="block">/* True if low on PAGECACHE memory */</comment>
}</block> <name>pcache1_g</name></expr>;</expr_stmt>

<comment type="block">/*
** All code in this file should access the global structure above via the
** alias "pcache1". This ensures that the WSD emulation is used when
** compiling for systems that do not support real WSD.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pcache1</name></cpp:macro> <cpp:value>(GLOBAL(struct PCacheGlobal, pcache1_g))</cpp:value></cpp:define>

<comment type="block">/*
** Macros to enter and leave the PCache LRU mutex.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_MEMORY_MANAGEMENT</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_THREADSAFE</name><operator>==</operator><literal type="number">0</literal></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pcache1EnterMutex</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>assert((X)-&gt;mutex==0)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pcache1LeaveMutex</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>assert((X)-&gt;mutex==0)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PCACHE1_MIGHT_USE_GROUP_MUTEX</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pcache1EnterMutex</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sqlite3_mutex_enter((X)-&gt;mutex)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pcache1LeaveMutex</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sqlite3_mutex_leave((X)-&gt;mutex)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PCACHE1_MIGHT_USE_GROUP_MUTEX</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block" format="doxygen">/******** Page Allocation/SQLITE_CONFIG_PCACHE Related Functions **************/</comment>


<comment type="block">/*
** This function is called during initialization if a static buffer is 
** supplied to use for the page-cache by passing the SQLITE_CONFIG_PAGECACHE
** verb to sqlite3_config(). Parameter pBuf points to an allocation large
** enough to contain 'n' buffers of 'sz' bytes each.
**
** This routine is called from sqlite3_initialize() and so it is guaranteed
** to be serialized already.  There is no need for further mutexing.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PCacheBufferSetup</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pcache1</name><operator>.</operator><name>isInit</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>PgFreeslot</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sz</name> <operator>=</operator> <name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>ROUNDDOWN8</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>szSlot</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>nSlot</name></name> <operator>=</operator> <name><name>pcache1</name><operator>.</operator><name>nFreeSlot</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>nReserve</name></name> <operator>=</operator> <ternary><condition><expr><name>n</name><operator>&gt;</operator><literal type="number">90</literal></expr> ?</condition><then> <expr><literal type="number">10</literal></expr> </then><else>: <expr><operator>(</operator><name>n</name><operator>/</operator><literal type="number">10</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>pStart</name></name> <operator>=</operator> <name>pBuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>pFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>bUnderPressure</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>n</name><operator>--</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>PgFreeslot</name><operator>*</operator><operator>)</operator><name>pBuf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pcache1</name><operator>.</operator><name>pFree</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>pFree</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pBuf</name><operator>)</operator><index>[<expr><name>sz</name></expr>]</index></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>pEnd</name></name> <operator>=</operator> <name>pBuf</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Try to initialize the pCache-&gt;pFree and pCache-&gt;pBulk fields.  Return
** true if pCache-&gt;pFree ends up containing one or more free pages.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pcache1InitBulk</name><parameter_list>(<parameter><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>szBulk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBulk</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pcache1</name><operator>.</operator><name>nInitPage</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <comment type="block">/* Do not bother with a bulk allocation if the cache size very small */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>nMax</name></name><operator>&lt;</operator><literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pcache1</name><operator>.</operator><name>nInitPage</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>szBulk</name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>szAlloc</name></name> <operator>*</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>pcache1</name><operator>.</operator><name>nInitPage</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>szBulk</name> <operator>=</operator> <operator>-</operator><literal type="number">1024</literal> <operator>*</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>pcache1</name><operator>.</operator><name>nInitPage</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>szBulk</name> <operator>&gt;</operator> <name><name>pCache</name><operator>-&gt;</operator><name>szAlloc</name></name><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>pCache</name><operator>-&gt;</operator><name>nMax</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>szBulk</name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>szAlloc</name></name><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>pCache</name><operator>-&gt;</operator><name>nMax</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zBulk</name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>pBulk</name></name> <operator>=</operator> <call><name>sqlite3Malloc</name><argument_list>( <argument><expr><name>szBulk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zBulk</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nBulk</name> <init>= <expr><call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>zBulk</name></expr></argument>)</argument_list></call><operator>/</operator><name><name>pCache</name><operator>-&gt;</operator><name>szAlloc</name></name></expr></init></decl>;</decl_stmt>
    <do>do<block>{<block_content>
      <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><operator>(</operator><name>PgHdr1</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zBulk</name><index>[<expr><name><name>pCache</name><operator>-&gt;</operator><name>szPage</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>page</name><operator>.</operator><name>pBuf</name></name> <operator>=</operator> <name>zBulk</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>page</name><operator>.</operator><name>pExtra</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pX</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>isBulkLocal</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>isAnchor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>pFree</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>pLruPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>           <comment type="block">/* Initializing this saves a valgrind error */</comment>
      <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>pFree</name></name> <operator>=</operator> <name>pX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zBulk</name> <operator>+=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>szAlloc</name></name></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><operator>--</operator><name>nBulk</name></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pCache</name><operator>-&gt;</operator><name>pFree</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Malloc function used within this file to allocate space from the buffer
** configured using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no 
** such buffer exists or there is no space left in it, this function falls 
** back to sqlite3Malloc().
**
** Multiple threads can run this routine at the same time.  Global variables
** in pcache1 need to be protected via mutex.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>pcache1Alloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_notheld</name><argument_list>(<argument><expr><name><name>pcache1</name><operator>.</operator><name>grp</name><operator>.</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&lt;=</operator><name><name>pcache1</name><operator>.</operator><name>szSlot</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pcache1</name><operator>.</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>PgHdr1</name> <operator>*</operator><operator>)</operator><name><name>pcache1</name><operator>.</operator><name>pFree</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>pFree</name></name> <operator>=</operator> <name><name>pcache1</name><operator>.</operator><name>pFree</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>nFreeSlot</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>bUnderPressure</name></name> <operator>=</operator> <name><name>pcache1</name><operator>.</operator><name>nFreeSlot</name></name><operator>&lt;</operator><name><name>pcache1</name><operator>.</operator><name>nReserve</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pcache1</name><operator>.</operator><name>nFreeSlot</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3StatusHighwater</name><argument_list>(<argument><expr><name>SQLITE_STATUS_PAGECACHE_SIZE</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3StatusUp</name><argument_list>(<argument><expr><name>SQLITE_STATUS_PAGECACHE_USED</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>pcache1</name><operator>.</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Memory is not available in the SQLITE_CONFIG_PAGECACHE pool.  Get
    ** it from sqlite3Malloc instead.
    */</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pcache1</name><operator>.</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3StatusHighwater</name><argument_list>(<argument><expr><name>SQLITE_STATUS_PAGECACHE_SIZE</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3StatusUp</name><argument_list>(<argument><expr><name>SQLITE_STATUS_PAGECACHE_OVERFLOW</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>pcache1</name><operator>.</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3MemdebugSetType</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>MEMTYPE_PCACHE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free an allocated buffer obtained from pcache1Alloc().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcache1Free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>SQLITE_WITHIN</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pcache1</name><operator>.</operator><name>pStart</name></name></expr></argument>, <argument><expr><name><name>pcache1</name><operator>.</operator><name>pEnd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>PgFreeslot</name> <modifier>*</modifier></type><name>pSlot</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pcache1</name><operator>.</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3StatusDown</name><argument_list>(<argument><expr><name>SQLITE_STATUS_PAGECACHE_USED</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSlot</name> <operator>=</operator> <operator>(</operator><name>PgFreeslot</name><operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSlot</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pcache1</name><operator>.</operator><name>pFree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>pFree</name></name> <operator>=</operator> <name>pSlot</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>nFreeSlot</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>bUnderPressure</name></name> <operator>=</operator> <name><name>pcache1</name><operator>.</operator><name>nFreeSlot</name></name><operator>&lt;</operator><name><name>pcache1</name><operator>.</operator><name>nReserve</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pcache1</name><operator>.</operator><name>nFreeSlot</name></name><operator>&lt;=</operator><name><name>pcache1</name><operator>.</operator><name>nSlot</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>pcache1</name><operator>.</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3MemdebugHasType</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>MEMTYPE_PCACHE</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3MemdebugSetType</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>MEMTYPE_HEAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS</name></cpp:ifndef>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nFreed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>nFreed</name> <operator>=</operator> <call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pcache1</name><operator>.</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3StatusDown</name><argument_list>(<argument><expr><name>SQLITE_STATUS_PAGECACHE_OVERFLOW</name></expr></argument>, <argument><expr><name>nFreed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>pcache1</name><operator>.</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMORY_MANAGEMENT</name></cpp:ifdef>
<comment type="block">/*
** Return the size of a pcache allocation
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pcache1MemSize</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>&gt;=</operator><name><name>pcache1</name><operator>.</operator><name>pStart</name></name> <operator>&amp;&amp;</operator> <name>p</name><operator>&lt;</operator><name><name>pcache1</name><operator>.</operator><name>pEnd</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pcache1</name><operator>.</operator><name>szSlot</name></name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iSize</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3MemdebugHasType</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>MEMTYPE_PCACHE</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3MemdebugSetType</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>MEMTYPE_HEAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iSize</name> <operator>=</operator> <call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3MemdebugSetType</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>MEMTYPE_PCACHE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>iSize</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_MEMORY_MANAGEMENT */</comment>

<comment type="block">/*
** Allocate a new page object initially associated with cache pCache.
*/</comment>
<function><type><specifier>static</specifier> <name>PgHdr1</name> <modifier>*</modifier></type><name>pcache1AllocPage</name><parameter_list>(<parameter><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>benignMalloc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>pFree</name></name> <operator>||</operator> <operator>(</operator><name><name>pCache</name><operator>-&gt;</operator><name>nPage</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>pcache1InitBulk</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pFree</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>pFree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>pFree</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMORY_MANAGEMENT</name></cpp:ifdef>
    <comment type="block">/* The group mutex must be released before pcache1Alloc() is called. This
    ** is because it might call sqlite3_release_memory(), which assumes that 
    ** this mutex is not held. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pcache1</name><operator>.</operator><name>separateCache</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name><operator>==</operator><operator>&amp;</operator><name><name>pcache1</name><operator>.</operator><name>grp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name>benignMalloc</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_PCACHE_SEPARATE_HEADER</name></cpp:ifdef>
    <expr_stmt><expr><name>pPg</name> <operator>=</operator> <call><name>pcache1Alloc</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>szPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgHdr1</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>pCache</name><operator>-&gt;</operator><name>szExtra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pPg</name> <operator>||</operator> <operator>!</operator><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>pcache1Free</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>pPg</name> <operator>=</operator> <call><name>pcache1Alloc</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>szAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name>benignMalloc</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMORY_MANAGEMENT</name></cpp:ifdef>
    <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name>pPg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_PCACHE_SEPARATE_HEADER</name></cpp:ifndef>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>PgHdr1</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pPg</name><operator>)</operator><index>[<expr><name><name>pCache</name><operator>-&gt;</operator><name>szPage</name></name></expr>]</index></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>page</name><operator>.</operator><name>pBuf</name></name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>page</name><operator>.</operator><name>pExtra</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>isBulkLocal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>isAnchor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLruPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>           <comment type="block">/* Initializing this saves a valgrind error */</comment>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>pCache</name><operator>-&gt;</operator><name>pnPurgeable</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free a page object allocated by pcache1AllocPage().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcache1FreePage</name><parameter_list>(<parameter><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCache</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pCache</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCache</name><operator>-&gt;</operator><name>pGroup</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>isBulkLocal</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>pFree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>pFree</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>pcache1Free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>page</name><operator>.</operator><name>pBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_PCACHE_SEPARATE_HEADER</name></cpp:ifdef>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>pCache</name><operator>-&gt;</operator><name>pnPurgeable</name></name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Malloc function used by SQLite to obtain space from the buffer configured
** using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no such buffer
** exists, this function falls back to sqlite3Malloc().
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3PageMalloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name><operator>&lt;=</operator><literal type="number">65536</literal><operator>+</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* These allocations are never very large */</comment>
  <return>return <expr><call><name>pcache1Alloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free an allocated buffer obtained from sqlite3PageMalloc().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PageFree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>pcache1Free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Return true if it desirable to avoid allocating a new page cache
** entry.
**
** If memory was allocated specifically to the page cache using
** SQLITE_CONFIG_PAGECACHE but that memory has all been used, then
** it is desirable to avoid allocating a new page cache entry because
** presumably SQLITE_CONFIG_PAGECACHE was suppose to be sufficient
** for all page cache needs and we should not need to spill the
** allocation onto the heap.
**
** Or, the heap is used for all page cache memory but the heap is
** under memory pressure, then again it is desirable to avoid
** allocating a new page cache entry in order to avoid stressing
** the heap even further.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pcache1UnderMemoryPressure</name><parameter_list>(<parameter><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pcache1</name><operator>.</operator><name>nSlot</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCache</name><operator>-&gt;</operator><name>szPage</name></name><operator>+</operator><name><name>pCache</name><operator>-&gt;</operator><name>szExtra</name></name><operator>)</operator><operator>&lt;=</operator><name><name>pcache1</name><operator>.</operator><name>szSlot</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pcache1</name><operator>.</operator><name>bUnderPressure</name></name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>sqlite3HeapNearlyFull</name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block" format="doxygen">/******** General Implementation Functions ************************************/</comment>

<comment type="block">/*
** This function is used to resize the hash table used by the cache passed
** as the first argument.
**
** The PCache mutex must be held when this function is called.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcache1ResizeHash</name><parameter_list>(<parameter><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier><modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>nNew</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nHash</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nNew</name><operator>&lt;</operator><literal type="number">256</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nNew</name> <operator>=</operator> <literal type="number">256</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nHash</name></name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator><name>PgHdr1</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgHdr1</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nHash</name></name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>apNew</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nHash</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <while>while<condition>( <expr><operator>(</operator><name>pPage</name> <operator>=</operator> <name>pNext</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>iKey</name></name> <operator>%</operator> <name>nNew</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>apNew</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>apNew</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>apHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apHash</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nHash</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is used internally to remove the page pPage from the 
** PGroup LRU list, if is part of it. If pPage is not part of the PGroup
** LRU list, then this function is a no-op.
**
** The PGroup mutex must be held when this function is called.
*/</comment>
<function><type><specifier>static</specifier> <name>PgHdr1</name> <modifier>*</modifier></type><name>pcache1PinPage</name><parameter_list>(<parameter><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>PAGE_IS_UNPINNED</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pLruNext</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pLruPrev</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pCache</name><operator>-&gt;</operator><name>pGroup</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pLruPrev</name><operator>-&gt;</operator><name>pLruNext</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pLruNext</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pLruNext</name><operator>-&gt;</operator><name>pLruPrev</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pLruPrev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pLruNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <comment type="block">/* pPage-&gt;pLruPrev = 0;
  ** No need to clear pLruPrev as it is never accessed if pLruNext is 0 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>isAnchor</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pCache</name><operator>-&gt;</operator><name>pGroup</name><operator>-&gt;</operator><name>lru</name><operator>.</operator><name>isAnchor</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pCache</name><operator>-&gt;</operator><name>nRecyclable</name></name><operator>--</operator></expr>;</expr_stmt>
  <return>return <expr><name>pPage</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Remove the page supplied as an argument from the hash table 
** (PCache1.apHash structure) that it is currently stored in.
** Also free the page if freePage is true.
**
** The PGroup mutex must be held when this function is called.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcache1RemoveFromHash</name><parameter_list>(<parameter><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>freeFlag</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pCache</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>iKey</name></name> <operator>%</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pCache</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</init> <condition><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>!=</operator><name>pPage</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>nPage</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>freeFlag</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pcache1FreePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If there are currently more than nMaxPage pages allocated, try
** to recycle pages to reduce the number allocated to nMaxPage.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcache1EnforceMaxPage</name><parameter_list>(<parameter><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>nPurgeable</name></name><operator>&gt;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>nMaxPage</name></name>
      <operator>&amp;&amp;</operator> <operator>(</operator><name>p</name><operator>=</operator><name><name>pGroup</name><operator>-&gt;</operator><name>lru</name><operator>.</operator><name>pLruPrev</name></name><operator>)</operator><operator>-&gt;</operator><name>isAnchor</name><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name><operator>==</operator><name>pGroup</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>PAGE_IS_UNPINNED</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1PinPage</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1RemoveFromHash</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>nPage</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCache</name><operator>-&gt;</operator><name>pBulk</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pBulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>pBulk</name></name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>pFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Discard all pages from cache pCache with a page number (key value) 
** greater than or equal to iLimit. Any pinned pages that meet this 
** criteria are unpinned before they are discarded.
**
** The PCache mutex must be held when this function is called.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcache1TruncateUnsafe</name><parameter_list>(
  <parameter><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>,             <comment type="block">/* The cache to truncate */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>iLimit</name></decl></parameter>          <comment type="block">/* Drop pages with this pgno or larger */</comment>
)</parameter_list><block>{<block_content>
  <macro><name>TESTONLY</name><argument_list>( <argument>int nPage = <literal type="number">0</literal>;</argument> )</argument_list></macro>  <comment type="block">/* To assert pCache-&gt;nPage is correct */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl>, <decl><type ref="prev"/><name>iStop</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>iMaxKey</name></name> <operator>&gt;=</operator> <name>iLimit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>iMaxKey</name></name> <operator>-</operator> <name>iLimit</name> <operator>&lt;</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If we are just shaving the last few pages off the end of the
    ** cache, then there is no point in scanning the entire hash table.
    ** Only scan those hash slots that might contain pages that need to
    ** be removed. */</comment>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <name>iLimit</name> <operator>%</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iStop</name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>iMaxKey</name></name> <operator>%</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name></expr>;</expr_stmt>
    <macro><name>TESTONLY</name><argument_list>( <argument>nPage = -<literal type="number">10</literal>;</argument> )</argument_list></macro>  <comment type="block">/* Disable the pCache-&gt;nPage validity check */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* This is the general case where many pages are being removed.
    ** It is necessary to scan the entire hash table */</comment>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iStop</name> <operator>=</operator> <name>h</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>h</name><operator>&lt;</operator><name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCache</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt> 
    <while>while<condition>( <expr><operator>(</operator><name>pPage</name> <operator>=</operator> <operator>*</operator><name>pp</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>iKey</name></name><operator>&gt;=</operator><name>iLimit</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>nPage</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>PAGE_IS_UNPINNED</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pcache1PinPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>pcache1FreePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPage</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <macro><name>TESTONLY</name><argument_list>( <argument>if( nPage&gt;=<literal type="number">0</literal> ) nPage++;</argument> )</argument_list></macro>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>h</name><operator>==</operator><name>iStop</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <operator>(</operator><name>h</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nPage</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nPage</name></name><operator>==</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>nPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************/</comment>
<comment type="block" format="doxygen">/******** sqlite3_pcache Methods **********************************************/</comment>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xInit method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pcache1Init</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pcache1</name><operator>.</operator><name>isInit</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcache1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pcache1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/*
  ** The pcache1.separateCache variable is true if each PCache has its own
  ** private PGroup (mode-1).  pcache1.separateCache is false if the single
  ** PGroup in pcache1.grp is used for all page caches (mode-2).
  **
  **   *  Always use a unified cache (mode-2) if ENABLE_MEMORY_MANAGEMENT
  **
  **   *  Use a unified cache in single-threaded applications that have
  **      configured a start-time buffer for use as page-cache memory using
  **      sqlite3_config(SQLITE_CONFIG_PAGECACHE, pBuf, sz, N) with non-NULL 
  **      pBuf argument.
  **
  **   *  Otherwise use separate caches (mode-1)
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_MEMORY_MANAGEMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>separateCache</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SQLITE_THREADSAFE</name></expr></cpp:elif>
  <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>separateCache</name></name> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pPage</name></name><operator>==</operator><literal type="number">0</literal>
                          <operator>||</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name><operator>&gt;</operator><literal type="number">0</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>separateCache</name></name> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pPage</name></name><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>grp</name><operator>.</operator><name>mutex</name></name> <operator>=</operator> <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_LRU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>mutex</name></name> <operator>=</operator> <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_PMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>pcache1</name><operator>.</operator><name>separateCache</name></name>
   <operator>&amp;&amp;</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nPage</name></name><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pPage</name></name><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>nInitPage</name></name> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nPage</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>nInitPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>grp</name><operator>.</operator><name>mxPinned</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pcache1</name><operator>.</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xShutdown method.
** Note that the static mutex allocated in xInit does 
** not need to be freed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcache1Shutdown</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pcache1</name><operator>.</operator><name>isInit</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcache1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pcache1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pcache1Destroy</name><parameter_list>(<parameter><decl><type><name>sqlite3_pcache</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xCreate method.
**
** Allocate a new cache.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_pcache</name> <modifier>*</modifier></type><name>pcache1Create</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>szPage</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>szExtra</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bPurgeable</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name></decl>;</decl_stmt>      <comment type="block">/* The newly created page cache */</comment>
  <decl_stmt><decl><type><name>PGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>       <comment type="block">/* The group the new page cache will belong to */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>               <comment type="block">/* Bytes of memory required to allocate the new cache */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>szPage</name> <operator>&amp;</operator> <operator>(</operator><name>szPage</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>szPage</name><operator>&gt;=</operator><literal type="number">512</literal> <operator>&amp;&amp;</operator> <name>szPage</name><operator>&lt;=</operator><literal type="number">65536</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>szExtra</name> <operator>&lt;</operator> <literal type="number">300</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCache1</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGroup</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pcache1</name><operator>.</operator><name>separateCache</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCache</name> <operator>=</operator> <operator>(</operator><name>PCache1</name> <operator>*</operator><operator>)</operator><call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCache</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pcache1</name><operator>.</operator><name>separateCache</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <operator>(</operator><name>PGroup</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pCache</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>mxPinned</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <operator>&amp;</operator><name><name>pcache1</name><operator>.</operator><name>grp</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>lru</name><operator>.</operator><name>isAnchor</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>lru</name><operator>.</operator><name>isAnchor</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>lru</name><operator>.</operator><name>pLruPrev</name></name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>lru</name><operator>.</operator><name>pLruNext</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>lru</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name> <operator>=</operator> <name>pGroup</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>szPage</name></name> <operator>=</operator> <name>szPage</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>szExtra</name></name> <operator>=</operator> <name>szExtra</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>szAlloc</name></name> <operator>=</operator> <name>szPage</name> <operator>+</operator> <name>szExtra</name> <operator>+</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgHdr1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>bPurgeable</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>bPurgeable</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1ResizeHash</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bPurgeable</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>nMin</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>nMinPage</name></name> <operator>+=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nMin</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>mxPinned</name></name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>nMaxPage</name></name> <operator>+</operator> <literal type="number">10</literal> <operator>-</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>nMinPage</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>pnPurgeable</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>nPurgeable</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>pnPurgeable</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pCache</name><operator>-&gt;</operator><name>nPurgeableDummy</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>pcache1Destroy</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_pcache</name><operator>*</operator><operator>)</operator><name>pCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCache</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>sqlite3_pcache</name> <operator>*</operator><operator>)</operator><name>pCache</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xCachesize method. 
**
** Configure the cache_size limit for a cache.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcache1Cachesize</name><parameter_list>(<parameter><decl><type><name>sqlite3_pcache</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMax</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name> <init>= <expr><operator>(</operator><name>PCache1</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nMax</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>bPurgeable</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>PGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>nMax</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name> <operator>&gt;</operator> <literal type="number">0x7fff0000</literal> <operator>-</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>nMaxPage</name></name> <operator>+</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nMax</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0x7fff0000</literal> <operator>-</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>nMaxPage</name></name> <operator>+</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nMax</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>nMaxPage</name></name> <operator>+=</operator> <operator>(</operator><name>n</name> <operator>-</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nMax</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>mxPinned</name></name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>nMaxPage</name></name> <operator>+</operator> <literal type="number">10</literal> <operator>-</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>nMinPage</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>nMax</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>n90pct</name></name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nMax</name></name><operator>*</operator><literal type="number">9</literal><operator>/</operator><literal type="number">10</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1EnforceMaxPage</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xShrink method. 
**
** Free up as much memory as possible.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcache1Shrink</name><parameter_list>(<parameter><decl><type><name>sqlite3_pcache</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name> <init>= <expr><operator>(</operator><name>PCache1</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>bPurgeable</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>PGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>savedMaxPage</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>savedMaxPage</name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>nMaxPage</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>nMaxPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1EnforceMaxPage</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>nMaxPage</name></name> <operator>=</operator> <name>savedMaxPage</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xPagecount method. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pcache1Pagecount</name><parameter_list>(<parameter><decl><type><name>sqlite3_pcache</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name> <init>= <expr><operator>(</operator><name>PCache1</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nPage</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Implement steps 3, 4, and 5 of the pcache1Fetch() algorithm described
** in the header of the pcache1Fetch() procedure.
**
** This steps are broken out into a separate procedure because they are
** usually not needed, and by avoiding the stack initialization required
** for these steps, the main pcache1Fetch() procedure can run faster.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>PgHdr1</name> <modifier>*</modifier></type><name>pcache1FetchStage2</name><parameter_list>(
  <parameter><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>, 
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>iKey</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>createFlag</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nPinned</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Step 3: Abort if createFlag is 1 but the cache is nearly full */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>nPage</name></name> <operator>&gt;=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nRecyclable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nPinned</name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nPage</name></name> <operator>-</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nRecyclable</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>mxPinned</name></name> <operator>==</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>nMaxPage</name></name> <operator>+</operator> <literal type="number">10</literal> <operator>-</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>nMinPage</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>n90pct</name></name> <operator>==</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nMax</name></name><operator>*</operator><literal type="number">9</literal><operator>/</operator><literal type="number">10</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>createFlag</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator>
        <name>nPinned</name><operator>&gt;=</operator><name><name>pGroup</name><operator>-&gt;</operator><name>mxPinned</name></name>
     <operator>||</operator> <name>nPinned</name><operator>&gt;=</operator><name><name>pCache</name><operator>-&gt;</operator><name>n90pct</name></name>
     <operator>||</operator> <operator>(</operator><call><name>pcache1UnderMemoryPressure</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nRecyclable</name></name><operator>&lt;</operator><name>nPinned</name><operator>)</operator>
  <operator>)</operator></expr>)</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>nPage</name></name><operator>&gt;=</operator><name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pcache1ResizeHash</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCache</name><operator>-&gt;</operator><name>apHash</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Step 4. Try to recycle a page. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>bPurgeable</name></name>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pGroup</name><operator>-&gt;</operator><name>lru</name><operator>.</operator><name>pLruPrev</name><operator>-&gt;</operator><name>isAnchor</name></name>
   <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>pCache</name><operator>-&gt;</operator><name>nPage</name></name><operator>+</operator><literal type="number">1</literal><operator>&gt;=</operator><name><name>pCache</name><operator>-&gt;</operator><name>nMax</name></name><operator>)</operator> <operator>||</operator> <call><name>pcache1UnderMemoryPressure</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pOther</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pPage</name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>lru</name><operator>.</operator><name>pLruPrev</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>PAGE_IS_UNPINNED</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1RemoveFromHash</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1PinPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOther</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pCache</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOther</name><operator>-&gt;</operator><name>szAlloc</name></name> <operator>!=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>szAlloc</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>pcache1FreePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>nPurgeable</name></name> <operator>-=</operator> <operator>(</operator><name><name>pOther</name><operator>-&gt;</operator><name>bPurgeable</name></name> <operator>-</operator> <name><name>pCache</name><operator>-&gt;</operator><name>bPurgeable</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Step 5. If a usable page buffer has still not been found, 
  ** attempt to allocate a new one. 
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pPage</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pPage</name> <operator>=</operator> <call><name>pcache1AllocPage</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>, <argument><expr><name>createFlag</name><operator>==</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pPage</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name> <init>= <expr><name>iKey</name> <operator>%</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>nPage</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>iKey</name></name> <operator>=</operator> <name>iKey</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pCache</name></name> <operator>=</operator> <name>pCache</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pLruNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* pPage-&gt;pLruPrev = 0;
    ** No need to clear pLruPrev since it is not accessed when pLruNext==0 */</comment>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>page</name><operator>.</operator><name>pExtra</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iKey</name><operator>&gt;</operator><name><name>pCache</name><operator>-&gt;</operator><name>iMaxKey</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>iMaxKey</name></name> <operator>=</operator> <name>iKey</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pPage</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xFetch method. 
**
** Fetch a page by key value.
**
** Whether or not a new page may be allocated by this function depends on
** the value of the createFlag argument.  0 means do not allocate a new
** page.  1 means allocate a new page if space is easily available.  2 
** means to try really hard to allocate a new page.
**
** For a non-purgeable cache (a cache used as the storage for an in-memory
** database) there is really no difference between createFlag 1 and 2.  So
** the calling function (pcache.c) will never have a createFlag of 1 on
** a non-purgeable cache.
**
** There are three different approaches to obtaining space for a page,
** depending on the value of parameter createFlag (which may be 0, 1 or 2).
**
**   1. Regardless of the value of createFlag, the cache is searched for a 
**      copy of the requested page. If one is found, it is returned.
**
**   2. If createFlag==0 and the page is not already in the cache, NULL is
**      returned.
**
**   3. If createFlag is 1, and the page is not already in the cache, then
**      return NULL (do not allocate a new page) if any of the following
**      conditions are true:
**
**       (a) the number of pages pinned by the cache is greater than
**           PCache1.nMax, or
**
**       (b) the number of pages pinned by the cache is greater than
**           the sum of nMax for all purgeable caches, less the sum of 
**           nMin for all other purgeable caches, or
**
**   4. If none of the first three conditions apply and the cache is marked
**      as purgeable, and if one of the following is true:
**
**       (a) The number of pages allocated for the cache is already 
**           PCache1.nMax, or
**
**       (b) The number of pages allocated for all purgeable caches is
**           already equal to or greater than the sum of nMax for all
**           purgeable caches,
**
**       (c) The system is under memory pressure and wants to avoid
**           unnecessary pages cache entry allocations
**
**      then attempt to recycle a page from the LRU list. If it is the right
**      size, return the recycled buffer. Otherwise, free the buffer and
**      proceed to step 5. 
**
**   5. Otherwise, allocate and return a new page buffer.
**
** There are two versions of this routine.  pcache1FetchWithMutex() is
** the general case.  pcache1FetchNoMutex() is a faster implementation for
** the common case where pGroup-&gt;mutex is NULL.  The pcache1Fetch() wrapper
** invokes the appropriate routine.
*/</comment>
<function><type><specifier>static</specifier> <name>PgHdr1</name> <modifier>*</modifier></type><name>pcache1FetchNoMutex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_pcache</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>iKey</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>createFlag</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name> <init>= <expr><operator>(</operator><name>PCache1</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Step 1: Search the hash table for an existing entry. */</comment>
  <expr_stmt><expr><name>pPage</name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>iKey</name> <operator>%</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pPage</name> <operator>&amp;&amp;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>iKey</name></name><operator>!=</operator><name>iKey</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>pPage</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt> </block_content>}</block></while>

  <comment type="block">/* Step 2: If the page was found in the hash table, then return it.
  ** If the page was not in the hash table and createFlag is 0, abort.
  ** Otherwise (page not in hash and createFlag!=0) continue with
  ** subsequent steps to try to create the page. */</comment>
  <if_stmt><if>if<condition>( <expr><name>pPage</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>PAGE_IS_UNPINNED</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>pcache1PinPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><name>pPage</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>createFlag</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Steps 3, 4, and 5 implemented by this subroutine */</comment>
    <return>return <expr><call><name>pcache1FetchStage2</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>createFlag</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCACHE1_MIGHT_USE_GROUP_MUTEX</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PgHdr1</name> <modifier>*</modifier></type><name>pcache1FetchWithMutex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_pcache</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>iKey</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>createFlag</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name> <init>= <expr><operator>(</operator><name>PCache1</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name> <operator>=</operator> <call><name>pcache1FetchNoMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>createFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCache</name><operator>-&gt;</operator><name>iMaxKey</name></name><operator>&gt;=</operator><name>iKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pPage</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>sqlite3_pcache_page</name> <modifier>*</modifier></type><name>pcache1Fetch</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_pcache</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>iKey</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>createFlag</name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCACHE1_MIGHT_USE_GROUP_MUTEX</name> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name> <init>= <expr><operator>(</operator><name>PCache1</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PgHdr1</name></expr></argument>,<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>bPurgeable</name></name> <operator>||</operator> <name>createFlag</name><operator>!=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>bPurgeable</name></name> <operator>||</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nMin</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>bPurgeable</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nMin</name></name><operator>==</operator><literal type="number">10</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>nMin</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCache</name><operator>-&gt;</operator><name>bPurgeable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCACHE1_MIGHT_USE_GROUP_MUTEX</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name><operator>-&gt;</operator><name>mutex</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>sqlite3_pcache_page</name><operator>*</operator><operator>)</operator><call><name>pcache1FetchWithMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>createFlag</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <return>return <expr><operator>(</operator><name>sqlite3_pcache_page</name><operator>*</operator><operator>)</operator><call><name>pcache1FetchNoMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>createFlag</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Implementation of the sqlite3_pcache.xUnpin method.
**
** Mark a page as unpinned (eligible for asynchronous recycling).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcache1Unpin</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_pcache</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_pcache_page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>reuseUnlikely</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name> <init>= <expr><operator>(</operator><name>PCache1</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><operator>(</operator><name>PgHdr1</name> <operator>*</operator><operator>)</operator><name>pPg</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
 
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pCache</name></name><operator>==</operator><name>pCache</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* It is an error to call this function if the page is already 
  ** part of the PGroup LRU list.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pLruNext</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>PAGE_IS_PINNED</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>reuseUnlikely</name> <operator>||</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>nPurgeable</name></name><operator>&gt;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>nMaxPage</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>pcache1RemoveFromHash</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Add the page to the PGroup LRU list. */</comment>
    <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppFirst</name> <init>= <expr><operator>&amp;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>lru</name><operator>.</operator><name>pLruNext</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pLruPrev</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>lru</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>pLruNext</name></name> <operator>=</operator> <operator>*</operator><name>ppFirst</name><operator>)</operator><operator>-&gt;</operator><name>pLruPrev</name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppFirst</name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>nRecyclable</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xRekey method. 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcache1Rekey</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_pcache</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_pcache_page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>,
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>iOld</name></decl></parameter>,
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>iNew</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name> <init>= <expr><operator>(</operator><name>PCache1</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><operator>(</operator><name>PgHdr1</name> <operator>*</operator><operator>)</operator><name>pPg</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl>;</decl_stmt> 
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>iKey</name></name><operator>==</operator><name>iOld</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pCache</name></name><operator>==</operator><name>pCache</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>h</name> <operator>=</operator> <name>iOld</name><operator>%</operator><name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCache</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>!=</operator><name>pPage</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>h</name> <operator>=</operator> <name>iNew</name><operator>%</operator><name><name>pCache</name><operator>-&gt;</operator><name>nHash</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>iKey</name></name> <operator>=</operator> <name>iNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iNew</name><operator>&gt;</operator><name><name>pCache</name><operator>-&gt;</operator><name>iMaxKey</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>iMaxKey</name></name> <operator>=</operator> <name>iNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xTruncate method. 
**
** Discard all unpinned pages in the cache with a page number equal to
** or greater than parameter iLimit. Any pinned pages with a page number
** equal to or greater than iLimit are implicitly unpinned.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcache1Truncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_pcache</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>iLimit</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name> <init>= <expr><operator>(</operator><name>PCache1</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iLimit</name><operator>&lt;=</operator><name><name>pCache</name><operator>-&gt;</operator><name>iMaxKey</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>pcache1TruncateUnsafe</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>iMaxKey</name></name> <operator>=</operator> <name>iLimit</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xDestroy method. 
**
** Destroy a cache allocated using pcache1Create().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcache1Destroy</name><parameter_list>(<parameter><decl><type><name>sqlite3_pcache</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PCache1</name> <modifier>*</modifier></type><name>pCache</name> <init>= <expr><operator>(</operator><name>PCache1</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>pCache</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>bPurgeable</name></name> <operator>||</operator> <operator>(</operator><name><name>pCache</name><operator>-&gt;</operator><name>nMax</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nMin</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>nPage</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pcache1TruncateUnsafe</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>nMaxPage</name></name> <operator>&gt;=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nMax</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>nMaxPage</name></name> <operator>-=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nMax</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>nMinPage</name></name> <operator>&gt;=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nMin</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>nMinPage</name></name> <operator>-=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nMin</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>mxPinned</name></name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>nMaxPage</name></name> <operator>+</operator> <literal type="number">10</literal> <operator>-</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>nMinPage</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcache1EnforceMaxPage</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pBulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>apHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called during initialization (sqlite3_initialize()) to
** install the default pluggable cache module, assuming the user has not
** already provided an alternative.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PCacheSetDefault</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_pcache_methods2</name></type> <name>defaultMethods</name> <init>= <expr><block>{
    <expr><literal type="number">1</literal></expr>,                       <comment type="block">/* iVersion */</comment>
    <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* pArg */</comment>
    <expr><name>pcache1Init</name></expr>,             <comment type="block">/* xInit */</comment>
    <expr><name>pcache1Shutdown</name></expr>,         <comment type="block">/* xShutdown */</comment>
    <expr><name>pcache1Create</name></expr>,           <comment type="block">/* xCreate */</comment>
    <expr><name>pcache1Cachesize</name></expr>,        <comment type="block">/* xCachesize */</comment>
    <expr><name>pcache1Pagecount</name></expr>,        <comment type="block">/* xPagecount */</comment>
    <expr><name>pcache1Fetch</name></expr>,            <comment type="block">/* xFetch */</comment>
    <expr><name>pcache1Unpin</name></expr>,            <comment type="block">/* xUnpin */</comment>
    <expr><name>pcache1Rekey</name></expr>,            <comment type="block">/* xRekey */</comment>
    <expr><name>pcache1Truncate</name></expr>,         <comment type="block">/* xTruncate */</comment>
    <expr><name>pcache1Destroy</name></expr>,          <comment type="block">/* xDestroy */</comment>
    <expr><name>pcache1Shrink</name></expr>            <comment type="block">/* xShrink */</comment>
  }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_PCACHE2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defaultMethods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the size of the header on each page of this PCACHE implementation.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3HeaderSizePcache1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgHdr1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<comment type="block">/*
** Return the global mutex used by this PCACHE implementation.  The
** sqlite3_status() routine needs access to this mutex.
*/</comment>
<function><type><name>sqlite3_mutex</name> <modifier>*</modifier></type><name>sqlite3Pcache1Mutex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pcache1</name><operator>.</operator><name>mutex</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMORY_MANAGEMENT</name></cpp:ifdef>
<comment type="block">/*
** This function is called to free superfluous dynamically allocated memory
** held by the pager system. Memory in use by any SQLite pager allocated
** by the current thread may be sqlite3_free()ed.
**
** nReq is the number of bytes of memory required. Once this much has
** been released, the function returns. The return value is the total number 
** of bytes of memory released.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheReleaseMemory</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nReq</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_notheld</name><argument_list>(<argument><expr><name><name>pcache1</name><operator>.</operator><name>grp</name><operator>.</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_notheld</name><argument_list>(<argument><expr><name><name>pcache1</name><operator>.</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pPage</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcache1</name><operator>.</operator><name>grp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>nReq</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>nFree</name><operator>&lt;</operator><name>nReq</name><operator>)</operator>
       <operator>&amp;&amp;</operator>  <operator>(</operator><name>p</name><operator>=</operator><name><name>pcache1</name><operator>.</operator><name>grp</name><operator>.</operator><name>lru</name><operator>.</operator><name>pLruPrev</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator>  <name><name>p</name><operator>-&gt;</operator><name>isAnchor</name></name><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>nFree</name> <operator>+=</operator> <call><name>pcache1MemSize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>page</name><operator>.</operator><name>pBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_PCACHE_SEPARATE_HEADER</name></cpp:ifdef>
      <expr_stmt><expr><name>nFree</name> <operator>+=</operator> <call><name>sqlite3MemSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>PAGE_IS_UNPINNED</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pcache1PinPage</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pcache1RemoveFromHash</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcache1</name><operator>.</operator><name>grp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>nFree</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_MEMORY_MANAGEMENT */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/*
** This function is used by test procedures to inspect the internal state
** of the global cache.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheStats</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnCurrent</name></decl></parameter>,      <comment type="block">/* OUT: Total number of pages cached */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnMax</name></decl></parameter>,          <comment type="block">/* OUT: Global maximum cache size */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnMin</name></decl></parameter>,          <comment type="block">/* OUT: Sum of PCache1.nMin for purgeable caches */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnRecyclable</name></decl></parameter>    <comment type="block">/* OUT: Total number of pages available for recycling */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr1</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRecyclable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pcache1</name><operator>.</operator><name>grp</name><operator>.</operator><name>lru</name><operator>.</operator><name>pLruNext</name></name></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>isAnchor</name></name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pLruNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>PAGE_IS_UNPINNED</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRecyclable</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>pnCurrent</name> <operator>=</operator> <name><name>pcache1</name><operator>.</operator><name>grp</name><operator>.</operator><name>nPurgeable</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnMax</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pcache1</name><operator>.</operator><name>grp</name><operator>.</operator><name>nMaxPage</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnMin</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pcache1</name><operator>.</operator><name>grp</name><operator>.</operator><name>nMinPage</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnRecyclable</name> <operator>=</operator> <name>nRecyclable</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
