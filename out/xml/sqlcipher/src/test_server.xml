<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/test_server.c"><comment type="block">/*
** 2006 January 07
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file contains demonstration code.  Nothing in this file gets compiled
** or linked into the SQLite library unless you use a non-standard option:
**
**      -DSQLITE_SERVER=1
**
** The configure script will never generate a Makefile with the option
** above.  You will need to manually modify the Makefile if you want to
** include any of the code from this file in your project.  Or, at your
** option, you may copy and paste the code from this file and
** thereby avoiding a recompile of SQLite.
**
**
** This source file demonstrates how to use SQLite to create an SQL database 
** server thread in a multiple-threaded program.  One or more client threads
** send messages to the server thread and the server thread processes those
** messages in the order received and returns the results to the client.
**
** One might ask:  "Why bother?  Why not just let each thread connect
** to the database directly?"  There are a several of reasons to
** prefer the client/server approach.
**
**    (1)  Some systems (ex: Redhat9) have broken threading implementations
**         that prevent SQLite database connections from being used in
**         a thread different from the one where they were created.  With
**         the client/server approach, all database connections are created
**         and used within the server thread.  Client calls to the database
**         can be made from multiple threads (though not at the same time!)
**
**    (2)  Beginning with SQLite version 3.3.0, when two or more 
**         connections to the same database occur within the same thread,
**         they can optionally share their database cache.  This reduces
**         I/O and memory requirements.  Cache shared is controlled using
**         the sqlite3_enable_shared_cache() API.
**
**    (3)  Database connections on a shared cache use table-level locking
**         instead of file-level locking for improved concurrency.
**
**    (4)  Database connections on a shared cache can by optionally
**         set to READ UNCOMMITTED isolation.  (The default isolation for
**         SQLite is SERIALIZABLE.)  When this occurs, readers will
**         never be blocked by a writer and writers will not be
**         blocked by readers.  There can still only be a single writer
**         at a time, but multiple readers can simultaneously exist with
**         that writer.  This is a huge increase in concurrency.
**
** To summarize the rational for using a client/server approach: prior
** to SQLite version 3.3.0 it probably was not worth the trouble.  But
** with SQLite version 3.3.0 and beyond you can get significant performance
** and concurrency improvements and memory usage reductions by going
** client/server.
**
** Note:  The extra features of version 3.3.0 described by points (2)
** through (4) above are only available if you compile without the
** option -DSQLITE_OMIT_SHARED_CACHE. 
**
** Here is how the client/server approach works:  The database server
** thread is started on this procedure:
**
**       void *sqlite3_server(void *NotUsed);
**
** The sqlite_server procedure runs as long as the g.serverHalt variable
** is false.  A mutex is used to make sure no more than one server runs
** at a time.  The server waits for messages to arrive on a message
** queue and processes the messages in order.
**
** Two convenience routines are provided for starting and stopping the
** server thread:
**
**       void sqlite3_server_start(void);
**       void sqlite3_server_stop(void);
**
** Both of the convenience routines return immediately.  Neither will
** ever give an error.  If a server is already started or already halted,
** then the routines are effectively no-ops.
**
** Clients use the following interfaces:
**
**       sqlite3_client_open
**       sqlite3_client_prepare
**       sqlite3_client_step
**       sqlite3_client_reset
**       sqlite3_client_finalize
**       sqlite3_client_close
**
** These interfaces work exactly like the standard core SQLite interfaces
** having the same names without the "_client_" infix.  Many other SQLite
** interfaces can be used directly without having to send messages to the
** server as long as SQLITE_ENABLE_MEMORY_MANAGEMENT is not defined.
** The following interfaces fall into this second category:
**
**       sqlite3_bind_*
**       sqlite3_changes
**       sqlite3_clear_bindings
**       sqlite3_column_*
**       sqlite3_complete
**       sqlite3_create_collation
**       sqlite3_create_function
**       sqlite3_data_count
**       sqlite3_db_handle
**       sqlite3_errcode
**       sqlite3_errmsg
**       sqlite3_last_insert_rowid
**       sqlite3_total_changes
**       sqlite3_transfer_bindings
**
** A single SQLite connection (an sqlite3* object) or an SQLite statement
** (an sqlite3_stmt* object) should only be passed to a single interface
** function at a time.  The connections and statements can be passed from
** any thread to any of the functions listed in the second group above as
** long as the same connection is not in use by two threads at once and
** as long as SQLITE_ENABLE_MEMORY_MANAGEMENT is not defined.  Additional
** information about the SQLITE_ENABLE_MEMORY_MANAGEMENT constraint is
** below.
**
** The busy handler for all database connections should remain turned
** off.  That means that any lock contention will cause the associated
** sqlite3_client_step() call to return immediately with an SQLITE_BUSY
** error code.  If a busy handler is enabled and lock contention occurs,
** then the entire server thread will block.  This will cause not only
** the requesting client to block but every other database client as
** well.  It is possible to enhance the code below so that lock
** contention will cause the message to be placed back on the top of
** the queue to be tried again later.  But such enhanced processing is
** not included here, in order to keep the example simple.
**
** This example code assumes the use of pthreads.  Pthreads
** implementations are available for windows.  (See, for example
** http://sourceware.org/pthreads-win32/announcement.html.)  Or, you
** can translate the locking and thread synchronization code to use
** windows primitives easily enough.  The details are left as an
** exercise to the reader.
**
**** Restrictions Associated With SQLITE_ENABLE_MEMORY_MANAGEMENT ****
**
** If you compile with SQLITE_ENABLE_MEMORY_MANAGEMENT defined, then
** SQLite includes code that tracks how much memory is being used by
** each thread.  These memory counts can become confused if memory
** is allocated by one thread and then freed by another.  For that
** reason, when SQLITE_ENABLE_MEMORY_MANAGEMENT is used, all operations
** that might allocate or free memory should be performanced in the same
** thread that originally created the database connection.  In that case,
** many of the operations that are listed above as safe to be performed
** in separate threads would need to be sent over to the server to be
** done there.  If SQLITE_ENABLE_MEMORY_MANAGEMENT is defined, then
** the following functions can be used safely from different threads
** without messing up the allocation counts:
**
**       sqlite3_bind_parameter_name
**       sqlite3_bind_parameter_index
**       sqlite3_changes
**       sqlite3_column_blob
**       sqlite3_column_count
**       sqlite3_complete
**       sqlite3_data_count
**       sqlite3_db_handle
**       sqlite3_errcode
**       sqlite3_errmsg
**       sqlite3_last_insert_rowid
**       sqlite3_total_changes
**
** The remaining functions are not thread-safe when memory management
** is enabled.  So one would have to define some new interface routines
** along the following lines:
**
**       sqlite3_client_bind_*
**       sqlite3_client_clear_bindings
**       sqlite3_client_column_*
**       sqlite3_client_create_collation
**       sqlite3_client_create_function
**       sqlite3_client_transfer_bindings
**
** The example code in this file is intended for use with memory
** management turned off.  So the implementation of these additional
** client interfaces is left as an exercise to the reader.
**
** It may seem surprising to the reader that the list of safe functions
** above does not include things like sqlite3_bind_int() or
** sqlite3_column_int().  But those routines might, in fact, allocate
** or deallocate memory.  In the case of sqlite3_bind_int(), if the
** parameter was previously bound to a string that string might need
** to be deallocated before the new integer value is inserted.  In
** the case of sqlite3_column_int(), the value of the column might be
** a UTF-16 string which will need to be converted to UTF-8 then into
** an integer.
*/</comment>

<comment type="block">/* Include this to get the definition of SQLITE_THREADSAFE, in the
** case that default values are used.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Only compile the code in this file on UNIX with a SQLITE_THREADSAFE build
** and only if the SQLITE_SERVER macro is defined.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_SERVER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SHARED_CACHE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_UNIX</name> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name></expr></cpp:if>

<comment type="block">/*
** We require only pthreads and the public interface of SQLite.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>

<comment type="block">/*
** Messages are passed from client to server and back again as 
** instances of the following structure.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>SqlMessage</name></name></type> <name>SqlMessage</name>;</typedef>
<struct>struct <name>SqlMessage</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                      <comment type="block">/* Opcode for the message */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                <comment type="block">/* The SQLite connection */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>         <comment type="block">/* A specific statement */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>errCode</name></decl>;</decl_stmt>                 <comment type="block">/* Error code returned */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>             <comment type="block">/* Input filename or SQL statement */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                   <comment type="block">/* Size of the zIn parameter for prepare() */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>            <comment type="block">/* Tail of the SQL statement */</comment>
  <decl_stmt><decl><type><name>SqlMessage</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>           <comment type="block">/* Next message in the queue */</comment>
  <decl_stmt><decl><type><name>SqlMessage</name> <modifier>*</modifier></type><name>pPrev</name></decl>;</decl_stmt>           <comment type="block">/* Previous message in the queue */</comment>
  <decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>clientMutex</name></decl>;</decl_stmt> <comment type="block">/* Hold this mutex to access the message */</comment>
  <decl_stmt><decl><type><name>pthread_cond_t</name></type> <name>clientWakeup</name></decl>;</decl_stmt> <comment type="block">/* Signal to wake up the client */</comment>
}</block>;</struct>

<comment type="block">/*
** Legal values for SqlMessage.op
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG_Open</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>  <comment type="block">/* sqlite3_open(zIn, &amp;pDb) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG_Prepare</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>  <comment type="block">/* sqlite3_prepare(pDb, zIn, nByte, &amp;pStmt, &amp;zOut) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG_Step</name></cpp:macro>       <cpp:value>3</cpp:value></cpp:define>  <comment type="block">/* sqlite3_step(pStmt) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG_Reset</name></cpp:macro>      <cpp:value>4</cpp:value></cpp:define>  <comment type="block">/* sqlite3_reset(pStmt) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG_Finalize</name></cpp:macro>   <cpp:value>5</cpp:value></cpp:define>  <comment type="block">/* sqlite3_finalize(pStmt) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG_Close</name></cpp:macro>      <cpp:value>6</cpp:value></cpp:define>  <comment type="block">/* sqlite3_close(pDb) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG_Done</name></cpp:macro>       <cpp:value>7</cpp:value></cpp:define>  <comment type="block">/* Server has finished with this message */</comment>


<comment type="block">/*
** State information about the server is stored in a static variable
** named "g" as follows:
*/</comment>
<struct><specifier>static</specifier> struct <name>ServerState</name> <block>{
  <decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>queueMutex</name></decl>;</decl_stmt>   <comment type="block">/* Hold this mutex to access the msg queue */</comment>
  <decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>serverMutex</name></decl>;</decl_stmt>  <comment type="block">/* Held by the server while it is running */</comment>
  <decl_stmt><decl><type><name>pthread_cond_t</name></type> <name>serverWakeup</name></decl>;</decl_stmt>  <comment type="block">/* Signal this condvar to wake up the server */</comment>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>serverHalt</name></decl>;</decl_stmt>      <comment type="block">/* Server halts itself when true */</comment>
  <decl_stmt><decl><type><name>SqlMessage</name> <modifier>*</modifier></type><name>pQueueHead</name></decl>;</decl_stmt>       <comment type="block">/* Head of the message queue */</comment>
  <decl_stmt><decl><type><name>SqlMessage</name> <modifier>*</modifier></type><name>pQueueTail</name></decl>;</decl_stmt>       <comment type="block">/* Tail of the message queue */</comment>
}</block> <decl><name>g</name> <init>= <expr><block>{
  <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr>,
  <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr>,
  <expr><name>PTHREAD_COND_INITIALIZER</name></expr>,
}</block></expr></init></decl>;</struct>

<comment type="block">/*
** Send a message to the server.  Block until we get a reply.
**
** The mutex and condition variable in the message are uninitialized
** when this routine is called.  This routine takes care of 
** initializing them and destroying them when it has finished.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sendToServer</name><parameter_list>(<parameter><decl><type><name>SqlMessage</name> <modifier>*</modifier></type><name>pMsg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Initialize the mutex and condition variable on the message
  */</comment>
  <expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMsg</name><operator>-&gt;</operator><name>clientMutex</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMsg</name><operator>-&gt;</operator><name>clientWakeup</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Add the message to the head of the server's message queue.
  */</comment>
  <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>queueMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMsg</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>g</name><operator>.</operator><name>pQueueHead</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>g</name><operator>.</operator><name>pQueueHead</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>g</name><operator>.</operator><name>pQueueTail</name></name> <operator>=</operator> <name>pMsg</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>g</name><operator>.</operator><name>pQueueHead</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>pMsg</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pMsg</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>.</operator><name>pQueueHead</name></name> <operator>=</operator> <name>pMsg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>queueMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Signal the server that the new message has be queued, then
  ** block waiting for the server to process the message.
  */</comment>
  <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMsg</name><operator>-&gt;</operator><name>clientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>serverWakeup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>pMsg</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>MSG_Done</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMsg</name><operator>-&gt;</operator><name>clientWakeup</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMsg</name><operator>-&gt;</operator><name>clientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMsg</name><operator>-&gt;</operator><name>clientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Destroy the mutex and condition variable of the message.
  */</comment>
  <expr_stmt><expr><call><name>pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMsg</name><operator>-&gt;</operator><name>clientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pthread_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMsg</name><operator>-&gt;</operator><name>clientWakeup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The following 6 routines are client-side implementations of the
** core SQLite interfaces:
**
**        sqlite3_open
**        sqlite3_prepare
**        sqlite3_step
**        sqlite3_reset
**        sqlite3_finalize
**        sqlite3_close
**
** Clients should use the following client-side routines instead of 
** the core routines above.
**
**        sqlite3_client_open
**        sqlite3_client_prepare
**        sqlite3_client_step
**        sqlite3_client_reset
**        sqlite3_client_finalize
**        sqlite3_client_close
**
** Each of these routines creates a message for the desired operation,
** sends that message to the server, waits for the server to process
** then message and return a response.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_client_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDatabaseName</name></decl></parameter>, <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SqlMessage</name></type> <name>msg</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>MSG_Open</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>zIn</name></name> <operator>=</operator> <name>zDatabaseName</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sendToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppDb</name> <operator>=</operator> <name><name>msg</name><operator>.</operator><name>pDb</name></name></expr>;</expr_stmt>
  <return>return <expr><name><name>msg</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_client_prepare</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzTail</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SqlMessage</name></type> <name>msg</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>MSG_Prepare</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>pDb</name></name> <operator>=</operator> <name>pDb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>zIn</name></name> <operator>=</operator> <name>zSql</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>nByte</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sendToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <name><name>msg</name><operator>.</operator><name>pStmt</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pzTail</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pzTail</name> <operator>=</operator> <name><name>msg</name><operator>.</operator><name>zOut</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name><name>msg</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_client_step</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SqlMessage</name></type> <name>msg</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>MSG_Step</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>pStmt</name></name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sendToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>msg</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_client_reset</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SqlMessage</name></type> <name>msg</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>MSG_Reset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>pStmt</name></name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sendToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>msg</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_client_finalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SqlMessage</name></type> <name>msg</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>MSG_Finalize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>pStmt</name></name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sendToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>msg</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_client_close</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SqlMessage</name></type> <name>msg</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>MSG_Close</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>pDb</name></name> <operator>=</operator> <name>pDb</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sendToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>msg</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine implements the server.  To start the server, first
** make sure g.serverHalt is false, then create a new detached thread
** on this procedure.  See the sqlite3_server_start() routine below
** for an example.  This procedure loops until g.serverHalt becomes
** true.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_server</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>pthread_mutex_trylock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>serverMutex</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Another server is already running */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_enable_shared_cache</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>!</operator><name><name>g</name><operator>.</operator><name>serverHalt</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SqlMessage</name> <modifier>*</modifier></type><name>pMsg</name></decl>;</decl_stmt>

    <comment type="block">/* Remove the last message from the message queue.
    */</comment>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>queueMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>g</name><operator>.</operator><name>pQueueTail</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>g</name><operator>.</operator><name>serverHalt</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>serverWakeup</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>queueMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>pMsg</name> <operator>=</operator> <name><name>g</name><operator>.</operator><name>pQueueTail</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pMsg</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pMsg</name><operator>-&gt;</operator><name>pPrev</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pMsg</name><operator>-&gt;</operator><name>pPrev</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>g</name><operator>.</operator><name>pQueueHead</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>g</name><operator>.</operator><name>pQueueTail</name></name> <operator>=</operator> <name><name>pMsg</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>queueMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pMsg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <comment type="block">/* Process the message just removed
    */</comment>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMsg</name><operator>-&gt;</operator><name>clientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name><name>pMsg</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>MSG_Open</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>pMsg</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>sqlite3_open</name><argument_list>(<argument><expr><name><name>pMsg</name><operator>-&gt;</operator><name>zIn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMsg</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>MSG_Prepare</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>pMsg</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name><name>pMsg</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><name><name>pMsg</name><operator>-&gt;</operator><name>zIn</name></name></expr></argument>, <argument><expr><name><name>pMsg</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name><name>pMsg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMsg</name><operator>-&gt;</operator><name>zOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>MSG_Step</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>pMsg</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pMsg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>MSG_Reset</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>pMsg</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pMsg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>MSG_Finalize</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>pMsg</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pMsg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>MSG_Close</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>pMsg</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>pMsg</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>

    <comment type="block">/* Signal the client that the message has been processed.
    */</comment>
    <expr_stmt><expr><name><name>pMsg</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>MSG_Done</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMsg</name><operator>-&gt;</operator><name>clientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMsg</name><operator>-&gt;</operator><name>clientWakeup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>serverMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Start a server thread if one is not already running.  If there
** is aleady a server thread running, the new thread will quickly
** die and this routine is effectively a no-op.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_server_start</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>pthread_t</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>g</name><operator>.</operator><name>serverHalt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sqlite3_server</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>pthread_detach</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** A wrapper around sqlite3_server() that decrements the int variable
** pointed to by the first argument after the sqlite3_server() call
** returns.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>serverWrapper</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pnDecr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3_server</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pnDecr</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is the similar to sqlite3_server_start(), except that
** the integer pointed to by the first argument is decremented when
** the server thread exits. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_server_start2</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnDecr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>pthread_t</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>g</name><operator>.</operator><name>serverHalt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>serverWrapper</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pnDecr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>pthread_detach</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If a server thread is running, then stop it.  If no server is
** running, this routine is effectively a no-op.
**
** This routine waits until the server has actually stopped before
** returning.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_server_stop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>g</name><operator>.</operator><name>serverHalt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pthread_cond_broadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>serverWakeup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>serverMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>serverMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OS_UNIX &amp;&amp; SQLITE_THREADSAFE */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(SQLITE_SERVER) */</comment>
</unit>
