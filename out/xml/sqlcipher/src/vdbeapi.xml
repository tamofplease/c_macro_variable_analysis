<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/vdbeapi.c"><comment type="block">/*
** 2004 May 26
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains code use to implement APIs that are part of the
** VDBE.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<comment type="block">/*
** Return TRUE (non-zero) of the statement supplied as an argument needs
** to be recompiled.  A statement needs to be recompiled whenever the
** execution environment changes in a way that would alter the program
** that sqlite3_prepare() generates.  For example, if new functions or
** collating sequences are registered or if an authorizer function is
** added or changed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_expired</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Vdbe</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>expired</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Check on a Vdbe to make sure it has not been finalized.  Log
** an error and return true if it has been finalized (or is otherwise
** invalid).  Return false if it is ok.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSafety</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_MISUSE</name></expr></argument>, <argument><expr><literal type="string">"API called with finalized prepared statement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSafetyNotNull</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_MISUSE</name></expr></argument>, <argument><expr><literal type="string">"API called with NULL prepared statement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>vdbeSafety</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
<comment type="block">/*
** Invoke the profile callback.  This routine is only called if we already
** know that the profile callback is defined and needs to be invoked.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>invokeProfileCallback</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iNow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iElapse</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>startTime</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mTrace</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_TRACE_PROFILE</name><operator>|</operator><name>SQLITE_TRACE_XPROFILE</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3OsCurrentTimeInt64</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iElapse</name> <operator>=</operator> <operator>(</operator><name>iNow</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>startTime</name></name><operator>)</operator><operator>*</operator><literal type="number">1000000</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xProfile</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>xProfile</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pProfileArg</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>, <argument><expr><name>iElapse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mTrace</name></name> <operator>&amp;</operator> <name>SQLITE_TRACE_PROFILE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>trace</name><operator>.</operator><name>xV2</name></name><argument_list>(<argument><expr><name>SQLITE_TRACE_PROFILE</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pTraceArg</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iElapse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>startTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
** The checkProfileCallback(DB,P) macro checks to see if a profile callback
** is needed, and it invokes the callback if it is needed.
*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>checkProfileCallback</name><parameter_list>(<parameter><type><name>DB</name></type></parameter>,<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>if( ((P)-&gt;startTime)&gt;0 ){ invokeProfileCallback(DB,P); }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>checkProfileCallback</name><parameter_list>(<parameter><type><name>DB</name></type></parameter>,<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>  <comment type="block">/*no-op*/</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The following routine destroys a virtual machine that is created by
** the sqlite3_compile() routine. The integer returned is an SQLITE_
** success/failure code that describes the result of executing the virtual
** machine.
**
** This routine sets the error code and string returned by
** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_finalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStmt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* IMPLEMENTATION-OF: R-57228-12904 Invoking sqlite3_finalize() on a NULL
    ** pointer is a harmless no-op. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>Vdbe</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>vdbeSafety</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkProfileCallback</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeFinalize</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3LeaveMutexAndCloseZombie</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Terminate the current execution of an SQL statement and reset it
** back to its starting state so that it can be reused. A success code from
** the prior execution is returned.
**
** This routine sets the error code and string returned by
** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_reset</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStmt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>Vdbe</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkProfileCallback</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeReset</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeRewind</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name> <operator>&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>errMask</name></name><operator>)</operator><operator>)</operator><operator>==</operator><name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set all the parameters in the compiled SQL statement to NULL.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_clear_bindings</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Vdbe</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name></expr></cpp:if>
  <decl_stmt><decl><type><name>sqlite3_mutex</name> <modifier>*</modifier></type><name>mutex</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Vdbe</name><operator>*</operator><operator>)</operator><name>pStmt</name><operator>)</operator><operator>-&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nVar</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aVar</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aVar</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prepFlags</name></name> <operator>&amp;</operator> <name>SQLITE_PREPARE_SAVESQL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>expmask</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>expmask</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**************************** sqlite3_value_  *******************************
** The following routines extract information from a Mem or sqlite3_value
** structure.
*/</comment>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_value_blob</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Blob</name><operator>|</operator><name>MEM_Str</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>ExpandBlob</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>MEM_Null</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Blob</name></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_value_bytes</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3ValueBytes</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_value_bytes16</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3ValueBytes</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>double</name></type> <name>sqlite3_value_double</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeRealValue</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_value_int</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>sqlite_int64</name></type> <name>sqlite3_value_int64</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>int</name></type> <name>sqlite3_value_subtype</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Subtype</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>pMem</name><operator>-&gt;</operator><name>eSubtype</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_value_pointer</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_TypeMask</name><operator>|</operator><name>MEM_Term</name><operator>|</operator><name>MEM_Subtype</name><operator>)</operator><operator>)</operator> <operator>==</operator>
                 <operator>(</operator><name>MEM_Null</name><operator>|</operator><name>MEM_Term</name><operator>|</operator><name>MEM_Subtype</name><operator>)</operator>
   <operator>&amp;&amp;</operator> <name>zPType</name><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>eSubtype</name></name><operator>==</operator><literal type="char">'p'</literal>
   <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zPType</name></name></expr></argument>, <argument><expr><name>zPType</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sqlite3_value_text</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3ValueText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_value_text16</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier></type> <name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3ValueText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_value_text16be</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3ValueText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF16BE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_value_text16le</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3ValueText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF16LE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>
<comment type="block">/* EVIDENCE-OF: R-12793-43283 Every value in SQLite has one of five
** fundamental datatypes: 64-bit signed integer 64-bit IEEE floating
** point number string BLOB NULL
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_value_type</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier></type> <name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aType</name><index>[]</index></name> <init>= <expr><block>{
     <expr><name>SQLITE_BLOB</name></expr>,     <comment type="block">/* 0x00 (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x01 NULL */</comment>
     <expr><name>SQLITE_TEXT</name></expr>,     <comment type="block">/* 0x02 TEXT */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x03 (not possible) */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x04 INTEGER */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x05 (not possible) */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x06 INTEGER + TEXT */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x07 (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x08 FLOAT */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x09 (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x0a FLOAT + TEXT */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x0b (not possible) */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x0c (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x0d (not possible) */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x0e (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x0f (not possible) */</comment>
     <expr><name>SQLITE_BLOB</name></expr>,     <comment type="block">/* 0x10 BLOB */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x11 (not possible) */</comment>
     <expr><name>SQLITE_TEXT</name></expr>,     <comment type="block">/* 0x12 (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x13 (not possible) */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x14 INTEGER + BLOB */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x15 (not possible) */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x16 (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x17 (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x18 FLOAT + BLOB */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x19 (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x1a (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x1b (not possible) */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x1c (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x1d (not possible) */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x1e (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x1f (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x20 INTREAL */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x21 (not possible) */</comment>
     <expr><name>SQLITE_TEXT</name></expr>,     <comment type="block">/* 0x22 INTREAL + TEXT */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x23 (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x24 (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x25 (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x26 (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x27 (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x28 (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x29 (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x2a (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x2b (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x2c (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x2d (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x2e (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x2f (not possible) */</comment>
     <expr><name>SQLITE_BLOB</name></expr>,     <comment type="block">/* 0x30 (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x31 (not possible) */</comment>
     <expr><name>SQLITE_TEXT</name></expr>,     <comment type="block">/* 0x32 (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x33 (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x34 (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x35 (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x36 (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x37 (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x38 (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x39 (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x3a (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x3b (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x3c (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x3d (not possible) */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x3e (not possible) */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x3f (not possible) */</comment>
  }</block></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><name>SQLITE_BLOB</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>SQLITE_NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>SQLITE_FLOAT</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>SQLITE_INTEGER</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>eType</name> <operator>=</operator> <name>SQLITE_TEXT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name> <operator>==</operator> <name><name>aType</name><index>[<expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_AffMask</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>aType</name><index>[<expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_AffMask</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return true if a parameter to xUpdate represents an unchanged column */</comment>
<function><type><name>int</name></type> <name>sqlite3_value_nochange</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_Null</name><operator>|</operator><name>MEM_Zero</name><operator>)</operator><operator>)</operator><operator>==</operator><operator>(</operator><name>MEM_Null</name><operator>|</operator><name>MEM_Zero</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return true if a parameter value originated from an sqlite3_bind() */</comment>
<function><type><name>int</name></type> <name>sqlite3_value_frombind</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_FromBind</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Make a copy of an sqlite3_value object
*/</comment>
<function><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>sqlite3_value_dup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>sqlite3_value</name> <modifier>*</modifier></type><name>pOrig</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrig</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pOrig</name></expr></argument>, <argument><expr><name>MEMCELLSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Dyn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Dyn</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Ephem</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemMakeWriteable</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Do not duplicate pointer values */</comment>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MEM_Term</name><operator>|</operator><name>MEM_Subtype</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Destroy an sqlite3_value object previously obtained from
** sqlite3_value_dup().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_value_free</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pOld</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
  

<comment type="block" format="doxygen">/**************************** sqlite3_result_  *******************************
** The following routines are used by user-defined functions to specify
** the function result.
**
** The setStrOrError() function calls sqlite3VdbeMemSetStr() to store the
** result as a string or blob.  Appropriate errors are set if the string/blob
** is too big or if an OOM occurs.
**
** The invokeValueDestructor(P,X) routine invokes destructor function X()
** on value P is not going to be used and need to be destroyed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setResultStrOrError</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,  <comment type="block">/* Function context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>,          <comment type="block">/* String pointer */</comment>
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,                  <comment type="block">/* Bytes in string, or negative */</comment>
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>,                 <comment type="block">/* Encoding of z.  0 for BLOBs */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>     <comment type="block">/* Destructor function */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_TOOBIG</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_toobig</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* The only errors possible from sqlite3VdbeMemSetStr are
      ** SQLITE_TOOBIG and SQLITE_NOMEM */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemTooBig</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_toobig</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>invokeValueDestructor</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* Value to destroy */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,       <comment type="block">/* The destructor */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>      <comment type="block">/* Set a SQLITE_TOOBIG error if no NULL */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xDel</name><operator>!=</operator><name>SQLITE_DYNAMIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>xDel</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* noop */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>xDel</name><operator>==</operator><name>SQLITE_TRANSIENT</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* noop */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>xDel</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error_toobig</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_TOOBIG</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_blob</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_blob64</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_uint64</name></type> <name>n</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xDel</name><operator>!=</operator><name>SQLITE_DYNAMIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0x7fffffff</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>invokeValueDestructor</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_double</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>rVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetDouble</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>rVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_error</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><name>void</name></type> <name>sqlite3_result_error16</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>void</name></type> <name>sqlite3_result_int</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_int64</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_null</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_pointer</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPType</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestructor</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetPointer</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>zPType</name></expr></argument>, <argument><expr><name>xDestructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_subtype</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>eSubtype</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>eSubtype</name></name> <operator>=</operator> <name>eSubtype</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Subtype</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_text</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_text64</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_uint64</name></type> <name>n</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>enc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xDel</name><operator>!=</operator><name>SQLITE_DYNAMIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>enc</name><operator>==</operator><name>SQLITE_UTF16</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>enc</name> <operator>=</operator> <name>SQLITE_UTF16NATIVE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0x7fffffff</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>invokeValueDestructor</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><name>void</name></type> <name>sqlite3_result_text16</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_text16be</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_UTF16BE</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_text16le</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_UTF16LE</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>
<function><type><name>void</name></type> <name>sqlite3_result_value</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemCopy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemTooBig</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_toobig</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_zeroblob</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_result_zeroblob64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><ternary><condition><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_result_zeroblob64</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>u64</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_toobig</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_TOOBIG</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetZeroBlob</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><call><name>sqlite3VdbeMemSetZeroBlob</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_error_code</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errCode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <ternary><condition><expr><name>errCode</name></expr> ?</condition><then> <expr><name>errCode</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name><operator>-&gt;</operator><name>rcApp</name></name> <operator>=</operator> <name>errCode</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>errCode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>,
                        <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Force an SQLITE_TOOBIG error. */</comment>
<function><type><name>void</name></type> <name>sqlite3_result_error_toobig</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <name>SQLITE_TOOBIG</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><literal type="string">"string or blob too big"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, 
                       <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* An SQLITE_NOMEM error. */</comment>
<function><type><name>void</name></type> <name>sqlite3_result_error_nomem</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_UNTESTABLE</name></cpp:ifndef>
<comment type="block">/* Force the INT64 value currently stored as the result to be
** a MEM_IntReal value.  See the SQLITE_TESTCTRL_RESULT_INTREAL
** test-control.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ResultIntReal</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content> 
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Int</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_IntReal</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** This function is called after a transaction has been committed. It 
** invokes callbacks registered with sqlite3_wal_hook() as required.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>doWalCallbacks</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nEntry</name> <operator>=</operator> <call><name>sqlite3PagerWalCallback</name><argument_list>(<argument><expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nEntry</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>xWalCallback</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>db</name><operator>-&gt;</operator><name>xWalCallback</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pWalArg</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>, <argument><expr><name>nEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Execute the statement pStmt, either until a row of data is ready, the
** statement is completely executed or an error occurs.
**
** This routine implements the bulk of the logic behind the sqlite_step()
** API.  The only thing omitted is the automatic recompile if a 
** schema change has occurred.  That detail is handled by the
** outer sqlite3_step() wrapper procedure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlite3Step</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>!=</operator><name>VDBE_RUN_STATE</name></expr> )</condition><block>{<block_content>
    <label><name>restart_step</name>:</label>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_READY_STATE</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_SCHEMA</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prepFlags</name></name> <operator>&amp;</operator> <name>SQLITE_PREPARE_SAVESQL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* If this statement was prepared using saved SQL and an 
          ** error has occurred, then return the error code in p-&gt;rc to the
          ** caller. Set the error code in the database handle to the same
          ** value.
          */</comment> 
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeTransferError</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <goto>goto <name>end_of_step</name>;</goto>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* If there are no other statements currently running, then
      ** reset the interrupt flag.  This prevents a call to sqlite3_interrupt
      ** from interrupting a statement that has not yet started.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>AtomicStore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>==</operator><literal type="number">0</literal> 
          <operator>||</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mTrace</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_TRACE_PROFILE</name><operator>|</operator><name>SQLITE_TRACE_XPROFILE</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
          <operator>&amp;&amp;</operator> <operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3OsCurrentTimeInt64</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>startTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>startTime</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name> <operator>=</operator> <name>VDBE_RUN_STATE</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else

    if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_HALT_STATE</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* We used to require that sqlite3_reset() be called before retrying
      ** sqlite3_step() after any error or after SQLITE_DONE.  But beginning
      ** with version 3.7.0, we changed this so that sqlite3_reset() would
      ** be called automatically instead of throwing the SQLITE_MISUSE error.
      ** This "automatic-reset" change is not technically an incompatibility, 
      ** since any application that receives an SQLITE_MISUSE is broken by
      ** definition.
      **
      ** Nevertheless, some published applications that were originally written
      ** for version 3.6.23 or earlier do in fact depend on SQLITE_MISUSE 
      ** returns, and those were broken by the automatic-reset change.  As a
      ** a work-around, the SQLITE_OMIT_AUTORESET compile-time restores the
      ** legacy behavior of returning SQLITE_MISUSE for cases where the 
      ** previous sqlite3_step() returned something other than a SQLITE_LOCKED
      ** or SQLITE_BUSY error.
      */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTORESET</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_BUSY</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_LOCKED</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_stmt</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_stmt</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_READY_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>restart_step</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rcApp</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>explain</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_EXPLAIN */</comment>
  <block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeExec</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeExec</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>SQLITE_ROW</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ROW</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
    <comment type="block">/* If the statement completed successfully, invoke the profile callback */</comment>
    <expr_stmt><expr><call><name>checkProfileCallback</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><name>doWalCallbacks</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prepFlags</name></name> <operator>&amp;</operator> <name>SQLITE_PREPARE_SAVESQL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* If this statement was prepared using saved SQL and an 
      ** error has occurred, then return the error code in p-&gt;rc to the
      ** caller. Set the error code in the database handle to the same value.
      */</comment> 
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeTransferError</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_NOMEM</name><operator>==</operator><call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prepFlags</name></name> <operator>&amp;</operator> <name>SQLITE_PREPARE_SAVESQL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<label><name>end_of_step</name>:</label>
  <comment type="block">/* There are only a limited number of result codes allowed from the
  ** statements prepared using the legacy sqlite3_prepare() interface */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prepFlags</name></name> <operator>&amp;</operator> <name>SQLITE_PREPARE_SAVESQL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_ROW</name>  <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_DONE</name>   <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_ERROR</name> 
       <operator>||</operator> <operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_BUSY</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_MISUSE</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>errMask</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the top-level implementation of sqlite3_step().  Call
** sqlite3Step() to do most of the work.  If a schema error occurs,
** call sqlite3Reprepare() and try again.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_step</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Result from sqlite3Step() */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>Vdbe</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* the prepared statement */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Counter to prevent infinite loop of reprepares */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>             <comment type="block">/* The database connection */</comment>

  <if_stmt><if>if<condition>( <expr><call><name>vdbeSafetyNotNull</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3Step</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_SCHEMA</name>
         <operator>&amp;&amp;</operator> <name>cnt</name><operator>++</operator> <operator>&lt;</operator> <name>SQLITE_MAX_SCHEMA_RETRY</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>savedPc</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>pc</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Reprepare</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* This case occurs after failing to recompile an sql statement. 
      ** The error message from the SQL compiler has already been loaded 
      ** into the database handle. This block copies the error message 
      ** from the database handle into the statement and sets the statement
      ** program counter to 0 to ensure that when the statement is 
      ** finalized or reset the parser error message is available via
      ** sqlite3_errmsg() and sqlite3_errcode().
      */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>savedPc</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Setting minWriteFileFormat to 254 is a signal to the OP_Init and
      ** OP_Trace opcodes to *not* perform SQLITE_TRACE_STMT because it has
      ** already been done once on a prior invocation that failed due to
      ** SQLITE_SCHEMA.   tag-20220401a  */</comment>
      <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>minWriteFileFormat</name></name> <operator>=</operator> <literal type="number">254</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>v</name><operator>-&gt;</operator><name>expired</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Extract the user data from a sqlite3_context structure and return a
** pointer to it.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_user_data</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pFunc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>pUserData</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Extract the user data from a sqlite3_context structure and return a
** pointer to it.
**
** IMPLEMENTATION-OF: R-46798-50301 The sqlite3_context_db_handle() interface
** returns a copy of the pointer to the database connection (the 1st
** parameter) of the sqlite3_create_function() and
** sqlite3_create_function16() routines that originally registered the
** application defined function.
*/</comment>
<function><type><name>sqlite3</name> <modifier>*</modifier></type><name>sqlite3_context_db_handle</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If this routine is invoked from within an xColumn method of a virtual
** table, then it returns true if and only if the the call is during an
** UPDATE operation and the value of the column will not be modified
** by the UPDATE.
**
** If this routine is called from any context other than within the
** xColumn method of a virtual table, then the return value is meaningless
** and arbitrary.
**
** Virtual table implements might use this routine to optimize their
** performance by substituting a NULL result, or some other light-weight
** value, as a signal to the xUpdate routine that the column is unchanged.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_vtab_nochange</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3_value_nochange</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of sqlite3_vtab_in_first() (if bNext==0) and
** sqlite3_vtab_in_next() (if bNext!=0).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>valueFromValueList</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>,        <comment type="block">/* Pointer to the ValueList object */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>,      <comment type="block">/* Store the next value from the list here */</comment>
  <parameter><decl><type><name>int</name></type> <name>bNext</name></decl></parameter>                   <comment type="block">/* 1 for _next(). 0 for _first() */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ValueList</name> <modifier>*</modifier></type><name>pRhs</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVal</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pRhs</name> <operator>=</operator> <operator>(</operator><name>ValueList</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_pointer</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><literal type="string">"ValueList"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRhs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>bNext</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeNext</name><argument_list>(<argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>dummy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeFirst</name><argument_list>(<argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <call><name>sqlite3BtreeEof</name><argument_list>(<argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeEof</name><argument_list>(<argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>sz</name></decl>;</decl_stmt>       <comment type="block">/* Size of current row in bytes */</comment>
    <decl_stmt><decl><type><name>Mem</name></type> <name>sMem</name></decl>;</decl_stmt>     <comment type="block">/* Raw content of current row */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sMem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>sqlite3BtreePayloadSize</name><argument_list>(<argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemFromBtreeZeroOffset</name><argument_list>(<argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>sz</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>zBuf</name> <init>= <expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>sMem</name><operator>.</operator><name>z</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>iSerial</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><name><name>pRhs</name><operator>-&gt;</operator><name>pOut</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iOff</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iSerial</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name>iSerial</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <call><name>ENC</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Ephem</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3VdbeMemMakeWriteable</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pOut</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the iterator value pVal to point to the first value in the set.
** Set (*ppOut) to point to this value before returning.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_vtab_in_first</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>valueFromValueList</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>ppOut</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the iterator value pVal to point to the next value in the set.
** Set (*ppOut) to point to this value before returning.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_vtab_in_next</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>valueFromValueList</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>ppOut</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the current time for a statement.  If the current time
** is requested more than once within the same run of a single prepared
** statement, the exact same time is returned for each invocation regardless
** of the amount of time that elapses between invocations.  In other words,
** the time returned is always the time of the first call.
*/</comment>
<function><type><name>sqlite3_int64</name></type> <name>sqlite3StmtCurrentTime</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifndef>
  <decl_stmt><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piTime</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pVdbe</name><operator>-&gt;</operator><name>iCurrentTime</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piTime</name> <init>= <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pVdbe</name><operator>-&gt;</operator><name>iCurrentTime</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name>iTime</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>piTime</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsCurrentTimeInt64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name>piTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piTime</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>*</operator><name>piTime</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new aggregate context for p and return a pointer to
** its pMem-&gt;z element.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name> <modifier>*</modifier></type><name>createAggContext</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pMem</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Agg</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemClearAndResize</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Agg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pDef</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFunc</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate or return the aggregate context for a user function.  A new
** context is allocated on the first call.  Subsequent calls return the
** same context that was returned on prior calls.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_aggregate_context</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pFunc</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>xFinalize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nByte</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Agg</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>createAggContext</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the auxiliary data pointer, if any, for the iArg'th argument to
** the user-function defined by pCtx.
**
** The left-most argument is 0.
**
** Undocumented behavior:  If iArg is negative then access a cache of
** auxiliary data pointers that is available to all functions within a
** single prepared statement.  The iArg values must match.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_get_auxdata</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AuxData</name> <modifier>*</modifier></type><name>pAuxData</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_STAT4</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for<control>(<init><expr><name>pAuxData</name><operator>=</operator><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name><operator>-&gt;</operator><name>pAuxData</name></name></expr>;</init> <condition><expr><name>pAuxData</name></expr>;</condition> <incr><expr><name>pAuxData</name><operator>=</operator><name><name>pAuxData</name><operator>-&gt;</operator><name>pNextAux</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>(  <expr><name><name>pAuxData</name><operator>-&gt;</operator><name>iAuxArg</name></name><operator>==</operator><name>iArg</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pAuxData</name><operator>-&gt;</operator><name>iAuxOp</name></name><operator>==</operator><name><name>pCtx</name><operator>-&gt;</operator><name>iOp</name></name> <operator>||</operator> <name>iArg</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <return>return <expr><name><name>pAuxData</name><operator>-&gt;</operator><name>pAux</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the auxiliary data pointer and delete function, for the iArg'th
** argument to the user-function defined by pCtx. Any previous value is
** deleted by calling the delete function specified when it was set.
**
** The left-most argument is 0.
**
** Undocumented behavior:  If iArg is negative then make the data available
** to all functions within the current prepared statement using iArg as an
** access code.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_set_auxdata</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iArg</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDelete</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AuxData</name> <modifier>*</modifier></type><name>pAuxData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVdbe</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>pVdbe</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVdbe</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <for>for<control>(<init><expr><name>pAuxData</name><operator>=</operator><name><name>pVdbe</name><operator>-&gt;</operator><name>pAuxData</name></name></expr>;</init> <condition><expr><name>pAuxData</name></expr>;</condition> <incr><expr><name>pAuxData</name><operator>=</operator><name><name>pAuxData</name><operator>-&gt;</operator><name>pNextAux</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pAuxData</name><operator>-&gt;</operator><name>iAuxArg</name></name><operator>==</operator><name>iArg</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pAuxData</name><operator>-&gt;</operator><name>iAuxOp</name></name><operator>==</operator><name><name>pCtx</name><operator>-&gt;</operator><name>iOp</name></name> <operator>||</operator> <name>iArg</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>pAuxData</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pAuxData</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name><name>pVdbe</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AuxData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pAuxData</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pAuxData</name><operator>-&gt;</operator><name>iAuxOp</name></name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>iOp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pAuxData</name><operator>-&gt;</operator><name>iAuxArg</name></name> <operator>=</operator> <name>iArg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pAuxData</name><operator>-&gt;</operator><name>pNextAux</name></name> <operator>=</operator> <name><name>pVdbe</name><operator>-&gt;</operator><name>pAuxData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pVdbe</name><operator>-&gt;</operator><name>pAuxData</name></name> <operator>=</operator> <name>pAuxData</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pAuxData</name><operator>-&gt;</operator><name>xDeleteAux</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>pAuxData</name><operator>-&gt;</operator><name>xDeleteAux</name></name><argument_list>(<argument><expr><name><name>pAuxData</name><operator>-&gt;</operator><name>pAux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pAuxData</name><operator>-&gt;</operator><name>pAux</name></name> <operator>=</operator> <name>pAux</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAuxData</name><operator>-&gt;</operator><name>xDeleteAux</name></name> <operator>=</operator> <name>xDelete</name></expr>;</expr_stmt>
  <return>return;</return>

<label><name>failed</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>xDelete</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>xDelete</name><argument_list>(<argument><expr><name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<comment type="block">/*
** Return the number of times the Step function of an aggregate has been 
** called.
**
** This function is deprecated.  Do not use it for new code.  It is
** provide only to avoid breaking legacy code.  New aggregate function
** implementations should keep their own counts within their aggregate
** context.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_aggregate_count</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pMem</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pFunc</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>xFinalize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return the number of columns in the result set for the statement pStmt.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_column_count</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVm</name> <init>= <expr><operator>(</operator><name>Vdbe</name> <operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><name>pVm</name></expr> ?</condition><then> <expr><name><name>pVm</name><operator>-&gt;</operator><name>nResColumn</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of values available from the current row of the
** currently executing statement pStmt.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_data_count</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVm</name> <init>= <expr><operator>(</operator><name>Vdbe</name> <operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVm</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pVm</name><operator>-&gt;</operator><name>pResultSet</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>pVm</name><operator>-&gt;</operator><name>nResColumn</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to static memory containing an SQL NULL value.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>columnNullValue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Even though the Mem structure contains an element
  ** of type i64, on certain architectures (x86) with certain compiler
  ** switches (-Os), gcc may align this Mem object on a 4-byte boundary
  ** instead of an 8-byte one. This all works fine, except that when
  ** running with SQLITE_DEBUG defined the SQLite code sometimes assert()s
  ** that a Mem structure is located on an 8-byte boundary. To prevent
  ** these assert()s from failing, when building with SQLITE_DEBUG defined
  ** using gcc, we force nullMem to be 8-byte aligned using the magical
  ** __attribute__((aligned(8))) macro.  */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Mem</name> <name>nullMem</name></type> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><call><name>aligned</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <init>= <expr><block>{
        <comment type="block">/* .u          = */</comment> <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>,
        <comment type="block">/* .z          = */</comment> <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .n          = */</comment> <expr><operator>(</operator><name>int</name><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .flags      = */</comment> <expr><operator>(</operator><name>u16</name><operator>)</operator><name>MEM_Null</name></expr>,
        <comment type="block">/* .enc        = */</comment> <expr><operator>(</operator><name>u8</name><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .eSubtype   = */</comment> <expr><operator>(</operator><name>u8</name><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .db         = */</comment> <expr><operator>(</operator><name>sqlite3</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .szMalloc   = */</comment> <expr><operator>(</operator><name>int</name><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .uTemp      = */</comment> <expr><operator>(</operator><name>u32</name><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .zMalloc    = */</comment> <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .xDel       = */</comment> <expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><literal type="number">0</literal></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
        <comment type="block">/* .pScopyFrom = */</comment> <expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .mScopyFlags= */</comment> <expr><literal type="number">0</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>&amp;</operator><name>nullMem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if column iCol of the given statement is valid.  If
** it is, return a pointer to the Mem for the value of that column.
** If iCol is not valid, return a pointer to a Mem which has a value
** of NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>Mem</name> <modifier>*</modifier></type><name>columnMem</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pVm</name> <operator>=</operator> <operator>(</operator><name>Vdbe</name> <operator>*</operator><operator>)</operator><name>pStmt</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVm</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><call><name>columnNullValue</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pVm</name><operator>-&gt;</operator><name>db</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pVm</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pVm</name><operator>-&gt;</operator><name>pResultSet</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pVm</name><operator>-&gt;</operator><name>nResColumn</name></name> <operator>&amp;&amp;</operator> <name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>pResultSet</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name><name>pVm</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><call><name>columnNullValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pOut</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called after invoking an sqlite3_value_XXX function on a 
** column value (i.e. a value returned by evaluating an SQL expression in the
** select list of a SELECT statement) that may cause a malloc() failure. If 
** malloc() has failed, the threads mallocFailed flag is cleared and the result
** code of statement pStmt set to SQLITE_NOMEM.
**
** Specifically, this is called from within:
**
**     sqlite3_column_int()
**     sqlite3_column_int64()
**     sqlite3_column_text()
**     sqlite3_column_text16()
**     sqlite3_column_real()
**     sqlite3_column_bytes()
**     sqlite3_column_bytes16()
**     sqiite3_column_blob()
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>columnMallocFailure</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* If malloc() failed during an encoding conversion within an
  ** sqlite3_column_XXX API, then set the return code of the statement to
  ** SQLITE_NOMEM. The next call to _step() (if any) will return SQLITE_ERROR
  ** and _finalize() will return NOMEM.
  */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Vdbe</name> <operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**************************** sqlite3_column_  *******************************
** The following routines are used to access elements of the current row
** in the result set.
*/</comment>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_column_blob</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>sqlite3_value_blob</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Even though there is no encoding conversion, value_blob() might
  ** need to call malloc() to expand the result of a zeroblob() 
  ** expression. 
  */</comment>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_column_bytes</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_column_bytes16</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>sqlite3_value_bytes16</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>double</name></type> <name>sqlite3_column_double</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>val</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_column_int</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>sqlite_int64</name></type> <name>sqlite3_column_int64</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>val</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sqlite3_column_text</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>sqlite3_column_value</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Static</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Static</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Ephem</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>sqlite3_value</name> <operator>*</operator><operator>)</operator><name>pOut</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_column_text16</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>sqlite3_value_text16</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>
<function><type><name>int</name></type> <name>sqlite3_column_type</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iType</name> <init>= <expr><call><name>sqlite3_value_type</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>iType</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert the N-th element of pStmt-&gt;pColName[] into a string using
** xFunc() then return that string.  If N is out of range, return 0.
**
** There are up to 5 names for each column.  useType determines which
** name is returned.  Here are the names:
**
**    0      The column name as it should be displayed for output
**    1      The datatype name for the column
**    2      The name of the database that the column derives from
**    3      The name of the table that the column derives from
**    4      The name of the table column that the result column derives from
**
** If the result is not a simple column reference (if it is an expression
** or a constant) then useTypes 2, 3, and 4 return NULL.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>columnName</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>,     <comment type="block">/* The statement */</comment>
  <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>,                   <comment type="block">/* Which column to get the name for */</comment>
  <parameter><decl><type><name>int</name></type> <name>useUtf16</name></decl></parameter>,            <comment type="block">/* True to return the name as UTF16 */</comment>
  <parameter><decl><type><name>int</name></type> <name>useType</name></decl></parameter>              <comment type="block">/* What type of name */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>pStmt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Vdbe</name> <operator>*</operator><operator>)</operator><name>pStmt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>N</name><operator>&lt;</operator><name>n</name> <operator>&amp;&amp;</operator> <name>N</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>N</name> <operator>+=</operator> <name>useType</name><operator>*</operator><name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>useUtf16</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sqlite3_value_text16</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aColName</name><index>[<expr><name>N</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aColName</name><index>[<expr><name>N</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* A malloc may have failed inside of the _text() call. If this
    ** is the case, clear the mallocFailed flag and return NULL.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OomClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the name of the Nth column of the result set returned by SQL
** statement pStmt.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_column_name</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>columnName</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_column_name16</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>columnName</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Constraint:  If you have ENABLE_COLUMN_METADATA then you must
** not define OMIT_DECLTYPE.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_DECLTYPE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_COLUMN_METADATA</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> <cpp:literal>"Must not define both SQLITE_OMIT_DECLTYPE \</cpp:literal></cpp:error>
         <expr><name>and</name> <name>SQLITE_ENABLE_COLUMN_METADATA</name><literal type="string">"
#endif

#ifndef SQLITE_OMIT_DECLTYPE
/*
** Return the column declaration type (if applicable) of the 'i'th column
** of the result set of SQL statement pStmt.
*/
const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 0, COLNAME_DECLTYPE);
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 1, COLNAME_DECLTYPE);
}
#endif /* SQLITE_OMIT_UTF16 */
#endif /* SQLITE_OMIT_DECLTYPE */

#ifdef SQLITE_ENABLE_COLUMN_METADATA
/*
** Return the name of the database from which a result column derives.
** NULL is returned if the result column is an expression or constant or
** anything else which is not an unambiguous reference to a database column.
*/
const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 0, COLNAME_DATABASE);
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 1, COLNAME_DATABASE);
}
#endif /* SQLITE_OMIT_UTF16 */

/*
** Return the name of the table from which a result column derives.
** NULL is returned if the result column is an expression or constant or
** anything else which is not an unambiguous reference to a database column.
*/
const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 0, COLNAME_TABLE);
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 1, COLNAME_TABLE);
}
#endif /* SQLITE_OMIT_UTF16 */

/*
** Return the name of the table column from which a result column derives.
** NULL is returned if the result column is an expression or constant or
** anything else which is not an unambiguous reference to a database column.
*/
const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 0, COLNAME_COLUMN);
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 1, COLNAME_COLUMN);
}
#endif /* SQLITE_OMIT_UTF16 */
#endif /* SQLITE_ENABLE_COLUMN_METADATA */


/******************************* sqlite3_bind_  ***************************
** 
** Routines used to attach values to wildcards in a compiled SQL statement.
*/
/*
** Unbind the value bound to variable i in virtual machine p. This is the 
** the same as binding a NULL value to the column. If the "</literal><name>i</name><literal type="string">" parameter is
** out of range, then SQLITE_RANGE is returned. Othewise SQLITE_OK.
**
** A successful evaluation of this routine acquires the mutex on p.
** the mutex is released if any kind of error occurs.
**
** The error code stored in database p-&gt;db is overwritten with the return
** value in any case.
*/
static int vdbeUnbind(Vdbe *p, int i){
  Mem *pVar;
  if( vdbeSafetyNotNull(p) ){
    return SQLITE_MISUSE_BKPT;
  }
  sqlite3_mutex_enter(p-&gt;db-&gt;mutex);
  if( p-&gt;eVdbeState!=VDBE_READY_STATE ){
    sqlite3Error(p-&gt;db, SQLITE_MISUSE);
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
    sqlite3_log(SQLITE_MISUSE, 
        "</literal><name>bind</name> <name>on</name> <name>a</name> <name>busy</name> <name>prepared</name> <name>statement</name><operator>:</operator> <index>[<expr><operator>%</operator><name>s</name></expr>]</index><literal type="string">"</literal></expr>, p-&gt;zSql);
    return SQLITE_MISUSE_BKPT;
  }
  if( i&lt;1 || i&gt;p-&gt;nVar ){
    sqlite3Error(p-&gt;db, SQLITE_RANGE);
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
    return SQLITE_RANGE;
  }
  i--;
  pVar = &amp;p-&gt;aVar[i];
  sqlite3VdbeMemRelease(pVar);
  pVar-&gt;flags = MEM_Null;
  p-&gt;db-&gt;errCode = SQLITE_OK;

  /* If the bit corresponding to this variable in Vdbe.expmask is set, then 
  ** binding a new value to this variable invalidates the current query plan.
  **
  ** IMPLEMENTATION-OF: R-57496-20354 If the specific value bound to a host
  ** parameter in the WHERE clause might influence the choice of query plan
  ** for a statement, then the statement will be automatically recompiled,
  ** as if there had been a schema change, on the first sqlite3_step() call
  ** following any change to the bindings of that parameter.
  */
  assert( (p-&gt;prepFlags &amp; SQLITE_PREPARE_SAVESQL)!=0 || p-&gt;expmask==0 );
  if( p-&gt;expmask!=0 &amp;&amp; (p-&gt;expmask &amp; (i&gt;=31 ? 0x80000000 : (u32)1&lt;&lt;i))!=0 ){
    p-&gt;expired = 1;
  }
  return SQLITE_OK;
}

/*
** Bind a text or BLOB value.
*/
static int bindText(
  sqlite3_stmt *pStmt,   /* The statement to bind against */
  int i,                 /* Index of the parameter to bind */
  const void *zData,     /* Pointer to the data to be bound */
  i64 nData,             /* Number of bytes of data to be bound */
  void (*xDel)(void*),   /* Destructor for the data */
  u8 encoding            /* Encoding for the data */
){
  Vdbe *p = (Vdbe *)pStmt;
  Mem *pVar;
  int rc;

  rc = vdbeUnbind(p, i);
  if( rc==SQLITE_OK ){
    if( zData!=0 ){
      pVar = &amp;p-&gt;aVar[i-1];
      rc = sqlite3VdbeMemSetStr(pVar, zData, nData, encoding, xDel);
      if( rc==SQLITE_OK &amp;&amp; encoding!=0 ){
        rc = sqlite3VdbeChangeEncoding(pVar, ENC(p-&gt;db));
      }
      if( rc ){
        sqlite3Error(p-&gt;db, rc);
        rc = sqlite3ApiExit(p-&gt;db, rc);
      }
    }
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  }else if( xDel!=SQLITE_STATIC &amp;&amp; xDel!=SQLITE_TRANSIENT ){
    xDel((void*)zData);
  }
  return rc;
}


/*
** Bind a blob value to an SQL statement variable.
*/
int sqlite3_bind_blob(
  sqlite3_stmt *pStmt, 
  int i, 
  const void *zData, 
  int nData, 
  void (*xDel)(void*)
){
#ifdef SQLITE_ENABLE_API_ARMOR
  if( nData&lt;0 ) return SQLITE_MISUSE_BKPT;
#endif
  return bindText(pStmt, i, zData, nData, xDel, 0);
}
int sqlite3_bind_blob64(
  sqlite3_stmt *pStmt, 
  int i, 
  const void *zData, 
  sqlite3_uint64 nData, 
  void (*xDel)(void*)
){
  assert( xDel!=SQLITE_DYNAMIC );
  return bindText(pStmt, i, zData, nData, xDel, 0);
}
int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==SQLITE_OK ){
    sqlite3VdbeMemSetDouble(&amp;p-&gt;aVar[i-1], rValue);
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  }
  return rc;
}
int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){
  return sqlite3_bind_int64(p, i, (i64)iValue);
}
int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==SQLITE_OK ){
    sqlite3VdbeMemSetInt64(&amp;p-&gt;aVar[i-1], iValue);
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  }
  return rc;
}
int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){
  int rc;
  Vdbe *p = (Vdbe*)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==SQLITE_OK ){
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  }
  return rc;
}
int sqlite3_bind_pointer(
  sqlite3_stmt *pStmt,
  int i,
  void *pPtr,
  const char *zPTtype,
  void (*xDestructor)(void*)
){
  int rc;
  Vdbe *p = (Vdbe*)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==SQLITE_OK ){
    sqlite3VdbeMemSetPointer(&amp;p-&gt;aVar[i-1], pPtr, zPTtype, xDestructor);
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  }else if( xDestructor ){
    xDestructor(pPtr);
  }
  return rc;
}
int sqlite3_bind_text( 
  sqlite3_stmt *pStmt, 
  int i, 
  const char *zData, 
  int nData, 
  void (*xDel)(void*)
){
  return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF8);
}
int sqlite3_bind_text64( 
  sqlite3_stmt *pStmt, 
  int i, 
  const char *zData, 
  sqlite3_uint64 nData, 
  void (*xDel)(void*),
  unsigned char enc
){
  assert( xDel!=SQLITE_DYNAMIC );
  if( enc==SQLITE_UTF16 ) enc = SQLITE_UTF16NATIVE;
  return bindText(pStmt, i, zData, nData, xDel, enc);
}
#ifndef SQLITE_OMIT_UTF16
int sqlite3_bind_text16(
  sqlite3_stmt *pStmt, 
  int i, 
  const void *zData, 
  int nData, 
  void (*xDel)(void*)
){
  return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF16NATIVE);
}
#endif /* SQLITE_OMIT_UTF16 */
int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){
  int rc;
  switch( sqlite3_value_type((sqlite3_value*)pValue) ){
    case SQLITE_INTEGER: {
      rc = sqlite3_bind_int64(pStmt, i, pValue-&gt;u.i);
      break;
    }
    case SQLITE_FLOAT: {
      assert( pValue-&gt;flags &amp; (MEM_Real|MEM_IntReal) );
      rc = sqlite3_bind_double(pStmt, i, 
          (pValue-&gt;flags &amp; MEM_Real) ? pValue-&gt;u.r : (double)pValue-&gt;u.i
      );
      break;
    }
    case SQLITE_BLOB: {
      if( pValue-&gt;flags &amp; MEM_Zero ){
        rc = sqlite3_bind_zeroblob(pStmt, i, pValue-&gt;u.nZero);
      }else{
        rc = sqlite3_bind_blob(pStmt, i, pValue-&gt;z, pValue-&gt;n,SQLITE_TRANSIENT);
      }
      break;
    }
    case SQLITE_TEXT: {
      rc = bindText(pStmt,i,  pValue-&gt;z, pValue-&gt;n, SQLITE_TRANSIENT,
                              pValue-&gt;enc);
      break;
    }
    default: {
      rc = sqlite3_bind_null(pStmt, i);
      break;
    }
  }
  return rc;
}
int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==SQLITE_OK ){
#ifndef SQLITE_OMIT_INCRBLOB
    sqlite3VdbeMemSetZeroBlob(&amp;p-&gt;aVar[i-1], n);
#else
    rc = sqlite3VdbeMemSetZeroBlob(&amp;p-&gt;aVar[i-1], n);
#endif
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  }
  return rc;
}
int sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt, int i, sqlite3_uint64 n){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  sqlite3_mutex_enter(p-&gt;db-&gt;mutex);
  if( n&gt;(u64)p-&gt;db-&gt;aLimit[SQLITE_LIMIT_LENGTH] ){
    rc = SQLITE_TOOBIG;
  }else{
    assert( (n &amp; 0x7FFFFFFF)==n );
    rc = sqlite3_bind_zeroblob(pStmt, i, n);
  }
  rc = sqlite3ApiExit(p-&gt;db, rc);
  sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  return rc;
}

/*
** Return the number of wildcards that can be potentially bound to.
** This routine is added to support DBD::SQLite.  
*/
int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe*)pStmt;
  return p ? p-&gt;nVar : 0;
}

/*
** Return the name of a wildcard parameter.  Return NULL if the index
** is out of range or if the wildcard is unnamed.
**
** The result is always UTF-8.
*/
const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){
  Vdbe *p = (Vdbe*)pStmt;
  if( p==0 ) return 0;
  return sqlite3VListNumToName(p-&gt;pVList, i);
}

/*
** Given a wildcard parameter name, return the index of the variable
** with that name.  If there is no variable with the given name,
** return 0.
*/
int sqlite3VdbeParameterIndex(Vdbe *p, const char *zName, int nName){
  if( p==0 || zName==0 ) return 0;
  return sqlite3VListNameToNum(p-&gt;pVList, zName, nName);
}
int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){
  return sqlite3VdbeParameterIndex((Vdbe*)pStmt, zName, sqlite3Strlen30(zName));
}

/*
** Transfer all bindings from the first statement over to the second.
*/
int sqlite3TransferBindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
  Vdbe *pFrom = (Vdbe*)pFromStmt;
  Vdbe *pTo = (Vdbe*)pToStmt;
  int i;
  assert( pTo-&gt;db==pFrom-&gt;db );
  assert( pTo-&gt;nVar==pFrom-&gt;nVar );
  sqlite3_mutex_enter(pTo-&gt;db-&gt;mutex);
  for(i=0; i&lt;pFrom-&gt;nVar; i++){
    sqlite3VdbeMemMove(&amp;pTo-&gt;aVar[i], &amp;pFrom-&gt;aVar[i]);
  }
  sqlite3_mutex_leave(pTo-&gt;db-&gt;mutex);
  return SQLITE_OK;
}

#ifndef SQLITE_OMIT_DEPRECATED
/*
** Deprecated external interface.  Internal/core SQLite code
** should call sqlite3TransferBindings.
**
** It is misuse to call this routine with statements from different
** database connections.  But as this is a deprecated interface, we
** will not bother to check for that condition.
**
** If the two statements contain a different number of bindings, then
** an SQLITE_ERROR is returned.  Nothing else can go wrong, so otherwise
** SQLITE_OK is returned.
*/
int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
  Vdbe *pFrom = (Vdbe*)pFromStmt;
  Vdbe *pTo = (Vdbe*)pToStmt;
  if( pFrom-&gt;nVar!=pTo-&gt;nVar ){
    return SQLITE_ERROR;
  }
  assert( (pTo-&gt;prepFlags &amp; SQLITE_PREPARE_SAVESQL)!=0 || pTo-&gt;expmask==0 );
  if( pTo-&gt;expmask ){
    pTo-&gt;expired = 1;
  }
  assert( (pFrom-&gt;prepFlags &amp; SQLITE_PREPARE_SAVESQL)!=0 || pFrom-&gt;expmask==0 );
  if( pFrom-&gt;expmask ){
    pFrom-&gt;expired = 1;
  }
  return sqlite3TransferBindings(pFromStmt, pToStmt);
}
#endif

/*
** Return the sqlite3* database handle to which the prepared statement given
** in the argument belongs.  This is the same database handle that was
** the first argument to the sqlite3_prepare() that was used to create
** the statement in the first place.
*/
sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)-&gt;db : 0;
}

/*
** Return true if the prepared statement is guaranteed to not modify the
** database.
*/
int sqlite3_stmt_readonly(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)-&gt;readOnly : 1;
}

/*
** Return 1 if the statement is an EXPLAIN and return 2 if the
** statement is an EXPLAIN QUERY PLAN
*/
int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)-&gt;explain : 0;
}

/*
** Return true if the prepared statement is in need of being reset.
*/
int sqlite3_stmt_busy(sqlite3_stmt *pStmt){
  Vdbe *v = (Vdbe*)pStmt;
  return v!=0 &amp;&amp; v-&gt;eVdbeState==VDBE_RUN_STATE;
}

/*
** Return a pointer to the next prepared statement after pStmt associated
** with database connection pDb.  If pStmt is NULL, return the first
** prepared statement for the database connection.  Return NULL if there
** are no more.
*/
sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){
  sqlite3_stmt *pNext;
#ifdef SQLITE_ENABLE_API_ARMOR
  if( !sqlite3SafetyCheckOk(pDb) ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif
  sqlite3_mutex_enter(pDb-&gt;mutex);
  if( pStmt==0 ){
    pNext = (sqlite3_stmt*)pDb-&gt;pVdbe;
  }else{
    pNext = (sqlite3_stmt*)((Vdbe*)pStmt)-&gt;pNext;
  }
  sqlite3_mutex_leave(pDb-&gt;mutex);
  return pNext;
}

/*
** Return the value of a status counter for a prepared statement
*/
int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){
  Vdbe *pVdbe = (Vdbe*)pStmt;
  u32 v;
#ifdef SQLITE_ENABLE_API_ARMOR
  if( !pStmt 
   || (op!=SQLITE_STMTSTATUS_MEMUSED &amp;&amp; (op&lt;0||op&gt;=ArraySize(pVdbe-&gt;aCounter)))
  ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif
  if( op==SQLITE_STMTSTATUS_MEMUSED ){
    sqlite3 *db = pVdbe-&gt;db;
    sqlite3_mutex_enter(db-&gt;mutex);
    v = 0;
    db-&gt;pnBytesFreed = (int*)&amp;v;
    sqlite3VdbeDelete(pVdbe);
    db-&gt;pnBytesFreed = 0;
    sqlite3_mutex_leave(db-&gt;mutex);
  }else{
    v = pVdbe-&gt;aCounter[op];
    if( resetFlag ) pVdbe-&gt;aCounter[op] = 0;
  }
  return (int)v;
}

/*
** Return the SQL associated with a prepared statement
*/
const char *sqlite3_sql(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe *)pStmt;
  return p ? p-&gt;zSql : 0;
}

/*
** Return the SQL associated with a prepared statement with
** bound parameters expanded.  Space to hold the returned string is
** obtained from sqlite3_malloc().  The caller is responsible for
** freeing the returned string by passing it to sqlite3_free().
**
** The SQLITE_TRACE_SIZE_LIMIT puts an upper bound on the size of
** expanded bound parameters.
*/
char *sqlite3_expanded_sql(sqlite3_stmt *pStmt){
#ifdef SQLITE_OMIT_TRACE
  return 0;
#else
  char *z = 0;
  const char *zSql = sqlite3_sql(pStmt);
  if( zSql ){
    Vdbe *p = (Vdbe *)pStmt;
    sqlite3_mutex_enter(p-&gt;db-&gt;mutex);
    z = sqlite3VdbeExpandSql(p, zSql);
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  }
  return z;
#endif
}

#ifdef SQLITE_ENABLE_NORMALIZE
/*
** Return the normalized SQL associated with a prepared statement.
*/
const char *sqlite3_normalized_sql(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe *)pStmt;
  if( p==0 ) return 0;
  if( p-&gt;zNormSql==0 &amp;&amp; ALWAYS(p-&gt;zSql!=0) ){
    sqlite3_mutex_enter(p-&gt;db-&gt;mutex);
    p-&gt;zNormSql = sqlite3Normalize(p, p-&gt;zSql);
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  }
  return p-&gt;zNormSql;
}
#endif /* SQLITE_ENABLE_NORMALIZE */

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
/*
** Allocate and populate an UnpackedRecord structure based on the serialized
** record in nKey/pKey. Return a pointer to the new UnpackedRecord structure
** if successful, or a NULL pointer if an OOM error is encountered.
*/
static UnpackedRecord *vdbeUnpackRecord(
  KeyInfo *pKeyInfo, 
  int nKey, 
  const void *pKey
){
  UnpackedRecord *pRet;           /* Return value */

  pRet = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
  if( pRet ){
    memset(pRet-&gt;aMem, 0, sizeof(Mem)*(pKeyInfo-&gt;nKeyField+1));
    sqlite3VdbeRecordUnpack(pKeyInfo, nKey, pKey, pRet);
  }
  return pRet;
}

/*
** This function is called from within a pre-update callback to retrieve
** a field of the row currently being updated or deleted.
*/
int sqlite3_preupdate_old(sqlite3 *db, int iIdx, sqlite3_value **ppValue){
  PreUpdate *p = db-&gt;pPreUpdate;
  Mem *pMem;
  int rc = SQLITE_OK;

  /* Test that this call is being made from within an SQLITE_DELETE or
  ** SQLITE_UPDATE pre-update callback, and that iIdx is within range. */
  if( !p || p-&gt;op==SQLITE_INSERT ){
    rc = SQLITE_MISUSE_BKPT;
    goto preupdate_old_out;
  }
  if( p-&gt;pPk ){
    iIdx = sqlite3TableColumnToIndex(p-&gt;pPk, iIdx);
  }
  if( iIdx&gt;=p-&gt;pCsr-&gt;nField || iIdx&lt;0 ){
    rc = SQLITE_RANGE;
    goto preupdate_old_out;
  }

  /* If the old.* record has not yet been loaded into memory, do so now. */
  if( p-&gt;pUnpacked==0 ){
    u32 nRec;
    u8 *aRec;

    assert( p-&gt;pCsr-&gt;eCurType==CURTYPE_BTREE );
    nRec = sqlite3BtreePayloadSize(p-&gt;pCsr-&gt;uc.pCursor);
    aRec = sqlite3DbMallocRaw(db, nRec);
    if( !aRec ) goto preupdate_old_out;
    rc = sqlite3BtreePayload(p-&gt;pCsr-&gt;uc.pCursor, 0, nRec, aRec);
    if( rc==SQLITE_OK ){
      p-&gt;pUnpacked = vdbeUnpackRecord(&amp;p-&gt;keyinfo, nRec, aRec);
      if( !p-&gt;pUnpacked ) rc = SQLITE_NOMEM;
    }
    if( rc!=SQLITE_OK ){
      sqlite3DbFree(db, aRec);
      goto preupdate_old_out;
    }
    p-&gt;aRecord = aRec;
  }

  pMem = *ppValue = &amp;p-&gt;pUnpacked-&gt;aMem[iIdx];
  if( iIdx==p-&gt;pTab-&gt;iPKey ){
    sqlite3VdbeMemSetInt64(pMem, p-&gt;iKey1);
  }else if( iIdx&gt;=p-&gt;pUnpacked-&gt;nField ){
    *ppValue = (sqlite3_value *)columnNullValue();
  }else if( p-&gt;pTab-&gt;aCol[iIdx].affinity==SQLITE_AFF_REAL ){
    if( pMem-&gt;flags &amp; (MEM_Int|MEM_IntReal) ){
      testcase( pMem-&gt;flags &amp; MEM_Int );
      testcase( pMem-&gt;flags &amp; MEM_IntReal );
      sqlite3VdbeMemRealify(pMem);
    }
  }

 preupdate_old_out:
  sqlite3Error(db, rc);
  return sqlite3ApiExit(db, rc);
}
#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
/*
** This function is called from within a pre-update callback to retrieve
** the number of columns in the row being updated, deleted or inserted.
*/
int sqlite3_preupdate_count(sqlite3 *db){
  PreUpdate *p = db-&gt;pPreUpdate;
  return (p ? p-&gt;keyinfo.nKeyField : 0);
}
#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
/*
** This function is designed to be called from within a pre-update callback
** only. It returns zero if the change that caused the callback was made
** immediately by a user SQL statement. Or, if the change was made by a
** trigger program, it returns the number of trigger programs currently
** on the stack (1 for a top-level trigger, 2 for a trigger fired by a 
** top-level trigger etc.).
**
** For the purposes of the previous paragraph, a foreign key CASCADE, SET NULL
** or SET DEFAULT action is considered a trigger.
*/
int sqlite3_preupdate_depth(sqlite3 *db){
  PreUpdate *p = db-&gt;pPreUpdate;
  return (p ? p-&gt;v-&gt;nFrame : 0);
}
#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
/*
** This function is designed to be called from within a pre-update callback
** only. 
*/
int sqlite3_preupdate_blobwrite(sqlite3 *db){
  PreUpdate *p = db-&gt;pPreUpdate;
  return (p ? p-&gt;iBlobWrite : -1);
}
#endif

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
/*
** This function is called from within a pre-update callback to retrieve
** a field of the row currently being updated or inserted.
*/
int sqlite3_preupdate_new(sqlite3 *db, int iIdx, sqlite3_value **ppValue){
  PreUpdate *p = db-&gt;pPreUpdate;
  int rc = SQLITE_OK;
  Mem *pMem;

  if( !p || p-&gt;op==SQLITE_DELETE ){
    rc = SQLITE_MISUSE_BKPT;
    goto preupdate_new_out;
  }
  if( p-&gt;pPk &amp;&amp; p-&gt;op!=SQLITE_UPDATE ){
    iIdx = sqlite3TableColumnToIndex(p-&gt;pPk, iIdx);
  }
  if( iIdx&gt;=p-&gt;pCsr-&gt;nField || iIdx&lt;0 ){
    rc = SQLITE_RANGE;
    goto preupdate_new_out;
  }

  if( p-&gt;op==SQLITE_INSERT ){
    /* For an INSERT, memory cell p-&gt;iNewReg contains the serialized record
    ** that is being inserted. Deserialize it. */
    UnpackedRecord *pUnpack = p-&gt;pNewUnpacked;
    if( !pUnpack ){
      Mem *pData = &amp;p-&gt;v-&gt;aMem[p-&gt;iNewReg];
      rc = ExpandBlob(pData);
      if( rc!=SQLITE_OK ) goto preupdate_new_out;
      pUnpack = vdbeUnpackRecord(&amp;p-&gt;keyinfo, pData-&gt;n, pData-&gt;z);
      if( !pUnpack ){
        rc = SQLITE_NOMEM;
        goto preupdate_new_out;
      }
      p-&gt;pNewUnpacked = pUnpack;
    }
    pMem = &amp;pUnpack-&gt;aMem[iIdx];
    if( iIdx==p-&gt;pTab-&gt;iPKey ){
      sqlite3VdbeMemSetInt64(pMem, p-&gt;iKey2);
    }else if( iIdx&gt;=pUnpack-&gt;nField ){
      pMem = (sqlite3_value *)columnNullValue();
    }
  }else{
    /* For an UPDATE, memory cell (p-&gt;iNewReg+1+iIdx) contains the required
    ** value. Make a copy of the cell contents and return a pointer to it.
    ** It is not safe to return a pointer to the memory cell itself as the
    ** caller may modify the value text encoding.
    */
    assert( p-&gt;op==SQLITE_UPDATE );
    if( !p-&gt;aNew ){
      p-&gt;aNew = (Mem *)sqlite3DbMallocZero(db, sizeof(Mem) * p-&gt;pCsr-&gt;nField);
      if( !p-&gt;aNew ){
        rc = SQLITE_NOMEM;
        goto preupdate_new_out;
      }
    }
    assert( iIdx&gt;=0 &amp;&amp; iIdx&lt;p-&gt;pCsr-&gt;nField );
    pMem = &amp;p-&gt;aNew[iIdx];
    if( pMem-&gt;flags==0 ){
      if( iIdx==p-&gt;pTab-&gt;iPKey ){
        sqlite3VdbeMemSetInt64(pMem, p-&gt;iKey2);
      }else{
        rc = sqlite3VdbeMemCopy(pMem, &amp;p-&gt;v-&gt;aMem[p-&gt;iNewReg+1+iIdx]);
        if( rc!=SQLITE_OK ) goto preupdate_new_out;
      }
    }
  }
  *ppValue = pMem;

 preupdate_new_out:
  sqlite3Error(db, rc);
  return sqlite3ApiExit(db, rc);
}
#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */

#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
/*
** Return status data for a single loop within query pStmt.
*/
int sqlite3_stmt_scanstatus(
  sqlite3_stmt *pStmt,            /* Prepared statement being queried */
  int idx,                        /* Index of loop to report on */
  int iScanStatusOp,              /* Which metric to return */
  void *pOut                      /* OUT: Write the answer here */
){
  Vdbe *p = (Vdbe*)pStmt;
  ScanStatus *pScan;
  if( idx&lt;0 || idx&gt;=p-&gt;nScan ) return 1;
  pScan = &amp;p-&gt;aScan[idx];
  switch( iScanStatusOp ){
    case SQLITE_SCANSTAT_NLOOP: {
      *(sqlite3_int64*)pOut = p-&gt;anExec[pScan-&gt;addrLoop];
      break;
    }
    case SQLITE_SCANSTAT_NVISIT: {
      *(sqlite3_int64*)pOut = p-&gt;anExec[pScan-&gt;addrVisit];
      break;
    }
    case SQLITE_SCANSTAT_EST: {
      double r = 1.0;
      LogEst x = pScan-&gt;nEst;
      while( x&lt;100 ){
        x += 10;
        r *= 0.5;
      }
      *(double*)pOut = r*sqlite3LogEstToInt(x);
      break;
    }
    case SQLITE_SCANSTAT_NAME: {
      *(const char**)pOut = pScan-&gt;zName;
      break;
    }
    case SQLITE_SCANSTAT_EXPLAIN: {
      if( pScan-&gt;addrExplain ){
        *(const char**)pOut = p-&gt;aOp[ pScan-&gt;addrExplain ].p4.z;
      }else{
        *(const char**)pOut = 0;
      }
      break;
    }
    case SQLITE_SCANSTAT_SELECTID: {
      if( pScan-&gt;addrExplain ){
        *(int*)pOut = p-&gt;aOp[ pScan-&gt;addrExplain ].p1;
      }else{
        *(int*)pOut = -1;
      }
      break;
    }
    default: {
      return 1;
    }
  }
  return 0;
}

/*
** Zero all counters associated with the sqlite3_stmt_scanstatus() data.
*/
void sqlite3_stmt_scanstatus_reset(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe*)pStmt;
  memset(p-&gt;anExec, 0, p-&gt;nOp * sizeof(i64));
}
#endif /* SQLITE_ENABLE_STMT_SCANSTATUS */
</unit>
