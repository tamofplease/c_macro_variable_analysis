<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/pager.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This is the implementation of the page cache subsystem or "pager".
** 
** The pager is used to access a database disk file.  It implements
** atomic commit and rollback through the use of a journal file that
** is separate from the database file.  The pager also implements file
** locking to prevent two processes from writing the same database
** file simultaneously, or one process from reading the database while
** another is writing.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DISKIO</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"wal.h"</cpp:file></cpp:include>


<comment type="block" format="doxygen">/******************* NOTES ON THE DESIGN OF THE PAGER ************************
**
** This comment block describes invariants that hold when using a rollback
** journal.  These invariants do not apply for journal_mode=WAL,
** journal_mode=MEMORY, or journal_mode=OFF.
**
** Within this comment block, a page is deemed to have been synced
** automatically as soon as it is written when PRAGMA synchronous=OFF.
** Otherwise, the page is not synced until the xSync method of the VFS
** is called successfully on the file containing the page.
**
** Definition:  A page of the database file is said to be "overwriteable" if
** one or more of the following are true about the page:
** 
**     (a)  The original content of the page as it was at the beginning of
**          the transaction has been written into the rollback journal and
**          synced.
** 
**     (b)  The page was a freelist leaf page at the start of the transaction.
** 
**     (c)  The page number is greater than the largest page that existed in
**          the database file at the start of the transaction.
** 
** (1) A page of the database file is never overwritten unless one of the
**     following are true:
** 
**     (a) The page and all other pages on the same sector are overwriteable.
** 
**     (b) The atomic page write optimization is enabled, and the entire
**         transaction other than the update of the transaction sequence
**         number consists of a single page change.
** 
** (2) The content of a page written into the rollback journal exactly matches
**     both the content in the database when the rollback journal was written
**     and the content in the database at the beginning of the current
**     transaction.
** 
** (3) Writes to the database file are an integer multiple of the page size
**     in length and are aligned on a page boundary.
** 
** (4) Reads from the database file are either aligned on a page boundary and
**     an integer multiple of the page size in length or are taken from the
**     first 100 bytes of the database file.
** 
** (5) All writes to the database file are synced prior to the rollback journal
**     being deleted, truncated, or zeroed.
** 
** (6) If a super-journal file is used, then all writes to the database file
**     are synced prior to the super-journal being deleted.
** 
** Definition: Two databases (or the same database at two points it time)
** are said to be "logically equivalent" if they give the same answer to
** all queries.  Note in particular the content of freelist leaf
** pages can be changed arbitrarily without affecting the logical equivalence
** of the database.
** 
** (7) At any time, if any subset, including the empty set and the total set,
**     of the unsynced changes to a rollback journal are removed and the 
**     journal is rolled back, the resulting database file will be logically
**     equivalent to the database file at the beginning of the transaction.
** 
** (8) When a transaction is rolled back, the xTruncate method of the VFS
**     is called to restore the database file to the same size it was at
**     the beginning of the transaction.  (In some VFSes, the xTruncate
**     method is a no-op, but that does not change the fact the SQLite will
**     invoke it.)
** 
** (9) Whenever the database file is modified, at least one bit in the range
**     of bytes from 24 through 39 inclusive will be changed prior to releasing
**     the EXCLUSIVE lock, thus signaling other connections on the same
**     database to flush their caches.
**
** (10) The pattern of bits in bytes 24 through 39 shall not repeat in less
**      than one billion transactions.
**
** (11) A database file is well-formed at the beginning and at the conclusion
**      of every transaction.
**
** (12) An EXCLUSIVE lock is held on the database file when writing to
**      the database file.
**
** (13) A SHARED lock is held on the database file while reading any
**      content out of the database file.
**
******************************************************************************/</comment>

<comment type="block">/*
** Macros for troubleshooting.  Normally turned off
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
int sqlite3PagerTrace=1;  <comment type="block">/* True to enable tracing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3DebugPrintf</name></cpp:macro> <cpp:value>printf</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGERTRACE</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>     <cpp:value>if( sqlite3PagerTrace ){ sqlite3DebugPrintf X; }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGERTRACE</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The following two macros are used within the PAGERTRACE() macros above
** to print out file-descriptors. 
**
** PAGERID() takes a pointer to a Pager struct as its argument. The
** associated file-descriptor is returned. FILEHANDLEID() takes an sqlite3_file
** struct as its argument.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGERID</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(SQLITE_PTR_TO_INT(p-&gt;fd))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILEHANDLEID</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(SQLITE_PTR_TO_INT(fd))</cpp:value></cpp:define>

<comment type="block">/*
** The Pager.eState variable stores the current 'state' of a pager. A
** pager may be in any one of the seven states shown in the following
** state diagram.
**
**                            OPEN &lt;------+------+
**                              |         |      |
**                              V         |      |
**               +---------&gt; READER-------+      |
**               |              |                |
**               |              V                |
**               |&lt;-------WRITER_LOCKED------&gt; ERROR
**               |              |                ^  
**               |              V                |
**               |&lt;------WRITER_CACHEMOD--------&gt;|
**               |              |                |
**               |              V                |
**               |&lt;-------WRITER_DBMOD----------&gt;|
**               |              |                |
**               |              V                |
**               +&lt;------WRITER_FINISHED--------&gt;+
**
**
** List of state transitions and the C [function] that performs each:
** 
**   OPEN              -&gt; READER              [sqlite3PagerSharedLock]
**   READER            -&gt; OPEN                [pager_unlock]
**
**   READER            -&gt; WRITER_LOCKED       [sqlite3PagerBegin]
**   WRITER_LOCKED     -&gt; WRITER_CACHEMOD     [pager_open_journal]
**   WRITER_CACHEMOD   -&gt; WRITER_DBMOD        [syncJournal]
**   WRITER_DBMOD      -&gt; WRITER_FINISHED     [sqlite3PagerCommitPhaseOne]
**   WRITER_***        -&gt; READER              [pager_end_transaction]
**
**   WRITER_***        -&gt; ERROR               [pager_error]
**   ERROR             -&gt; OPEN                [pager_unlock]
** 
**
**  OPEN:
**
**    The pager starts up in this state. Nothing is guaranteed in this
**    state - the file may or may not be locked and the database size is
**    unknown. The database may not be read or written.
**
**    * No read or write transaction is active.
**    * Any lock, or no lock at all, may be held on the database file.
**    * The dbSize, dbOrigSize and dbFileSize variables may not be trusted.
**
**  READER:
**
**    In this state all the requirements for reading the database in 
**    rollback (non-WAL) mode are met. Unless the pager is (or recently
**    was) in exclusive-locking mode, a user-level read transaction is 
**    open. The database size is known in this state.
**
**    A connection running with locking_mode=normal enters this state when
**    it opens a read-transaction on the database and returns to state
**    OPEN after the read-transaction is completed. However a connection
**    running in locking_mode=exclusive (including temp databases) remains in
**    this state even after the read-transaction is closed. The only way
**    a locking_mode=exclusive connection can transition from READER to OPEN
**    is via the ERROR state (see below).
** 
**    * A read transaction may be active (but a write-transaction cannot).
**    * A SHARED or greater lock is held on the database file.
**    * The dbSize variable may be trusted (even if a user-level read 
**      transaction is not active). The dbOrigSize and dbFileSize variables
**      may not be trusted at this point.
**    * If the database is a WAL database, then the WAL connection is open.
**    * Even if a read-transaction is not open, it is guaranteed that 
**      there is no hot-journal in the file-system.
**
**  WRITER_LOCKED:
**
**    The pager moves to this state from READER when a write-transaction
**    is first opened on the database. In WRITER_LOCKED state, all locks 
**    required to start a write-transaction are held, but no actual 
**    modifications to the cache or database have taken place.
**
**    In rollback mode, a RESERVED or (if the transaction was opened with 
**    BEGIN EXCLUSIVE) EXCLUSIVE lock is obtained on the database file when
**    moving to this state, but the journal file is not written to or opened 
**    to in this state. If the transaction is committed or rolled back while 
**    in WRITER_LOCKED state, all that is required is to unlock the database 
**    file.
**
**    IN WAL mode, WalBeginWriteTransaction() is called to lock the log file.
**    If the connection is running with locking_mode=exclusive, an attempt
**    is made to obtain an EXCLUSIVE lock on the database file.
**
**    * A write transaction is active.
**    * If the connection is open in rollback-mode, a RESERVED or greater 
**      lock is held on the database file.
**    * If the connection is open in WAL-mode, a WAL write transaction
**      is open (i.e. sqlite3WalBeginWriteTransaction() has been successfully
**      called).
**    * The dbSize, dbOrigSize and dbFileSize variables are all valid.
**    * The contents of the pager cache have not been modified.
**    * The journal file may or may not be open.
**    * Nothing (not even the first header) has been written to the journal.
**
**  WRITER_CACHEMOD:
**
**    A pager moves from WRITER_LOCKED state to this state when a page is
**    first modified by the upper layer. In rollback mode the journal file
**    is opened (if it is not already open) and a header written to the
**    start of it. The database file on disk has not been modified.
**
**    * A write transaction is active.
**    * A RESERVED or greater lock is held on the database file.
**    * The journal file is open and the first header has been written 
**      to it, but the header has not been synced to disk.
**    * The contents of the page cache have been modified.
**
**  WRITER_DBMOD:
**
**    The pager transitions from WRITER_CACHEMOD into WRITER_DBMOD state
**    when it modifies the contents of the database file. WAL connections
**    never enter this state (since they do not modify the database file,
**    just the log file).
**
**    * A write transaction is active.
**    * An EXCLUSIVE or greater lock is held on the database file.
**    * The journal file is open and the first header has been written 
**      and synced to disk.
**    * The contents of the page cache have been modified (and possibly
**      written to disk).
**
**  WRITER_FINISHED:
**
**    It is not possible for a WAL connection to enter this state.
**
**    A rollback-mode pager changes to WRITER_FINISHED state from WRITER_DBMOD
**    state after the entire transaction has been successfully written into the
**    database file. In this state the transaction may be committed simply
**    by finalizing the journal file. Once in WRITER_FINISHED state, it is 
**    not possible to modify the database further. At this point, the upper 
**    layer must either commit or rollback the transaction.
**
**    * A write transaction is active.
**    * An EXCLUSIVE or greater lock is held on the database file.
**    * All writing and syncing of journal and database data has finished.
**      If no error occurred, all that remains is to finalize the journal to
**      commit the transaction. If an error did occur, the caller will need
**      to rollback the transaction. 
**
**  ERROR:
**
**    The ERROR state is entered when an IO or disk-full error (including
**    SQLITE_IOERR_NOMEM) occurs at a point in the code that makes it 
**    difficult to be sure that the in-memory pager state (cache contents, 
**    db size etc.) are consistent with the contents of the file-system.
**
**    Temporary pager files may enter the ERROR state, but in-memory pagers
**    cannot.
**
**    For example, if an IO error occurs while performing a rollback, 
**    the contents of the page-cache may be left in an inconsistent state.
**    At this point it would be dangerous to change back to READER state
**    (as usually happens after a rollback). Any subsequent readers might
**    report database corruption (due to the inconsistent cache), and if
**    they upgrade to writers, they may inadvertently corrupt the database
**    file. To avoid this hazard, the pager switches into the ERROR state
**    instead of READER following such an error.
**
**    Once it has entered the ERROR state, any attempt to use the pager
**    to read or write data returns an error. Eventually, once all 
**    outstanding transactions have been abandoned, the pager is able to
**    transition back to OPEN state, discarding the contents of the 
**    page-cache and any other in-memory state at the same time. Everything
**    is reloaded from disk (and, if necessary, hot-journal rollback peformed)
**    when a read-transaction is next opened on the pager (transitioning
**    the pager into READER state). At that point the system has recovered 
**    from the error.
**
**    Specifically, the pager jumps into the ERROR state if:
**
**      1. An error occurs while attempting a rollback. This happens in
**         function sqlite3PagerRollback().
**
**      2. An error occurs while attempting to finalize a journal file
**         following a commit in function sqlite3PagerCommitPhaseTwo().
**
**      3. An error occurs while attempting to write to the journal or
**         database file in function pagerStress() in order to free up
**         memory.
**
**    In other cases, the error is returned to the b-tree layer. The b-tree
**    layer then attempts a rollback operation. If the error condition 
**    persists, the pager enters the ERROR state via condition (1) above.
**
**    Condition (3) is necessary because it can be triggered by a read-only
**    statement executed within a transaction. In this case, if the error
**    code were simply returned to the user, the b-tree layer would not
**    automatically attempt a rollback, as it assumes that an error in a
**    read-only statement cannot leave the pager in an internally inconsistent 
**    state.
**
**    * The Pager.errCode variable is set to something other than SQLITE_OK.
**    * There are one or more outstanding references to pages (after the
**      last reference is dropped the pager should move back to OPEN state).
**    * The pager is not an in-memory pager.
**    
**
** Notes:
**
**   * A pager is never in WRITER_DBMOD or WRITER_FINISHED state if the
**     connection is open in WAL mode. A WAL connection is always in one
**     of the first four states.
**
**   * Normally, a connection open in exclusive mode is never in PAGER_OPEN
**     state. There are two exceptions: immediately after exclusive-mode has
**     been turned on (and before any read or write transactions are 
**     executed), and when the pager is leaving the "error state".
**
**   * See also: assert_pager_state().
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_OPEN</name></cpp:macro>                  <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_READER</name></cpp:macro>                <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_WRITER_LOCKED</name></cpp:macro>         <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_WRITER_CACHEMOD</name></cpp:macro>       <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_WRITER_DBMOD</name></cpp:macro>          <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_WRITER_FINISHED</name></cpp:macro>       <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_ERROR</name></cpp:macro>                 <cpp:value>6</cpp:value></cpp:define>

<comment type="block">/*
** The Pager.eLock variable is almost always set to one of the 
** following locking-states, according to the lock currently held on
** the database file: NO_LOCK, SHARED_LOCK, RESERVED_LOCK or EXCLUSIVE_LOCK.
** This variable is kept up to date as locks are taken and released by
** the pagerLockDb() and pagerUnlockDb() wrappers.
**
** If the VFS xLock() or xUnlock() returns an error other than SQLITE_BUSY
** (i.e. one of the SQLITE_IOERR subtypes), it is not clear whether or not
** the operation was successful. In these circumstances pagerLockDb() and
** pagerUnlockDb() take a conservative approach - eLock is always updated
** when unlocking the file, and only updated when locking the file if the
** VFS call is successful. This way, the Pager.eLock variable may be set
** to a less exclusive (lower) value than the lock that is actually held
** at the system level, but it is never set to a more exclusive value.
**
** This is usually safe. If an xUnlock fails or appears to fail, there may 
** be a few redundant xLock() calls or a lock may be held for longer than
** required, but nothing really goes wrong.
**
** The exception is when the database file is unlocked as the pager moves
** from ERROR to OPEN state. At this point there may be a hot-journal file 
** in the file-system that needs to be rolled back (as part of an OPEN-&gt;SHARED
** transition, by the same pager or any other). If the call to xUnlock()
** fails at this point and the pager is left holding an EXCLUSIVE lock, this
** can confuse the call to xCheckReservedLock() call made later as part
** of hot-journal detection.
**
** xCheckReservedLock() is defined as returning true "if there is a RESERVED 
** lock held by this process or any others". So xCheckReservedLock may 
** return true because the caller itself is holding an EXCLUSIVE lock (but
** doesn't know it because of a previous error in xUnlock). If this happens
** a hot-journal may be mistaken for a journal being created by an active
** transaction in another process, causing SQLite to read from the database
** without rolling it back.
**
** To work around this, if a call to xUnlock() fails when unlocking the
** database in the ERROR state, Pager.eLock is set to UNKNOWN_LOCK. It
** is only changed back to a real locking state after a successful call
** to xLock(EXCLUSIVE). Also, the code to do the OPEN-&gt;SHARED state transition
** omits the check for a hot-journal if Pager.eLock is set to UNKNOWN_LOCK 
** lock. Instead, it assumes a hot-journal exists and obtains an EXCLUSIVE
** lock on the database file before attempting to roll it back. See function
** PagerSharedLock() for more detail.
**
** Pager.eLock may only be set to UNKNOWN_LOCK when the pager is in 
** PAGER_OPEN state.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNKNOWN_LOCK</name></cpp:macro>                <cpp:value>(EXCLUSIVE_LOCK+1)</cpp:value></cpp:define>

<comment type="block">/*
** A macro used for invoking the codec if there is one
*/</comment>
<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CODEC1</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>D</name></type></parameter>,<parameter><type><name>N</name></type></parameter>,<parameter><type><name>X</name></type></parameter>,<parameter><type><name>E</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>if( P-&gt;xCodec &amp;&amp; P-&gt;xCodec(P-&gt;pCodec,D,N,X)==0 ){ E; }</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CODEC2</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>D</name></type></parameter>,<parameter><type><name>N</name></type></parameter>,<parameter><type><name>X</name></type></parameter>,<parameter><type><name>E</name></type></parameter>,<parameter><type><name>O</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>if( P-&gt;xCodec==0 ){ O=(char*)D; }else \
    if( (O=(char*)(P-&gt;xCodec(P-&gt;pCodec,D,N,X)))==0 ){ E; }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CODEC1</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>D</name></type></parameter>,<parameter><type><name>N</name></type></parameter>,<parameter><type><name>X</name></type></parameter>,<parameter><type><name>E</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>   <comment type="block">/* NO-OP */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CODEC2</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>D</name></type></parameter>,<parameter><type><name>N</name></type></parameter>,<parameter><type><name>X</name></type></parameter>,<parameter><type><name>E</name></type></parameter>,<parameter><type><name>O</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>O=(char*)D</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>

<comment type="block">/*
** The maximum allowed sector size. 64KiB. If the xSectorsize() method 
** returns a value larger than this, then MAX_SECTOR_SIZE is used instead.
** This could conceivably cause corruption following a power failure on
** such a system. This is currently an undocumented limit.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SECTOR_SIZE</name></cpp:macro> <cpp:value>0x10000</cpp:value></cpp:define>


<comment type="block">/*
** An instance of the following structure is allocated for each active
** savepoint and statement transaction in the system. All such structures
** are stored in the Pager.aSavepoint[] array, which is allocated and
** resized using sqlite3Realloc().
**
** When a savepoint is created, the PagerSavepoint.iHdrOffset field is
** set to 0. If a journal-header is written into the main journal while
** the savepoint is active, then iHdrOffset is set to the byte offset 
** immediately following the last journal record written into the main
** journal before the journal-header. This is required during savepoint
** rollback (see pagerPlaybackSavepoint()).
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>PagerSavepoint</name></name></type> <name>PagerSavepoint</name>;</typedef>
<struct>struct <name>PagerSavepoint</name> <block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>iOffset</name></decl>;</decl_stmt>                 <comment type="block">/* Starting offset in main journal */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iHdrOffset</name></decl>;</decl_stmt>              <comment type="block">/* See above */</comment>
  <decl_stmt><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name>pInSavepoint</name></decl>;</decl_stmt>        <comment type="block">/* Set of pages in this savepoint */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>nOrig</name></decl>;</decl_stmt>                  <comment type="block">/* Original number of pages in file */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iSubRec</name></decl>;</decl_stmt>                <comment type="block">/* Index of first record in sub-journal */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bTruncateOnRelease</name></decl>;</decl_stmt>      <comment type="block">/* If stmt journal may be truncated on RELEASE */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aWalData</name><index>[<expr><name>WAL_SAVEPOINT_NDATA</name></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* WAL savepoint context */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<comment type="block">/*
** Bits of the Pager.doNotSpill flag.  See further description below.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPILLFLAG_OFF</name></cpp:macro>         <cpp:value>0x01</cpp:value></cpp:define> <comment type="block">/* Never spill cache.  Set via pragma */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPILLFLAG_ROLLBACK</name></cpp:macro>    <cpp:value>0x02</cpp:value></cpp:define> <comment type="block">/* Current rolling back, so do not spill */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPILLFLAG_NOSYNC</name></cpp:macro>      <cpp:value>0x04</cpp:value></cpp:define> <comment type="block">/* Spill is ok, but do not sync */</comment>

<comment type="block">/*
** An open page cache is an instance of struct Pager. A description of
** some of the more important member variables follows:
**
** eState
**
**   The current 'state' of the pager object. See the comment and state
**   diagram above for a description of the pager state.
**
** eLock
**
**   For a real on-disk database, the current lock held on the database file -
**   NO_LOCK, SHARED_LOCK, RESERVED_LOCK or EXCLUSIVE_LOCK.
**
**   For a temporary or in-memory database (neither of which require any
**   locks), this variable is always set to EXCLUSIVE_LOCK. Since such
**   databases always have Pager.exclusiveMode==1, this tricks the pager
**   logic into thinking that it already has all the locks it will ever
**   need (and no reason to release them).
**
**   In some (obscure) circumstances, this variable may also be set to
**   UNKNOWN_LOCK. See the comment above the #define of UNKNOWN_LOCK for
**   details.
**
** changeCountDone
**
**   This boolean variable is used to make sure that the change-counter 
**   (the 4-byte header field at byte offset 24 of the database file) is 
**   not updated more often than necessary. 
**
**   It is set to true when the change-counter field is updated, which 
**   can only happen if an exclusive lock is held on the database file.
**   It is cleared (set to false) whenever an exclusive lock is 
**   relinquished on the database file. Each time a transaction is committed,
**   The changeCountDone flag is inspected. If it is true, the work of
**   updating the change-counter is omitted for the current transaction.
**
**   This mechanism means that when running in exclusive mode, a connection 
**   need only update the change-counter once, for the first transaction
**   committed.
**
** setSuper
**
**   When PagerCommitPhaseOne() is called to commit a transaction, it may
**   (or may not) specify a super-journal name to be written into the 
**   journal file before it is synced to disk.
**
**   Whether or not a journal file contains a super-journal pointer affects 
**   the way in which the journal file is finalized after the transaction is 
**   committed or rolled back when running in "journal_mode=PERSIST" mode.
**   If a journal file does not contain a super-journal pointer, it is
**   finalized by overwriting the first journal header with zeroes. If
**   it does contain a super-journal pointer the journal file is finalized 
**   by truncating it to zero bytes, just as if the connection were 
**   running in "journal_mode=truncate" mode.
**
**   Journal files that contain super-journal pointers cannot be finalized
**   simply by overwriting the first journal-header with zeroes, as the
**   super-journal pointer could interfere with hot-journal rollback of any
**   subsequently interrupted transaction that reuses the journal file.
**
**   The flag is cleared as soon as the journal file is finalized (either
**   by PagerCommitPhaseTwo or PagerRollback). If an IO error prevents the
**   journal file from being successfully finalized, the setSuper flag
**   is cleared anyway (and the pager will move to ERROR state).
**
** doNotSpill
**
**   This variables control the behavior of cache-spills  (calls made by
**   the pcache module to the pagerStress() routine to write cached data
**   to the file-system in order to free up memory).
**
**   When bits SPILLFLAG_OFF or SPILLFLAG_ROLLBACK of doNotSpill are set,
**   writing to the database from pagerStress() is disabled altogether.
**   The SPILLFLAG_ROLLBACK case is done in a very obscure case that
**   comes up during savepoint rollback that requires the pcache module
**   to allocate a new page to prevent the journal file from being written
**   while it is being traversed by code in pager_playback().  The SPILLFLAG_OFF
**   case is a user preference.
** 
**   If the SPILLFLAG_NOSYNC bit is set, writing to the database from
**   pagerStress() is permitted, but syncing the journal file is not.
**   This flag is set by sqlite3PagerWrite() when the file-system sector-size
**   is larger than the database page-size in order to prevent a journal sync
**   from happening in between the journalling of two pages on the same sector. 
**
** subjInMemory
**
**   This is a boolean variable. If true, then any required sub-journal
**   is opened as an in-memory journal file. If false, then in-memory
**   sub-journals are only used for in-memory pager files.
**
**   This variable is updated by the upper layer each time a new 
**   write-transaction is opened.
**
** dbSize, dbOrigSize, dbFileSize
**
**   Variable dbSize is set to the number of pages in the database file.
**   It is valid in PAGER_READER and higher states (all states except for
**   OPEN and ERROR). 
**
**   dbSize is set based on the size of the database file, which may be 
**   larger than the size of the database (the value stored at offset
**   28 of the database header by the btree). If the size of the file
**   is not an integer multiple of the page-size, the value stored in
**   dbSize is rounded down (i.e. a 5KB file with 2K page-size has dbSize==2).
**   Except, any file that is greater than 0 bytes in size is considered
**   to have at least one page. (i.e. a 1KB file with 2K page-size leads
**   to dbSize==1).
**
**   During a write-transaction, if pages with page-numbers greater than
**   dbSize are modified in the cache, dbSize is updated accordingly.
**   Similarly, if the database is truncated using PagerTruncateImage(), 
**   dbSize is updated.
**
**   Variables dbOrigSize and dbFileSize are valid in states 
**   PAGER_WRITER_LOCKED and higher. dbOrigSize is a copy of the dbSize
**   variable at the start of the transaction. It is used during rollback,
**   and to determine whether or not pages need to be journalled before
**   being modified.
**
**   Throughout a write-transaction, dbFileSize contains the size of
**   the file on disk in pages. It is set to a copy of dbSize when the
**   write-transaction is first opened, and updated when VFS calls are made
**   to write or truncate the database file on disk. 
**
**   The only reason the dbFileSize variable is required is to suppress 
**   unnecessary calls to xTruncate() after committing a transaction. If, 
**   when a transaction is committed, the dbFileSize variable indicates 
**   that the database file is larger than the database image (Pager.dbSize), 
**   pager_truncate() is called. The pager_truncate() call uses xFilesize()
**   to measure the database file on disk, and then truncates it if required.
**   dbFileSize is not used when rolling back a transaction. In this case
**   pager_truncate() is called unconditionally (which means there may be
**   a call to xFilesize() that is not strictly required). In either case,
**   pager_truncate() may cause the file to become smaller or larger.
**
** dbHintSize
**
**   The dbHintSize variable is used to limit the number of calls made to
**   the VFS xFileControl(FCNTL_SIZE_HINT) method. 
**
**   dbHintSize is set to a copy of the dbSize variable when a
**   write-transaction is opened (at the same time as dbFileSize and
**   dbOrigSize). If the xFileControl(FCNTL_SIZE_HINT) method is called,
**   dbHintSize is increased to the number of pages that correspond to the
**   size-hint passed to the method call. See pager_write_pagelist() for 
**   details.
**
** errCode
**
**   The Pager.errCode variable is only ever used in PAGER_ERROR state. It
**   is set to zero in all other states. In PAGER_ERROR state, Pager.errCode 
**   is always set to SQLITE_FULL, SQLITE_IOERR or one of the SQLITE_IOERR_XXX 
**   sub-codes.
**
** syncFlags, walSyncFlags
**
**   syncFlags is either SQLITE_SYNC_NORMAL (0x02) or SQLITE_SYNC_FULL (0x03).
**   syncFlags is used for rollback mode.  walSyncFlags is used for WAL mode
**   and contains the flags used to sync the checkpoint operations in the
**   lower two bits, and sync flags used for transaction commits in the WAL
**   file in bits 0x04 and 0x08.  In other words, to get the correct sync flags
**   for checkpoint operations, use (walSyncFlags&amp;0x03) and to get the correct
**   sync flags for transaction commit, use ((walSyncFlags&gt;&gt;2)&amp;0x03).  Note
**   that with synchronous=NORMAL in WAL mode, transaction commit is not synced
**   meaning that the 0x04 and 0x08 bits are both zero.
*/</comment>
<struct>struct <name>Pager</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl>;</decl_stmt>          <comment type="block">/* OS functions to use for IO */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>exclusiveMode</name></decl>;</decl_stmt>           <comment type="block">/* Boolean. True if locking_mode==EXCLUSIVE */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>journalMode</name></decl>;</decl_stmt>             <comment type="block">/* One of the PAGER_JOURNALMODE_* values */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>useJournal</name></decl>;</decl_stmt>              <comment type="block">/* Use a rollback journal on this file */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>noSync</name></decl>;</decl_stmt>                  <comment type="block">/* Do not sync the journal if true */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>fullSync</name></decl>;</decl_stmt>                <comment type="block">/* Do extra syncs of the journal for robustness */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>extraSync</name></decl>;</decl_stmt>               <comment type="block">/* sync directory after journal delete */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>syncFlags</name></decl>;</decl_stmt>               <comment type="block">/* SYNC_NORMAL or SYNC_FULL otherwise */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>walSyncFlags</name></decl>;</decl_stmt>            <comment type="block">/* See description above */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>tempFile</name></decl>;</decl_stmt>                <comment type="block">/* zFilename is a temporary or immutable file */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>noLock</name></decl>;</decl_stmt>                  <comment type="block">/* Do not lock (except in WAL mode) */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>readOnly</name></decl>;</decl_stmt>                <comment type="block">/* True for a read-only database */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>memDb</name></decl>;</decl_stmt>                   <comment type="block">/* True to inhibit all file I/O */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>memVfs</name></decl>;</decl_stmt>                  <comment type="block">/* VFS-implemented memory database */</comment>

  <comment type="block" format="doxygen">/**************************************************************************
  ** The following block contains those class members that change during
  ** routine operation.  Class members not in this block are either fixed
  ** when the pager is first created or else only change when there is a
  ** significant mode change (such as changing the page_size, locking_mode,
  ** or the journal_mode).  From another view, these class members describe
  ** the "state" of the pager, while other class members describe the
  ** "configuration" of the pager.
  */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>eState</name></decl>;</decl_stmt>                  <comment type="block">/* Pager state (OPEN, READER, WRITER_LOCKED..) */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>eLock</name></decl>;</decl_stmt>                   <comment type="block">/* Current lock held on database file */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>changeCountDone</name></decl>;</decl_stmt>         <comment type="block">/* Set after incrementing the change-counter */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>setSuper</name></decl>;</decl_stmt>                <comment type="block">/* Super-jrnl name is written into jrnl */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>doNotSpill</name></decl>;</decl_stmt>              <comment type="block">/* Do not spill the cache when non-zero */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>subjInMemory</name></decl>;</decl_stmt>            <comment type="block">/* True to use in-memory sub-journals */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bUseFetch</name></decl>;</decl_stmt>               <comment type="block">/* True to use xFetch() */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>hasHeldSharedLock</name></decl>;</decl_stmt>       <comment type="block">/* True if a shared lock has ever been held */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>dbSize</name></decl>;</decl_stmt>                <comment type="block">/* Number of pages in the database */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>dbOrigSize</name></decl>;</decl_stmt>            <comment type="block">/* dbSize before the current transaction */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>dbFileSize</name></decl>;</decl_stmt>            <comment type="block">/* Number of pages in the database file */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>dbHintSize</name></decl>;</decl_stmt>            <comment type="block">/* Value passed to FCNTL_SIZE_HINT call */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>errCode</name></decl>;</decl_stmt>                <comment type="block">/* One of several kinds of errors */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRec</name></decl>;</decl_stmt>                   <comment type="block">/* Pages journalled since last j-header written */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksumInit</name></decl>;</decl_stmt>              <comment type="block">/* Quasi-random value added to every checksum */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nSubRec</name></decl>;</decl_stmt>                <comment type="block">/* Number of records written to sub-journal */</comment>
  <decl_stmt><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name>pInJournal</name></decl>;</decl_stmt>         <comment type="block">/* One bit for each page in the database file */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>           <comment type="block">/* File descriptor for database */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>jfd</name></decl>;</decl_stmt>          <comment type="block">/* File descriptor for main journal */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>sjfd</name></decl>;</decl_stmt>         <comment type="block">/* File descriptor for sub-journal */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>journalOff</name></decl>;</decl_stmt>             <comment type="block">/* Current write offset in the journal file */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>journalHdr</name></decl>;</decl_stmt>             <comment type="block">/* Byte offset to previous journal header */</comment>
  <decl_stmt><decl><type><name>sqlite3_backup</name> <modifier>*</modifier></type><name>pBackup</name></decl>;</decl_stmt>    <comment type="block">/* Pointer to list of ongoing backup processes */</comment>
  <decl_stmt><decl><type><name>PagerSavepoint</name> <modifier>*</modifier></type><name>aSavepoint</name></decl>;</decl_stmt> <comment type="block">/* Array of active savepoints */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSavepoint</name></decl>;</decl_stmt>             <comment type="block">/* Number of elements in aSavepoint[] */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iDataVersion</name></decl>;</decl_stmt>           <comment type="block">/* Changes whenever database content changes */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>dbFileVers</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* Changes whenever database file changes */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>nMmapOut</name></decl>;</decl_stmt>               <comment type="block">/* Number of mmap pages currently outstanding */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>szMmap</name></decl>;</decl_stmt>       <comment type="block">/* Desired maximum mmap size */</comment>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pMmapFreelist</name></decl>;</decl_stmt>       <comment type="block">/* List of free mmap page headers (pDirty) */</comment>
  <comment type="block">/*
  ** End of the routinely-changing class members
  ***************************************************************************/</comment>

  <decl_stmt><decl><type><name>u16</name></type> <name>nExtra</name></decl>;</decl_stmt>                 <comment type="block">/* Add this many bytes to each in-memory page */</comment>
  <decl_stmt><decl><type><name>i16</name></type> <name>nReserve</name></decl>;</decl_stmt>               <comment type="block">/* Number of unused bytes at end of each page */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>vfsFlags</name></decl>;</decl_stmt>               <comment type="block">/* Flags for sqlite3_vfs.xOpen() */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>sectorSize</name></decl>;</decl_stmt>             <comment type="block">/* Assumed sector size during rollback */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>mxPgno</name></decl>;</decl_stmt>                <comment type="block">/* Maximum allowed size of the database */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>lckPgno</name></decl>;</decl_stmt>               <comment type="block">/* Page number for the locking page */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>pageSize</name></decl>;</decl_stmt>               <comment type="block">/* Number of bytes in a page */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>journalSizeLimit</name></decl>;</decl_stmt>       <comment type="block">/* Size limit for persistent journal files */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl>;</decl_stmt>            <comment type="block">/* Name of the database file */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zJournal</name></decl>;</decl_stmt>             <comment type="block">/* Name of the journal file */</comment>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xBusyHandler</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl> <comment type="block">/* Function to call when busy */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pBusyHandlerArg</name></decl>;</decl_stmt>      <comment type="block">/* Context argument for xBusyHandler */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>aStat</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>               <comment type="block">/* Total cache hits, misses, writes, spills */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name></decl>;</decl_stmt>                  <comment type="block">/* Database pages read */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xReiniter</name>)<parameter_list>(<parameter><decl><type><name>DbPage</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl> <comment type="block">/* Call this routine when reloading pages */</comment>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xGet</name>)<parameter_list>(<parameter><decl><type><name>Pager</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>Pgno</name></type></decl></parameter>,<parameter><decl><type><name>DbPage</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl> <comment type="block">/* Routine to fetch a patch */</comment>
<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
  <function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>xCodec</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>Pgno</name></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl> <comment type="block">/* Routine for en/decoding data */</comment>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xCodecSizeChng</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl> <comment type="block">/* Notify of page size changes */</comment>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xCodecFree</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>             <comment type="block">/* Destructor for the codec */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pCodec</name></decl>;</decl_stmt>               <comment type="block">/* First argument to xCodec... methods */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pTmpSpace</name></decl>;</decl_stmt>            <comment type="block">/* Pager.pageSize bytes of space for tmp use */</comment>
  <decl_stmt><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pPCache</name></decl>;</decl_stmt>            <comment type="block">/* Pointer to page cache object */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <decl_stmt><decl><type><name>Wal</name> <modifier>*</modifier></type><name>pWal</name></decl>;</decl_stmt>                  <comment type="block">/* Write-ahead log used by "journal_mode=wal" */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWal</name></decl>;</decl_stmt>                 <comment type="block">/* File name for write-ahead log */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<comment type="block">/*
** Indexes for use with Pager.aStat[]. The Pager.aStat[] array contains
** the values accessed by passing SQLITE_DBSTATUS_CACHE_HIT, CACHE_MISS 
** or CACHE_WRITE to sqlite3_db_status().
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_STAT_HIT</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_STAT_MISS</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_STAT_WRITE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_STAT_SPILL</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/*
** The following global variables hold counters used for
** testing purposes only.  These variables do not exist in
** a non-testing build.  These variables are not thread-safe.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_pager_readdb_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Number of full pages read from DB */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_pager_writedb_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Number of full pages written to DB */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_pager_writej_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Number of pages written to journal */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_INCR</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>v++</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PAGER_INCR</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<comment type="block">/*
** Journal files begin with the following magic string.  The data
** was obtained from /dev/random.  It is used only as a sanity check.
**
** Since version 2.8.0, the journal format contains additional sanity
** checking information.  If the power fails while the journal is being
** written, semi-random garbage data might appear in the journal
** file after power is restored.  If an attempt is then made
** to roll the journal back, the database could be corrupted.  The additional
** sanity checking data is an attempt to discover the garbage in the
** journal and ignore it.
**
** The sanity checking information for the new journal format consists
** of a 32-bit checksum on each page of data.  The checksum covers both
** the page number and the pPager-&gt;pageSize bytes of data for the page.
** This cksum is initialized to a 32-bit random value that appears in the
** journal file right after the header.  The random initializer is important,
** because garbage data that appears at the end of a journal is likely
** data that was once in other files that have now been deleted.  If the
** garbage data came from an obsolete journal file, the checksums might
** be correct.  But by initializing the checksum to random value which
** is different for every journal, we minimize that risk.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>aJournalMagic</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0xd9</literal></expr>, <expr><literal type="number">0xd5</literal></expr>, <expr><literal type="number">0x05</literal></expr>, <expr><literal type="number">0xf9</literal></expr>, <expr><literal type="number">0x20</literal></expr>, <expr><literal type="number">0xa1</literal></expr>, <expr><literal type="number">0x63</literal></expr>, <expr><literal type="number">0xd7</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** The size of the of each page record in the journal is given by
** the following macro.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JOURNAL_PG_SZ</name><parameter_list>(<parameter><type><name>pPager</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((pPager-&gt;pageSize) + 8)</cpp:value></cpp:define>

<comment type="block">/*
** The journal header size for this pager. This is usually the same 
** size as a single disk sector. See also setSectorSize().
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JOURNAL_HDR_SZ</name><parameter_list>(<parameter><type><name>pPager</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(pPager-&gt;sectorSize)</cpp:value></cpp:define>

<comment type="block">/*
** The macro MEMDB is true if we are dealing with an in-memory database.
** We do this as a macro so that if the SQLITE_OMIT_MEMORYDB macro is set,
** the value of MEMDB will be a constant and the compiler will optimize
** out code that would never execute.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_MEMORYDB</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>MEMDB</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>MEMDB</name></cpp:macro> <cpp:value>pPager-&gt;memDb</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The macro USEFETCH is true if we are allowed to use the xFetch and xUnfetch
** interfaces to access the database using memory-mapped I/O.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>USEFETCH</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x)-&gt;bUseFetch)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>USEFETCH</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The argument to this macro is a file descriptor (type sqlite3_file*).
** Return 0 if it is not open, or non-zero (but not 1) if it is.
**
** This is so that expressions can be written as:
**
**   if( isOpen(pPager-&gt;jfd) ){ ...
**
** instead of
**
**   if( pPager-&gt;jfd-&gt;pMethods ){ ...
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isOpen</name><parameter_list>(<parameter><type><name>pFd</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((pFd)-&gt;pMethods!=0)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DIRECT_OVERFLOW_READ</name></cpp:ifdef>
<comment type="block">/*
** Return true if page pgno can be read directly from the database file
** by the b-tree layer. This is the case if:
**
**   * the database file is open,
**   * there are no dirty pages in the cache, and
**   * the desired page is not currently in the wal file.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerDirectReadOk</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name><operator>-&gt;</operator><name>pMethods</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3PCacheIsDirty</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>xCodec</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>iRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalFindFrame</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iRead</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pagerUseWal</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x)-&gt;pWal!=0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pagerUseWal</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pagerRollbackWal</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pagerWalFrames</name><parameter_list>(<parameter><type><name>v</name></type></parameter>,<parameter><type><name>w</name></type></parameter>,<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pagerOpenWalIfPresent</name><parameter_list>(<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SQLITE_OK</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pagerBeginReadTransaction</name><parameter_list>(<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SQLITE_OK</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef> 
<comment type="block">/*
** Usage:
**
**   assert( assert_pager_state(pPager) );
**
** This function runs many asserts to try to find inconsistencies in
** the internal state of the Pager object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>assert_pager_state</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* State must be valid. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name>
       <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_READER</name>
       <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_LOCKED</name>
       <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_CACHEMOD</name>
       <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_DBMOD</name>
       <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_FINISHED</name>
       <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_ERROR</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Regardless of the current state, a temp-file connection always behaves
  ** as if it has an exclusive lock on the database file. It never updates
  ** the change-counter field, so the changeCountDone flag is always set.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>tempFile</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>tempFile</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>changeCountDone</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the useJournal flag is clear, the journal-mode must be "OFF". 
  ** And if the journal-mode is "OFF", the journal file must not be open.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_OFF</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>useJournal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>!=</operator><name>PAGER_JOURNALMODE_OFF</name> <operator>||</operator> <operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check that MEMDB implies noSync. And an in-memory journal. Since 
  ** this means an in-memory pager performs no IO at all, it cannot encounter 
  ** either SQLITE_IOERR or SQLITE_FULL during rollback or while finalizing 
  ** a journal file. (although the in-memory journal implementation may 
  ** return SQLITE_IOERR_NOMEM while the journal file is being written). It 
  ** is therefore not possible for an in-memory pager to enter the ERROR 
  ** state.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>MEMDB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>noSync</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_OFF</name> 
         <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_MEMORY</name></expr></argument> 
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_ERROR</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_OPEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If changeCountDone is set, a RESERVED lock or greater must be held
  ** on the file.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>changeCountDone</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>RESERVED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>!=</operator><name>PENDING_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>PAGER_OPEN</name></expr>:</case>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>PAGER_READER</name></expr>:</case>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>!=</operator><name>UNKNOWN_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>PAGER_WRITER_LOCKED</name></expr>:</case>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>!=</operator><name>UNKNOWN_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>RESERVED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>==</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name><operator>==</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbFileSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name><operator>==</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbHintSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>setSuper</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>PAGER_WRITER_CACHEMOD</name></expr>:</case>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>!=</operator><name>UNKNOWN_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* It is possible that if journal_mode=wal here that neither the
        ** journal file nor the WAL file are open. This happens during
        ** a rollback transaction that switches from journal_mode=off
        ** to journal_mode=wal.
        */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>RESERVED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call> 
             <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_OFF</name> 
             <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name></expr></argument> 
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name><operator>==</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbFileSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name><operator>==</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbHintSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>PAGER_WRITER_DBMOD</name></expr>:</case>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>EXCLUSIVE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call> 
           <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_OFF</name> 
           <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name> 
           <operator>||</operator> <operator>(</operator><call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call><operator>&amp;</operator><name>SQLITE_IOCAP_BATCH_ATOMIC</name><operator>)</operator></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name><operator>&lt;=</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbHintSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>PAGER_WRITER_FINISHED</name></expr>:</case>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call> 
           <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_OFF</name> 
           <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name> 
           <operator>||</operator> <operator>(</operator><call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call><operator>&amp;</operator><name>SQLITE_IOCAP_BATCH_ATOMIC</name><operator>)</operator></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>PAGER_ERROR</name></expr>:</case>
      <comment type="block">/* There must be at least one outstanding reference to the pager if
      ** in ERROR state. Otherwise the pager should have already dropped
      ** back to OPEN state.
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef NDEBUG */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef> 
<comment type="block">/*
** Return a pointer to a human readable string in a static buffer
** containing the state of the Pager object passed as an argument. This
** is intended to be used within debuggers. For example, as an alternative
** to "print *pPager" in gdb:
**
** (gdb) printf "%s", print_pager_state(pPager)
**
** This routine has external linkage in order to suppress compiler warnings
** about an unused function.  It is enclosed within SQLITE_DEBUG and so does
** not appear in normal builds.
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>print_pager_state</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>zRet</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><name>zRet</name></expr></argument>,
      <argument><expr><literal type="string">"Filename:      %s\n"</literal>
      <literal type="string">"State:         %s errCode=%d\n"</literal>
      <literal type="string">"Lock:          %s\n"</literal>
      <literal type="string">"Locking mode:  locking_mode=%s\n"</literal>
      <literal type="string">"Journal mode:  journal_mode=%s\n"</literal>
      <literal type="string">"Backing store: tempFile=%d memDb=%d useJournal=%d\n"</literal>
      <literal type="string">"Journal:       journalOff=%lld journalHdr=%lld\n"</literal>
      <literal type="string">"Size:          dbsize=%d dbOrigSize=%d dbFileSize=%d\n"</literal></expr></argument>
      , <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>
      , <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name></expr>            ?</condition><then> <expr><literal type="string">"OPEN"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_READER</name></expr>          ?</condition><then> <expr><literal type="string">"READER"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_LOCKED</name></expr>   ?</condition><then> <expr><literal type="string">"WRITER_LOCKED"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_CACHEMOD</name></expr> ?</condition><then> <expr><literal type="string">"WRITER_CACHEMOD"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_DBMOD</name></expr>    ?</condition><then> <expr><literal type="string">"WRITER_DBMOD"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_FINISHED</name></expr> ?</condition><then> <expr><literal type="string">"WRITER_FINISHED"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_ERROR</name></expr>           ?</condition><then> <expr><literal type="string">"ERROR"</literal></expr> </then><else>: <expr><literal type="string">"?error?"</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></argument>
      , <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>
      , <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>NO_LOCK</name></expr>         ?</condition><then> <expr><literal type="string">"NO_LOCK"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>RESERVED_LOCK</name></expr>   ?</condition><then> <expr><literal type="string">"RESERVED"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr>  ?</condition><then> <expr><literal type="string">"EXCLUSIVE"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>SHARED_LOCK</name></expr>     ?</condition><then> <expr><literal type="string">"SHARED"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>UNKNOWN_LOCK</name></expr>    ?</condition><then> <expr><literal type="string">"UNKNOWN"</literal></expr> </then><else>: <expr><literal type="string">"?error?"</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></argument>
      , <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>exclusiveMode</name></name></expr> ?</condition><then> <expr><literal type="string">"exclusive"</literal></expr> </then><else>: <expr><literal type="string">"normal"</literal></expr></else></ternary></expr></argument>
      , <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_MEMORY</name></expr>   ?</condition><then> <expr><literal type="string">"memory"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_OFF</name></expr>      ?</condition><then> <expr><literal type="string">"off"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_DELETE</name></expr>   ?</condition><then> <expr><literal type="string">"delete"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_PERSIST</name></expr>  ?</condition><then> <expr><literal type="string">"persist"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_TRUNCATE</name></expr> ?</condition><then> <expr><literal type="string">"truncate"</literal></expr> </then><else>:
        <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name></expr>      ?</condition><then> <expr><literal type="string">"wal"</literal></expr> </then><else>: <expr><literal type="string">"?error?"</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></argument>
      , <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>tempFile</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>memDb</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>useJournal</name></name></expr></argument>
      , <argument><expr><name><name>p</name><operator>-&gt;</operator><name>journalOff</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>journalHdr</name></name></expr></argument>
      , <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>dbSize</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>dbOrigSize</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>dbFileSize</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Forward references to the various page getters */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>getPageNormal</name><parameter_list>(<parameter><decl><type><name>Pager</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>Pgno</name></type></decl></parameter>,<parameter><decl><type><name>DbPage</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>getPageError</name><parameter_list>(<parameter><decl><type><name>Pager</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>Pgno</name></type></decl></parameter>,<parameter><decl><type><name>DbPage</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>getPageMMap</name><parameter_list>(<parameter><decl><type><name>Pager</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>Pgno</name></type></decl></parameter>,<parameter><decl><type><name>DbPage</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Set the Pager.xGet method for the appropriate routine used to fetch
** content from the pager.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setGetterMethod</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>xGet</name></name> <operator>=</operator> <name>getPageError</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>USEFETCH</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>
<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
   <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>xCodec</name></name><operator>==</operator><literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>xGet</name></name> <operator>=</operator> <name>getPageMMap</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_MAX_MMAP_SIZE&gt;0 */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>xGet</name></name> <operator>=</operator> <name>getPageNormal</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return true if it is necessary to write page *pPg into the sub-journal.
** A page needs to be written into the sub-journal if there exists one
** or more open savepoints for which:
**
**   * The page-number is less than or equal to PagerSavepoint.nOrig, and
**   * The bit corresponding to the page-number is not set in
**     PagerSavepoint.pInSavepoint.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>subjRequiresPage</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PagerSavepoint</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nOrig</name></name><operator>&gt;=</operator><name>pgno</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3BitvecTestNotNull</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pInSavepoint</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bTruncateOnRelease</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Return true if the page is already in the journal file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pageInJournal</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3BitvecTest</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Read a 32-bit integer from the given file descriptor.  Store the integer
** that is read in *pRes.  Return SQLITE_OK if everything worked, or an
** error code is something goes wrong.
**
** All values are stored on disk as big-endian.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>read32bits</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pRes</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>ac</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ac</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write a 32-bit integer into a string buffer in big-endian byte order.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>put32bits</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>sqlite3Put4byte((u8*)A,B)</cpp:value></cpp:define>


<comment type="block">/*
** Write a 32-bit integer into the given file descriptor.  Return SQLITE_OK
** on success or an error code is something goes wrong.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>write32bits</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>ac</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ac</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Unlock the database file to level eLock, which must be either NO_LOCK
** or SHARED_LOCK. Regardless of whether or not the call to xUnlock()
** succeeds, set the Pager.eLock variable to match the (attempted) new lock.
**
** Except, if Pager.eLock is set to UNKNOWN_LOCK when this function is
** called, do not modify it. See the comment above the #define of 
** UNKNOWN_LOCK for an explanation of this.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerUnlockDb</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>eLock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eLock</name><operator>==</operator><name>NO_LOCK</name> <operator>||</operator> <name>eLock</name><operator>==</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eLock</name><operator>!=</operator><name>NO_LOCK</name> <operator>||</operator> <call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>eLock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name><name>pPager</name><operator>-&gt;</operator><name>noLock</name></name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><call><name>sqlite3OsUnlock</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>!=</operator><name>UNKNOWN_LOCK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>eLock</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <macro><name>IOTRACE</name><argument_list>(<argument>(<literal type="string">"UNLOCK %p %d\n"</literal>, pPager, eLock)</argument>)</argument_list></macro>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>changeCountDone</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr>;</expr_stmt> <comment type="block">/* ticket fb3b3024ea238d5c */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lock the database file to level eLock, which must be either SHARED_LOCK,
** RESERVED_LOCK or EXCLUSIVE_LOCK. If the caller is successful, set the
** Pager.eLock variable to the new locking state. 
**
** Except, if Pager.eLock is set to UNKNOWN_LOCK when this function is 
** called, do not modify it unless the new locking state is EXCLUSIVE_LOCK. 
** See the comment above the #define of UNKNOWN_LOCK for an explanation 
** of this.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerLockDb</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eLock</name><operator>==</operator><name>SHARED_LOCK</name> <operator>||</operator> <name>eLock</name><operator>==</operator><name>RESERVED_LOCK</name> <operator>||</operator> <name>eLock</name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>&lt;</operator><name>eLock</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>UNKNOWN_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name><name>pPager</name><operator>-&gt;</operator><name>noLock</name></name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><call><name>sqlite3OsLock</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>!=</operator><name>UNKNOWN_LOCK</name><operator>||</operator><name>eLock</name><operator>==</operator><name>EXCLUSIVE_LOCK</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>eLock</name></expr>;</expr_stmt>
      <macro><name>IOTRACE</name><argument_list>(<argument>(<literal type="string">"LOCK %p %d\n"</literal>, pPager, eLock)</argument>)</argument_list></macro>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function determines whether or not the atomic-write or
** atomic-batch-write optimizations can be used with this pager. The
** atomic-write optimization can be used if:
**
**  (a) the value returned by OsDeviceCharacteristics() indicates that
**      a database page may be written atomically, and
**  (b) the value returned by OsSectorSize() is less than or equal
**      to the page size.
**
** If it can be used, then the value returned is the size of the journal 
** file when it contains rollback data for exactly one page.
**
** The atomic-batch-write optimization can be used if OsDeviceCharacteristics()
** returns a value with the SQLITE_IOCAP_BATCH_ATOMIC bit set. -1 is
** returned in this case.
**
** If neither optimization can be used, 0 is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jrnlBufferSize</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_ATOMIC_WRITE</name></expr></argument>)</argument_list></call> \
 <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_BATCH_ATOMIC_WRITE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>dc</name></decl>;</decl_stmt>                           <comment type="block">/* Device characteristics */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>dc</name> <operator>=</operator> <call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_BATCH_ATOMIC_WRITE</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>dc</name><operator>&amp;</operator><name>SQLITE_IOCAP_BATCH_ATOMIC</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ATOMIC_WRITE</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nSector</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>sectorSize</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>szPage</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC512</name><operator>==</operator><operator>(</operator><literal type="number">512</literal><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC64K</name><operator>==</operator><operator>(</operator><literal type="number">65536</literal><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name>dc</name><operator>&amp;</operator><operator>(</operator><name>SQLITE_IOCAP_ATOMIC</name><operator>|</operator><operator>(</operator><name>szPage</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>)</operator> <operator>||</operator> <name>nSector</name><operator>&gt;</operator><name>szPage</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <return>return <expr><call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>JOURNAL_PG_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If SQLITE_CHECK_PAGES is defined then we do some sanity checking
** on the cache using a hash function.  This is used for testing
** and debugging only.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_CHECK_PAGES</name></cpp:ifdef>
<comment type="block">/*
** Return a 32-bit hash of the page data for pPage.
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>pager_datahash</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>hash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nByte</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>hash</name> <operator>=</operator> <operator>(</operator><name>hash</name><operator>*</operator><literal type="number">1039</literal><operator>)</operator> <operator>+</operator> <name><name>pData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>pager_pagehash</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>pager_datahash</name><argument_list>(<argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pager_set_pagehash</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pageHash</name></name> <operator>=</operator> <call><name>pager_pagehash</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The CHECK_PAGE macro takes a PgHdr* as an argument. If SQLITE_CHECK_PAGES
** is defined, and NDEBUG is not defined, an assert() statement checks
** that the page is either dirty or still matches the calculated page-hash.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_PAGE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>checkPage(x)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checkPage</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_ERROR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_DIRTY</name><operator>)</operator> <operator>||</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pageHash</name></name><operator>==</operator><call><name>pager_pagehash</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pager_datahash</name><parameter_list>(<parameter><type><name>X</name></type></parameter>,<parameter><type><name>Y</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pager_pagehash</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pager_set_pagehash</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_PAGE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SQLITE_CHECK_PAGES */</comment>

<comment type="block">/*
** When this is called the journal file for pager pPager must be open.
** This function attempts to read a super-journal file name from the 
** end of the file and, if successful, copies it into memory supplied 
** by the caller. See comments above writeSuperJournal() for the format
** used to store a super-journal file name at the end of a journal file.
**
** zSuper must point to a buffer of at least nSuper bytes allocated by
** the caller. This should be sqlite3_vfs.mxPathname+1 (to ensure there is
** enough space to write the super-journal name). If the super-journal
** name in the journal is longer than nSuper bytes (including a
** nul-terminator), then this is handled as if no super-journal name
** were present in the journal.
**
** If a super-journal file name is present at the end of the journal
** file, then it is copied into the buffer pointed to by zSuper. A
** nul-terminator byte is appended to the buffer following the
** super-journal file name.
**
** If it is determined that no super-journal file name is present 
** zSuper[0] is set to 0 and SQLITE_OK returned.
**
** If an error occurs while reading from the journal file, an SQLite
** error code is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>readSuperJournal</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pJrnl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zSuper</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>nSuper</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                    <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>len</name></decl>;</decl_stmt>                   <comment type="block">/* Length in bytes of super-journal name */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>szJ</name></decl>;</decl_stmt>                   <comment type="block">/* Total size in bytes of journal file pJrnl */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum</name></decl>;</decl_stmt>                 <comment type="block">/* MJ checksum value read from journal */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>u</name></decl>;</decl_stmt>                     <comment type="block">/* Unsigned loop counter */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>aMagic</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* A buffer to hold the magic header */</comment>
  <expr_stmt><expr><name><name>zSuper</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name>pJrnl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>szJ</name></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>||</operator> <name><name>szJ</name><argument_list type="generic">&lt;<argument><expr><literal type="number">16</literal>
   <operator>||</operator> <name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <name>read32bits</name><operator>(</operator><name>pJrnl</name>, <name>szJ</name><operator>-</operator><literal type="number">16</literal>, <operator>&amp;</operator><name>len</name><operator>)</operator><operator>)</operator>
   <operator>||</operator> <name>len</name><operator>&gt;=</operator><name>nSuper</name> 
   <operator>||</operator> <name>len</name></expr></argument>&gt;</argument_list></name><name>szJ</name><operator>-</operator><literal type="number">16</literal>
   <operator>||</operator> <name>len</name><operator>==</operator><literal type="number">0</literal> 
   <operator>||</operator> <name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>read32bits</name><argument_list>(<argument><expr><name>pJrnl</name></expr></argument>, <argument><expr><name>szJ</name><operator>-</operator><literal type="number">12</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cksum</name></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>||</operator> <name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>pJrnl</name></expr></argument>, <argument><expr><name>aMagic</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>szJ</name><operator>-</operator><literal type="number">8</literal></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>aMagic</name></expr></argument>, <argument><expr><name>aJournalMagic</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call>
   <operator>||</operator> <name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>pJrnl</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>szJ</name><operator>-</operator><literal type="number">16</literal><operator>-</operator><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* See if the checksum matches the super-journal name */</comment>
  <for>for<control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name><operator>&lt;</operator><name>len</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>cksum</name> <operator>-=</operator> <name><name>zSuper</name><index>[<expr><name>u</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>cksum</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If the checksum doesn't add up, then one or more of the disk sectors
    ** containing the super-journal filename is corrupted. This means
    ** definitely roll back, so just return SQLITE_OK and report a (nul)
    ** super-journal filename.
    */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>zSuper</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zSuper</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
   
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the offset of the sector boundary at or immediately 
** following the value in pPager-&gt;journalOff, assuming a sector 
** size of pPager-&gt;sectorSize bytes.
**
** i.e for a sector size of 512:
**
**   Pager.journalOff          Return value
**   ---------------------------------------
**   0                         0
**   512                       512
**   100                       512
**   2000                      2048
** 
*/</comment>
<function><type><specifier>static</specifier> <name>i64</name></type> <name>journalHdrOffset</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>c</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>c</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>offset</name><operator>%</operator><call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>offset</name><operator>&gt;=</operator><name>c</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>offset</name><operator>-</operator><name>c</name><operator>)</operator><operator>&lt;</operator><call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The journal file must be open when this function is called.
**
** This function is a no-op if the journal file has not been written to
** within the current transaction (i.e. if Pager.journalOff==0).
**
** If doTruncate is non-zero or the Pager.journalSizeLimit variable is
** set to 0, then truncate the journal file to zero bytes in size. Otherwise,
** zero the 28-byte header at the start of the journal file. In either case, 
** if the pager is not in no-sync mode, sync the journal file immediately 
** after writing or truncating it.
**
** If Pager.journalSizeLimit is set to a positive, non-zero value, and
** following the truncation or zeroing described above the size of the 
** journal file in bytes is larger than this value, then truncate the
** journal file to Pager.journalSizeLimit bytes. The journal file does
** not need to be synced following this operation.
**
** If an IO error occurs, abandon processing and return the IO error code.
** Otherwise, return SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zeroJournalHdr</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>doTruncate</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                               <comment type="block">/* Return code */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3JournalIsInMemory</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>i64</name></type> <name>iLimit</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalSizeLimit</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Local cache of jsl */</comment>

    <macro><name>IOTRACE</name><argument_list>(<argument>(<literal type="string">"JZEROHDR %p\n"</literal>, pPager)</argument>)</argument_list></macro>
    <if_stmt><if>if<condition>( <expr><name>doTruncate</name> <operator>||</operator> <name>iLimit</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zeroHdr</name><index>[<expr><literal type="number">28</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>zeroHdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zeroHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>noSync</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>SQLITE_SYNC_DATAONLY</name><operator>|</operator><name><name>pPager</name><operator>-&gt;</operator><name>syncFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* At this point the transaction is committed but the write lock 
    ** is still held on the file. If there is a size limit configured for 
    ** the persistent journal and the journal file currently consumes more
    ** space than that limit allows for, truncate it now. There is no need
    ** to sync the file following this operation.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iLimit</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>sz</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>sz</name><operator>&gt;</operator><name>iLimit</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The journal file must be open when this routine is called. A journal
** header (JOURNAL_HDR_SZ bytes) is written into the journal file at the
** current location.
**
** The format for the journal header is as follows:
** - 8 bytes: Magic identifying journal format.
** - 4 bytes: Number of records in journal, or -1 no-sync mode is on.
** - 4 bytes: Random number used for page hash.
** - 4 bytes: Initial database page count.
** - 4 bytes: Sector size used by the process that wrote this journal.
** - 4 bytes: Database page size.
** 
** Followed by (JOURNAL_HDR_SZ - 28) bytes of unused space.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>writeJournalHdr</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zHeader</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Temporary space used to build header */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nHeader</name> <init>= <expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></init></decl>;</decl_stmt><comment type="block">/* Size of buffer pointed to by zHeader */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nWrite</name></decl>;</decl_stmt>                         <comment type="block">/* Bytes of header sector written */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>                             <comment type="block">/* Loop counter */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* Journal file must be open. */</comment>

  <if_stmt><if>if<condition>( <expr><name>nHeader</name><operator>&gt;</operator><call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nHeader</name> <operator>=</operator> <call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If there are active savepoints and any of them were created 
  ** since the most recent journal header was written, update the 
  ** PagerSavepoint.iHdrOffset fields now.
  */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iHdrOffset</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iHdrOffset</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>=</operator> <call><name>journalHdrOffset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* 
  ** Write the nRec Field - the number of page records that follow this
  ** journal header. Normally, zero is written to this value at this time.
  ** After the records are added to the journal (and the journal synced, 
  ** if in full-sync mode), the zero is overwritten with the true number
  ** of records (see syncJournal()).
  **
  ** A faster alternative is to write 0xFFFFFFFF to the nRec field. When
  ** reading the journal this value tells SQLite to assume that the
  ** rest of the journal file contains valid page records. This assumption
  ** is dangerous, as if a failure occurred whilst writing to the journal
  ** file it may contain some garbage data. There are two scenarios
  ** where this risk can be ignored:
  **
  **   * When the pager is in no-sync mode. Corruption can follow a
  **     power failure in this case anyway.
  **
  **   * When the SQLITE_IOCAP_SAFE_APPEND flag is set. This guarantees
  **     that garbage data is never appended to the journal file.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>noSync</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>noSync</name></name> <operator>||</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_MEMORY</name><operator>)</operator>
   <operator>||</operator> <operator>(</operator><call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call><operator>&amp;</operator><name>SQLITE_IOCAP_SAFE_APPEND</name><operator>)</operator></expr> 
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zHeader</name></expr></argument>, <argument><expr><name>aJournalMagic</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zHeader</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0xffffffff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>zHeader</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* The random check-hash initializer */</comment> 
  <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>cksumInit</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>cksumInit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zHeader</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>cksumInit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* The initial database size */</comment>
  <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zHeader</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* The assumed sector size for this process */</comment>
  <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zHeader</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>sectorSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The page size */</comment>
  <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zHeader</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initializing the tail of the buffer is not necessary.  Everything
  ** works find if the following memset() is omitted.  But initializing
  ** the memory prevents valgrind from complaining, so we are willing to
  ** take the performance hit.
  */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zHeader</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">20</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
         <argument><expr><name>nHeader</name><operator>-</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">20</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* In theory, it is only necessary to write the 28 bytes that the 
  ** journal header consumes to the journal file here. Then increment the 
  ** Pager.journalOff variable by JOURNAL_HDR_SZ so that the next 
  ** record is written to the following sector (leaving a gap in the file
  ** that will be implicitly filled in by the OS).
  **
  ** However it has been discovered that on some systems this pattern can 
  ** be significantly slower than contiguously writing data to the file,
  ** even if that means explicitly writing data to the block of 
  ** (JOURNAL_HDR_SZ - 28) bytes that will not be used. So that is what
  ** is done. 
  **
  ** The loop is required here in case the sector-size is larger than the 
  ** database page size. Since the zHeader buffer is only Pager.pageSize
  ** bytes in size, more than one call to sqlite3OsWrite() may be required
  ** to populate the entire journal header sector.
  */</comment> 
  <for>for<control>(<init><expr><name>nWrite</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name><operator>&amp;&amp;</operator><name>nWrite</name><operator>&lt;</operator><call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>nWrite</name><operator>+=</operator><name>nHeader</name></expr></incr>)</control><block>{<block_content>
    <macro><name>IOTRACE</name><argument_list>(<argument>(<literal type="string">"JHDR %p %lld %d\n"</literal>, pPager, pPager-&gt;journalHdr, nHeader)</argument>)</argument_list></macro>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>zHeader</name></expr></argument>, <argument><expr><name>nHeader</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name> <operator>&lt;=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>+=</operator> <name>nHeader</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The journal file must be open when this is called. A journal header file
** (JOURNAL_HDR_SZ bytes) is read from the current location in the journal
** file. The current location in the journal file is given by
** pPager-&gt;journalOff. See comments above function writeJournalHdr() for
** a description of the journal header format.
**
** If the header is read successfully, *pNRec is set to the number of
** page records following this header and *pDbSize is set to the size of the
** database before the transaction began, in pages. Also, pPager-&gt;cksumInit
** is set to the value read from the journal header. SQLITE_OK is returned
** in this case.
**
** If the journal header file appears to be corrupted, SQLITE_DONE is
** returned and *pNRec and *PDbSize are undefined.  If JOURNAL_HDR_SZ bytes
** cannot be read from the journal file an error code is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>readJournalHdr</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,               <comment type="block">/* Pager object */</comment>
  <parameter><decl><type><name>int</name></type> <name>isHot</name></decl></parameter>,
  <parameter><decl><type><name>i64</name></type> <name>journalSize</name></decl></parameter>,             <comment type="block">/* Size of the open journal file in bytes */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pNRec</name></decl></parameter>,                  <comment type="block">/* OUT: Value read from the nRec field */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pDbSize</name></decl></parameter>                 <comment type="block">/* OUT: Value of original database size field */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                      <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>aMagic</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>     <comment type="block">/* A buffer to hold the magic header */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iHdrOff</name></decl>;</decl_stmt>                 <comment type="block">/* Offset of journal header being read */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* Journal file must be open. */</comment>

  <comment type="block">/* Advance Pager.journalOff to the start of the next sector. If the
  ** journal file is too small for there to be a header stored at this
  ** point, return SQLITE_DONE.
  */</comment>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>=</operator> <call><name>journalHdrOffset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>+</operator><call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>journalSize</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iHdrOff</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr>;</expr_stmt>

  <comment type="block">/* Read in the first 8 bytes of the journal header. If they do not match
  ** the  magic string found at the start of each journal header, return
  ** SQLITE_DONE. If an IO error occurs, return an error code. Otherwise,
  ** proceed.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isHot</name> <operator>||</operator> <name>iHdrOff</name><operator>!=</operator><name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>aMagic</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aMagic</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>iHdrOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>aMagic</name></expr></argument>, <argument><expr><name>aJournalMagic</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aMagic</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Read the first three 32-bit fields of the journal header: The nRec
  ** field, the checksum-initializer and the database size at the start
  ** of the transaction. Return an error code if anything goes wrong.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>read32bits</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>iHdrOff</name><operator>+</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>pNRec</name></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>||</operator> <name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>read32bits</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>iHdrOff</name><operator>+</operator><literal type="number">12</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>cksumInit</name></name></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>||</operator> <name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>read32bits</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>iHdrOff</name><operator>+</operator><literal type="number">16</literal></expr></argument>, <argument><expr><name>pDbSize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>iPageSize</name></decl>;</decl_stmt>               <comment type="block">/* Page-size field of journal header */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>iSectorSize</name></decl>;</decl_stmt>             <comment type="block">/* Sector-size field of journal header */</comment>

    <comment type="block">/* Read the page-size and sector-size journal header fields. */</comment>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>read32bits</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>iHdrOff</name><operator>+</operator><literal type="number">20</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iSectorSize</name></expr></argument>)</argument_list></call><operator>)</operator>
     <operator>||</operator> <name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>read32bits</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>iHdrOff</name><operator>+</operator><literal type="number">24</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPageSize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Versions of SQLite prior to 3.5.8 set the page-size field of the
    ** journal header to zero. In this case, assume that the Pager.pageSize
    ** variable is already set to the correct page size.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>iPageSize</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPageSize</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check that the values read from the page-size and sector-size fields
    ** are within range. To be 'in range', both values need to be a power
    ** of two greater than or equal to 512 or 32, and not greater than their 
    ** respective compile time maximum limits.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>iPageSize</name><argument_list type="generic">&lt;<argument><expr><literal type="number">512</literal>                  <operator>||</operator> <name><name>iSectorSize</name><argument_list type="generic">&lt;<argument><expr><literal type="number">32</literal>
     <operator>||</operator> <name>iPageSize</name></expr></argument>&gt;</argument_list></name><name>SQLITE_MAX_PAGE_SIZE</name> <operator>||</operator> <name>iSectorSize</name></expr></argument>&gt;</argument_list></name><name>MAX_SECTOR_SIZE</name>
     <operator>||</operator> <operator>(</operator><operator>(</operator><name>iPageSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><name>iPageSize</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>   <operator>||</operator> <operator>(</operator><operator>(</operator><name>iSectorSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><name>iSectorSize</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> 
    )</condition><block>{<block_content>
      <comment type="block">/* If the either the page-size or sector-size in the journal-header is 
      ** invalid, then the process that wrote the journal-header must have 
      ** crashed before the header was synced. In this case stop reading 
      ** the journal file here.
      */</comment>
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Update the page-size to match the value read from the journal. 
    ** Use a testcase() macro to make sure that malloc failure within 
    ** PagerSetPagesize() is tested.
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSetPagesize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPageSize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update the assumed sector-size to match the value used by 
    ** the process that created this journal. If this journal was
    ** created by a process other than this one, then this routine
    ** is being called from within pager_playback(). The local value
    ** of Pager.sectorSize is restored at the end of that routine.
    */</comment>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>=</operator> <name>iSectorSize</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>+=</operator> <call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Write the supplied super-journal name into the journal file for pager
** pPager at the current location. The super-journal name must be the last
** thing written to a journal file. If the pager is in full-sync mode, the
** journal file descriptor is advanced to the next sector boundary before
** anything is written. The format is:
**
**   + 4 bytes: PAGER_SJ_PGNO.
**   + N bytes: super-journal filename in utf-8.
**   + 4 bytes: N (length of super-journal name in bytes, no nul-terminator).
**   + 4 bytes: super-journal name checksum.
**   + 8 bytes: aJournalMagic[].
**
** The super-journal page checksum is the sum of the bytes in thesuper-journal
** name, where each byte is interpreted as a signed 8-bit integer.
**
** If zSuper is a NULL pointer (occurs for a single database transaction), 
** this call is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>writeSuperJournal</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSuper</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                          <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSuper</name></decl>;</decl_stmt>                      <comment type="block">/* Length of string zSuper */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iHdrOff</name></decl>;</decl_stmt>                     <comment type="block">/* Offset of header in journal file */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>jrnlSize</name></decl>;</decl_stmt>                    <comment type="block">/* Size of journal file on disk */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Checksum of string zSuper */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>setSuper</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zSuper</name> 
   <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_MEMORY</name> 
   <operator>||</operator> <operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>setSuper</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name> <operator>&lt;=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Calculate the length in bytes and the checksum of zSuper */</comment>
  <for>for<control>(<init><expr><name>nSuper</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zSuper</name><index>[<expr><name>nSuper</name></expr>]</index></name></expr>;</condition> <incr><expr><name>nSuper</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>cksum</name> <operator>+=</operator> <name><name>zSuper</name><index>[<expr><name>nSuper</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* If in full-sync mode, advance to the next disk sector before writing
  ** the super-journal name. This is in case the previous page written to
  ** the journal has already been synced.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>fullSync</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>=</operator> <call><name>journalHdrOffset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iHdrOff</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr>;</expr_stmt>

  <comment type="block">/* Write the super-journal data to the end of the journal file. If
  ** an error occurs, return the error code to the caller.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><literal type="number">0</literal> <operator>!=</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>write32bits</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>iHdrOff</name></expr></argument>, <argument><expr><call><name>PAGER_SJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator>
   <operator>||</operator> <operator>(</operator><literal type="number">0</literal> <operator>!=</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>, <argument><expr><name>nSuper</name></expr></argument>, <argument><expr><name>iHdrOff</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator>
   <operator>||</operator> <operator>(</operator><literal type="number">0</literal> <operator>!=</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>write32bits</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>iHdrOff</name><operator>+</operator><literal type="number">4</literal><operator>+</operator><name>nSuper</name></expr></argument>, <argument><expr><name>nSuper</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator>
   <operator>||</operator> <operator>(</operator><literal type="number">0</literal> <operator>!=</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>write32bits</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>iHdrOff</name><operator>+</operator><literal type="number">4</literal><operator>+</operator><name>nSuper</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>cksum</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator>
   <operator>||</operator> <operator>(</operator><literal type="number">0</literal> <operator>!=</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>aJournalMagic</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>,
                                 <argument><expr><name>iHdrOff</name><operator>+</operator><literal type="number">4</literal><operator>+</operator><name>nSuper</name><operator>+</operator><literal type="number">8</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>+=</operator> <operator>(</operator><name>nSuper</name><operator>+</operator><literal type="number">20</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* If the pager is in peristent-journal mode, then the physical 
  ** journal-file may extend past the end of the super-journal name
  ** and 8 bytes of magic data just written to the file. This is 
  ** dangerous because the code to rollback a hot-journal file
  ** will not be able to find the super-journal name to determine 
  ** whether or not the journal is hot. 
  **
  ** Easiest thing to do in this scenario is to truncate the journal 
  ** file to the required size.
  */</comment> 
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jrnlSize</name></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>&amp;&amp;</operator> <name>jrnlSize</name><operator>&gt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Discard the entire contents of the in-memory page-cache.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pager_reset</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iDataVersion</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BackupRestart</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pBackup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PcacheClear</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the pPager-&gt;iDataVersion value
*/</comment>
<function><type><name>u32</name></type> <name>sqlite3PagerDataVersion</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>iDataVersion</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free all structures in the Pager.aSavepoint[] array and set both
** Pager.aSavepoint and Pager.nSavepoint to zero. Close the sub-journal
** if it is open and the pager is not in exclusive mode.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>releaseAllSavepoints</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>               <comment type="block">/* Iterator for looping through Pager.aSavepoint */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pInSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>||</operator> <call><name>sqlite3JournalIsInMemory</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>sjfd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>sjfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nSubRec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the bit number pgno in the PagerSavepoint.pInSavepoint 
** bitvecs of all open savepoints. Return SQLITE_OK if successful
** or SQLITE_NOMEM if a malloc failure occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>addToSavepointBitvecs</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>                   <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Result code */</comment>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>PagerSavepoint</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nOrig</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>|=</operator> <call><name>sqlite3BitvecSet</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pInSavepoint</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if the pager is in exclusive mode and not
** in the ERROR state. Otherwise, it switches the pager to PAGER_OPEN
** state.
**
** If the pager is not in exclusive-access mode, the database file is
** completely unlocked. If the file is unlocked and the file-system does
** not exhibit the UNDELETABLE_WHEN_OPEN property, the journal file is
** closed (if it is open).
**
** If the pager is in ERROR state when this function is called, the 
** contents of the pager cache are discarded before switching back to 
** the OPEN state. Regardless of whether the pager is in exclusive-mode
** or not, any journal file left in the file-system will be treated
** as a hot-journal and rolled back the next time a read-transaction
** is opened (by this or by any other connection).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pager_unlock</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_READER</name> 
       <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name> 
       <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_ERROR</name></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>releaseAllSavepoints</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalEndReadTransaction</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_OPEN</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                       <comment type="block">/* Error code returned by pagerUnlockDb() */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iDc</name> <init>= <expr><ternary><condition><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>?</condition><then><expr><call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If the operating system support deletion of open files, then
    ** close the journal file when dropping the database lock.  Otherwise
    ** another connection with journal_mode=delete might delete the file
    ** out from under us.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>PAGER_JOURNALMODE_MEMORY</name>   <operator>&amp;</operator> <literal type="number">5</literal><operator>)</operator><operator>!=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>PAGER_JOURNALMODE_OFF</name>      <operator>&amp;</operator> <literal type="number">5</literal><operator>)</operator><operator>!=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>PAGER_JOURNALMODE_WAL</name>      <operator>&amp;</operator> <literal type="number">5</literal><operator>)</operator><operator>!=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>PAGER_JOURNALMODE_DELETE</name>   <operator>&amp;</operator> <literal type="number">5</literal><operator>)</operator><operator>!=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>PAGER_JOURNALMODE_TRUNCATE</name> <operator>&amp;</operator> <literal type="number">5</literal><operator>)</operator><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>PAGER_JOURNALMODE_PERSIST</name>  <operator>&amp;</operator> <literal type="number">5</literal><operator>)</operator><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name>iDc</name> <operator>&amp;</operator> <name>SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN</name><operator>)</operator>
     <operator>||</operator> <literal type="number">1</literal><operator>!=</operator><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name> <operator>&amp;</operator> <literal type="number">5</literal><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the pager is in the ERROR state and the call to unlock the database
    ** file fails, set the current lock to UNKNOWN_LOCK. See the comment
    ** above the #define for UNKNOWN_LOCK for an explanation of why this
    ** is necessary.
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerUnlockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_ERROR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name> <operator>=</operator> <name>UNKNOWN_LOCK</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* The pager state may be changed from PAGER_ERROR to PAGER_OPEN here
    ** without clearing the error code. This is intentional - the error
    ** code is cleared and the cache reset in the block below.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_ERROR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_OPEN</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If Pager.errCode is set, the contents of the pager cache cannot be
  ** trusted. Now that there are no outstanding references to the pager,
  ** it can safely move back to PAGER_OPEN state. This happens in both
  ** normal and exclusive-locking mode.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>!</operator><name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>pager_reset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>changeCountDone</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_OPEN</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>PAGER_OPEN</name></expr> </then><else>: <expr><name>PAGER_READER</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>USEFETCH</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3OsUnfetch</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setGetterMethod</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>setSuper</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called whenever an IOERR or FULL error that requires
** the pager to transition into the ERROR state may ahve occurred.
** The first argument is a pointer to the pager structure, the second 
** the error-code about to be returned by a pager API function. The 
** value returned is a copy of the second argument to this function. 
**
** If the second argument is SQLITE_FULL, SQLITE_IOERR or one of the
** IOERR sub-codes, the pager enters the ERROR state and the error code
** is stored in Pager.errCode. While the pager remains in the ERROR state,
** all major API calls on the Pager will immediately return Pager.errCode.
**
** The ERROR state indicates that the contents of the pager-cache 
** cannot be trusted. This state can be cleared by completely discarding 
** the contents of the pager-cache. If a transaction was active when
** the persistent error occurred, then the rollback journal may need
** to be replayed to restore the contents of the database file (as if
** it were a hot-journal).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_error</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><name>rc</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>!</operator><name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(
       <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_FULL</name> <operator>||</operator>
       <name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator>
       <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_IOERR</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>==</operator><name>SQLITE_FULL</name> <operator>||</operator> <name>rc2</name><operator>==</operator><name>SQLITE_IOERR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setGetterMethod</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>pager_truncate</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>nPage</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** The write transaction open on pPager is being committed (bCommit==1)
** or rolled back (bCommit==0).
**
** Return TRUE if and only if all dirty pages should be flushed to disk.
**
** Rules:
**
**   *  For non-TEMP databases, always sync to disk.  This is necessary
**      for transactions to be durable.
**
**   *  Sync TEMP database only on a COMMIT (not a ROLLBACK) when the backing
**      file has been created already (via a spill on pagerStress()) and
**      when the number of dirty pages in memory exceeds 25% of the total
**      cache size.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerFlushOnCommit</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bCommit</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bCommit</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>(</operator><call><name>sqlite3PCachePercentDirty</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call><operator>&gt;=</operator><literal type="number">25</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine ends a transaction. A transaction is usually ended by 
** either a COMMIT or a ROLLBACK operation. This routine may be called 
** after rollback of a hot-journal, or if an error occurs while opening
** the journal file or writing the very first journal-header of a
** database transaction.
** 
** This routine is never called in PAGER_ERROR state. If it is called
** in PAGER_NONE or PAGER_SHARED state and the lock held is less
** exclusive than a RESERVED lock, it is a no-op.
**
** Otherwise, any active savepoints are released.
**
** If the journal file is open, then it is "finalized". Once a journal 
** file has been finalized it is not possible to use it to roll back a 
** transaction. Nor will it be considered to be a hot-journal by this
** or any other database connection. Exactly how a journal is finalized
** depends on whether or not the pager is running in exclusive mode and
** the current journal-mode (Pager.journalMode value), as follows:
**
**   journalMode==MEMORY
**     Journal file descriptor is simply closed. This destroys an 
**     in-memory journal.
**
**   journalMode==TRUNCATE
**     Journal file is truncated to zero bytes in size.
**
**   journalMode==PERSIST
**     The first 28 bytes of the journal file are zeroed. This invalidates
**     the first journal header in the file, and hence the entire journal
**     file. An invalid journal file cannot be rolled back.
**
**   journalMode==DELETE
**     The journal file is closed and deleted using sqlite3OsDelete().
**
**     If the pager is running in exclusive mode, this method of finalizing
**     the journal file is never used. Instead, if the journalMode is
**     DELETE and the pager is in exclusive mode, the method described under
**     journalMode==PERSIST is used instead.
**
** After the journal is finalized, the pager moves to PAGER_READER state.
** If running in non-exclusive rollback mode, the lock on the file is 
** downgraded to a SHARED_LOCK.
**
** SQLITE_OK is returned if no error occurs. If an error occurs during
** any of the IO operations to finalize the journal file or unlock the
** database then the IO error code is returned to the user. If the 
** operation to finalize the journal file fails, then the code still
** tries to unlock the database file if not in exclusive mode. If the
** unlock operation fails as well, then the first error code related
** to the first error encountered (the journal finalization one) is
** returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_end_transaction</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hasSuper</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bCommit</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Error code from journal finalization operation */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Error code from db file unlock operation */</comment>

  <comment type="block">/* Do nothing if the pager does not have an open write transaction
  ** or at least a RESERVED lock. This function may be called when there
  ** is no write-transaction active but a RESERVED or greater lock is
  ** held under two circumstances:
  **
  **   1. After a successful hot-journal rollback, it is called with
  **      eState==PAGER_NONE and eLock==EXCLUSIVE_LOCK.
  **
  **   2. If a connection with locking_mode=exclusive holding an EXCLUSIVE 
  **      lock switches back to locking_mode=normal and then executes a
  **      read-transaction, this function is called with eState==PAGER_READER 
  **      and eLock==EXCLUSIVE_LOCK when the read-transaction is closed.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_ERROR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&lt;</operator><name>PAGER_WRITER_LOCKED</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>&lt;</operator><name>RESERVED_LOCK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>releaseAllSavepoints</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name><operator>==</operator><literal type="number">0</literal> 
      <operator>||</operator> <operator>(</operator><call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call><operator>&amp;</operator><name>SQLITE_IOCAP_BATCH_ATOMIC</name><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Finalize the journal file. */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3JournalIsInMemory</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* assert( pPager-&gt;journalMode==PAGER_JOURNALMODE_MEMORY ); */</comment>
      <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_TRUNCATE</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>fullSync</name></name></expr> )</condition><block>{<block_content>
          <comment type="block">/* Make sure the new file size is written into the inode right away.
          ** Otherwise the journal might resurrect following a power loss and
          ** cause the last transaction to roll back.  See
          ** https://bugzilla.mozilla.org/show_bug.cgi?id=1072773
          */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>syncFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_PERSIST</name>
      <operator>||</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>!=</operator><name>PAGER_JOURNALMODE_WAL</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zeroJournalHdr</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>hasSuper</name><operator>||</operator><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* This branch may be executed with Pager.journalMode==MEMORY if
      ** a hot-journal was just rolled back. In this case the journal
      ** file should be closed and deleted. If this connection writes to
      ** the database file, it will do so using an in-memory journal.
      */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>bDelete</name> <init>= <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3JournalIsInMemory</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_DELETE</name> 
           <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_MEMORY</name> 
           <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name></expr></argument> 
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>bDelete</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>extraSync</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_CHECK_PAGES</name></cpp:ifdef>
  <expr_stmt><expr><call><name>sqlite3PcacheIterateDirty</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>, <argument><expr><name>pager_set_pagehash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3PagerLookup</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pageHash</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerUnrefNotNull</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nRec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>MEMDB</name> <operator>||</operator> <call><name>pagerFlushOnCommit</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>bCommit</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PcacheCleanAll</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PcacheClearWritable</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3PcacheTruncate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Drop the WAL write-lock, if any. Also, if the connection was in 
    ** locking_mode=exclusive mode but is no longer, drop the EXCLUSIVE 
    ** lock held on the database file.
    */</comment>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3WalEndWriteTransaction</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc2</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bCommit</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbFileSize</name></name><operator>&gt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This branch is taken when committing a transaction in rollback-journal
    ** mode if the database file on disk is larger than the database image.
    ** At this point the journal has been finalized and the transaction 
    ** successfully committed, but the EXCLUSIVE lock is still held on the
    ** file. So it is safe to truncate the database file to its minimum
    ** required size.  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_truncate</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bCommit</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileControl</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_COMMIT_PHASETWO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOTFOUND</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name> 
   <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>sqlite3WalExclusiveMode</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>pagerUnlockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_READER</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>setSuper</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <return>return <expr><operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>?</condition><then><expr><name>rc2</name></expr></then><else>:<expr><name>rc</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Execute a rollback if a transaction is active and unlock the 
** database file. 
**
** If the pager has already entered the ERROR state, do not attempt 
** the rollback at this time. Instead, pager_unlock() is called. The
** call to pager_unlock() will discard all in-memory pages, unlock
** the database file and move the pager back to OPEN state. If this 
** means that there is a hot-journal left in the file-system, the next 
** connection to obtain a shared lock on the pager (which may be this one) 
** will roll it back.
**
** If the pager has not already entered the ERROR state, but an IO or
** malloc error occurs during a rollback, then this will itself cause 
** the pager to enter the ERROR state. Which will be cleared by the
** call to pager_unlock(), as described above.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pagerUnlockAndRollback</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_ERROR</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_OPEN</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_WRITER_LOCKED</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerRollback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_READER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pager_end_transaction</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>pager_unlock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Parameter aData must point to a buffer of pPager-&gt;pageSize bytes
** of data. Compute and return a checksum based ont the contents of the 
** page of data and the current value of pPager-&gt;cksumInit.
**
** This is not a real checksum. It is really just the sum of the 
** random initial value (pPager-&gt;cksumInit) and every 200th byte
** of the page data, starting with byte offset (pPager-&gt;pageSize%200).
** Each byte is interpreted as an 8-bit unsigned integer.
**
** Changing the formula used to compute this checksum results in an
** incompatible journal file format.
**
** If journal corruption occurs due to a power failure, the most likely 
** scenario is that one end or the other of the record will be changed. 
** It is much less likely that the two ends of the journal record will be
** correct and the middle be corrupt.  Thus, this "checksum" scheme,
** though fast and simple, catches the mostly likely kind of corruption.
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>pager_cksum</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>cksumInit</name></name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Checksum value to return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name><operator>-</operator><literal type="number">200</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Loop counter */</comment>
  <while>while<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>cksum</name> <operator>+=</operator> <name><name>aData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>-=</operator> <literal type="number">200</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>cksum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Report the current page size and number of reserved bytes back
** to the codec.
*/</comment>
<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pagerReportSize</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>xCodecSizeChng</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>pPager</name><operator>-&gt;</operator><name>xCodecSizeChng</name></name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pCodec</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>,
                           <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>nReserve</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pagerReportSize</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>     <comment type="block">/* No-op if we do not support a codec */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>

<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
<comment type="block">/*
** Make sure the number of reserved bits is the same in the destination
** pager as it is in the source.  This comes up when a VACUUM changes the
** number of reserved bits to the "optimal" amount.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerAlignReserve</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>, <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>nReserve</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nReserve</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>nReserve</name></name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>nReserve</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pagerReportSize</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>

<comment type="block">/*
** Read a single page from either the journal file (if isMainJrnl==1) or
** from the sub-journal (if isMainJrnl==0) and playback that page.
** The page begins at offset *pOffset into the file. The *pOffset
** value is increased to the start of the next page in the journal.
**
** The main rollback journal uses checksums - the statement journal does 
** not.
**
** If the page number of the page record read from the (sub-)journal file
** is greater than the current value of Pager.dbSize, then playback is
** skipped and SQLITE_OK is returned.
**
** If pDone is not NULL, then it is a record of pages that have already
** been played back.  If the page at *pOffset has already been played back
** (if the corresponding pDone bit is set) then skip the playback.
** Make sure the pDone bit corresponding to the *pOffset page is set
** prior to returning.
**
** If the page record is successfully read from the (sub-)journal file
** and played back, then SQLITE_OK is returned. If an IO error occurs
** while reading the record from the (sub-)journal file or while writing
** to the database file, then the IO error code is returned. If data
** is successfully read from the (sub-)journal file but appears to be
** corrupted, SQLITE_DONE is returned. Data is considered corrupted in
** two circumstances:
** 
**   * If the record page-number is illegal (0 or PAGER_SJ_PGNO), or
**   * If the record is being rolled back from the main journal file
**     and the checksum field does not match the record content.
**
** Neither of these two scenarios are possible during a savepoint rollback.
**
** If this is a savepoint rollback, then memory may have to be dynamically
** allocated by this function. If this is the case and an allocation fails,
** SQLITE_NOMEM is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_playback_one_page</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,                <comment type="block">/* The pager being played back */</comment>
  <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pOffset</name></decl></parameter>,                 <comment type="block">/* Offset of record to playback */</comment>
  <parameter><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name>pDone</name></decl></parameter>,                <comment type="block">/* Bitvec of pages already played back */</comment>
  <parameter><decl><type><name>int</name></type> <name>isMainJrnl</name></decl></parameter>,               <comment type="block">/* 1 -&gt; main journal. 0 -&gt; sub-journal. */</comment>
  <parameter><decl><type><name>int</name></type> <name>isSavepnt</name></decl></parameter>                 <comment type="block">/* True for a savepoint rollback */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>                   <comment type="block">/* An existing page in the cache */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name></decl>;</decl_stmt>                    <comment type="block">/* The page number of a page in journal */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum</name></decl>;</decl_stmt>                    <comment type="block">/* Checksum used for sanity checking */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                  <comment type="block">/* Temporary storage for the page */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>jfd</name></decl>;</decl_stmt>            <comment type="block">/* The file descriptor for the journal file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isSynced</name></decl>;</decl_stmt>                 <comment type="block">/* True if journal page is synced */</comment>
<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
  <comment type="block">/* The jrnlEnc flag is true if Journal pages should be passed through
  ** the codec.  It is false for pure in-memory journals. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>jrnlEnc</name> <init>= <expr><operator>(</operator><name>isMainJrnl</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>subjInMemory</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>isMainJrnl</name><operator>&amp;</operator><operator>~</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* isMainJrnl is 0 or 1 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>isSavepnt</name><operator>&amp;</operator><operator>~</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* isSavepnt is 0 or 1 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isMainJrnl</name> <operator>||</operator> <name>pDone</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* pDone always used on sub-journals */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isSavepnt</name> <operator>||</operator> <name>pDone</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* pDone never used on non-savepoint */</comment>

  <expr_stmt><expr><name>aData</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>         <comment type="block">/* Temp storage must have already been allocated */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><name>isMainJrnl</name> <operator>&amp;&amp;</operator> <name>isSavepnt</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Either the state is greater than PAGER_WRITER_CACHEMOD (a transaction 
  ** or savepoint rollback done at the request of the caller) or this is
  ** a hot-journal rollback. If it is a hot-journal rollback, the pager
  ** is in state OPEN and holds an EXCLUSIVE lock. Hot-journal rollback
  ** only reads from the main journal, not the sub-journal.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_WRITER_CACHEMOD</name>
       <operator>||</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>EXCLUSIVE_LOCK</name><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_WRITER_CACHEMOD</name> <operator>||</operator> <name>isMainJrnl</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read the page number and page data from the journal or sub-journal
  ** file. Return an error code to the caller if an IO error occurs.
  */</comment>
  <expr_stmt><expr><name>jfd</name> <operator>=</operator> <ternary><condition><expr><name>isMainJrnl</name></expr> ?</condition><then> <expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr> </then><else>: <expr><name><name>pPager</name><operator>-&gt;</operator><name>sjfd</name></name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>read32bits</name><argument_list>(<argument><expr><name>jfd</name></expr></argument>, <argument><expr><operator>*</operator><name>pOffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>jfd</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>aData</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>pOffset</name><operator>)</operator><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pOffset</name> <operator>+=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <name>isMainJrnl</name><operator>*</operator><literal type="number">4</literal></expr>;</expr_stmt>

  <comment type="block">/* Sanity checking on the page.  This is more important that I originally
  ** thought.  If a power failure occurs while the journal is being written,
  ** it could cause invalid data to be written into the journal.  We need to
  ** detect this invalid data (with high probability) and ignore it.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pgno</name><operator>==</operator><call><name>PAGER_SJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>isSavepnt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>&gt;</operator><operator>(</operator><name>Pgno</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>||</operator> <call><name>sqlite3BitvecTest</name><argument_list>(<argument><expr><name>pDone</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isMainJrnl</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>read32bits</name><argument_list>(<argument><expr><name>jfd</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>pOffset</name><operator>)</operator><operator>-</operator><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isSavepnt</name> <operator>&amp;&amp;</operator> <call><name>pager_cksum</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>aData</name></expr></argument>)</argument_list></call><operator>!=</operator><name>cksum</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If this page has already been played back before during the current
  ** rollback, then don't bother to play it back again.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pDone</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3BitvecSet</name><argument_list>(<argument><expr><name>pDone</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* When playing back page 1, restore the nReserve setting
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>nReserve</name></name><operator>!=</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>aData</name><operator>)</operator><index>[<expr><literal type="number">20</literal></expr>]</index></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nReserve</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>aData</name><operator>)</operator><index>[<expr><literal type="number">20</literal></expr>]</index></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pagerReportSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the pager is in CACHEMOD state, then there must be a copy of this
  ** page in the pager cache. In this case just update the pager cache,
  ** not the database file. The page is left marked dirty in this case.
  **
  ** An exception to the above rule: If the database is in no-sync mode
  ** and a page is moved during an incremental vacuum then the page may
  ** not be in the pager cache. Later: if a malloc() or IO error occurs
  ** during a Movepage() call, then the page may not be in the cache
  ** either. So the condition described in the above paragraph is not
  ** assert()able.
  **
  ** If in WRITER_DBMOD, WRITER_FINISHED or OPEN state, then we update the
  ** pager cache if it exists and the main file. The page is then marked 
  ** not dirty. Since this code is only executed in PAGER_OPEN state for
  ** a hot-journal rollback, it is guaranteed that the page-cache is empty
  ** if the pager is in OPEN state.
  **
  ** Ticket #1171:  The statement journal might contain page content that is
  ** different from the page content at the start of the transaction.
  ** This occurs when a page is changed prior to the start of a statement
  ** then changed again within the statement.  When rolling back such a
  ** statement we must not write to the original database unless we know
  ** for certain that original page contents are synced into the main rollback
  ** journal.  Otherwise, a power loss might leave modified data in the
  ** database file without an entry in the rollback journal that can
  ** restore the database to its original form.  Two conditions must be
  ** met before writing to the database files. (1) the database must be
  ** locked.  (2) we know that the original page content is fully synced
  ** in the main journal either because the page is not in cache or else
  ** the page is marked as needSync==0.
  **
  ** 2008-04-14:  When attempting to vacuum a corrupt database file, it
  ** is possible to fail a statement on a database that does not yet exist.
  ** Do not attempt to write if database file has never been opened.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pPg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pPg</name> <operator>=</operator> <call><name>sqlite3PagerLookup</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPg</name> <operator>||</operator> <operator>!</operator><name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_OPEN</name> <operator>||</operator> <name>pPg</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"PLAYBACK %d page %d hash(%08x) %s\n"</literal><operator>,</operator>
           <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>,</operator> <name>pgno</name><operator>,</operator> <call><name>pager_datahash</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>aData</name></expr></argument>)</argument_list></call><operator>,</operator>
           <operator>(</operator><ternary><condition><expr><name>isMainJrnl</name></expr>?</condition><then><expr><literal type="string">"main-journal"</literal></expr></then><else>:<expr><literal type="string">"sub-journal"</literal></expr></else></ternary><operator>)</operator>
  <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>isMainJrnl</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>isSynced</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>noSync</name></name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>pOffset</name> <operator>&lt;=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>isSynced</name> <operator>=</operator> <operator>(</operator><name>pPg</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_NEED_SYNC</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_WRITER_DBMOD</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name><operator>)</operator>
   <operator>&amp;&amp;</operator> <name>isSynced</name></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>ofst</name> <init>= <expr><operator>(</operator><name>pgno</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>!</operator><name>isSavepnt</name> <operator>&amp;&amp;</operator> <name>pPg</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Write the data read from the journal back into the database file.
    ** This is usually safe even for an encrypted database - as the data
    ** was encrypted before it was written to the journal file. The exception
    ** is if the data was just read from an in-memory sub-journal. In that
    ** case it must be encrypted here before it is copied into the database
    ** file.  */</comment>
<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>jrnlEnc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>CODEC2</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><name>rc</name><operator>=</operator><name>SQLITE_NOMEM_BKPT</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>aData</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><name>ofst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>CODEC1</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>rc</name><operator>=</operator><name>SQLITE_NOMEM_BKPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>aData</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><name>ofst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>&gt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbFileSize</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbFileSize</name></name> <operator>=</operator> <name>pgno</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pBackup</name></name></expr> )</condition><block>{<block_content>
<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name>jrnlEnc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>CODEC1</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>rc</name><operator>=</operator><name>SQLITE_NOMEM_BKPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3BackupUpdate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pBackup</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CODEC2</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><name>rc</name><operator>=</operator><name>SQLITE_NOMEM_BKPT</name></expr></argument>,<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>
      <expr_stmt><expr><call><name>sqlite3BackupUpdate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pBackup</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><name>isMainJrnl</name> <operator>&amp;&amp;</operator> <name>pPg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* If this is a rollback of a savepoint and data was not written to
    ** the database and the page is not in-memory, there is a potential
    ** problem. When the page is next fetched by the b-tree layer, it 
    ** will be read from the database file, which may or may not be 
    ** current. 
    **
    ** There are a couple of different ways this can happen. All are quite
    ** obscure. When running in synchronous mode, this can only happen 
    ** if the page is on the free-list at the start of the transaction, then
    ** populated, then moved using sqlite3PagerMovepage().
    **
    ** The solution is to add an in-memory page to the cache containing
    ** the data just read from the sub-journal. Mark the page as dirty 
    ** and if the pager requires a journal-sync, then mark the page as 
    ** requiring a journal-sync before it is written.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isSavepnt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name> <operator>&amp;</operator> <name>SPILLFLAG_ROLLBACK</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name> <operator>|=</operator> <name>SPILLFLAG_ROLLBACK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name> <operator>&amp;</operator> <name>SPILLFLAG_ROLLBACK</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SPILLFLAG_ROLLBACK</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3PcacheMakeDirty</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* No page should ever be explicitly rolled back that is in use, except
    ** for page 1 which is held in use in order to keep the lock on the
    ** database active. However such a page may be rolled back as a result
    ** of an internal error resulting in an automatic call to
    ** sqlite3PagerRollback().
    */</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pData</name> <operator>=</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>aData</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pPager</name><operator>-&gt;</operator><name>xReiniter</name></name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* It used to be that sqlite3PcacheMakeClean(pPg) was called here.  But
    ** that call was dangerous and had no detectable benefit since the cache
    ** is normally cleaned by sqlite3PcacheCleanAll() after rollback and so
    ** has been removed. */</comment>
    <expr_stmt><expr><call><name>pager_set_pagehash</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If this was page 1, then restore the value of Pager.dbFileVers.
    ** Do this before any decoding. */</comment>
    <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbFileVers</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>pData</name><operator>)</operator><index>[<expr><literal type="number">24</literal></expr>]</index></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbFileVers</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Decode the page just read from disk */</comment>
<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_HAS_CODEC</name></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name>jrnlEnc</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>CODEC1</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>rc</name><operator>=</operator><name>SQLITE_NOMEM_BKPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>
    <expr_stmt><expr><call><name>sqlite3PcacheRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Parameter zSuper is the name of a super-journal file. A single journal
** file that referred to the super-journal file has just been rolled back.
** This routine checks if it is possible to delete the super-journal file,
** and does so if it is.
**
** Argument zSuper may point to Pager.pTmpSpace. So that buffer is not 
** available for use within this function.
**
** When a super-journal file is created, it is populated with the names 
** of all of its child journals, one after another, formatted as utf-8 
** encoded text. The end of each child journal file is marked with a 
** nul-terminator byte (0x00). i.e. the entire contents of a super-journal
** file for a transaction involving two databases might be:
**
**   "/home/bill/a.db-journal\x00/home/bill/b.db-journal\x00"
**
** A super-journal file may only be deleted once all of its child 
** journals have been rolled back.
**
** This function reads the contents of the super-journal file into 
** memory and loops through each of the child journal names. For
** each child journal, it checks if:
**
**   * if the child journal exists, and if so
**   * if the child journal contains a reference to super-journal 
**     file zSuper
**
** If a child journal can be found that matches both of the criteria
** above, this function returns without doing anything. Otherwise, if
** no such child journal can be found, file zSuper is deleted from
** the file-system using sqlite3OsDelete().
**
** If an IO error within this function, an error code is returned. This
** function allocates memory by calling sqlite3Malloc(). If an allocation
** fails, SQLITE_NOMEM is returned. Otherwise, if no IO or malloc errors 
** occur, SQLITE_OK is returned.
**
** TODO: This function allocates a single block of memory to load
** the entire contents of the super-journal file. This could be
** a couple of kilobytes or so - potentially larger than the page 
** size.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_delsuper</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSuper</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                   <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSuper</name></decl>;</decl_stmt>     <comment type="block">/* Malloc'd super-journal file descriptor */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pJournal</name></decl>;</decl_stmt>   <comment type="block">/* Malloc'd child-journal file descriptor */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSuperJournal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Contents of super-journal file */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nSuperJournal</name></decl>;</decl_stmt>        <comment type="block">/* Size of super-journal file */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zJournal</name></decl>;</decl_stmt>           <comment type="block">/* Pointer to one journal within MJ file */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSuperPtr</name></decl>;</decl_stmt>          <comment type="block">/* Space to hold super-journal filename */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Free this buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSuperPtr</name></decl>;</decl_stmt>            <comment type="block">/* Amount of space allocated to zSuperPtr[] */</comment>

  <comment type="block">/* Allocate space for both the pJournal and pSuper file descriptors.
  ** If successful, open the super-journal file for reading.
  */</comment>
  <expr_stmt><expr><name>pSuper</name> <operator>=</operator> <operator>(</operator><name>sqlite3_file</name> <operator>*</operator><operator>)</operator><call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>szOsFile</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pSuper</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pJournal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name> <init>= <expr><operator>(</operator><name>SQLITE_OPEN_READONLY</name><operator>|</operator><name>SQLITE_OPEN_SUPER_JOURNAL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>, <argument><expr><name>pSuper</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pJournal</name> <operator>=</operator> <operator>(</operator><name>sqlite3_file</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pSuper</name><operator>)</operator> <operator>+</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>szOsFile</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>delsuper_out</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Load the entire super-journal file into space obtained from
  ** sqlite3_malloc() and pointed to by zSuperJournal.   Also obtain
  ** sufficient space (in zSuperPtr) to hold the names of super-journal
  ** files extracted from regular rollback-journals.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name>pSuper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSuperJournal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>delsuper_out</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nSuperPtr</name> <operator>=</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFree</name> <operator>=</operator> <call><name>sqlite3Malloc</name><argument_list>(<argument><expr><literal type="number">4</literal> <operator>+</operator> <name>nSuperJournal</name> <operator>+</operator> <name>nSuperPtr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zFree</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
    <goto>goto <name>delsuper_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>zFree</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>zFree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>zFree</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>zFree</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSuperJournal</name> <operator>=</operator> <operator>&amp;</operator><name><name>zFree</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSuperPtr</name> <operator>=</operator> <operator>&amp;</operator><name><name>zSuperJournal</name><index>[<expr><name>nSuperJournal</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>pSuper</name></expr></argument>, <argument><expr><name>zSuperJournal</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nSuperJournal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>delsuper_out</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>zSuperJournal</name><index>[<expr><name>nSuperJournal</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zSuperJournal</name><index>[<expr><name>nSuperJournal</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>zJournal</name> <operator>=</operator> <name>zSuperJournal</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>zJournal</name><operator>-</operator><name>zSuperJournal</name><operator>)</operator><operator>&lt;</operator><name>nSuperJournal</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>exists</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsAccess</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zJournal</name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>delsuper_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>exists</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* One of the journals pointed to by the super-journal exists.
      ** Open it and check if it points at the super-journal. If
      ** so, return without deleting the super-journal file.
      ** NB:  zJournal is really a MAIN_JOURNAL.  But call it a 
      ** SUPER_JOURNAL here so that the VFS will not send the zJournal
      ** name into sqlite3_database_file_object().
      */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><operator>(</operator><name>SQLITE_OPEN_READONLY</name><operator>|</operator><name>SQLITE_OPEN_SUPER_JOURNAL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zJournal</name></expr></argument>, <argument><expr><name>pJournal</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>delsuper_out</name>;</goto>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>readSuperJournal</name><argument_list>(<argument><expr><name>pJournal</name></expr></argument>, <argument><expr><name>zSuperPtr</name></expr></argument>, <argument><expr><name>nSuperPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>pJournal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>delsuper_out</name>;</goto>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zSuperPtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>zSuperPtr</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* We have a match. Do not delete the super-journal file. */</comment>
        <goto>goto <name>delsuper_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zJournal</name> <operator>+=</operator> <operator>(</operator><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zJournal</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
 
  <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>pSuper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>delsuper_out</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSuper</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>pSuper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name>pJournal</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pSuper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is used to change the actual size of the database 
** file in the file-system. This only happens when committing a transaction,
** or rolling back a transaction (including rolling back a hot-journal).
**
** If the main database file is not open, or the pager is not in either
** DBMOD or OPEN state, this function is a no-op. Otherwise, the size 
** of the file is changed to nPage pages (nPage*pPager-&gt;pageSize bytes). 
** If the file on disk is currently larger than nPage pages, then use the VFS
** xTruncate() method to truncate it.
**
** Or, it might be the case that the file on disk is smaller than 
** nPage pages. Some operating system implementations can get confused if 
** you try to truncate a file to some size that is larger than it 
** currently is, so detect this case and write a single zero byte to 
** the end of the new file instead.
**
** If successful, return SQLITE_OK. If an IO error occurs while modifying
** the database file, return the error code to the caller.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_truncate</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>nPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_ERROR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_READER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>( <expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> 
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_WRITER_DBMOD</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name><operator>)</operator></expr> 
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>currentSize</name></decl>, <decl><type ref="prev"/><name>newSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>szPage</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* TODO: Is it safe to use Pager.dbFileSize here? */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>currentSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>newSize</name> <operator>=</operator> <name>szPage</name><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><name>nPage</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>currentSize</name><operator>!=</operator><name>newSize</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>currentSize</name><operator>&gt;</operator><name>newSize</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>currentSize</name><operator>+</operator><name>szPage</name><operator>)</operator><operator>&lt;=</operator><name>newSize</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pTmp</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pTmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>szPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>newSize</name><operator>-</operator><name>szPage</name><operator>)</operator> <operator>==</operator> <name>currentSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>newSize</name><operator>-</operator><name>szPage</name><operator>)</operator> <operator>&gt;</operator>  <name>currentSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3OsFileControlHint</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_SIZE_HINT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>pTmp</name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>, <argument><expr><name>newSize</name><operator>-</operator><name>szPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbFileSize</name></name> <operator>=</operator> <name>nPage</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a sanitized version of the sector-size of OS file pFile. The
** return value is guaranteed to lie between 32 and MAX_SECTOR_SIZE.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3SectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iRet</name> <init>= <expr><call><name>sqlite3OsSectorSize</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iRet</name><operator>&lt;</operator><literal type="number">32</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iRet</name> <operator>=</operator> <literal type="number">512</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iRet</name><operator>&gt;</operator><name>MAX_SECTOR_SIZE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>MAX_SECTOR_SIZE</name><operator>&gt;=</operator><literal type="number">512</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iRet</name> <operator>=</operator> <name>MAX_SECTOR_SIZE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>iRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the value of the Pager.sectorSize variable for the given
** pager based on the value returned by the xSectorSize method
** of the open database file. The sector size will be used 
** to determine the size and alignment of journal header and 
** super-journal pointers within created journal files.
**
** For temporary files the effective sector size is always 512 bytes.
**
** Otherwise, for non-temporary files, the effective sector size is
** the value returned by the xSectorSize() method rounded up to 32 if
** it is less than 32, or rounded down to MAX_SECTOR_SIZE if it
** is greater than MAX_SECTOR_SIZE.
**
** If the file has the SQLITE_IOCAP_POWERSAFE_OVERWRITE property, then set
** the effective sector size to its minimum value (512).  The purpose of
** pPager-&gt;sectorSize is to define the "blast radius" of bytes that
** might change if a crash occurs while writing to a single byte in
** that range.  But with POWERSAFE_OVERWRITE, the blast radius is zero
** (that is what POWERSAFE_OVERWRITE means), so we minimize the sector
** size.  For backwards compatibility of the rollback journal file format,
** we cannot reduce the effective sector size below 512.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setSectorSize</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name>
   <operator>||</operator> <operator>(</operator><call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> 
              <name>SQLITE_IOCAP_POWERSAFE_OVERWRITE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* Sector size doesn't matter for temporary files. Also, the file
    ** may not have been opened yet, in which case the OsSectorSize()
    ** call will segfault. */</comment>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>=</operator> <literal type="number">512</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>=</operator> <call><name>sqlite3SectorSize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Playback the journal and thus restore the database file to
** the state it was in before we started making changes.  
**
** The journal file format is as follows: 
**
**  (1)  8 byte prefix.  A copy of aJournalMagic[].
**  (2)  4 byte big-endian integer which is the number of valid page records
**       in the journal.  If this value is 0xffffffff, then compute the
**       number of page records from the journal size.
**  (3)  4 byte big-endian integer which is the initial value for the 
**       sanity checksum.
**  (4)  4 byte integer which is the number of pages to truncate the
**       database to during a rollback.
**  (5)  4 byte big-endian integer which is the sector size.  The header
**       is this many bytes in size.
**  (6)  4 byte big-endian integer which is the page size.
**  (7)  zero padding out to the next sector size.
**  (8)  Zero or more pages instances, each as follows:
**        +  4 byte page number.
**        +  pPager-&gt;pageSize bytes of data.
**        +  4 byte checksum
**
** When we speak of the journal header, we mean the first 7 items above.
** Each entry in the journal is an instance of the 8th item.
**
** Call the value from the second bullet "nRec".  nRec is the number of
** valid page entries in the journal.  In most cases, you can compute the
** value of nRec from the size of the journal file.  But if a power
** failure occurred while the journal was being written, it could be the
** case that the size of the journal file had already been increased but
** the extra entries had not yet made it safely to disk.  In such a case,
** the value of nRec computed from the file size would be too large.  For
** that reason, we always use the nRec value in the header.
**
** If the nRec value is 0xffffffff it means that nRec should be computed
** from the file size.  This value is used when the user selects the
** no-sync option for the journal.  A power failure could lead to corruption
** in this case.  But for things like temporary table (which will be
** deleted when the power is restored) we don't care.  
**
** If the file opened as the journal file is not a well-formed
** journal file then all pages up to the first corrupted page are rolled
** back (or no pages if the journal header is corrupted). The journal file
** is then deleted and SQLITE_OK returned, just as if no corruption had
** been encountered.
**
** If an I/O or malloc() error occurs, the journal-file is not deleted
** and an error code is returned.
**
** The isHot parameter indicates that we are trying to rollback a journal
** that might be a hot journal.  Or, it could be that the journal is 
** preserved because of JOURNALMODE_PERSIST or JOURNALMODE_TRUNCATE.
** If the journal really is hot, reset the pager cache prior rolling
** back any content.  If the journal is merely persistent, no reset is
** needed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_playback</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isHot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>szJ</name></decl>;</decl_stmt>                 <comment type="block">/* Size of the journal file in bytes */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nRec</name></decl>;</decl_stmt>                <comment type="block">/* Number of Records in the journal */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>u</name></decl>;</decl_stmt>                   <comment type="block">/* Unsigned loop counter */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>mxPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Size of the original file in pages */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                  <comment type="block">/* Result code of a subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Value returned by sqlite3OsAccess() */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSuper</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Name of super-journal file if any */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>needPagerReset</name></decl>;</decl_stmt>      <comment type="block">/* True to reset page prior to first page rollback */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPlayback</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Total number of pages restored from journal */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>savedPageSize</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Figure out how many records are in the journal.  Abort early if
  ** the journal is empty.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>szJ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>end_playback</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Read the super-journal name from the journal, if it is present.
  ** If a super-journal file name is specified, but the file is not
  ** present on disk, then the journal is not hot and does not need to be
  ** played back.
  **
  ** TODO: Technically the following is an error because it assumes that
  ** buffer Pager.pTmpSpace is (mxPathname+1) bytes or larger. i.e. that
  ** (pPager-&gt;pageSize &gt;= pPager-&gt;pVfs-&gt;mxPathname+1). Using os_unix.c,
  ** mxPathname is 512, which is the same as the minimum allowable value
  ** for pageSize.
  */</comment>
  <expr_stmt><expr><name>zSuper</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>readSuperJournal</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>zSuper</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsAccess</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zSuper</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>!</operator><name>res</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>end_playback</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>needPagerReset</name> <operator>=</operator> <name>isHot</name></expr>;</expr_stmt>

  <comment type="block">/* This loop terminates either when a readJournalHdr() or 
  ** pager_playback_one_page() call returns SQLITE_DONE or an IO error 
  ** occurs. 
  */</comment>
  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Read the next journal header from the journal file.  If there are
    ** not enough bytes left in the journal file for a complete header, or
    ** it is corrupted, then a process must have failed while writing it.
    ** This indicates nothing more needs to be rolled back.
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>readJournalHdr</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>isHot</name></expr></argument>, <argument><expr><name>szJ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nRec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mxPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content> 
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <goto>goto <name>end_playback</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If nRec is 0xffffffff, then this journal was created by a process
    ** working in no-sync mode. This means that the rest of the journal
    ** file consists of pages, there are no more journal headers. Compute
    ** the value of nRec based on this assumption.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>nRec</name><operator>==</operator><literal type="number">0xffffffff</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>==</operator><call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRec</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>szJ</name> <operator>-</operator> <call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>)</operator><operator>/</operator><call><name>JOURNAL_PG_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If nRec is 0 and this rollback is of a transaction created by this
    ** process and if this is the final header in the journal, then it means
    ** that this part of the journal was being filled but has not yet been
    ** synced to disk.  Compute the number of pages based on the remaining
    ** size of the file.
    **
    ** The third term of the test was added to fix ticket #2565.
    ** When rolling back a hot journal, nRec==0 always means that the next
    ** chunk of the journal contains zero pages to be rolled back.  But
    ** when doing a ROLLBACK and the nRec==0 chunk is the last chunk in
    ** the journal, it means that the journal might contain additional
    ** pages that need to be rolled back and that the number of pages 
    ** should be computed based on the journal file size.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>nRec</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>isHot</name> <operator>&amp;&amp;</operator>
        <name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name><operator>+</operator><call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>==</operator><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nRec</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>szJ</name> <operator>-</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>)</operator> <operator>/</operator> <call><name>JOURNAL_PG_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If this is the first header read from the journal, truncate the
    ** database file back to its original size.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>==</operator><call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_truncate</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>mxPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>end_playback</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>=</operator> <name>mxPg</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>mxPgno</name></name><operator>&lt;</operator><name>mxPg</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>mxPgno</name></name> <operator>=</operator> <name>mxPg</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Copy original pages out of the journal and back into the 
    ** database file and/or page cache.
    */</comment>
    <for>for<control>(<init><expr><name>u</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name><operator>&lt;</operator><name>nRec</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>needPagerReset</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>pager_reset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>needPagerReset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_playback_one_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nPlayback</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>=</operator> <name>szJ</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_IOERR_SHORT_READ</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* If the journal has been truncated, simply stop reading and
          ** processing the journal. This might happen if the journal was
          ** not completely written and synced prior to a crash.  In that
          ** case, the database should have never been written in the
          ** first place so it is OK to simply abandon the rollback. */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
          <goto>goto <name>end_playback</name>;</goto>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* If we are unable to rollback, quit and return the error
          ** code.  This will cause the pager to enter the error state
          ** so that no further harm will be done.  Perhaps the next
          ** process to come along will be able to rollback the database.
          */</comment>
          <goto>goto <name>end_playback</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></while>
  <comment type="block">/*NOTREACHED*/</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>end_playback</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSetPagesize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedPageSize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Following a rollback, the database file should be back in its original
  ** state prior to the start of the transaction, so invoke the
  ** SQLITE_FCNTL_DB_UNCHANGED file-control method to disable the
  ** assertion that the transaction counter was modified.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>sqlite3OsFileControlHint</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,<argument><expr><name>SQLITE_FCNTL_DB_UNCHANGED</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If this playback is happening automatically as a result of an IO or 
  ** malloc error that occurred after the change-counter was updated but 
  ** before the transaction was committed, then the change-counter 
  ** modification may just have been reverted. If this happens in exclusive 
  ** mode, then subsequent transactions performed by the connection will not
  ** update the change-counter at all. This may lead to cache inconsistency
  ** problems for other processes at some point in the future. So, just
  ** in case this has happened, clear the changeCountDone flag now.
  */</comment>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>changeCountDone</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Leave 4 bytes of space before the super-journal filename in memory.
    ** This is because it may end up being passed to sqlite3OsOpen(), in
    ** which case it requires 4 0x00 bytes in memory immediately before
    ** the filename. */</comment>
    <expr_stmt><expr><name>zSuper</name> <operator>=</operator> <operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>readSuperJournal</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_WRITER_DBMOD</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSync</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_end_transaction</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name><name>zSuper</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'\0'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>zSuper</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>res</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there was a super-journal and this routine will return success,
    ** see if it is possible to delete the super-journal.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zSuper</name><operator>==</operator><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zSuper</name><index>[<expr><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_delsuper</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isHot</name> <operator>&amp;&amp;</operator> <name>nPlayback</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_NOTICE_RECOVER_ROLLBACK</name></expr></argument>, <argument><expr><literal type="string">"recovered %d pages from %s"</literal></expr></argument>,
                <argument><expr><name>nPlayback</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The Pager.sectorSize variable may have been updated while rolling
  ** back a journal created by a process with a different sector size
  ** value. Reset it to the correct value for this process.
  */</comment>
  <expr_stmt><expr><call><name>setSectorSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Read the content for page pPg out of the database file (or out of
** the WAL if that is where the most recent copy if found) into 
** pPg-&gt;pData. A shared lock or greater must be held on the database
** file before this function is called.
**
** If page 1 is read, then the value of Pager.dbFileVers[] is set to
** the value read from the database file.
**
** If an IO error occurs, then the IO error is returned to the caller.
** Otherwise, SQLITE_OK is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>readDbPage</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Pager object associated with page pPg */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>          <comment type="block">/* Return code */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <decl_stmt><decl><type><name>u32</name></type> <name>iFrame</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Frame of WAL containing pgno */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_READER</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalFindFrame</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iFrame</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalReadFrame</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name>iFrame</name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>,<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iOffset</name> <init>= <expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_IOERR_SHORT_READ</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If the read is unsuccessful, set the dbFileVers[] to something
      ** that will never be a valid file version.  dbFileVers[] is a copy
      ** of bytes 24..39 of the database.  Bytes 28..31 should always be
      ** zero or the size of the database in page. Bytes 32..35 and 35..39
      ** should be page numbers which are never 0xffffffff.  So filling
      ** pPager-&gt;dbFileVers[] with all 0xff bytes should suffice.
      **
      ** For an encrypted database, the situation is more complex:  bytes
      ** 24..39 of the database are white noise.  But the probability of
      ** white noise equaling 16 bytes of 0xff is vanishingly small so
      ** we should still be ok.
      */</comment>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbFileVers</name></name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbFileVers</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>dbFileVers</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pPg</name><operator>-&gt;</operator><name>pData</name></name><operator>)</operator><index>[<expr><literal type="number">24</literal></expr>]</index></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbFileVers</name></name></expr></argument>, <argument><expr><name>dbFileVers</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbFileVers</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>CODEC1</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PAGER_INCR</name><argument_list>(<argument><expr><name>sqlite3_pager_readdb_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PAGER_INCR</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>nRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>IOTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"PGIN %p %d\n"</literal><operator>,</operator> <name>pPager</name><operator>,</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FETCH %d page %d hash(%08x)\n"</literal><operator>,</operator>
               <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>,</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>,</operator> <call><name>pager_pagehash</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Update the value of the change-counter at offsets 24 and 92 in
** the header and the sqlite version number at offset 96.
**
** This is an unconditional update.  See also the pager_incr_changecounter()
** routine which only updates the change-counter if the update is actually
** needed, as determined by the pPager-&gt;changeCountDone state variable.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pager_write_changecounter</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>change_counter</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pPg</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Increment the value just read and write it back to byte 24. */</comment>
  <expr_stmt><expr><name>change_counter</name> <operator>=</operator> <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>dbFileVers</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>pPg</name><operator>-&gt;</operator><name>pData</name></name><operator>)</operator><operator>+</operator><literal type="number">24</literal></expr></argument>, <argument><expr><name>change_counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Also store the SQLite version number in bytes 96..99 and in
  ** bytes 92..95 store the change counter for which the version number
  ** is valid. */</comment>
  <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>pPg</name><operator>-&gt;</operator><name>pData</name></name><operator>)</operator><operator>+</operator><literal type="number">92</literal></expr></argument>, <argument><expr><name>change_counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>pPg</name><operator>-&gt;</operator><name>pData</name></name><operator>)</operator><operator>+</operator><literal type="number">96</literal></expr></argument>, <argument><expr><name>SQLITE_VERSION_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
<comment type="block">/*
** This function is invoked once for each page that has already been 
** written into the log file when a WAL transaction is rolled back.
** Parameter iPg is the page number of said page. The pCtx argument 
** is actually a pointer to the Pager structure.
**
** If page iPg is present in the cache, and has no outstanding references,
** it is discarded. Otherwise, if there are one or more outstanding
** references, the page content is reloaded from the database. If the
** attempt to reload content from the database is required and fails, 
** return an SQLite error code. Otherwise, SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerUndoCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><operator>(</operator><name>Pager</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPg</name> <operator>=</operator> <call><name>sqlite3PagerLookup</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3PcachePageRefcount</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PcacheDrop</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>readDbPage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name><name>pPager</name><operator>-&gt;</operator><name>xReiniter</name></name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerUnrefNotNull</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Normally, if a transaction is rolled back, any backup processes are
  ** updated as data is copied out of the rollback journal and into the
  ** database. This is not generally possible with a WAL database, as
  ** rollback involves simply truncating the log file. Therefore, if one
  ** or more frames have already been written to the log (and therefore 
  ** also copied into the backup databases) as part of this transaction,
  ** the backups must be restarted.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3BackupRestart</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pBackup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to rollback a transaction on a WAL database.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerRollbackWal</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>                   <comment type="block">/* List of dirty pages to revert */</comment>

  <comment type="block">/* For all pages in the cache that are currently dirty or have already
  ** been written (but not committed) to the log file, do one of the 
  ** following:
  **
  **   + Discard the cached page (if refcount==0), or
  **   + Reload page content from the database (if refcount&gt;0).
  */</comment>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalUndo</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name>pagerUndoCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3PcacheDirtyList</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pList</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>pDirty</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerUndoCallback</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pPager</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a wrapper around sqlite3WalFrames(). As well as logging
** the contents of the list of pages headed by pList (connected by pDirty),
** this function notifies any active backup processes that the pages have
** changed. 
**
** The list of pages passed into this routine is always sorted by page number.
** Hence, if page 1 appears anywhere on the list, it will be the first page.
*/</comment> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerWalFrames</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,                  <comment type="block">/* Pager object */</comment>
  <parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,                   <comment type="block">/* List of frames to log */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>nTruncate</name></decl></parameter>,                 <comment type="block">/* Database size after this commit */</comment>
  <parameter><decl><type><name>int</name></type> <name>isCommit</name></decl></parameter>                    <comment type="block">/* True if this is a commit */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nList</name></decl>;</decl_stmt>                      <comment type="block">/* Number of pages in pList */</comment>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                       <comment type="block">/* For looping over pages */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* Verify that the page list is in accending order */</comment>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pList</name></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pgno</name></name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>pDirty</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>pDirty</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isCommit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>isCommit</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If a WAL transaction is being committed, there is no point in writing
    ** any pages with page numbers greater than nTruncate into the WAL file.
    ** They will never be read by any client. So remove them from the pDirty
    ** list here. */</comment>
    <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNext</name> <init>= <expr><operator>&amp;</operator><name>pList</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nList</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pList</name></expr>;</init> <condition><expr><operator>(</operator><operator>*</operator><name>ppNext</name> <operator>=</operator> <name>p</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pgno</name></name><operator>&lt;=</operator><name>nTruncate</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>ppNext</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nList</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nList</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>aStat</name><index>[<expr><name>PAGER_STAT_WRITE</name></expr>]</index></name> <operator>+=</operator> <name>nList</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pList</name><operator>-&gt;</operator><name>pgno</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pager_write_changecounter</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalFrames</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, 
      <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>nTruncate</name></expr></argument>, <argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>walSyncFlags</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pBackup</name></name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pList</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BackupUpdate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pBackup</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_CHECK_PAGES</name></cpp:ifdef>
  <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3PcacheDirtyList</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pList</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>pager_set_pagehash</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Begin a read transaction on the WAL.
**
** This routine used to be called "pagerOpenSnapshot()" because it essentially
** makes a snapshot of the database at the current point in time and preserves
** that snapshot for use by the reader in spite of concurrently changes by
** other writers or checkpointers.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerBeginReadTransaction</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>changed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* True if cache must be reset */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_READER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* sqlite3WalEndReadTransaction() was not called for the previous
  ** transaction in locking_mode=EXCLUSIVE.  So call it now.  If we
  ** are in locking_mode=NORMAL and EndRead() was previously called,
  ** the duplicate call is harmless.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3WalEndReadTransaction</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalBeginReadTransaction</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>changed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name>changed</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>pager_reset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>USEFETCH</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3OsUnfetch</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This function is called as part of the transition from PAGER_OPEN
** to PAGER_READER state to determine the size of the database file
** in pages (assuming the page size currently stored in Pager.pageSize).
**
** If no error occurs, SQLITE_OK is returned and the size of the database
** in pages is stored in *pnPage. Otherwise, an error code (perhaps
** SQLITE_IOERR_FSTAT) is returned and *pnPage is left unmodified.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerPagecount</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>Pgno</name> <modifier>*</modifier></type><name>pnPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>nPage</name></decl>;</decl_stmt>                     <comment type="block">/* Value to return via *pnPage */</comment>

  <comment type="block">/* Query the WAL sub-system for the database size. The WalDbsize()
  ** function returns zero if the WAL is not open (i.e. Pager.pWal==0), or
  ** if the database size is not available. The database size is not
  ** available from the WAL sub-system if the log file is empty or
  ** contains no valid committed transactions.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nPage</name> <operator>=</operator> <call><name>sqlite3WalDbsize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the number of pages in the database is not available from the
  ** WAL sub-system, determine the page count based on the size of
  ** the database file.  If the size of the database file is not an
  ** integer multiple of the page-size, round up the result.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nPage</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Size of db file in bytes */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nPage</name> <operator>=</operator> <operator>(</operator><name>Pgno</name><operator>)</operator><operator>(</operator><operator>(</operator><name>n</name><operator>+</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the current number of pages in the file is greater than the
  ** configured maximum pager number, increase the allowed limit so
  ** that the file can be read.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nPage</name><operator>&gt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>mxPgno</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>mxPgno</name></name> <operator>=</operator> <operator>(</operator><name>Pgno</name><operator>)</operator><name>nPage</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pnPage</name> <operator>=</operator> <name>nPage</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
<comment type="block">/*
** Check if the *-wal file that corresponds to the database opened by pPager
** exists if the database is not empy, or verify that the *-wal file does
** not exist (by deleting it) if the database file is empty.
**
** If the database is not empty and the *-wal file exists, open the pager
** in WAL mode.  If the database is empty or if no *-wal file exists and
** if no error occurs, make sure Pager.journalMode is not set to
** PAGER_JOURNALMODE_WAL.
**
** Return SQLITE_OK or an error code.
**
** The caller must hold a SHARED lock on the database file to call this
** function. Because an EXCLUSIVE lock on the db file is required to delete 
** a WAL on a none-empty database, this ensures there is no race condition 
** between the xAccess() below and an xDelete() being executed by some 
** other connection.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerOpenWalIfPresent</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>isWal</name></decl>;</decl_stmt>                    <comment type="block">/* True if WAL file exists */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsAccess</name><argument_list>(
        <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zWal</name></name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isWal</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>isWal</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Pgno</name></type> <name>nPage</name></decl>;</decl_stmt>                   <comment type="block">/* Size of the database file */</comment>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerPagecount</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>nPage</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zWal</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>sqlite3PcachePagecount</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerOpenWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name> <operator>=</operator> <name>PAGER_JOURNALMODE_DELETE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Playback savepoint pSavepoint. Or, if pSavepoint==NULL, then playback
** the entire super-journal file. The case pSavepoint==NULL occurs when 
** a ROLLBACK TO command is invoked on a SAVEPOINT that is a transaction 
** savepoint.
**
** When pSavepoint is not NULL (meaning a non-transaction savepoint is 
** being rolled back), then the rollback consists of up to three stages,
** performed in the order specified:
**
**   * Pages are played back from the main journal starting at byte
**     offset PagerSavepoint.iOffset and continuing to 
**     PagerSavepoint.iHdrOffset, or to the end of the main journal
**     file if PagerSavepoint.iHdrOffset is zero.
**
**   * If PagerSavepoint.iHdrOffset is not zero, then pages are played
**     back starting from the journal header immediately following 
**     PagerSavepoint.iHdrOffset to the end of the main journal file.
**
**   * Pages are then played back from the sub-journal file, starting
**     with the PagerSavepoint.iSubRec and continuing to the end of
**     the journal file.
**
** Throughout the rollback process, each time a page is rolled back, the
** corresponding bit is set in a bitvec structure (variable pDone in the
** implementation below). This is used to ensure that a page is only
** rolled back the first time it is encountered in either journal.
**
** If pSavepoint is NULL, then pages are only played back from the main
** journal file. There is no need for a bitvec in this case.
**
** In either case, before playback commences the Pager.dbSize variable
** is reset to the value that it held at the start of the savepoint 
** (or transaction). No page with a page-number greater than this value
** is played back. If one is encountered it is simply skipped.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerPlaybackSavepoint</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>PagerSavepoint</name> <modifier>*</modifier></type><name>pSavepoint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>szJ</name></decl>;</decl_stmt>                 <comment type="block">/* Effective size of the main journal */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iHdrOff</name></decl>;</decl_stmt>             <comment type="block">/* End of first segment of main-journal records */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Bitvec</name> <modifier>*</modifier></type><name>pDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Bitvec to ensure pages played back only once */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_ERROR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_WRITER_LOCKED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate a bitvec to use to store the set of pages rolled back */</comment>
  <if_stmt><if>if<condition>( <expr><name>pSavepoint</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pDone</name> <operator>=</operator> <call><name>sqlite3BitvecCreate</name><argument_list>(<argument><expr><name><name>pSavepoint</name><operator>-&gt;</operator><name>nOrig</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pDone</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the database size back to the value it was before the savepoint 
  ** being reverted was opened.
  */</comment>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>=</operator> <ternary><condition><expr><name>pSavepoint</name></expr> ?</condition><then> <expr><name><name>pSavepoint</name><operator>-&gt;</operator><name>nOrig</name></name></expr> </then><else>: <expr><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>changeCountDone</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pSavepoint</name> <operator>&amp;&amp;</operator> <call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>pagerRollbackWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Use pPager-&gt;journalOff as the effective size of the main rollback
  ** journal.  The actual file might be larger than this in
  ** PAGER_JOURNALMODE_TRUNCATE or PAGER_JOURNALMODE_PERSIST.  But anything
  ** past pPager-&gt;journalOff is off-limits to us.
  */</comment>
  <expr_stmt><expr><name>szJ</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>szJ</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Begin by rolling back records from the main journal starting at
  ** PagerSavepoint.iOffset and continuing to the next journal header.
  ** There might be records in the main journal that have a page number
  ** greater than the current database size (pPager-&gt;dbSize) but those
  ** will be skipped automatically.  Pages are added to pDone as they
  ** are played back.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pSavepoint</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iHdrOff</name> <operator>=</operator> <ternary><condition><expr><name><name>pSavepoint</name><operator>-&gt;</operator><name>iHdrOffset</name></name></expr> ?</condition><then> <expr><name><name>pSavepoint</name><operator>-&gt;</operator><name>iHdrOffset</name></name></expr> </then><else>: <expr><name>szJ</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>=</operator> <name><name>pSavepoint</name><operator>-&gt;</operator><name>iOffset</name></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>&lt;</operator><name>iHdrOff</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_playback_one_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr></argument>, <argument><expr><name>pDone</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Continue rolling back records out of the main journal starting at
  ** the first journal header seen and continuing until the effective end
  ** of the main journal file.  Continue to skip out-of-range pages and
  ** continue adding pages rolled back to pDone.
  */</comment>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>&lt;</operator><name>szJ</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>ii</name></decl>;</decl_stmt>            <comment type="block">/* Loop counter */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>nJRec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Number of Journal Records */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>dummy</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>readJournalHdr</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>szJ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nJRec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
    ** The "pPager-&gt;journalHdr+JOURNAL_HDR_SZ(pPager)==pPager-&gt;journalOff"
    ** test is related to ticket #2565.  See the discussion in the
    ** pager_playback() function for additional information.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>nJRec</name><operator>==</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name><operator>+</operator><call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>==</operator><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>nJRec</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>szJ</name> <operator>-</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>)</operator><operator>/</operator><call><name>JOURNAL_PG_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>&lt;</operator><name>nJRec</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>&lt;</operator><name>szJ</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_playback_one_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr></argument>, <argument><expr><name>pDone</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>&gt;=</operator><name>szJ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Finally,  rollback pages from the sub-journal.  Page that were
  ** previously rolled back out of the main journal (and are hence in pDone)
  ** will be skipped.  Out-of-range pages are also skipped.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pSavepoint</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>ii</name></decl>;</decl_stmt>            <comment type="block">/* Loop counter */</comment>
    <decl_stmt><decl><type><name>i64</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>i64</name><operator>)</operator><name><name>pSavepoint</name><operator>-&gt;</operator><name>iSubRec</name></name><operator>*</operator><operator>(</operator><literal type="number">4</literal><operator>+</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalSavepointUndo</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name><name>pSavepoint</name><operator>-&gt;</operator><name>aWalData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><name><name>pSavepoint</name><operator>-&gt;</operator><name>iSubRec</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>&lt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>nSubRec</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>offset</name><operator>==</operator><operator>(</operator><name>i64</name><operator>)</operator><name>ii</name><operator>*</operator><operator>(</operator><literal type="number">4</literal><operator>+</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_playback_one_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><name>pDone</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name>pDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>=</operator> <name>szJ</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change the maximum number of in-memory pages that are allowed
** before attempting to recycle clean and unused pages.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerSetCachesize</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mxPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3PcacheSetCachesize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>, <argument><expr><name>mxPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Change the maximum number of in-memory pages that are allowed
** before attempting to spill pages to journal.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerSetSpillsize</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mxPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3PcacheSetSpillsize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>, <argument><expr><name>mxPage</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Invoke SQLITE_FCNTL_MMAP_SIZE based on the current value of szMmap.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pagerFixMaplimit</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>isOpen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>fd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>sz</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>szMmap</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>bUseFetch</name></name> <operator>=</operator> <operator>(</operator><name>sz</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setGetterMethod</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3OsFileControlHint</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_MMAP_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Change the maximum size of any memory mapping made of the database file.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerSetMmapLimit</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>szMmap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>szMmap</name></name> <operator>=</operator> <name>szMmap</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pagerFixMaplimit</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free as much memory as possible from the pager.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerShrink</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3PcacheShrink</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Adjust settings of the pager to those specified in the pgFlags parameter.
**
** The "level" in pgFlags &amp; PAGER_SYNCHRONOUS_MASK sets the robustness
** of the database to damage due to OS crashes or power failures by
** changing the number of syncs()s when writing the journals.
** There are four levels:
**
**    OFF       sqlite3OsSync() is never called.  This is the default
**              for temporary and transient files.
**
**    NORMAL    The journal is synced once before writes begin on the
**              database.  This is normally adequate protection, but
**              it is theoretically possible, though very unlikely,
**              that an inopertune power failure could leave the journal
**              in a state which would cause damage to the database
**              when it is rolled back.
**
**    FULL      The journal is synced twice before writes begin on the
**              database (with some additional information - the nRec field
**              of the journal header - being written in between the two
**              syncs).  If we assume that writing a
**              single disk sector is atomic, then this mode provides
**              assurance that the journal will not be corrupted to the
**              point of causing damage to the database during rollback.
**
**    EXTRA     This is like FULL except that is also syncs the directory
**              that contains the rollback journal after the rollback
**              journal is unlinked.
**
** The above is for a rollback-journal mode.  For WAL mode, OFF continues
** to mean that no syncs ever occur.  NORMAL means that the WAL is synced
** prior to the start of checkpoint and that the database file is synced
** at the conclusion of the checkpoint if the entire content of the WAL
** was written back into the database.  But no sync operations occur for
** an ordinary commit in NORMAL mode with WAL.  FULL means that the WAL
** file is synced following each commit operation, in addition to the
** syncs associated with NORMAL.  There is no difference between FULL
** and EXTRA for WAL mode.
**
** Do not confuse synchronous=FULL with SQLITE_SYNC_FULL.  The
** SQLITE_SYNC_FULL macro means to use the MacOSX-style full-fsync
** using fcntl(F_FULLFSYNC).  SQLITE_SYNC_NORMAL means to do an
** ordinary fsync() call.  There is no difference between SQLITE_SYNC_FULL
** and SQLITE_SYNC_NORMAL on platforms other than MacOSX.  But the
** synchronous=FULL versus synchronous=NORMAL setting determines when
** the xSync primitive is called and is relevant to all platforms.
**
** Numeric values associated with these states are OFF==1, NORMAL=2,
** and FULL=3.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PAGER_PRAGMAS</name></cpp:ifndef>
<function><type><name>void</name></type> <name>sqlite3PagerSetFlags</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,        <comment type="block">/* The pager to set safety level for */</comment>
  <parameter><decl><type><name>unsigned</name></type> <name>pgFlags</name></decl></parameter>      <comment type="block">/* Various flags */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>level</name> <init>= <expr><name>pgFlags</name> <operator>&amp;</operator> <name>PAGER_SYNCHRONOUS_MASK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>noSync</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>fullSync</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>extraSync</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>noSync</name></name> <operator>=</operator>  <ternary><condition><expr><name>level</name><operator>==</operator><name>PAGER_SYNCHRONOUS_OFF</name></expr> ?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>fullSync</name></name> <operator>=</operator> <ternary><condition><expr><name>level</name><operator>&gt;=</operator><name>PAGER_SYNCHRONOUS_FULL</name></expr> ?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>extraSync</name></name> <operator>=</operator> <ternary><condition><expr><name>level</name><operator>==</operator><name>PAGER_SYNCHRONOUS_EXTRA</name></expr> ?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>noSync</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>syncFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pgFlags</name> <operator>&amp;</operator> <name>PAGER_FULLFSYNC</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>syncFlags</name></name> <operator>=</operator> <name>SQLITE_SYNC_FULL</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>syncFlags</name></name> <operator>=</operator> <name>SQLITE_SYNC_NORMAL</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>walSyncFlags</name></name> <operator>=</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>syncFlags</name></name><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>fullSync</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>walSyncFlags</name></name> <operator>|=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>syncFlags</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pgFlags</name> <operator>&amp;</operator> <name>PAGER_CKPT_FULLFSYNC</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>noSync</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>walSyncFlags</name></name> <operator>|=</operator> <operator>(</operator><name>SQLITE_SYNC_FULL</name><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pgFlags</name> <operator>&amp;</operator> <name>PAGER_CACHESPILL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SPILLFLAG_OFF</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name> <operator>|=</operator> <name>SPILLFLAG_OFF</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The following global variable is incremented whenever the library
** attempts to open a temporary file.  This information is used for
** testing and analysis only.  
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_opentemp_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Open a temporary file.
**
** Write the file descriptor into *pFile. Return SQLITE_OK on success 
** or some other error code if we fail. The OS will automatically 
** delete the temporary file when it is closed.
**
** The flags passed to the VFS layer xOpen() call are those specified
** by parameter vfsFlags ORed with the following:
**
**     SQLITE_OPEN_READWRITE
**     SQLITE_OPEN_CREATE
**     SQLITE_OPEN_EXCLUSIVE
**     SQLITE_OPEN_DELETEONCLOSE
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerOpentemp</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,        <comment type="block">/* The pager object */</comment>
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,  <comment type="block">/* Write the file descriptor here */</comment>
  <parameter><decl><type><name>int</name></type> <name>vfsFlags</name></decl></parameter>          <comment type="block">/* Flags passed through to the VFS */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>               <comment type="block">/* Return code */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <expr_stmt><expr><name>sqlite3_opentemp_count</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* Used for testing and analysis only */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>vfsFlags</name> <operator>|=</operator>  <name>SQLITE_OPEN_READWRITE</name> <operator>|</operator> <name>SQLITE_OPEN_CREATE</name> <operator>|</operator>
            <name>SQLITE_OPEN_EXCLUSIVE</name> <operator>|</operator> <name>SQLITE_OPEN_DELETEONCLOSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>vfsFlags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <call><name>isOpen</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the busy handler function.
**
** The pager invokes the busy-handler if sqlite3OsLock() returns 
** SQLITE_BUSY when trying to upgrade from no-lock to a SHARED lock,
** or when trying to upgrade from a RESERVED lock to an EXCLUSIVE 
** lock. It does *not* invoke the busy handler when upgrading from
** SHARED to RESERVED, or when upgrading from SHARED to EXCLUSIVE
** (which occurs during hot-journal rollback). Summary:
**
**   Transition                        | Invokes xBusyHandler
**   --------------------------------------------------------
**   NO_LOCK       -&gt; SHARED_LOCK      | Yes
**   SHARED_LOCK   -&gt; RESERVED_LOCK    | No
**   SHARED_LOCK   -&gt; EXCLUSIVE_LOCK   | No
**   RESERVED_LOCK -&gt; EXCLUSIVE_LOCK   | Yes
**
** If the busy-handler callback returns non-zero, the lock is 
** retried. If it returns zero, then the SQLITE_BUSY error is
** returned to the caller of the pager API function.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerSetBusyHandler</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,                       <comment type="block">/* Pager object */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xBusyHandler</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,         <comment type="block">/* Pointer to busy-handler function */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBusyHandlerArg</name></decl></parameter>                <comment type="block">/* Argument to pass to xBusyHandler */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>xBusyHandler</name></name> <operator>=</operator> <name>xBusyHandler</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pBusyHandlerArg</name></name> <operator>=</operator> <name>pBusyHandlerArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ap</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>xBusyHandler</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><call><call><name>int</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><operator>(</operator><name><name>ap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>)</operator><operator>==</operator><name>xBusyHandler</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>ap</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>pBusyHandlerArg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3OsFileControlHint</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_BUSYHANDLER</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Change the page size used by the Pager object. The new page size 
** is passed in *pPageSize.
**
** If the pager is in the error state when this function is called, it
** is a no-op. The value returned is the error state error code (i.e. 
** one of SQLITE_IOERR, an SQLITE_IOERR_xxx sub-code or SQLITE_FULL).
**
** Otherwise, if all of the following are true:
**
**   * the new page size (value of *pPageSize) is valid (a power 
**     of two between 512 and SQLITE_MAX_PAGE_SIZE, inclusive), and
**
**   * there are no outstanding page references, and
**
**   * the database is either not an in-memory database or it is
**     an in-memory database that currently consists of zero pages.
**
** then the pager object page size is set to *pPageSize.
**
** If the page size is changed, then this function uses sqlite3PagerMalloc() 
** to obtain a new Pager.pTmpSpace buffer. If this allocation attempt 
** fails, SQLITE_NOMEM is returned and the page size remains unchanged. 
** In all other cases, SQLITE_OK is returned.
**
** If the page size is not changed, either because one of the enumerated
** conditions above is not true, the pager was in error state when this
** function was called, or because the memory allocation attempt failed, 
** then *pPageSize is set to the old, retained page size before returning.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerSetPagesize</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pPageSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReserve</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* It is not possible to do a full assert_pager_state() here, as this
  ** function may be called from within PagerOpen(), before the state
  ** of the Pager object is internally consistent.
  **
  ** At one point this function returned an error if the pager was in 
  ** PAGER_ERROR state. But since PAGER_ERROR state guarantees that
  ** there is at least one outstanding page reference, this function
  ** is a no-op for that case anyhow.
  */</comment>

  <decl_stmt><decl><type><name>u32</name></type> <name>pageSize</name> <init>= <expr><operator>*</operator><name>pPageSize</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pageSize</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>pageSize</name><operator>&gt;=</operator><literal type="number">512</literal> <operator>&amp;&amp;</operator> <name>pageSize</name><operator>&lt;=</operator><name>SQLITE_MAX_PAGE_SIZE</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>memDb</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator>
   <operator>&amp;&amp;</operator> <call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> 
   <operator>&amp;&amp;</operator> <name>pageSize</name> <operator>&amp;&amp;</operator> <name>pageSize</name><operator>!=</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr> 
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* New temp space */</comment>
    <decl_stmt><decl><type><name>i64</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;</operator><name>PAGER_OPEN</name> <operator>&amp;&amp;</operator> <call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* 8 bytes of zeroed overrun space is sufficient so that the b-tree
      * cell header parser will never run off the end of the allocation */</comment>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3PageMalloc</name><argument_list>(<argument><expr><name>pageSize</name><operator>+</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pNew</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name><operator>+</operator><name>pageSize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>pager_reset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PcacheSetPageSize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>, <argument><expr><name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PageFree</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>=</operator> <operator>(</operator><name>Pgno</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nByte</name><operator>+</operator><name>pageSize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><name>pageSize</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>=</operator> <name>pageSize</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>lckPgno</name></name> <operator>=</operator> <operator>(</operator><name>Pgno</name><operator>)</operator><operator>(</operator><name>PENDING_BYTE</name><operator>/</operator><name>pageSize</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PageFree</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pPageSize</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nReserve</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nReserve</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>nReserve</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nReserve</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nReserve</name><operator>&lt;</operator><literal type="number">1000</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nReserve</name></name> <operator>=</operator> <operator>(</operator><name>i16</name><operator>)</operator><name>nReserve</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pagerReportSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pagerFixMaplimit</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the "temporary page" buffer held internally
** by the pager.  This is a buffer that is big enough to hold the
** entire content of a database page.  This buffer is used internally
** during rollback and will be overwritten whenever a rollback
** occurs.  But other modules are free to use it too, as long as
** no rollbacks are happening.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3PagerTempSpace</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to set the maximum database page count if mxPage is positive. 
** Make no changes if mxPage is zero or negative.  And never reduce the
** maximum page count below the current size of the database.
**
** Regardless of mxPage, return the current maximum page count.
*/</comment>
<function><type><name>Pgno</name></type> <name>sqlite3PagerMaxPageCount</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>mxPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>mxPage</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>mxPgno</name></name> <operator>=</operator> <name>mxPage</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_OPEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* Called only by OP_MaxPgcnt */</comment>
  <comment type="block">/* assert( pPager-&gt;mxPgno&gt;=pPager-&gt;dbSize ); */</comment>
  <comment type="block">/* OP_MaxPgcnt ensures that the parameter passed to this function is not
  ** less than the total number of valid pages in the database. But this
  ** may be less than Pager.dbSize, and so the assert() above is not valid */</comment>
  <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>mxPgno</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following set of routines are used to disable the simulated
** I/O error mechanism.  These routines are used to avoid simulated
** errors in places where we do not care about errors.
**
** Unless -DSQLITE_TEST=1 is used, these routines are all no-ops
** and generate no code.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>sqlite3_io_error_pending</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>sqlite3_io_error_hit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>saved_cnt</name></decl>;</decl_stmt>
<function><type><name>void</name></type> <name>disable_simulated_io_errors</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>saved_cnt</name> <operator>=</operator> <name>sqlite3_io_error_pending</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sqlite3_io_error_pending</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>enable_simulated_io_errors</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>sqlite3_io_error_pending</name> <operator>=</operator> <name>saved_cnt</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>disable_simulated_io_errors</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>enable_simulated_io_errors</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Read the first N bytes from the beginning of the file into memory
** that pDest points to. 
**
** If the pager was opened on a transient file (zFilename==""), or
** opened on a file less than N bytes in size, the output buffer is
** zeroed and SQLITE_OK returned. The rationale for this is that this 
** function is used to read database headers, and a new transient or
** zero sized database has a header than consists entirely of zeroes.
**
** If any IO error apart from SQLITE_IOERR_SHORT_READ is encountered,
** the error code is returned to the caller and the contents of the
** output buffer undefined.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerReadFileheader</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This routine is only called by btree immediately after creating
  ** the Pager object.  There has not been an opportunity to transition
  ** to WAL mode yet.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <macro><name>IOTRACE</name><argument_list>(<argument>(<literal type="string">"DBHDR %p 0 %d\n"</literal>, pPager, N)</argument>)</argument_list></macro>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_IOERR_SHORT_READ</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function may only be called when a read-transaction is open on
** the pager. It returns the total number of pages in the database.
**
** However, if the file is between 1 and &lt;page-size&gt; bytes in size, then 
** this is considered a 1 page file.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerPagecount</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_READER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_WRITER_FINISHED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnPage</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Try to obtain a lock of type locktype on the database file. If
** a similar or greater lock is already held, this function is a no-op
** (returning SQLITE_OK immediately).
**
** Otherwise, attempt to obtain the lock using sqlite3OsLock(). Invoke 
** the busy callback if the lock is currently not available. Repeat 
** until the busy callback returns false or until the attempt to 
** obtain the lock succeeds.
**
** Return SQLITE_OK on success and an error code if we cannot obtain
** the lock. If the lock is obtained successfully, set the Pager.state 
** variable to locktype before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_wait_on_lock</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>locktype</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                              <comment type="block">/* Return code */</comment>

  <comment type="block">/* Check that this is either a no-op (because the requested lock is 
  ** already held), or one of the transitions that the busy-handler
  ** may be invoked during, according to the comment above
  ** sqlite3PagerSetBusyhandler().
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>locktype</name><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>NO_LOCK</name> <operator>&amp;&amp;</operator> <name>locktype</name><operator>==</operator><name>SHARED_LOCK</name><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>RESERVED_LOCK</name> <operator>&amp;&amp;</operator> <name>locktype</name><operator>==</operator><name>EXCLUSIVE_LOCK</name><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <do>do <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerLockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name> <operator>&amp;&amp;</operator> <call><name><name>pPager</name><operator>-&gt;</operator><name>xBusyHandler</name></name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pBusyHandlerArg</name></name></expr></argument>)</argument_list></call></expr> )</condition>;</do>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Function assertTruncateConstraint(pPager) checks that one of the 
** following is true for all dirty pages currently in the page-cache:
**
**   a) The page number is less than or equal to the size of the 
**      current database image, in pages, OR
**
**   b) if the page content were written at this time, it would not
**      be necessary to write the current content out to the sub-journal.
**
** If the condition asserted by this function were not true, and the
** dirty page were to be discarded from the cache via the pagerStress()
** routine, pagerStress() would not write the current page content to
** the database file. If a savepoint transaction were rolled back after
** this happened, the correct behavior would be to restore the current
** content of the page. However, since this content is not present in either
** the database file or the portion of the rollback journal and 
** sub-journal rolled back the content could not be restored and the
** database image would become corrupt. It is therefore fortunate that 
** this circumstance cannot arise.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>assertTruncateConstraintCb</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_DIRTY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>&gt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr> )</condition><block>{<block_content>      <comment type="block">/* if (a) is false */</comment>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>PagerSavepoint</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOrig</name></name><operator>&lt;</operator><name>pgno</name> <operator>||</operator> <call><name>sqlite3BitvecTestNotNull</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pInSavepoint</name></name></expr></argument>,<argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>assertTruncateConstraint</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3PcacheIterateDirty</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>, <argument><expr><name>assertTruncateConstraintCb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>assertTruncateConstraint</name><parameter_list>(<parameter><type><name>pPager</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Truncate the in-memory database file image to nPage pages. This 
** function does not actually modify the database file on disk. It 
** just sets the internal state of the pager object so that the 
** truncation will be done when the current transaction is committed.
**
** This function is only called right before committing a transaction.
** Once this function has been called, the transaction must either be
** rolled back or committed. It is not safe to call this function and
** then continue writing to the database.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerTruncateImage</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>nPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>&gt;=</operator><name>nPage</name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_WRITER_CACHEMOD</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>=</operator> <name>nPage</name></expr>;</expr_stmt>

  <comment type="block">/* At one point the code here called assertTruncateConstraint() to
  ** ensure that all pages being truncated away by this operation are,
  ** if one or more savepoints are open, present in the savepoint 
  ** journal so that they can be restored if the savepoint is rolled
  ** back. This is no longer necessary as this function is now only
  ** called right before committing a transaction. So although the 
  ** Pager object may still have open savepoints (Pager.nSavepoint!=0), 
  ** they cannot be rolled back. So the assertTruncateConstraint() call
  ** is no longer correct. */</comment>
</block_content>}</block></function>


<comment type="block">/*
** This function is called before attempting a hot-journal rollback. It
** syncs the journal file to disk, then sets pPager-&gt;journalHdr to the
** size of the journal file so that the pager_playback() routine knows
** that the entire journal file has been synced.
**
** Syncing a hot-journal to disk before attempting to roll it back ensures 
** that if a power-failure occurs during the rollback, the process that
** attempts rollback following system recovery sees the same journal
** content as this process.
**
** If everything goes as planned, SQLITE_OK is returned. Otherwise, 
** an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerSyncHotJournal</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>noSync</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>SQLITE_SYNC_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Obtain a reference to a memory mapped page object for page number pgno. 
** The new object will use the pointer pData, obtained from xFetch().
** If successful, set *ppPage to point to the new page reference
** and return SQLITE_OK. Otherwise, return an SQLite error code and set
** *ppPage to zero.
**
** Page references obtained by calling this function should be released
** by calling pagerReleaseMapPage().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerAcquireMapPage</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,                  <comment type="block">/* Pager object */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>,                      <comment type="block">/* Page number */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,                    <comment type="block">/* xFetch()'d data for this page */</comment>
  <parameter><decl><type><name>PgHdr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>                  <comment type="block">/* OUT: Acquired page object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                       <comment type="block">/* Memory mapped page to return */</comment>
  
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pMmapFreelist</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <name>p</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pMmapFreelist</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pMmapFreelist</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>nExtra</name></name><operator>&gt;=</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pExtra</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <name>p</name> <operator>=</operator> <operator>(</operator><name>PgHdr</name> <operator>*</operator><operator>)</operator><call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgHdr</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>pPager</name><operator>-&gt;</operator><name>nExtra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OsUnfetch</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><name>pgno</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pExtra</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>PGHDR_MMAP</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPager</name></name> <operator>=</operator> <name>pPager</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pExtra</name></name><operator>==</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPage</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>PGHDR_MMAP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPager</name></name><operator>==</operator><name>pPager</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pgno</name></name> <operator>=</operator> <name>pgno</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nMmapOut</name></name><operator>++</operator></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Release a reference to page pPg. pPg must have been returned by an 
** earlier call to pagerAcquireMapPage().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pagerReleaseMapPage</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nMmapOut</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pMmapFreelist</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pMmapFreelist</name></name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&gt;=</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3OsUnfetch</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free all PgHdr objects stored in the Pager.pMmapFreelist list.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pagerFreeMapHdrs</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pPager</name><operator>-&gt;</operator><name>pMmapFreelist</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Verify that the database file has not be deleted or renamed out from
** under the pager.  Return SQLITE_OK if the database is still where it ought
** to be on disk.  Return non-zero (SQLITE_READONLY_DBMOVED or some other error
** code from sqlite3OsAccess()) if the database has gone missing.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>databaseIsUnmoved</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>bHasMoved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileControl</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_HAS_MOVED</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bHasMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOTFOUND</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If the HAS_MOVED file-control is unimplemented, assume that the file
    ** has not been moved.  That is the historical behavior of SQLite: prior to
    ** version 3.8.3, it never checked */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bHasMoved</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_READONLY_DBMOVED</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Shutdown the page cache.  Free all memory and close all files.
**
** If a transaction was in progress when this routine is called, that
** transaction is rolled back.  All outstanding pages are invalidated
** and their memory is freed.  Any attempt to use a page associated
** with this page cache after this function returns will likely
** result in a coredump.
**
** This function always succeeds. If a transaction is active an attempt
** is made to roll it back. If an error occurs during the rollback 
** a hot journal may be left in the filesystem but no error is returned
** to the caller.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerClose</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pTmp</name> <init>= <expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name> <operator>||</operator> <call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>disable_simulated_io_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pagerFreeMapHdrs</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* pPager-&gt;errCode = 0; */</comment>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>db</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_NoCkptOnClose</name><operator>)</operator> 
     <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><call><name>databaseIsUnmoved</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>a</name> <operator>=</operator> <name>pTmp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3WalClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>walSyncFlags</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>,<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>pager_reset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>MEMDB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>pager_unlock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* If it is open, sync the journal file before calling UnlockAndRollback.
    ** If this is not done, then an unsynced portion of the open journal 
    ** file may be played back into the database. If a power failure occurs 
    ** while this is happening, the database could become corrupt.
    **
    ** If an error occurs while trying to sync the journal, shift the pager
    ** into the ERROR state. This causes UnlockAndRollback to unlock the
    ** database and close the journal file without attempting to roll it
    ** back or finalize it. The next database user will have to do hot-journal
    ** rollback before accessing the database file.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>pager_error</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><call><name>pagerSyncHotJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pagerUnlockAndRollback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>enable_simulated_io_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"CLOSE %d\n"</literal><operator>,</operator> <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>IOTRACE</name><argument_list>(<argument>(<literal type="string">"CLOSE %p\n"</literal>, pPager)</argument>)</argument_list></macro>
  <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PageFree</name><argument_list>(<argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PcacheClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>xCodecFree</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>pPager</name><operator>-&gt;</operator><name>xCodecFree</name></name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pCodec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>sjfd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Return the page number for page pPg.
*/</comment>
<function><type><name>Pgno</name></type> <name>sqlite3PagerPagenumber</name><parameter_list>(<parameter><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Increment the reference count for page pPg.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerRef</name><parameter_list>(<parameter><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3PcacheRef</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Sync the journal. In other words, make sure all the pages that have
** been written to the journal have actually reached the surface of the
** disk and can be restored in the event of a hot-journal rollback.
**
** If the Pager.noSync flag is set, then this function is a no-op.
** Otherwise, the actions required depend on the journal-mode and the 
** device characteristics of the file-system, as follows:
**
**   * If the journal file is an in-memory journal file, no action need
**     be taken.
**
**   * Otherwise, if the device does not support the SAFE_APPEND property,
**     then the nRec field of the most recently written journal header
**     is updated to contain the number of journal records that have
**     been written following it. If the pager is operating in full-sync
**     mode, then the journal file is synced before this field is updated.
**
**   * If the device does not support the SEQUENTIAL property, then 
**     journal file is synced.
**
** Or, in pseudo-code:
**
**   if( NOT &lt;in-memory journal&gt; ){
**     if( NOT SAFE_APPEND ){
**       if( &lt;full-sync mode&gt; ) xSync(&lt;journal file&gt;);
**       &lt;update nRec field&gt;
**     } 
**     if( NOT SEQUENTIAL ) xSync(&lt;journal file&gt;);
**   }
**
** If successful, this routine clears the PGHDR_NEED_SYNC flag of every 
** page currently held in memory before returning SQLITE_OK. If an IO
** error is encountered, then the IO error code is returned to the caller.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>syncJournal</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newHdr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_CACHEMOD</name>
       <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_DBMOD</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerExclusiveLock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>noSync</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>!=</operator><name>PAGER_JOURNALMODE_MEMORY</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>iDc</name> <init>= <expr><call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name>iDc</name><operator>&amp;</operator><name>SQLITE_IOCAP_SAFE_APPEND</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <comment type="block">/* This block deals with an obscure problem. If the last connection
        ** that wrote to this database was operating in persistent-journal
        ** mode, then the journal file may at this point actually be larger
        ** than Pager.journalOff bytes. If the next thing in the journal
        ** file happens to be a journal-header (written as part of the
        ** previous connection's transaction), and a crash or power-failure 
        ** occurs after nRec is updated but before this connection writes 
        ** anything else to the journal file (or commits/rolls back its 
        ** transaction), then SQLite may become confused when doing the 
        ** hot-journal rollback following recovery. It may roll back all
        ** of this connections data, then proceed to rolling back the old,
        ** out-of-date data that follows it. Database corruption.
        **
        ** To work around this, if the journal file does appear to contain
        ** a valid header following Pager.journalOff, then write a 0x00
        ** byte to the start of it to prevent it from being recognized.
        **
        ** Variable iNextHdrOffset is set to the offset at which this
        ** problematic header will occur, if it exists. aMagic is used 
        ** as a temporary buffer to inspect the first couple of bytes of
        ** the potential journal header.
        */</comment>
        <decl_stmt><decl><type><name>i64</name></type> <name>iNextHdrOffset</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name></type> <name><name>aMagic</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name></type> <name><name>zHeader</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zHeader</name></expr></argument>, <argument><expr><name>aJournalMagic</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zHeader</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>nRec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>iNextHdrOffset</name> <operator>=</operator> <call><name>journalHdrOffset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>aMagic</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>iNextHdrOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>aMagic</name></expr></argument>, <argument><expr><name>aJournalMagic</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name>zerobyte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zerobyte</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iNextHdrOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_IOERR_SHORT_READ</name></expr> )</condition><block>{<block_content>
          <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Write the nRec value into the journal file header. If in
        ** full-synchronous mode, sync the journal first. This ensures that
        ** all data has really hit the disk before nRec is updated to mark
        ** it as a candidate for rollback.
        **
        ** This is not required if the persistent media supports the
        ** SAFE_APPEND property. Because in this case it is not possible 
        ** for garbage data to be appended to the file, the nRec field
        ** is populated with 0xFFFFFFFF when the journal header is written
        ** and never needs to be updated.
        */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>fullSync</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name>iDc</name><operator>&amp;</operator><name>SQLITE_IOCAP_SEQUENTIAL</name><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SYNC journal of %d\n"</literal><operator>,</operator> <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <macro><name>IOTRACE</name><argument_list>(<argument>(<literal type="string">"JSYNC %p\n"</literal>, pPager)</argument>)</argument_list></macro>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>syncFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>IOTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"JHDR %p %lld\n"</literal><operator>,</operator> <name>pPager</name><operator>,</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(
            <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>zHeader</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name>iDc</name><operator>&amp;</operator><name>SQLITE_IOCAP_SEQUENTIAL</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SYNC journal of %d\n"</literal><operator>,</operator> <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>IOTRACE</name><argument_list>(<argument>(<literal type="string">"JSYNC %p\n"</literal>, pPager)</argument>)</argument_list></macro>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>syncFlags</name></name><operator>|</operator> 
          <operator>(</operator><ternary><condition><expr><name><name>pPager</name><operator>-&gt;</operator><name>syncFlags</name></name><operator>==</operator><name>SQLITE_SYNC_FULL</name></expr>?</condition><then><expr><name>SQLITE_SYNC_DATAONLY</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>newHdr</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name>iDc</name><operator>&amp;</operator><name>SQLITE_IOCAP_SAFE_APPEND</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nRec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>writeJournalHdr</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Unless the pager is in noSync mode, the journal file was just 
  ** successfully synced. Either way, clear the PGHDR_NEED_SYNC flag on 
  ** all pages.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3PcacheClearSyncFlags</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_WRITER_DBMOD</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The argument is the first in a linked list of dirty pages connected
** by the PgHdr.pDirty pointer. This function writes each one of the
** in-memory pages in the list to the database file. The argument may
** be NULL, representing an empty list. In this case this function is
** a no-op.
**
** The pager must hold at least a RESERVED lock when this function
** is called. Before writing anything to the database file, this lock
** is upgraded to an EXCLUSIVE lock. If the lock cannot be obtained,
** SQLITE_BUSY is returned and no data is written to the database file.
** 
** If the pager is a temp-file pager and the actual file-system file
** is not yet open, it is created and opened before any data is 
** written out.
**
** Once the lock has been upgraded and, if necessary, the file opened,
** the pages are written out to the database file in list order. Writing
** a page is skipped if it meets either of the following criteria:
**
**   * The page number is greater than Pager.dbSize, or
**   * The PGHDR_DONT_WRITE flag is set on the page.
**
** If writing out a page causes the database file to grow, Pager.dbFileSize
** is updated accordingly. If page 1 is written out, then the value cached
** in Pager.dbFileVers[] is updated to match the new value stored in
** the database file.
**
** If everything is successful, SQLITE_OK is returned. If an IO error 
** occurs, an IO error code is returned. Or, if the EXCLUSIVE lock cannot
** be obtained, SQLITE_BUSY is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_write_pagelist</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Return code */</comment>

  <comment type="block">/* This function is only called for rollback pagers in WRITER_DBMOD state. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_DBMOD</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pList</name><operator>-&gt;</operator><name>pDirty</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the file is a temp-file has not yet been opened, open it now. It
  ** is not possible for rc to be other than SQLITE_OK if this branch
  ** is taken, as pager_wait_on_lock() is a no-op for temp-files.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerOpentemp</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>vfsFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Before the first write, give the VFS a hint of what the final
  ** file size will be.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> 
   <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbHintSize</name></name><operator>&lt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pList</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>||</operator> <name><name>pList</name><operator>-&gt;</operator><name>pgno</name></name><operator>&gt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbHintSize</name></name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>szFile</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>*</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3OsFileControlHint</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_SIZE_HINT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>szFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbHintSize</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pList</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>pgno</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If there are dirty pages in the page cache with page numbers greater
    ** than Pager.dbSize, this means sqlite3PagerTruncateImage() was called to
    ** make the file smaller (presumably by auto-vacuum code). Do not write
    ** any such pages to the file.
    **
    ** Also, do not write out any page that has the PGHDR_DONT_WRITE flag
    ** set (set by sqlite3PagerDontWrite()).
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>&lt;=</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>pList</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_DONT_WRITE</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>pgno</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Offset to write */</comment>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>                                   <comment type="block">/* Data to write */</comment>    

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pList</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pList</name><operator>-&gt;</operator><name>pgno</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pager_write_changecounter</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <comment type="block">/* Encode the database */</comment>
      <macro><name>CODEC2</name><argument_list>(<argument>pPager</argument>, <argument>pList-&gt;pData</argument>, <argument>pgno</argument>, <argument><literal type="number">6</literal></argument>, <argument>return SQLITE_NOMEM_BKPT</argument>, <argument>pData</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

      <comment type="block">/* Write out the page data. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If page 1 was just written, update Pager.dbFileVers to match
      ** the value now stored in the database file. If writing this 
      ** page caused the database file to grow, update dbFileSize. 
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbFileVers</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pData</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbFileVers</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>&gt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbFileSize</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbFileSize</name></name> <operator>=</operator> <name>pgno</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>aStat</name><index>[<expr><name>PAGER_STAT_WRITE</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* Update any backup objects copying the contents of this pager. */</comment>
      <expr_stmt><expr><call><name>sqlite3BackupUpdate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pBackup</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pList</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"STORE %d page %d hash(%08x)\n"</literal><operator>,</operator>
                   <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>,</operator> <name>pgno</name><operator>,</operator> <call><name>pager_pagehash</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>IOTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"PGOUT %p %d\n"</literal><operator>,</operator> <name>pPager</name><operator>,</operator> <name>pgno</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PAGER_INCR</name><argument_list>(<argument><expr><name>sqlite3_pager_writedb_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"NOSTORE %d page %d\n"</literal><operator>,</operator> <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>,</operator> <name>pgno</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>pager_set_pagehash</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>pDirty</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Ensure that the sub-journal file is open. If it is already open, this 
** function is a no-op.
**
** SQLITE_OK is returned if everything goes according to plan. An 
** SQLITE_IOERR_XXX error code is returned if a call to sqlite3OsOpen() 
** fails.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>openSubJournal</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>sjfd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name> <init>=  <expr><name>SQLITE_OPEN_SUBJOURNAL</name> <operator>|</operator> <name>SQLITE_OPEN_READWRITE</name> 
      <operator>|</operator> <name>SQLITE_OPEN_CREATE</name> <operator>|</operator> <name>SQLITE_OPEN_EXCLUSIVE</name> 
      <operator>|</operator> <name>SQLITE_OPEN_DELETEONCLOSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nStmtSpill</name> <init>= <expr><name><name>sqlite3Config</name><operator>.</operator><name>nStmtSpill</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_MEMORY</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>subjInMemory</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nStmtSpill</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3JournalOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>sjfd</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>nStmtSpill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append a record of the current state of page pPg to the sub-journal. 
**
** If successful, set the bit corresponding to pPg-&gt;pgno in the bitvecs
** for all open savepoints before returning.
**
** This function returns SQLITE_OK if everything is successful, an IO
** error code if the attempt to write to the sub-journal fails, or 
** SQLITE_NOMEM if a malloc fails while setting a bit in a savepoint
** bitvec.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>subjournalPage</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>!=</operator><name>PAGER_JOURNALMODE_OFF</name></expr> )</condition><block>{<block_content>

    <comment type="block">/* Open the sub-journal, if it has not already been opened */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>useJournal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>sjfd</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>nSubRec</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> 
         <operator>||</operator> <call><name>pageInJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call> 
         <operator>||</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>&gt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name></expr></argument> 
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>openSubJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the sub-journal was opened successfully (or was already open),
    ** write the journal record into the file.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>i64</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>nSubRec</name></name><operator>*</operator><operator>(</operator><literal type="number">4</literal><operator>+</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pData2</name></decl>;</decl_stmt>

<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_HAS_CODEC</name></expr></cpp:if>   
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>subjInMemory</name></name></expr> )</condition><block>{<block_content>
        <macro><name>CODEC2</name><argument_list>(<argument>pPager</argument>, <argument>pData</argument>, <argument>pPg-&gt;pgno</argument>, <argument><literal type="number">7</literal></argument>, <argument>return SQLITE_NOMEM_BKPT</argument>, <argument>pData2</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
      </block_content>}</block></if><else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>
      <expr_stmt><expr><name>pData2</name> <operator>=</operator> <name>pData</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"STMT-JOURNAL %d page %d\n"</literal><operator>,</operator> <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>,</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>write32bits</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>sjfd</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>sjfd</name></name></expr></argument>, <argument><expr><name>pData2</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><name>offset</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nSubRec</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>addToSavepointBitvecs</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>subjournalPageIfRequired</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>subjRequiresPage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>subjournalPage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called by the pcache layer when it has reached some
** soft memory limit. The first argument is a pointer to a Pager object
** (cast as a void*). The pager is always 'purgeable' (not an in-memory
** database). The second argument is a reference to a page that is 
** currently dirty but has no outstanding references. The page
** is always associated with the Pager object passed as the first 
** argument.
**
** The job of this function is to make pPg clean by writing its contents
** out to the database file, if possible. This may involve syncing the
** journal file. 
**
** If successful, sqlite3PcacheMakeClean() is called on the page and
** SQLITE_OK returned. If an IO error occurs while trying to make the
** page clean, the IO error code is returned. If the page cannot be
** made clean for some other reason, but no error occurs, then SQLITE_OK
** is returned by sqlite3PcacheMakeClean() is not called.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerStress</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><operator>(</operator><name>Pager</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name><operator>==</operator><name>pPager</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_DIRTY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The doNotSpill NOSYNC bit is set during times when doing a sync of
  ** journal (and adding a new header) is not allowed.  This occurs
  ** during calls to sqlite3PagerWrite() while trying to journal multiple
  ** pages belonging to the same sector.
  **
  ** The doNotSpill ROLLBACK and OFF bits inhibits all cache spilling
  ** regardless of whether or not a sync is required.  This is set during
  ** a rollback or by user request, respectively.
  **
  ** Spilling is also prohibited when in an error state since that could
  ** lead to database corruption.   In the current implementation it 
  ** is impossible for sqlite3PcacheFetch() to be called with createFlag==3
  ** while in the error state, hence it is impossible for this routine to
  ** be called in the error state.  Nevertheless, we include a NEVER()
  ** test for the error state as a safeguard against future changes.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name> <operator>&amp;</operator> <name>SPILLFLAG_ROLLBACK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name> <operator>&amp;</operator> <name>SPILLFLAG_OFF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name> <operator>&amp;</operator> <name>SPILLFLAG_NOSYNC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name>
   <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name> <operator>&amp;</operator> <operator>(</operator><name>SPILLFLAG_ROLLBACK</name><operator>|</operator><name>SPILLFLAG_OFF</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
      <operator>||</operator> <operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_NEED_SYNC</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>aStat</name><index>[<expr><name>PAGER_STAT_SPILL</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Write a single frame for this page to the log. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>subjournalPageIfRequired</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerWalFrames</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_BATCH_ATOMIC_WRITE</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3JournalCreate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>pager_error</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
    <comment type="block">/* Sync the journal file if required. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name> 
     <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_CACHEMOD</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>syncJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* Write the contents of the page out to the database file. */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_write_pagelist</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Mark the page as clean. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"STRESS %d page %d\n"</literal><operator>,</operator> <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>,</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PcacheMakeClean</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name>pager_error</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return> 
</block_content>}</block></function>

<comment type="block">/*
** Flush all unreferenced dirty pages to disk.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerFlush</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>MEMDB</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><call><name>sqlite3PcacheDirtyList</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pList</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>pDirty</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pList</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerStress</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pPager</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pList</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and initialize a new Pager object and put a pointer to it
** in *ppPager. The pager should eventually be freed by passing it
** to sqlite3PagerClose().
**
** The zFilename argument is the path to the database file to open.
** If zFilename is NULL then a randomly-named temporary file is created
** and used as the file to be cached. Temporary files are be deleted
** automatically when they are closed. If zFilename is ":memory:" then 
** all information is held in cache. It is never written to disk. 
** This can be used to implement an in-memory database.
**
** The nExtra parameter specifies the number of bytes of space allocated
** along with each page reference. This space is available to the user
** via the sqlite3PagerGetExtra() API.  When a new page is allocated, the
** first 8 bytes of this space are zeroed but the remainder is uninitialized.
** (The extra space is used by btree as the MemPage object.)
**
** The flags argument is used to specify properties that affect the
** operation of the pager. It should be passed some bitwise combination
** of the PAGER_* flags.
**
** The vfsFlags parameter is a bitmask to pass to the flags parameter
** of the xOpen() method of the supplied VFS when opening files. 
**
** If the pager object is allocated and the specified file opened 
** successfully, SQLITE_OK is returned and *ppPager set to point to
** the new pager object. If an error occurs, *ppPager is set to NULL
** and error code returned. This function may return SQLITE_NOMEM
** (sqlite3Malloc() is used to allocate memory), SQLITE_CANTOPEN or 
** various SQLITE_IO_XXX errors.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerOpen</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,       <comment type="block">/* The virtual file system to use */</comment>
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPager</name></decl></parameter>,         <comment type="block">/* OUT: Return the Pager structure here */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,   <comment type="block">/* Name of the database file to open */</comment>
  <parameter><decl><type><name>int</name></type> <name>nExtra</name></decl></parameter>,              <comment type="block">/* Extra bytes append to each in-memory page */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,               <comment type="block">/* flags controlling this file */</comment>
  <parameter><decl><type><name>int</name></type> <name>vfsFlags</name></decl></parameter>,            <comment type="block">/* flags passed through to sqlite3_vfs.xOpen() */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xReinit</name>)<parameter_list>(<parameter><decl><type><name>DbPage</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter> <comment type="block">/* Function to reinitialize pages */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pPtr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Pager object to allocate and return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>tempFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* True for temp files (incl. in-memory files) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>memDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* True if this is an in-memory file */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DESERIALIZE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>memJM</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Memory journal mode */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>memJM</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>readOnly</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* True if this is a read-only file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>journalFileSize</name></decl>;</decl_stmt>     <comment type="block">/* Bytes to allocate for each journal fd */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zPathname</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Full path to database file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPathname</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Number of bytes in zPathname */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>useJournal</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PAGER_OMIT_JOURNAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* False to omit journal */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pcacheSize</name> <init>= <expr><call><name>sqlite3PcacheSize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>       <comment type="block">/* Bytes to allocate for PCache */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>szPageDflt</name> <init>= <expr><name>SQLITE_DEFAULT_PAGE_SIZE</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Default page size */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUri</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* URI args to copy */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nUriByte</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Number of bytes of URI args at *zUri */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nUri</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Number of URI parameters */</comment>

  <comment type="block">/* Figure out how much space is required for each journal file-handle
  ** (there are two of them, the main journal and the sub-journal).  */</comment>
  <expr_stmt><expr><name>journalFileSize</name> <operator>=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><call><name>sqlite3JournalSize</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the output variable to NULL in case an error occurs. */</comment>
  <expr_stmt><expr><operator>*</operator><name>ppPager</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_MEMORYDB</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>PAGER_MEMORY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>memDb</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zFilename</name> <operator>&amp;&amp;</operator> <name><name>zFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zPathname</name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zPathname</name><operator>==</operator><literal type="number">0</literal></expr>  )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>nPathname</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Compute and store the full pathname in an allocated buffer pointed
  ** to by zPathname, length nPathname. Or, if this is a temporary file,
  ** leave both nPathname and zPathname set to 0.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>zFilename</name> <operator>&amp;&amp;</operator> <name><name>zFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nPathname</name> <operator>=</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zPathname</name> <operator>=</operator> <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nPathname</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zPathname</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>zPathname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Make sure initialized even if FullPathname() fails */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFullPathname</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>nPathname</name></expr></argument>, <argument><expr><name>zPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK_SYMLINK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>vfsFlags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_NOFOLLOW</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN_SYMLINK</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nPathname</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name>zUri</name> <operator>=</operator> <operator>&amp;</operator><name><name>zFilename</name><index>[<expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nUri</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>nUriByte</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name>zUri</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nUriByte</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nPathname</name><operator>+</operator><literal type="number">8</literal><operator>&gt;</operator><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* This branch is taken when the journal path required by
      ** the database being opened will be more than pVfs-&gt;mxPathname
      ** bytes in length. This means the database cannot be opened,
      ** as it will not be possible to open the journal file or even
      ** check for a hot-journal before reading.
      */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Allocate memory for the Pager structure, PCache object, the
  ** three file descriptors, the database file name and the journal 
  ** file name. The layout in memory is as follows:
  **
  **     Pager object                    (sizeof(Pager) bytes)
  **     PCache object                   (sqlite3PcacheSize() bytes)
  **     Database file handle            (pVfs-&gt;szOsFile bytes)
  **     Sub-journal file handle         (journalFileSize bytes)
  **     Main journal file handle        (journalFileSize bytes)
  **     Ptr back to the Pager           (sizeof(Pager*) bytes)
  **     \0\0\0\0 database prefix        (4 bytes)
  **     Database file name              (nPathname+1 bytes)
  **     URI query parameters            (nUriByte bytes)
  **     Journal filename                (nPathname+8+1 bytes)
  **     WAL filename                    (nPathname+4+1 bytes)
  **     \0\0\0 terminator               (3 bytes)
  **
  ** Some 3rd-party software, over which we have no control, depends on
  ** the specific order of the filenames and the \0 separators between them
  ** so that it can (for example) find the database filename given the WAL
  ** filename without using the sqlite3_filename_database() API.  This is a
  ** misuse of SQLite and a bug in the 3rd-party software, but the 3rd-party
  ** software is in widespread use, so we try to avoid changing the filename
  ** order and formatting if possible.  In particular, the details of the
  ** filename format expected by 3rd-party software should be as follows:
  **
  **   - Main Database Path
  **   - \0
  **   - Multiple URI components consisting of:
  **     - Key
  **     - \0
  **     - Value
  **     - \0
  **   - \0
  **   - Journal Path
  **   - \0
  **   - WAL Path (zWALName)
  **   - \0
  **
  ** The sqlite3_create_filename() interface and the databaseFilename() utility
  ** that is used by sqlite3_filename_database() and kin also depend on the
  ** specific formatting and order of the various filenames, so if the format
  ** changes here, be sure to change it there as well.
  */</comment>
  <expr_stmt><expr><name>pPtr</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>sqlite3MallocZero</name><argument_list>(
    <argument><expr><call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pPager</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>            <comment type="block">/* Pager structure */</comment>
    <call><name>ROUND8</name><argument_list>(<argument><expr><name>pcacheSize</name></expr></argument>)</argument_list></call> <operator>+</operator>                 <comment type="block">/* PCache object */</comment>
    <call><name>ROUND8</name><argument_list>(<argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr></argument>)</argument_list></call> <operator>+</operator>             <comment type="block">/* The main db file */</comment>
    <name>journalFileSize</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator>                <comment type="block">/* The two journal files */</comment>
    <sizeof>sizeof<argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>                     <comment type="block">/* Space to hold a pointer */</comment>
    <literal type="number">4</literal> <operator>+</operator>                                  <comment type="block">/* Database prefix */</comment>
    <name>nPathname</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>                      <comment type="block">/* database filename */</comment>
    <name>nUriByte</name> <operator>+</operator>                           <comment type="block">/* query parameters */</comment>
    <name>nPathname</name> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>                  <comment type="block">/* Journal filename */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
    <name>nPathname</name> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>                  <comment type="block">/* WAL filename */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <literal type="number">3</literal></expr></argument>                                    <comment type="block">/* Terminator */</comment>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><call><name>SQLITE_INT_TO_PTR</name><argument_list>(<argument><expr><name>journalFileSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pPtr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pPager</name> <operator>=</operator> <operator>(</operator><name>Pager</name><operator>*</operator><operator>)</operator><name>pPtr</name></expr>;</expr_stmt>                  <expr_stmt><expr><name>pPtr</name> <operator>+=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pPager</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name> <operator>=</operator> <operator>(</operator><name>PCache</name><operator>*</operator><operator>)</operator><name>pPtr</name></expr>;</expr_stmt>        <expr_stmt><expr><name>pPtr</name> <operator>+=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><name>pcacheSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>pPtr</name></expr>;</expr_stmt>       <expr_stmt><expr><name>pPtr</name> <operator>+=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>sjfd</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>pPtr</name></expr>;</expr_stmt>     <expr_stmt><expr><name>pPtr</name> <operator>+=</operator> <name>journalFileSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name> <operator>=</operator>  <operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>pPtr</name></expr>;</expr_stmt>     <expr_stmt><expr><name>pPtr</name> <operator>+=</operator> <name>journalFileSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPager</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <expr_stmt><expr><name>pPtr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

  <comment type="block">/* Fill in the Pager.zFilename and pPager.zQueryParam fields */</comment>
                                          <expr_stmt><expr><name>pPtr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>  <comment type="block">/* Skip zero prefix */</comment>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pPtr</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPathname</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>zPathname</name></expr></argument>, <argument><expr><name>nPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><name>pPtr</name> <operator>+=</operator> <name>nPathname</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zUri</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>zUri</name></expr></argument>, <argument><expr><name>nUriByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <expr_stmt><expr><name>pPtr</name> <operator>+=</operator> <name>nUriByte</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
                                          <expr_stmt><expr><name>pPtr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>


  <comment type="block">/* Fill in Pager.zJournal */</comment>
  <if_stmt><if>if<condition>( <expr><name>nPathname</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>zPathname</name></expr></argument>, <argument><expr><name>nPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><name>pPtr</name> <operator>+=</operator> <name>nPathname</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><literal type="string">"-journal"</literal></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>           <expr_stmt><expr><name>pPtr</name> <operator>+=</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_8_3_NAMES</name></cpp:ifdef>
    <expr_stmt><expr><call><name>sqlite3FileSuffix3</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>,<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPtr</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name> <operator>+</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <comment type="block">/* Fill in Pager.zWal */</comment>
  <if_stmt><if>if<condition>( <expr><name>nPathname</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>zWal</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><name>zPathname</name></expr></argument>, <argument><expr><name>nPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><name>pPtr</name> <operator>+=</operator> <name>nPathname</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPtr</name></expr></argument>, <argument><expr><literal type="string">"-wal"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>              <expr_stmt><expr><name>pPtr</name> <operator>+=</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_8_3_NAMES</name></cpp:ifdef>
    <expr_stmt><expr><call><name>sqlite3FileSuffix3</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zWal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPtr</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>zWal</name></name> <operator>+</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zWal</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>zWal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pPtr</name></expr>;</expr_stmt>  <comment type="block">/* Suppress warning about unused pPtr value */</comment>

  <if_stmt><if>if<condition>( <expr><name>nPathname</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name> <operator>=</operator> <name>pVfs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>vfsFlags</name></name> <operator>=</operator> <name>vfsFlags</name></expr>;</expr_stmt>

  <comment type="block">/* Open the pager file.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>zFilename</name> <operator>&amp;&amp;</operator> <name><name>zFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>fout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                    <comment type="block">/* VFS flags returned by xOpen() */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>vfsFlags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>memDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DESERIALIZE</name></cpp:ifndef>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>memVfs</name></name> <operator>=</operator> <name>memJM</name> <operator>=</operator> <operator>(</operator><name>fout</name><operator>&amp;</operator><name>SQLITE_OPEN_MEMORY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>readOnly</name> <operator>=</operator> <operator>(</operator><name>fout</name><operator>&amp;</operator><name>SQLITE_OPEN_READONLY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* If the file was successfully opened for read/write access,
    ** choose a default page size in case we have to create the
    ** database file. The default page size is the maximum of:
    **
    **    + SQLITE_DEFAULT_PAGE_SIZE,
    **    + The value returned by sqlite3OsSectorSize()
    **    + The largest page size that can be written atomically.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iDc</name> <init>= <expr><call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>readOnly</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>setSectorSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SQLITE_DEFAULT_PAGE_SIZE</name><operator>&lt;=</operator><name>SQLITE_MAX_DEFAULT_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>szPageDflt</name><operator>&lt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>sectorSize</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>sectorSize</name></name><operator>&gt;</operator><name>SQLITE_MAX_DEFAULT_PAGE_SIZE</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>szPageDflt</name> <operator>=</operator> <name>SQLITE_MAX_DEFAULT_PAGE_SIZE</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>szPageDflt</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>sectorSize</name></name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ATOMIC_WRITE</name></cpp:ifdef>
        <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC512</name><operator>==</operator><operator>(</operator><literal type="number">512</literal><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC64K</name><operator>==</operator><operator>(</operator><literal type="number">65536</literal><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SQLITE_MAX_DEFAULT_PAGE_SIZE</name><operator>&lt;=</operator><literal type="number">65536</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>ii</name><operator>=</operator><name>szPageDflt</name></expr>;</init> <condition><expr><name>ii</name><operator>&lt;=</operator><name>SQLITE_MAX_DEFAULT_PAGE_SIZE</name></expr>;</condition> <incr><expr><name>ii</name><operator>=</operator><name>ii</name><operator>*</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>iDc</name><operator>&amp;</operator><operator>(</operator><name>SQLITE_IOCAP_ATOMIC</name><operator>|</operator><operator>(</operator><name>ii</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>szPageDflt</name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>noLock</name></name> <operator>=</operator> <call><name>sqlite3_uri_boolean</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><literal type="string">"nolock"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iDc</name> <operator>&amp;</operator> <name>SQLITE_IOCAP_IMMUTABLE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
       <operator>||</operator> <call><name>sqlite3_uri_boolean</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><literal type="string">"immutable"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>vfsFlags</name> <operator>|=</operator> <name>SQLITE_OPEN_READONLY</name></expr>;</expr_stmt>
          <goto>goto <name>act_like_temp_file</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* If a temporary file is requested, it is not opened immediately.
    ** In this case we accept the default page size and delay actually
    ** opening the file until the first call to OsWrite().
    **
    ** This branch is also run for an in-memory database. An in-memory
    ** database is the same as a temp-file that is never written out to
    ** disk and uses an in-memory rollback journal.
    **
    ** This branch also runs for files marked as immutable.
    */</comment> 
<label><name>act_like_temp_file</name>:</label>
    <expr_stmt><expr><name>tempFile</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_READER</name></expr>;</expr_stmt>     <comment type="block">/* Pretend we already have a lock */</comment>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name> <operator>=</operator> <name>EXCLUSIVE_LOCK</name></expr>;</expr_stmt>    <comment type="block">/* Pretend we are in EXCLUSIVE mode */</comment>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>noLock</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>                <comment type="block">/* Do no locking */</comment>
    <expr_stmt><expr><name>readOnly</name> <operator>=</operator> <operator>(</operator><name>vfsFlags</name><operator>&amp;</operator><name>SQLITE_OPEN_READONLY</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* The following call to PagerSetPagesize() serves to set the value of 
  ** Pager.pageSize and to allocate the Pager.pTmpSpace buffer.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>memDb</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSetPagesize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>szPageDflt</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Initialize the PCache object. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nExtra</name> <operator>=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><name>nExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nExtra</name><operator>&gt;=</operator><literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>nExtra</name><operator>&lt;</operator><literal type="number">1000</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PcacheOpen</name><argument_list>(<argument><expr><name>szPageDflt</name></expr></argument>, <argument><expr><name>nExtra</name></expr></argument>, <argument><expr><operator>!</operator><name>memDb</name></expr></argument>,
                       <argument><expr><ternary><condition><expr><operator>!</operator><name>memDb</name></expr>?</condition><then><expr><name>pagerStress</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pPager</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If an error occurred above, free the  Pager structure and close the file.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PageFree</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"OPEN %d %s\n"</literal><operator>,</operator> <call><name>FILEHANDLEID</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call><operator>,</operator> <name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>IOTRACE</name><argument_list>(<argument>(<literal type="string">"OPEN %p %s\n"</literal>, pPager, pPager-&gt;zFilename)</argument>)</argument_list></macro>

  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>useJournal</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>useJournal</name></expr>;</expr_stmt>
  <comment type="block">/* pPager-&gt;stmtOpen = 0; */</comment>
  <comment type="block">/* pPager-&gt;stmtInUse = 0; */</comment>
  <comment type="block">/* pPager-&gt;nRef = 0; */</comment>
  <comment type="block">/* pPager-&gt;stmtSize = 0; */</comment>
  <comment type="block">/* pPager-&gt;stmtJSize = 0; */</comment>
  <comment type="block">/* pPager-&gt;nPage = 0; */</comment>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>mxPgno</name></name> <operator>=</operator> <name>SQLITE_MAX_PAGE_COUNT</name></expr>;</expr_stmt>
  <comment type="block">/* pPager-&gt;state = PAGER_UNLOCK; */</comment>
  <comment type="block">/* pPager-&gt;errMask = 0; */</comment>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>tempFile</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>tempFile</name><operator>==</operator><name>PAGER_LOCKINGMODE_NORMAL</name> 
          <operator>||</operator> <name>tempFile</name><operator>==</operator><name>PAGER_LOCKINGMODE_EXCLUSIVE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PAGER_LOCKINGMODE_EXCLUSIVE</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>tempFile</name></expr>;</expr_stmt> 
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>changeCountDone</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>memDb</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>memDb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>readOnly</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>useJournal</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>noSync</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>noSync</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fullSync</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>extraSync</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>syncFlags</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>walSyncFlags</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>fullSync</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>extraSync</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>syncFlags</name></name> <operator>=</operator> <name>SQLITE_SYNC_NORMAL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>walSyncFlags</name></name> <operator>=</operator> <name>SQLITE_SYNC_NORMAL</name> <operator>|</operator> <operator>(</operator><name>SQLITE_SYNC_NORMAL</name><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* pPager-&gt;pFirst = 0; */</comment>
  <comment type="block">/* pPager-&gt;pFirstSynced = 0; */</comment>
  <comment type="block">/* pPager-&gt;pLast = 0; */</comment>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nExtra</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nExtra</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalSizeLimit</name></name> <operator>=</operator> <name>SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>tempFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setSectorSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>useJournal</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name> <operator>=</operator> <name>PAGER_JOURNALMODE_OFF</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>memDb</name> <operator>||</operator> <name>memJM</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name> <operator>=</operator> <name>PAGER_JOURNALMODE_MEMORY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* pPager-&gt;xBusyHandler = 0; */</comment>
  <comment type="block">/* pPager-&gt;pBusyHandlerArg = 0; */</comment>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>xReiniter</name></name> <operator>=</operator> <name>xReinit</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setGetterMethod</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* memset(pPager-&gt;aHash, 0, sizeof(pPager-&gt;aHash)); */</comment>
  <comment type="block">/* pPager-&gt;szMmap = SQLITE_DEFAULT_MMAP_SIZE // will be set by btree.c */</comment>

  <expr_stmt><expr><operator>*</operator><name>ppPager</name> <operator>=</operator> <name>pPager</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the sqlite3_file for the main database given the name
** of the corresonding WAL or Journal name as passed into
** xOpen.
*/</comment>
<function><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>sqlite3_database_file_object</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name><name>zName</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zName</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zName</name><index>[<expr><operator>-</operator><literal type="number">3</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zName</name><index>[<expr><operator>-</operator><literal type="number">4</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zName</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>pPager</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>Pager</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name>zName</name> <operator>-</operator> <literal type="number">4</literal> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Pager</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is called after transitioning from PAGER_UNLOCK to
** PAGER_SHARED state. It tests if there is a hot journal present in
** the file-system for the given pager. A hot journal is one that 
** needs to be played back. According to this function, a hot-journal
** file exists if the following criteria are met:
**
**   * The journal file exists in the file system, and
**   * No process holds a RESERVED or greater lock on the database file, and
**   * The database file itself is greater than 0 bytes in size, and
**   * The first byte of the journal file exists and is not 0x00.
**
** If the current size of the database file is 0 but a journal file
** exists, that is probably an old journal left over from a prior
** database with the same name. In this case the journal file is
** just deleted using OsDelete, *pExists is set to 0 and SQLITE_OK
** is returned.
**
** This routine does not check if there is a super-journal filename
** at the end of the file. If there is, and that super-journal file
** does not exist, then the journal file is not really hot. In this
** case this routine will return a false-positive. The pager_playback()
** routine will discover that the journal file is not really hot and 
** will not roll it back. 
**
** If a hot-journal file is found to exist, *pExists is set to 1 and 
** SQLITE_OK returned. If no hot-journal file is present, *pExists is
** set to 0 and SQLITE_OK returned. If an IO error occurs while trying
** to determine whether or not a hot-journal file exists, the IO error
** code is returned and the value of *pExists is undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hasHotJournal</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pExists</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pVfs</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>           <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>exists</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* True if a journal file is present */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>jrnlOpen</name> <init>= <expr><operator>!</operator><operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>useJournal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>jrnlOpen</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator> <call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator>
    <name>SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN</name>
  <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>pExists</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>jrnlOpen</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsAccess</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>exists</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>locked</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* True if some process holds a RESERVED lock */</comment>

    <comment type="block">/* Race condition here:  Another process might have been holding the
    ** the RESERVED lock and have a journal open at the sqlite3OsAccess() 
    ** call above, but then delete the journal and drop the lock before
    ** we get to the following sqlite3OsCheckReservedLock() call.  If that
    ** is the case, this routine might think there is a hot journal when
    ** in fact there is none.  This results in a false-positive which will
    ** be dealt with by the playback routine.  Ticket #3883.
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsCheckReservedLock</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>locked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>locked</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>nPage</name></decl>;</decl_stmt>                 <comment type="block">/* Number of pages in database file */</comment>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerPagecount</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* If the database is zero pages in size, that means that either (1) the
        ** journal is a remnant from a prior database with the same name where
        ** the database file but not the journal was deleted, or (2) the initial
        ** transaction that populates a new database is being rolled back.
        ** In either case, the journal file can be deleted.  However, take care
        ** not to delete the journal file if it is already open due to
        ** journal_mode=PERSIST.
        */</comment>
        <if_stmt><if>if<condition>( <expr><name>nPage</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>jrnlOpen</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>pagerLockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>RESERVED_LOCK</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pagerUnlockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* The journal file exists and no other connection has a reserved
          ** or greater lock on the database file. Now check that there is
          ** at least one non-zero bytes at the start of the journal file.
          ** If there is, then we consider this journal to be hot. If not, 
          ** it can be ignored.
          */</comment>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name>jrnlOpen</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>SQLITE_OPEN_READONLY</name><operator>|</operator><name>SQLITE_OPEN_MAIN_JOURNAL</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>u8</name></type> <name>first</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>first</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_IOERR_SHORT_READ</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><operator>!</operator><name>jrnlOpen</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><name>pExists</name> <operator>=</operator> <operator>(</operator><name>first</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_CANTOPEN</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* If we cannot open the rollback journal file in order to see if
            ** it has a zero header, that might be due to an I/O error, or
            ** it might be due to the race condition described above and in
            ** ticket #3883.  Either way, assume that the journal is hot.
            ** This might be a false positive.  But if it is, then the
            ** automatic journal playback and recovery mechanism will deal
            ** with it under an EXCLUSIVE lock where we do not need to
            ** worry so much with race conditions.
            */</comment>
            <expr_stmt><expr><operator>*</operator><name>pExists</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to obtain a shared lock on the database file.
** It is illegal to call sqlite3PagerGet() until after this function
** has been successfully called. If a shared-lock is already held when
** this function is called, it is a no-op.
**
** The following operations are also performed by this function.
**
**   1) If the pager is currently in PAGER_OPEN state (no lock held
**      on the database file), then an attempt is made to obtain a
**      SHARED lock on the database file. Immediately after obtaining
**      the SHARED lock, the file-system is checked for a hot-journal,
**      which is played back if present. Following any hot-journal 
**      rollback, the contents of the cache are validated by checking
**      the 'change-counter' field of the database file header and
**      discarded if they are found to be invalid.
**
**   2) If the pager is running in exclusive-mode, and there are currently
**      no outstanding references to any pages, and is in the error state,
**      then an attempt is made to clear the error state by discarding
**      the contents of the page cache and rolling back any open journal
**      file.
**
** If everything is successful, SQLITE_OK is returned. If an IO error 
** occurs while locking the database, checking for a hot-journal file or 
** rolling back a journal file, the IO error code is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerSharedLock</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>

  <comment type="block">/* This routine is only called from b-tree and only when there are no
  ** outstanding pages. This implies that the pager state should either
  ** be OPEN or READER. READER is only possible if the pager is or was in 
  ** exclusive access mode.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_READER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bHotJournal</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* True if there exists a hot journal-file */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_wait_on_lock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>NO_LOCK</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>UNKNOWN_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>failed</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If a journal file exists, and there is no RESERVED lock on the
    ** database file, then it either needs to be played back or deleted.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>&lt;=</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>hasHotJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bHotJournal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>failed</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>bHotJournal</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>readOnly</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_READONLY_ROLLBACK</name></expr>;</expr_stmt>
        <goto>goto <name>failed</name>;</goto>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Get an EXCLUSIVE lock on the database file. At this point it is
      ** important that a RESERVED lock is not obtained on the way to the
      ** EXCLUSIVE lock. If it were, another process might open the
      ** database file, detect the RESERVED lock, and conclude that the
      ** database is safe to read while this process is still rolling the 
      ** hot-journal back.
      ** 
      ** Because the intermediate RESERVED lock is not requested, any
      ** other process attempting to access the database file will get to 
      ** this point in the code and fail to obtain its own EXCLUSIVE lock 
      ** on the database file.
      **
      ** Unless the pager is in locking_mode=exclusive mode, the lock is
      ** downgraded to SHARED_LOCK before this function returns.
      */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerLockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>failed</name>;</goto>
      </block_content>}</block></if></if_stmt>
 
      <comment type="block">/* If it is not already open and the file exists on disk, open the 
      ** journal for read/write access. Write access is required because 
      ** in exclusive-access mode the file descriptor will be kept open 
      ** and possibly used for a transaction later on. Also, write-access 
      ** is usually required to finalize the journal in journal_mode=persist 
      ** mode (and also for journal_mode=truncate on some systems).
      **
      ** If the journal does not exist, it usually means that some 
      ** other connection managed to get in and roll it back before 
      ** this connection obtained the exclusive lock above. Or, it 
      ** may mean that the pager was in the error-state when this
      ** function was called and the journal file does not exist.
      */</comment>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>!=</operator><name>PAGER_JOURNALMODE_OFF</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pVfs</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bExists</name></decl>;</decl_stmt>              <comment type="block">/* True if journal file exists */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsAccess</name><argument_list>(
            <argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bExists</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>fout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>SQLITE_OPEN_READWRITE</name><operator>|</operator><name>SQLITE_OPEN_MAIN_JOURNAL</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>fout</name><operator>&amp;</operator><name>SQLITE_OPEN_READONLY</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN_BKPT</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
 
      <comment type="block">/* Playback and delete the journal.  Drop the database write
      ** lock and reacquire the read lock. Purge the cache before
      ** playing back the hot-journal so that we don't end up with
      ** an inconsistent cache.  Sync the hot journal before playing
      ** it back since the process that crashed and left the hot journal
      ** probably did not sync it and we are required to always sync
      ** the journal before playing it back.
      */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerSyncHotJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_playback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_OPEN</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>pagerUnlockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* This branch is taken if an error occurs while trying to open
        ** or roll back a hot-journal while holding an EXCLUSIVE lock. The
        ** pager_unlock() routine will be called before returning to unlock
        ** the file. If the unlock attempt fails, then Pager.eLock must be
        ** set to UNKNOWN_LOCK (see the comment above the #define for 
        ** UNKNOWN_LOCK above for an explanation). 
        **
        ** In order to get pager_unlock() to do this, set Pager.eState to
        ** PAGER_ERROR now. This is not actually counted as a transition
        ** to ERROR state in the state diagram at the top of this file,
        ** since we know that the same call to pager_unlock() will very
        ** shortly transition the pager object to the OPEN state. Calling
        ** assert_pager_state() would fail now, as it should not be possible
        ** to be in ERROR state when there are zero outstanding page 
        ** references.
        */</comment>
        <expr_stmt><expr><call><name>pager_error</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>failed</name>;</goto>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>SHARED_LOCK</name><operator>)</operator>
           <operator>||</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;</operator><name>SHARED_LOCK</name><operator>)</operator></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>hasHeldSharedLock</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The shared-lock has just been acquired then check to
      ** see if the database has been modified.  If the database has changed,
      ** flush the cache.  The hasHeldSharedLock flag prevents this from
      ** occurring on the very first access to a file, in order to save a
      ** single unnecessary sqlite3OsRead() call at the start-up.
      **
      ** Database changes are detected by looking at 15 bytes beginning
      ** at offset 24 into the file.  The first 4 of these 16 bytes are
      ** a 32-bit counter that is incremented with each change.  The
      ** other bytes change randomly with each file change when
      ** a codec is in use.
      ** 
      ** There is a vanishingly small chance that a change will not be 
      ** detected.  The chance of an undetected change is so small that
      ** it can be neglected.
      */</comment>
      <decl_stmt><decl><type><name>char</name></type> <name><name>dbFileVers</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbFileVers</name></name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>IOTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"CKVERS %p %d\n"</literal><operator>,</operator> <name>pPager</name><operator>,</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dbFileVers</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbFileVers</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dbFileVers</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_IOERR_SHORT_READ</name></expr> )</condition><block>{<block_content>
          <goto>goto <name>failed</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dbFileVers</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dbFileVers</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbFileVers</name></name></expr></argument>, <argument><expr><name>dbFileVers</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dbFileVers</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>pager_reset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Unmap the database file. It is possible that external processes
        ** may have truncated the database file and then extended it back
        ** to its original size while this process was not holding a lock.
        ** In this case there may exist a Pager.pMap mapping that appears
        ** to be the right size but is not actually valid. Avoid this
        ** possibility by unmapping the db here. */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>USEFETCH</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3OsUnfetch</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If there is a WAL file in the file-system, open this database in WAL
    ** mode. Otherwise, the following function call is a no-op.
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerOpenWalIfPresent</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerBeginReadTransaction</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerPagecount</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

 <label><name>failed</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pager_unlock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_READER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>hasHeldSharedLock</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the reference count has reached zero, rollback any active
** transaction and unlock the pager.
**
** Except, in locking_mode=EXCLUSIVE when there is nothing to in
** the rollback journal, the unlock is not performed and there is
** nothing to rollback, so this routine is a no-op.
*/</comment> 
<function><type><specifier>static</specifier> <name>void</name></type> <name>pagerUnlockIfUnused</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>nMmapOut</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* because page1 is never memory mapped */</comment>
    <expr_stmt><expr><call><name>pagerUnlockAndRollback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The page getter methods each try to acquire a reference to a
** page with page number pgno. If the requested reference is 
** successfully obtained, it is copied to *ppPage and SQLITE_OK returned.
**
** There are different implementations of the getter method depending
** on the current state of the pager.
**
**     getPageNormal()         --  The normal getter
**     getPageError()          --  Used if the pager is in an error state
**     getPageMmap()           --  Used if memory-mapped I/O is enabled
**
** If the requested page is already in the cache, it is returned. 
** Otherwise, a new page object is allocated and populated with data
** read from the database file. In some cases, the pcache module may
** choose not to allocate a new page object and may reuse an existing
** object with no outstanding references.
**
** The extra data appended to a page is always initialized to zeros the 
** first time a page is loaded into memory. If the page requested is 
** already in the cache when this function is called, then the extra
** data is left as it was when the page object was last used.
**
** If the database image is smaller than the requested page or if 
** the flags parameter contains the PAGER_GET_NOCONTENT bit and the 
** requested page is not already stored in the cache, then no 
** actual disk read occurs. In this case the memory image of the 
** page is initialized to all zeros. 
**
** If PAGER_GET_NOCONTENT is true, it means that we do not care about
** the contents of the page. This occurs in two scenarios:
**
**   a) When reading a free-list leaf page from the database, and
**
**   b) When a savepoint is being rolled back and we need to load
**      a new page into the cache to be filled with the data read
**      from the savepoint journal.
**
** If PAGER_GET_NOCONTENT is true, then the data returned is zeroed instead
** of being read from the database. Additionally, the bits corresponding
** to pgno in Pager.pInJournal (bitvec of pages already written to the
** journal file) and the PagerSavepoint.pInSavepoint bitvecs of any open
** savepoints are set. This means if the page is made writable at any
** point in the future, using a call to sqlite3PagerWrite(), its contents
** will not be journaled. This saves IO.
**
** The acquisition might fail for several reasons.  In all cases,
** an appropriate error code is returned and *ppPage is set to NULL.
**
** See also sqlite3PagerLookup().  Both this routine and Lookup() attempt
** to find a page in the in-memory cache first.  If the page is not already
** in memory, this routine goes to disk to read it in whereas Lookup()
** just returns 0.  This routine acquires a read-lock the first time it
** has to go to disk, and could also playback an old journal if necessary.
** Since Lookup() never goes to disk, it never has to deal with locks
** or journal files.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getPageNormal</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,      <comment type="block">/* The pager open on the database file */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>,          <comment type="block">/* Page number to fetch */</comment>
  <parameter><decl><type><name>DbPage</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>,    <comment type="block">/* Write a pointer to the page here */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>           <comment type="block">/* PAGER_GET_XXX flags */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>noContent</name></decl>;</decl_stmt>                   <comment type="block">/* True if PAGER_GET_NOCONTENT is set */</comment>
  <decl_stmt><decl><type><name>sqlite3_pcache_page</name> <modifier>*</modifier></type><name>pBase</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_READER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>hasHeldSharedLock</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pBase</name> <operator>=</operator> <call><name>sqlite3PcacheFetch</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBase</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pPg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PcacheFetchStress</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>pager_acquire_err</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBase</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>pager_acquire_err</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pPg</name> <operator>=</operator> <operator>*</operator><name>ppPage</name> <operator>=</operator> <call><name>sqlite3PcacheFetchFinish</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>pBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPg</name><operator>==</operator><operator>(</operator><operator>*</operator><name>ppPage</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>==</operator><name>pgno</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name><operator>==</operator><name>pPager</name> <operator>||</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>noContent</name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PAGER_GET_NOCONTENT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>noContent</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* In this case the pcache already contains an initialized copy of
    ** the page. Return without further ado.  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pgno</name><operator>!=</operator><call><name>PAGER_SJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>aStat</name><index>[<expr><name>PAGER_STAT_HIT</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>

  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* The pager cache has created a new page. Its content needs to 
    ** be initialized. But first some error checks:
    **
    ** (*) obsolete.  Was: maximum page number is 2^31
    ** (2) Never try to fetch the locking page
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>==</operator><call><name>PAGER_SJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>pager_acquire_err</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name> <operator>=</operator> <name>pPager</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>&lt;</operator><name>pgno</name> <operator>||</operator> <name>noContent</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>&gt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>mxPgno</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_FULL</name></expr>;</expr_stmt>
        <goto>goto <name>pager_acquire_err</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>noContent</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Failure to set the bits in the InJournal bit-vectors is benign.
        ** It merely means that we might do some extra work to journal a 
        ** page that does not need to be journaled.  Nevertheless, be sure 
        ** to test the case where a malloc error occurs while trying to set 
        ** a bit in a bit vector.
        */</comment>
        <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>&lt;=</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name></expr> )</condition><block>{<block_content>
          <macro><name>TESTONLY</name><argument_list>( <argument>rc =</argument> )</argument_list></macro> <expr_stmt><expr><call><name>sqlite3BitvecSet</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <macro><name>TESTONLY</name><argument_list>( <argument>rc =</argument> )</argument_list></macro> <expr_stmt><expr><call><name>addToSavepointBitvecs</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>IOTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"ZERO %p %d\n"</literal><operator>,</operator> <name>pPager</name><operator>,</operator> <name>pgno</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name><operator>==</operator><name>pPager</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>aStat</name><index>[<expr><name>PAGER_STAT_MISS</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>readDbPage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>pager_acquire_err</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>pager_set_pagehash</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

<label><name>pager_acquire_err</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3PcacheDrop</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>pagerUnlockIfUnused</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* The page getter for when memory-mapped I/O is enabled */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getPageMMap</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,      <comment type="block">/* The pager open on the database file */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>,          <comment type="block">/* Page number to fetch */</comment>
  <parameter><decl><type><name>DbPage</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>,    <comment type="block">/* Write a pointer to the page here */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>           <comment type="block">/* PAGER_GET_XXX flags */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iFrame</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Frame to read from WAL file */</comment>

  <comment type="block">/* It is acceptable to use a read-only (mmap) page for any page except
  ** page 1 if there is no write-transaction open or the ACQUIRE_READONLY
  ** flag was specified by the caller. And so long as the db is not a 
  ** temporary or in-memory database.  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bMmapOk</name> <init>= <expr><operator>(</operator><name>pgno</name><operator>&gt;</operator><literal type="number">1</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_READER</name> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PAGER_GET_READONLY</name><operator>)</operator><operator>)</operator>
  <operator>)</operator></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>USEFETCH</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>xCodec</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>

  <comment type="block">/* Optimization note:  Adding the "pgno&lt;=1" term before "pgno==0" here
  ** allows the compiler optimizer to reuse the results of the "pgno&gt;1"
  ** test in the previous statement, and avoid testing pgno==0 in the
  ** common case where pgno is large. */</comment>
  <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>&lt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>pgno</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_READER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>hasHeldSharedLock</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>bMmapOk</name> <operator>&amp;&amp;</operator> <call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalFindFrame</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>bMmapOk</name> <operator>&amp;&amp;</operator> <name>iFrame</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFetch</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, 
        <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><name>pgno</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pData</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pData</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;</operator><name>PAGER_READER</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pPg</name> <operator>=</operator> <call><name>sqlite3PagerLookup</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pPg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerAcquireMapPage</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3OsUnfetch</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><name>pgno</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>getPageNormal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>ppPage</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_MAX_MMAP_SIZE&gt;0 */</comment>

<comment type="block">/* The page getter method for when the pager is an error state */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getPageError</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,      <comment type="block">/* The pager open on the database file */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>,          <comment type="block">/* Page number to fetch */</comment>
  <parameter><decl><type><name>DbPage</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>,    <comment type="block">/* Write a pointer to the page here */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>           <comment type="block">/* PAGER_GET_XXX flags */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Dispatch all page fetch requests to the appropriate getter method.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerGet</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,      <comment type="block">/* The pager open on the database file */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>,          <comment type="block">/* Page number to fetch */</comment>
  <parameter><decl><type><name>DbPage</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>,    <comment type="block">/* Write a pointer to the page here */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>           <comment type="block">/* PAGER_GET_XXX flags */</comment>
)</parameter_list><block>{<block_content>
  <comment type="block">/* printf("PAGE %u\n", pgno); fflush(stdout); */</comment>
  <return>return <expr><call><name><name>pPager</name><operator>-&gt;</operator><name>xGet</name></name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>ppPage</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Acquire a page if it is already in the in-memory cache.  Do
** not read the page from disk.  Return a pointer to the page,
** or 0 if the page is not in cache. 
**
** See also sqlite3PagerGet().  The difference between this routine
** and sqlite3PagerGet() is that _get() will go to the disk and read
** in the page if the page is not already in cache.  This routine
** returns NULL if the page is not in cache or if a disk I/O error 
** has ever happened.
*/</comment>
<function><type><name>DbPage</name> <modifier>*</modifier></type><name>sqlite3PagerLookup</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_pcache_page</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pgno</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name> <operator>=</operator> <call><name>sqlite3PcacheFetch</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>hasHeldSharedLock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPage</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sqlite3PcacheFetchFinish</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Release a page reference.
**
** The sqlite3PagerUnref() and sqlite3PagerUnrefNotNull() may only be
** used if we know that the page being released is not the last page.
** The btree layer always holds page1 open until the end, so these first
** to routines can be used to release any page other than BtShared.pPage1.
**
** Use sqlite3PagerUnrefPageOne() to release page1.  This latter routine
** checks the total number of outstanding pages and if the number of
** pages reaches zero it drops the database lock.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerUnrefNotNull</name><parameter_list>(<parameter><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <macro><name>TESTONLY</name><argument_list>( <argument>Pager *pPager = pPg-&gt;pPager;</argument> )</argument_list></macro>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPg</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_MMAP</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>!=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Page1 is never memory mapped */</comment>
    <expr_stmt><expr><call><name>pagerReleaseMapPage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3PcacheRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Do not use this routine to release the last reference to page1 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3PagerUnref</name><parameter_list>(<parameter><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pPg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3PagerUnrefNotNull</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3PagerUnrefPageOne</name><parameter_list>(<parameter><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPg</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_MMAP</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Page1 is never memory mapped */</comment>
  <expr_stmt><expr><name>pPager</name> <operator>=</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PcacheRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pagerUnlockIfUnused</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called at the start of every write transaction.
** There must already be a RESERVED or EXCLUSIVE lock on the database 
** file when this routine is called.
**
** Open the journal file for pager pPager and write a journal header
** to the start of it. If there are active savepoints, open the sub-journal
** as well. This function is only used when the journal file is being 
** opened to write a rollback log for a transaction. It is not used 
** when opening a hot journal file to roll it back.
**
** If the journal file is already open (as it may be in exclusive mode),
** then this function just writes a journal header to the start of the
** already open file. 
**
** Whether or not the journal file is opened by this function, the
** Pager.pInJournal bitvec structure is allocated.
**
** Return SQLITE_OK if everything is successful. Otherwise, return 
** SQLITE_NOMEM if the attempt to allocate Pager.pInJournal fails, or 
** an IO error code if opening or writing the journal file fails.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_open_journal</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                        <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>pVfs</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Local cache of vfs pointer */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_LOCKED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* If already in the error state, this function is a no-op.  But on
  ** the other hand, this routine is never called if we are already in
  ** an error state. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>!=</operator><name>PAGER_JOURNALMODE_OFF</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name> <operator>=</operator> <call><name>sqlite3BitvecCreate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* Open the journal file if it is not already open. */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_MEMORY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3MemJournalOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>SQLITE_OPEN_READWRITE</name><operator>|</operator><name>SQLITE_OPEN_CREATE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nSpill</name></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>flags</name> <operator>|=</operator> <operator>(</operator><name>SQLITE_OPEN_DELETEONCLOSE</name><operator>|</operator><name>SQLITE_OPEN_TEMP_JOURNAL</name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>nSpill</name> <operator>=</operator> <name><name>sqlite3Config</name><operator>.</operator><name>nStmtSpill</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>SQLITE_OPEN_MAIN_JOURNAL</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>nSpill</name> <operator>=</operator> <call><name>jrnlBufferSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
          
        <comment type="block">/* Verify that the database still has the same name as it did when
        ** it was originally opened. */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>databaseIsUnmoved</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3JournalOpen</name> <argument_list>(
              <argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>nSpill</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
  
    <comment type="block">/* Write the first journal header to the journal file and open 
    ** the sub-journal if necessary.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* TODO: Check if all of these are really required. */</comment>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nRec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>setSuper</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>writeJournalHdr</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_LOCKED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_WRITER_CACHEMOD</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Begin a write-transaction on the specified pager object. If a 
** write-transaction has already been opened, this function is a no-op.
**
** If the exFlag argument is false, then acquire at least a RESERVED
** lock on the database file. If exFlag is true, then acquire at least
** an EXCLUSIVE lock. If such a lock is already held, no locking 
** functions need be called.
**
** If the subjInMemory argument is non-zero, then any sub-journal opened
** within this transaction will be opened as an in-memory file. This
** has no effect if the sub-journal is already opened (as it may be when
** running in exclusive mode) or if the transaction does not require a
** sub-journal. If the subjInMemory argument is zero, then any required
** sub-journal is implemented in-memory if pPager is an in-memory database, 
** or using a temporary file otherwise.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerBegin</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exFlag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subjInMemory</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_READER</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&lt;</operator><name>PAGER_ERROR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>subjInMemory</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>subjInMemory</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_READER</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* If the pager is configured to use locking_mode=exclusive, and an
      ** exclusive lock on the database is not already held, obtain it now.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3WalExclusiveMode</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerLockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>sqlite3WalExclusiveMode</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Grab the write lock on the log file. If successful, upgrade to
      ** PAGER_RESERVED state. Otherwise, return an error code to the caller.
      ** The busy-handler is not invoked if another connection already
      ** holds the write-lock. If possible, the upper layer will call it.
      */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalBeginWriteTransaction</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Obtain a RESERVED lock on the database file. If the exFlag parameter
      ** is true, then immediately upgrade this to an EXCLUSIVE lock. The
      ** busy-handler callback can be used when upgrading to the EXCLUSIVE
      ** lock, but not when obtaining the RESERVED lock.
      */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerLockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>RESERVED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>exFlag</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_wait_on_lock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Change to WRITER_LOCKED state.
      **
      ** WAL mode sets Pager.eState to PAGER_WRITER_LOCKED or CACHEMOD
      ** when it has an open transaction, but never to DBMOD or FINISHED.
      ** This is because in those states the code to roll back savepoint 
      ** transactions may copy data from the sub-journal into the database 
      ** file as well as into the page cache. Which would be incorrect in 
      ** WAL mode.
      */</comment>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_WRITER_LOCKED</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbHintSize</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbFileSize</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_READER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_LOCKED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TRANSACTION %d\n"</literal><operator>,</operator> <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write page pPg onto the end of the rollback journal.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>pagerAddPageToRollbackJournal</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pData2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* We should never write to the journal file the page that
  ** contains the database locks.  The following assert verifies
  ** that we do not. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>!=</operator><call><name>PAGER_SJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalHdr</name></name><operator>&lt;=</operator><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>CODEC2</name><argument_list>(<argument>pPager</argument>, <argument>pPg-&gt;pData</argument>, <argument>pPg-&gt;pgno</argument>, <argument><literal type="number">7</literal></argument>, <argument>return SQLITE_NOMEM_BKPT</argument>, <argument>pData2</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><name>cksum</name> <operator>=</operator> <call><name>pager_cksum</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>pData2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Even if an IO or diskfull error occurs while journalling the
  ** page in the block above, set the need-sync flag for the page.
  ** Otherwise, when the transaction is rolled back, the logic in
  ** playback_one_page() will think that the page needs to be restored
  ** in the database file. And if an IO error occurs while doing so,
  ** then corruption may follow.
  */</comment>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PGHDR_NEED_SYNC</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>write32bits</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>pData2</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><name>iOff</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>write32bits</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>, <argument><expr><name>iOff</name><operator>+</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>cksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>IOTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"JOUT %p %d %lld %d\n"</literal><operator>,</operator> <name>pPager</name><operator>,</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>,</operator> 
           <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>,</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PAGER_INCR</name><argument_list>(<argument><expr><name>sqlite3_pager_writej_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"JOURNAL %d page %d needSync=%d hash(%08x)\n"</literal><operator>,</operator>
       <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>,</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>,</operator> 
       <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>,</operator> <call><name>pager_pagehash</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name> <operator>+=</operator> <literal type="number">8</literal> <operator>+</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nRec</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BitvecSet</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>|=</operator> <call><name>addToSavepointBitvecs</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Mark a single data page as writeable. The page is written into the 
** main journal or sub-journal as required. If the page is written into
** one of the journals, the corresponding bit is set in the 
** Pager.pInJournal bitvec and the PagerSavepoint.pInSavepoint bitvecs
** of any open savepoints as appropriate.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_write</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* This routine is not called unless a write-transaction has already 
  ** been started. The journal file may or may not be open at this point.
  ** It is never called in the ERROR state.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_LOCKED</name>
       <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_CACHEMOD</name>
       <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_DBMOD</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CHECK_PAGE</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The journal file needs to be opened. Higher level routines have already
  ** obtained the necessary locks to begin the write-transaction, but the
  ** rollback journal might not yet be open. Open it now if this is the case.
  **
  ** This is done before calling sqlite3PcacheMakeDirty() on the page. 
  ** Otherwise, if it were done after calling sqlite3PcacheMakeDirty(), then
  ** an error might occur and the pager would end up in WRITER_LOCKED state
  ** with pages marked as dirty in the cache.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_LOCKED</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_open_journal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_WRITER_CACHEMOD</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Mark the page that is about to be modified as dirty. */</comment>
  <expr_stmt><expr><call><name>sqlite3PcacheMakeDirty</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If a rollback journal is in use, them make sure the page that is about
  ** to change is in the rollback journal, or if the page is a new page off
  ** then end of the file, make sure it is marked as PGHDR_NEED_SYNC.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator> <operator>==</operator> <call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <call><name>sqlite3BitvecTestNotNull</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>&lt;=</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerAddPageToRollbackJournal</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_WRITER_DBMOD</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PGHDR_NEED_SYNC</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"APPEND %d page %d needSync=%d\n"</literal><operator>,</operator>
              <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>,</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>,</operator>
             <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The PGHDR_DIRTY bit is set above when the page was added to the dirty-list
  ** and before writing the page into the rollback journal.  Wait until now,
  ** after the page has been successfully journalled, before setting the
  ** PGHDR_WRITEABLE bit that indicates that the page can be safely modified.
  */</comment>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PGHDR_WRITEABLE</name></expr>;</expr_stmt>
  
  <comment type="block">/* If the statement journal is open and the page is not in it,
  ** then write the page into the statement journal.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>subjournalPageIfRequired</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Update the database size and return. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>&lt;</operator><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>=</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is a variant of sqlite3PagerWrite() that runs when the sector size
** is larger than the page size.  SQLite makes the (reasonable) assumption that
** all bytes of a sector are written together by hardware.  Hence, all bytes of
** a sector need to be journalled in case of a power loss in the middle of
** a write.
**
** Usually, the sector size is less than or equal to the page size, in which
** case pages can be individually written.  This routine only runs in the
** exceptional case where the page size is smaller than the sector size.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>pagerWriteLargeSector</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>          <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>nPageCount</name></decl>;</decl_stmt>             <comment type="block">/* Total number of pages in database file */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pg1</name></decl>;</decl_stmt>                    <comment type="block">/* First page of the sector pPg is located on. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Number of pages starting at pg1 to journal */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>                      <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>needSync</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* True if any page has PGHDR_NEED_SYNC */</comment>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* The pager that owns pPg */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>nPagePerSector</name> <init>= <expr><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>sectorSize</name></name><operator>/</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Set the doNotSpill NOSYNC bit to 1. This is because we cannot allow
  ** a journal header to be written between the pages journaled by
  ** this function.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name> <operator>&amp;</operator> <name>SPILLFLAG_NOSYNC</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name> <operator>|=</operator> <name>SPILLFLAG_NOSYNC</name></expr>;</expr_stmt>

  <comment type="block">/* This trick assumes that both the page-size and sector-size are
  ** an integer power of 2. It sets variable pg1 to the identifier
  ** of the first page of the sector pPg is located on.
  */</comment>
  <expr_stmt><expr><name>pg1</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>nPagePerSector</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>nPageCount</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>&gt;</operator><name>nPageCount</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nPage</name> <operator>=</operator> <operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name> <operator>-</operator> <name>pg1</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>pg1</name><operator>+</operator><name>nPagePerSector</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&gt;</operator><name>nPageCount</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nPage</name> <operator>=</operator> <name>nPageCount</name><operator>+</operator><literal type="number">1</literal><operator>-</operator><name>pg1</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nPage</name> <operator>=</operator> <name>nPagePerSector</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nPage</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pg1</name><operator>&lt;=</operator><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>pg1</name><operator>+</operator><name>nPage</name><operator>)</operator><operator>&gt;</operator><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nPage</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>pg</name> <init>= <expr><name>pg1</name><operator>+</operator><name>ii</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pg</name><operator>==</operator><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name> <operator>||</operator> <operator>!</operator><call><name>sqlite3BitvecTest</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name></expr></argument>, <argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pg</name><operator>!=</operator><call><name>PAGER_SJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_write</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>needSync</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3PagerUnrefNotNull</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>pPage</name> <operator>=</operator> <call><name>sqlite3PagerLookup</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>needSync</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerUnrefNotNull</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* If the PGHDR_NEED_SYNC flag is set for any of the nPage pages 
  ** starting at pg1, then it needs to be set for all of them. Because
  ** writing to any of these nPage pages may damage the others, the
  ** journal file must contain sync()ed copies of all of them
  ** before any of them can be written out to the database file.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>needSync</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nPage</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><call><name>sqlite3PagerLookup</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pg1</name><operator>+</operator><name>ii</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pPage</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PGHDR_NEED_SYNC</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3PagerUnrefNotNull</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name> <operator>&amp;</operator> <name>SPILLFLAG_NOSYNC</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>doNotSpill</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SPILLFLAG_NOSYNC</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Mark a data page as writeable. This routine must be called before 
** making changes to a page. The caller must check the return value 
** of this function and be careful not to change any page data unless 
** this routine returns SQLITE_OK.
**
** The difference between this function and pager_write() is that this
** function also deals with the special case where 2 or more pages
** fit on a single disk sector. In this case all co-resident pages
** must have been written to the journal file before returning.
**
** If an error occurs, SQLITE_NOMEM or an IO error code is returned
** as appropriate. Otherwise, SQLITE_OK.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerWrite</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_MMAP</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_WRITER_LOCKED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_WRITEABLE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>&gt;=</operator><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>subjournalPageIfRequired</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>sectorSize</name></name> <operator>&gt;</operator> <operator>(</operator><name>u32</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>pagerWriteLargeSector</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>pager_write</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the page given in the argument was previously passed
** to sqlite3PagerWrite().  In other words, return TRUE if it is ok
** to change the content of the page.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3PagerIswriteable</name><parameter_list>(<parameter><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_WRITEABLE</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** A call to this routine tells the pager that it is not necessary to
** write the information on page pPg back to the disk, even though
** that page might be marked as dirty.  This happens, for example, when
** the page has been added as a leaf of the freelist and so its
** content no longer matters.
**
** The overlying software layer calls this routine when all of the data
** on the given page is unused. The pager marks the page as clean so
** that it does not get written to disk.
**
** Tests show that this optimization can quadruple the speed of large 
** DELETE operations.
**
** This optimization cannot be used with a temp-file, as the page may
** have been dirty at the start of the transaction. In that case, if
** memory pressure forces page pPg out of the cache, the data does need 
** to be written out to disk so that it may be read back in if the 
** current transaction is rolled back.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerDontWrite</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pPager</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_DIRTY</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"DONT_WRITE page %d of %d\n"</literal><operator>,</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>,</operator> <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>IOTRACE</name><argument_list>(<argument>(<literal type="string">"CLEAN %p %d\n"</literal>, pPager, pPg-&gt;pgno)</argument>)</argument_list></macro>
    <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PGHDR_DONT_WRITE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PGHDR_WRITEABLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_NEED_SYNC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pager_set_pagehash</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine is called to increment the value of the database file 
** change-counter, stored as a 4-byte big-endian integer starting at 
** byte offset 24 of the pager file.  The secondary change counter at
** 92 is also updated, as is the SQLite version number at offset 96.
**
** But this only happens if the pPager-&gt;changeCountDone flag is false.
** To avoid excess churning of page 1, the update only happens once.
** See also the pager_write_changecounter() routine that does an 
** unconditional update of the change counters.
**
** If the isDirectMode flag is zero, then this is done by calling 
** sqlite3PagerWrite() on page 1, then modifying the contents of the
** page data. In this case the file will be updated when the current
** transaction is committed.
**
** The isDirectMode flag may only be non-zero if the library was compiled
** with the SQLITE_ENABLE_ATOMIC_WRITE macro defined. In this case,
** if isDirect is non-zero, then the database file is updated directly
** by writing an updated version of page 1 using a call to the 
** sqlite3OsWrite() function.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pager_incr_changecounter</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isDirectMode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_CACHEMOD</name>
       <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_DBMOD</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Declare and initialize constant integer 'isDirect'. If the
  ** atomic-write optimization is enabled in this build, then isDirect
  ** is initialized to the value passed as the isDirectMode parameter
  ** to this function. Otherwise, it is always set to zero.
  **
  ** The idea is that if the atomic-write optimization is not
  ** enabled at compile time, the compiler can omit the tests of
  ** 'isDirect' below, as well as the block enclosed in the
  ** "if( isDirect )" condition.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_ATOMIC_WRITE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>DIRECT_MODE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isDirectMode</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>isDirectMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>DIRECT_MODE</name></cpp:macro> <cpp:value>isDirectMode</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>changeCountDone</name></name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPgHdr</name></decl>;</decl_stmt>                <comment type="block">/* Reference to page 1 */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name> <operator>&amp;&amp;</operator> <call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Open page 1 of the file for writing. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPgHdr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPgHdr</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If page one was fetched successfully, and this function is not
    ** operating in direct-mode, make page 1 writable.  When not in 
    ** direct mode, page 1 is always held in cache and hence the PagerGet()
    ** above is always successful - hence the ALWAYS on rc==SQLITE_OK.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>DIRECT_MODE</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPgHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Actually do the update of the change counter */</comment>
      <expr_stmt><expr><call><name>pager_write_changecounter</name><argument_list>(<argument><expr><name>pPgHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If running in direct mode, write the contents of page 1 to the file. */</comment>
      <if_stmt><if>if<condition>( <expr><name>DIRECT_MODE</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zBuf</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbFileSize</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CODEC2</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name><name>pPgHdr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>rc</name><operator>=</operator><name>SQLITE_NOMEM_BKPT</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>aStat</name><index>[<expr><name>PAGER_STAT_WRITE</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* Update the pager's copy of the change-counter. Otherwise, the
          ** next time a read transaction is opened the cache will be
          ** flushed (as the change-counter values will not match).  */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pCopy</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>zBuf</name><operator>)</operator><index>[<expr><literal type="number">24</literal></expr>]</index></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbFileVers</name></name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbFileVers</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>changeCountDone</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>changeCountDone</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Release the page reference. */</comment>
    <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPgHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Sync the database file to disk. This is a no-op for in-memory databases
** or pages with the Pager.noSync flag set.
**
** If successful, or if called on a pager for which it is a no-op, this
** function returns SQLITE_OK. Otherwise, an IO error code is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerSync</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSuper</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>zSuper</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileControl</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_SYNC</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOTFOUND</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>noSync</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>syncFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function may only be called while a write-transaction is active in
** rollback. If the connection is in WAL mode, this call is a no-op. 
** Otherwise, if the connection does not already have an EXCLUSIVE lock on 
** the database file, an attempt is made to obtain one.
**
** If the EXCLUSIVE lock is already held or the attempt to obtain it is
** successful, or the connection is in WAL mode, SQLITE_OK is returned.
** Otherwise, either SQLITE_BUSY or an SQLITE_IOERR_XXX error code is 
** returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerExclusiveLock</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_CACHEMOD</name> 
         <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_DBMOD</name> 
         <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_LOCKED</name></expr></argument> 
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_wait_on_lock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Sync the database file for the pager pPager. zSuper points to the name
** of a super-journal file that should be written into the individual
** journal file. zSuper may be NULL, which is interpreted as no 
** super-journal (a single database transaction).
**
** This routine ensures that:
**
**   * The database file change-counter is updated,
**   * the journal is synced (unless the atomic-write optimization is used),
**   * all dirty pages are written to the database file, 
**   * the database file is truncated (if required), and
**   * the database file synced. 
**
** The only thing that remains to commit the transaction is to finalize 
** (delete, truncate or zero the first part of) the journal file (or 
** delete the super-journal file if specified).
**
** Note that if zSuper==NULL, this does not overwrite a previous value
** passed to an sqlite3PagerCommitPhaseOne() call.
**
** If the final parameter - noSync - is true, then the database file itself
** is not synced. The caller must call sqlite3PagerSync() directly to
** sync the database file before calling CommitPhaseTwo() to delete the
** journal file in this case.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerCommitPhaseOne</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,                  <comment type="block">/* Pager object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSuper</name></decl></parameter>,            <comment type="block">/* If not NULL, the super-journal name */</comment>
  <parameter><decl><type><name>int</name></type> <name>noSync</name></decl></parameter>                      <comment type="block">/* True to omit the xSync on the db file */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_LOCKED</name>
       <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_CACHEMOD</name>
       <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_DBMOD</name>
       <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_ERROR</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If a prior error occurred, report that error again. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Provide the ability to easily simulate an I/O error during testing */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3FaultSim</name><argument_list>(<argument><expr><literal type="number">400</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_IOERR</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"DATABASE SYNC: File=%s zSuper=%s nSize=%d\n"</literal><operator>,</operator> 
      <name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name><operator>,</operator> <name>zSuper</name><operator>,</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If no database changes have been made, return early. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&lt;</operator><name>PAGER_WRITER_CACHEMOD</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>MEMDB</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>pagerFlushOnCommit</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* If this is an in-memory db, or no pages have been written to, or this
    ** function has already been called, it is mostly a no-op.  However, any
    ** backup in progress needs to be restarted.  */</comment>
    <expr_stmt><expr><call><name>sqlite3BackupRestart</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pBackup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPageOne</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3PcacheDirtyList</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Must have at least one page for the WAL commit flag.
        ** Ticket [2d1a5c67dfc2363e44f29d9bbd57f] 2011-05-18 */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPageOne</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pList</name> <operator>=</operator> <name>pPageOne</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerWalFrames</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPageOne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3PcacheCleanAll</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* The bBatch boolean is true if the batch-atomic-write commit method
      ** should be used.  No rollback journal is created if batch-atomic-write
      ** is enabled.
      */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_BATCH_ATOMIC_WRITE</name></cpp:ifdef>
      <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bBatch</name> <init>= <expr><name>zSuper</name><operator>==</operator><literal type="number">0</literal>    <comment type="block">/* An SQLITE_IOCAP_BATCH_ATOMIC commit */</comment>
        <operator>&amp;&amp;</operator> <operator>(</operator><call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>SQLITE_IOCAP_BATCH_ATOMIC</name><operator>)</operator>
        <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>noSync</name></name>
        <operator>&amp;&amp;</operator> <call><name>sqlite3JournalIsInMemory</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#     <cpp:directive>define</cpp:directive> <cpp:macro><name>bBatch</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ATOMIC_WRITE</name></cpp:ifdef>
      <comment type="block">/* The following block updates the change-counter. Exactly how it
      ** does this depends on whether or not the atomic-update optimization
      ** was enabled at compile time, and if this transaction meets the 
      ** runtime criteria to use the operation: 
      **
      **    * The file-system supports the atomic-write property for
      **      blocks of size page-size, and 
      **    * This commit is not part of a multi-file transaction, and
      **    * Exactly one page has been modified and store in the journal file.
      **
      ** If the optimization was not enabled at compile time, then the
      ** pager_incr_changecounter() function is called to update the change
      ** counter in 'indirect-mode'. If the optimization is compiled in but
      ** is not applicable to this transaction, call sqlite3JournalCreate()
      ** to make sure the journal file has actually been created, then call
      ** pager_incr_changecounter() to update the change-counter in indirect
      ** mode. 
      **
      ** Otherwise, if the optimization is both enabled and applicable,
      ** then call pager_incr_changecounter() to update the change-counter
      ** in 'direct' mode. In this case the journal file will never be
      ** created for this transaction.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>bBatch</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call> 
            <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_OFF</name> 
            <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name></expr></argument> 
            )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zSuper</name> <operator>&amp;&amp;</operator> <call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call> 
         <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>==</operator><call><name>jrnlBufferSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> 
         <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>&gt;=</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name>
         <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>(</operator><name>pPg</name> <operator>=</operator> <call><name>sqlite3PcacheDirtyList</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <literal type="number">0</literal><operator>==</operator><name><name>pPg</name><operator>-&gt;</operator><name>pDirty</name></name><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <comment type="block">/* Update the db file change counter via the direct-write method. The 
          ** following call will modify the in-memory representation of page 1 
          ** to include the updated change counter and then write page 1 
          ** directly to the database file. Because of the atomic-write 
          ** property of the host file-system, this is safe.
          */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_incr_changecounter</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3JournalCreate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_incr_changecounter</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* SQLITE_ENABLE_ATOMIC_WRITE */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_BATCH_ATOMIC_WRITE</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name>zSuper</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3JournalCreate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>commit_phase_one_exit</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bBatch</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_incr_changecounter</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_ENABLE_ATOMIC_WRITE */</comment>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>commit_phase_one_exit</name>;</goto></block_content></block></if></if_stmt>
  
      <comment type="block">/* Write the super-journal name into the journal file. If a
      ** super-journal file name has already been written to the journal file, 
      ** or if zSuper is NULL (no super-journal), then this call is a no-op.
      */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>writeSuperJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>commit_phase_one_exit</name>;</goto></block_content></block></if></if_stmt>
  
      <comment type="block">/* Sync the journal file and write all dirty pages to the database.
      ** If the atomic-update optimization is being used, this sync will not 
      ** create the journal file or perform any real IO.
      **
      ** Because the change-counter page was just modified, unless the
      ** atomic-update optimization is used it is almost certain that the
      ** journal requires a sync here. However, in locking_mode=exclusive
      ** on a system under memory pressure it is just possible that this is 
      ** not the case. In this case it is likely enough that the redundant
      ** xSync() call will be changed to a no-op by the OS anyhow. 
      */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>syncJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>commit_phase_one_exit</name>;</goto></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3PcacheDirtyList</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_BATCH_ATOMIC_WRITE</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name>bBatch</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileControl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_BEGIN_ATOMIC_WRITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_write_pagelist</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileControl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_COMMIT_ATOMIC_WRITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3OsFileControlHint</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xFF</literal><operator>)</operator><operator>==</operator><name>SQLITE_IOERR</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_IOERR_NOMEM</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3JournalCreate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>commit_phase_one_exit</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>bBatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_BATCH_ATOMIC_WRITE */</comment>

      <if_stmt><if>if<condition>( <expr><name>bBatch</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_write_pagelist</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_IOERR_BLOCKED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>commit_phase_one_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3PcacheCleanAll</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If the file on disk is smaller than the database image, use 
      ** pager_truncate to grow the file here. This can happen if the database
      ** image was extended as part of the current transaction and then the
      ** last page in the db image moved to the free-list. In this case the
      ** last page is never written out to disk, leaving the database file
      ** undersized. Fix this now if it is the case.  */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>&gt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbFileSize</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Pgno</name></type> <name>nNew</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name> <operator>-</operator> <operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>==</operator><call><name>PAGER_SJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_DBMOD</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_truncate</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>commit_phase_one_exit</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
  
      <comment type="block">/* Finally, sync the database file. */</comment>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>noSync</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSync</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <macro><name>IOTRACE</name><argument_list>(<argument>(<literal type="string">"DBSYNC %p\n"</literal>, pPager)</argument>)</argument_list></macro>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<label><name>commit_phase_one_exit</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_WRITER_FINISHED</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** When this function is called, the database file has been completely
** updated to reflect the changes made by the current transaction and
** synced to disk. The journal file still exists in the file-system 
** though, and if a failure occurs at this point it will eventually
** be used as a hot-journal and the current transaction rolled back.
**
** This function finalizes the journal file, either by deleting, 
** truncating or partially zeroing it, so that it cannot be used 
** for hot-journal rollback. Once this is done the transaction is
** irrevocably committed.
**
** If an error occurs, an IO error code is returned and the pager
** moves into the error state. Otherwise, SQLITE_OK is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerCommitPhaseTwo</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Return code */</comment>

  <comment type="block">/* This routine should not be called if a prior error has occurred.
  ** But if (due to a coding error elsewhere in the system) it does get
  ** called, just return the same error code without doing anything. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>iDataVersion</name></name><operator>++</operator></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_LOCKED</name>
       <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_FINISHED</name>
       <operator>||</operator> <operator>(</operator><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_CACHEMOD</name><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* An optimization. If the database was not actually modified during
  ** this transaction, the pager is running in exclusive-mode and is
  ** using persistent journals, then this function is a no-op.
  **
  ** The start of the journal file currently contains a single journal 
  ** header with the nRec field set to 0. If such a journal is used as
  ** a hot-journal during hot-journal rollback, 0 changes will be made
  ** to the database file. So there is no need to zero the journal 
  ** header. Since the pager is in exclusive mode, there is no need
  ** to drop any locks either.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_LOCKED</name> 
   <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name> 
   <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_PERSIST</name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>==</operator><call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_READER</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"COMMIT %d\n"</literal><operator>,</operator> <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_end_transaction</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>setSuper</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>pager_error</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If a write transaction is open, then all changes made within the 
** transaction are reverted and the current write-transaction is closed.
** The pager falls back to PAGER_READER state if successful, or PAGER_ERROR
** state if an error occurs.
**
** If the pager is already in PAGER_ERROR state when this function is called,
** it returns Pager.errCode immediately. No work is performed in this case.
**
** Otherwise, in rollback mode, this function performs two functions:
**
**   1) It rolls back the journal file, restoring all database file and 
**      in-memory cache pages to the state they were in when the transaction
**      was opened, and
**
**   2) It finalizes the journal file, so that it is not used for hot
**      rollback at any point in the future.
**
** Finalization of the journal file (task 2) is only performed if the 
** rollback is successful.
**
** In WAL mode, all cache-entries containing data modified within the
** current transaction are either expelled from the cache or reverted to
** their pre-transaction state by re-reading data from the database or
** WAL files. The WAL transaction is then closed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerRollback</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Return code */</comment>
  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"ROLLBACK %d\n"</literal><operator>,</operator> <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* PagerRollback() is a no-op if called in READER or OPEN state. If
  ** the pager is already in the ERROR state, the rollback is not 
  ** attempted here. Instead, the error code is returned to the caller.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_ERROR</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&lt;=</operator><name>PAGER_READER</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSavepoint</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>SAVEPOINT_ROLLBACK</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>pager_end_transaction</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>setSuper</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_LOCKED</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eState</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_end_transaction</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>MEMDB</name> <operator>&amp;&amp;</operator> <name>eState</name><operator>&gt;</operator><name>PAGER_WRITER_LOCKED</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* This can happen using journal_mode=off. Move the pager to the error 
      ** state to indicate that the contents of the cache may not be trusted.
      ** Any active readers will get SQLITE_ABORT.
      */</comment>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>SQLITE_ABORT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_ERROR</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setGetterMethod</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pager_playback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_READER</name> <operator>||</operator> <name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_FULL</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_CORRUPT</name>
          <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name> <operator>||</operator> <operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xFF</literal><operator>)</operator><operator>==</operator><name>SQLITE_IOERR</name> 
          <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_CANTOPEN</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If an error occurs during a ROLLBACK, we can no longer trust the pager
  ** cache. So call pager_error() on the way out to make any error persistent.
  */</comment>
  <return>return <expr><call><name>pager_error</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the database file is opened read-only.  Return FALSE
** if the database is (in theory) writable.
*/</comment>
<function><type><name>u8</name></type> <name>sqlite3PagerIsreadonly</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>readOnly</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Return the sum of the reference counts for all pages held by pPager.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerRefcount</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return the approximate number of bytes of memory currently
** used by the pager and its associated cache.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerMemUsed</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>perPageSize</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name> <operator>+</operator> <name><name>pPager</name><operator>-&gt;</operator><name>nExtra</name></name>
    <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PgHdr</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">5</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>perPageSize</name><operator>*</operator><call><name>sqlite3PcachePagecount</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call>
           <operator>+</operator> <call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>
           <operator>+</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of references to the specified page.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerPageRefcount</name><parameter_list>(<parameter><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3PcachePageRefcount</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/*
** This routine is used for testing and analysis only.
*/</comment>
<function><type><name>int</name> <modifier>*</modifier></type><name>sqlite3PagerStats</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>a</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3PcachePagecount</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3PcacheGetCachesize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pPCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>aStat</name><index>[<expr><name>PAGER_STAT_HIT</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>aStat</name><index>[<expr><name>PAGER_STAT_MISS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Used to be pPager-&gt;nOvfl */</comment>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>nRead</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>aStat</name><index>[<expr><name>PAGER_STAT_WRITE</name></expr>]</index></name></expr>;</expr_stmt>
  <return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Parameter eStat must be one of SQLITE_DBSTATUS_CACHE_HIT, _MISS, _WRITE,
** or _WRITE+1.  The SQLITE_DBSTATUS_CACHE_WRITE+1 case is a translation
** of SQLITE_DBSTATUS_CACHE_SPILL.  The _SPILL case is not contiguous because
** it was added later.
**
** Before returning, *pnVal is incremented by the
** current cache hit or miss count, according to the value of eStat. If the 
** reset parameter is non-zero, the cache hit or miss count is zeroed before 
** returning.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerCacheStat</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eStat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reset</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnVal</name></decl></parameter>)</parameter_list><block>{<block_content>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eStat</name><operator>==</operator><name>SQLITE_DBSTATUS_CACHE_HIT</name>
       <operator>||</operator> <name>eStat</name><operator>==</operator><name>SQLITE_DBSTATUS_CACHE_MISS</name>
       <operator>||</operator> <name>eStat</name><operator>==</operator><name>SQLITE_DBSTATUS_CACHE_WRITE</name>
       <operator>||</operator> <name>eStat</name><operator>==</operator><name>SQLITE_DBSTATUS_CACHE_WRITE</name><operator>+</operator><literal type="number">1</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_DBSTATUS_CACHE_HIT</name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>SQLITE_DBSTATUS_CACHE_MISS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_DBSTATUS_CACHE_HIT</name><operator>+</operator><literal type="number">2</literal><operator>==</operator><name>SQLITE_DBSTATUS_CACHE_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PAGER_STAT_HIT</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>PAGER_STAT_MISS</name><operator>==</operator><literal type="number">1</literal>
           <operator>&amp;&amp;</operator> <name>PAGER_STAT_WRITE</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>PAGER_STAT_SPILL</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>eStat</name> <operator>-=</operator> <name>SQLITE_DBSTATUS_CACHE_HIT</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnVal</name> <operator>+=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>aStat</name><index>[<expr><name>eStat</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>reset</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>aStat</name><index>[<expr><name>eStat</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return true if this is an in-memory or temp-file backed pager.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerIsMemdb</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>memVfs</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check that there are at least nSavepoint savepoints open. If there are
** currently less than nSavepoints open, then open one or more savepoints
** to make up the difference. If the number of savepoints is already
** equal to nSavepoint, then this function is a no-op.
**
** If a memory allocation fails, SQLITE_NOMEM is returned. If an error 
** occurs while opening the sub-journal file, then an IO error code is
** returned. Otherwise, SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>pagerOpenSavepoint</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nSavepoint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                       <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCurrent</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Current number of savepoints */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>                                   <comment type="block">/* Iterator variable */</comment>
  <decl_stmt><decl><type><name>PagerSavepoint</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>                     <comment type="block">/* New Pager.aSavepoint array */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_WRITER_LOCKED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nSavepoint</name><operator>&gt;</operator><name>nCurrent</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>useJournal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Grow the Pager.aSavepoint array using realloc(). Return SQLITE_NOMEM
  ** if the allocation fails. Otherwise, zero the new portion in case a 
  ** malloc failure occurs while populating it in the for(...) loop below.
  */</comment>
  <expr_stmt><expr><name>aNew</name> <operator>=</operator> <operator>(</operator><name>PagerSavepoint</name> <operator>*</operator><operator>)</operator><call><name>sqlite3Realloc</name><argument_list>(
      <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagerSavepoint</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nSavepoint</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aNew</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aNew</name><index>[<expr><name>nCurrent</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>nSavepoint</name><operator>-</operator><name>nCurrent</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PagerSavepoint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>

  <comment type="block">/* Populate the PagerSavepoint structures just allocated. */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><name>nCurrent</name></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nSavepoint</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>aNew</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>nOrig</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>aNew</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iOffset</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>aNew</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iOffset</name> <operator>=</operator> <call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>aNew</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iSubRec</name> <operator>=</operator> <name><name>pPager</name><operator>-&gt;</operator><name>nSubRec</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aNew</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pInSavepoint</name> <operator>=</operator> <call><name>sqlite3BitvecCreate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aNew</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>bTruncateOnRelease</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>aNew</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pInSavepoint</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3WalSavepoint</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name><name>aNew</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>aWalData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name> <operator>=</operator> <name>ii</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name><operator>==</operator><name>nSavepoint</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assertTruncateConstraint</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3PagerOpenSavepoint</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nSavepoint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_WRITER_LOCKED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nSavepoint</name><operator>&gt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>useJournal</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>pagerOpenSavepoint</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>nSavepoint</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** This function is called to rollback or release (commit) a savepoint.
** The savepoint to release or rollback need not be the most recently 
** created savepoint.
**
** Parameter op is always either SAVEPOINT_ROLLBACK or SAVEPOINT_RELEASE.
** If it is SAVEPOINT_RELEASE, then release and destroy the savepoint with
** index iSavepoint. If it is SAVEPOINT_ROLLBACK, then rollback all changes
** that have occurred since the specified savepoint was created.
**
** The savepoint to rollback or release is identified by parameter 
** iSavepoint. A value of 0 means to operate on the outermost savepoint
** (the first created). A value of (Pager.nSavepoint-1) means operate
** on the most recently created savepoint. If iSavepoint is greater than
** (Pager.nSavepoint-1), then this function is a no-op.
**
** If a negative value is passed to this function, then the current
** transaction is rolled back. This is different to calling 
** sqlite3PagerRollback() because this function does not terminate
** the transaction or unlock the database, it just restores the 
** contents of the database to its original state. 
**
** In any case, all savepoints with an index greater than iSavepoint 
** are destroyed. If this is a release operation (op==SAVEPOINT_RELEASE),
** then savepoint iSavepoint is also destroyed.
**
** This function may return SQLITE_NOMEM if a memory allocation fails,
** or an IO error code if an IO error occurs while rolling back a 
** savepoint. If no errors occur, SQLITE_OK is returned.
*/</comment> 
<function><type><name>int</name></type> <name>sqlite3PagerSavepoint</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSavepoint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name></expr></init></decl>;</decl_stmt>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ZIPVFS</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>SAVEPOINT_RELEASE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>SAVEPOINT_RELEASE</name> <operator>||</operator> <name>op</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSavepoint</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>op</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iSavepoint</name><operator>&lt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>            <comment type="block">/* Iterator variable */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nNew</name></decl>;</decl_stmt>          <comment type="block">/* Number of remaining savepoints after this op. */</comment>

    <comment type="block">/* Figure out how many savepoints will still be active after this
    ** operation. Store this value in nNew. Then free resources associated 
    ** with any savepoints that are destroyed by this operation.
    */</comment>
    <expr_stmt><expr><name>nNew</name> <operator>=</operator> <name>iSavepoint</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator> <name>op</name><operator>==</operator><name>SAVEPOINT_RELEASE</name> <operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><name>nNew</name></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pInSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nSavepoint</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>

    <comment type="block">/* Truncate the sub-journal so that it only includes the parts
    ** that are still in use. */</comment>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>SAVEPOINT_RELEASE</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>PagerSavepoint</name> <modifier>*</modifier></type><name>pRel</name> <init>= <expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name><index>[<expr><name>nNew</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pRel</name><operator>-&gt;</operator><name>bTruncateOnRelease</name></name> <operator>&amp;&amp;</operator> <call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>sjfd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* Only truncate if it is an in-memory sub-journal. */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3JournalIsInMemory</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>sjfd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>i64</name></type> <name>sz</name> <init>= <expr><operator>(</operator><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name><operator>+</operator><literal type="number">4</literal><operator>)</operator><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>pRel</name><operator>-&gt;</operator><name>iSubRec</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>sjfd</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>nSubRec</name></name> <operator>=</operator> <name><name>pRel</name><operator>-&gt;</operator><name>iSubRec</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <comment type="block">/* Else this is a rollback operation, playback the specified savepoint.
    ** If this is a temp-file, it is possible that the journal file has
    ** not yet been opened. In this case there have been no changes to
    ** the database file, so the playback operation can be skipped.
    */</comment>
    <if type="elseif">else if<condition>( <expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>PagerSavepoint</name> <modifier>*</modifier></type><name>pSavepoint</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nNew</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>?</condition><then><expr><literal type="number">0</literal></expr></then><else>:<expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>aSavepoint</name><index>[<expr><name>nNew</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerPlaybackSavepoint</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ZIPVFS</name></cpp:ifdef>
    <comment type="block">/* If the cache has been modified but the savepoint cannot be rolled 
    ** back journal_mode=off, put the pager in the error state. This way,
    ** if the VFS used by this pager includes ZipVFS, the entire transaction
    ** can be rolled back at the ZipVFS level.  */</comment>
    <if type="elseif">else if<condition>( 
        <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_OFF</name> 
     <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_WRITER_CACHEMOD</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>SQLITE_ABORT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_ERROR</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setGetterMethod</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the full pathname of the database file.
**
** Except, if the pager is in-memory only, then return an empty string if
** nullIfMemDb is true.  This routine is called with nullIfMemDb==1 when
** used to report the filename to the user, for compatibility with legacy
** behavior.  But when the Btree needs to know the filename for matching to
** shared cache, it uses nullIfMemDb==0 so that in-memory databases can
** participate in shared-cache.
**
** The return value to this routine is always safe to use with
** sqlite3_uri_parameter() and sqlite3_filename_database() and friends.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3PagerFilename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nullIfMemDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zFake</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>nullIfMemDb</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>memDb</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>zFake</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>pPager</name><operator>-&gt;</operator><name>zFilename</name></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the VFS structure for the pager.
*/</comment>
<function><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>sqlite3PagerVfs</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the file handle for the database file associated
** with the pager.  This might return NULL if the file has
** not yet been opened.
*/</comment>
<function><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>sqlite3PagerFile</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the file handle for the journal file (if it exists).
** This will be either the rollback journal or the WAL file.
*/</comment>
<function><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>sqlite3PagerJrnlFile</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OMIT_WAL</name></expr></cpp:if>
  <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><ternary><condition><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr> ?</condition><then> <expr><call><name>sqlite3WalFile</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></else></ternary></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Return the full pathname of the journal file.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3PagerJournalname</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
<comment type="block">/*
** Set or retrieve the codec for this pager
*/</comment>
<function><type><name>void</name></type> <name>sqlcipherPagerSetCodec</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>xCodec</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>Pgno</name></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xCodecSizeChng</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xCodecFree</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCodec</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>xCodecFree</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>pPager</name><operator>-&gt;</operator><name>xCodecFree</name></name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pCodec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>pager_reset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>xCodec</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pPager</name><operator>-&gt;</operator><name>memDb</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>xCodec</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>xCodecSizeChng</name></name> <operator>=</operator> <name>xCodecSizeChng</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>xCodecFree</name></name> <operator>=</operator> <name>xCodecFree</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pCodec</name></name> <operator>=</operator> <name>pCodec</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setGetterMethod</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pagerReportSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlcipherPagerGetCodec</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>pCodec</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called by the wal module when writing page content
** into the log file.
**
** This function returns a pointer to a buffer containing the encrypted
** page content. If a malloc fails, this function may return NULL.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlcipherPagerCodec</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>aData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <macro><name>CODEC2</name><argument_list>(<argument>pPg-&gt;pPager</argument>, <argument>pPg-&gt;pData</argument>, <argument>pPg-&gt;pgno</argument>, <argument><literal type="number">6</literal></argument>, <argument>return <literal type="number">0</literal></argument>, <argument>aData</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <return>return <expr><name>aData</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_HAS_CODEC */</comment>
<comment type="block">/* END SQLCIPHER */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
<comment type="block">/*
** Move the page pPg to location pgno in the file.
**
** There must be no references to the page previously located at
** pgno (which we call pPgOld) though that page is allowed to be
** in cache.  If the page previously located at pgno is not already
** in the rollback journal, it is not put there by by this routine.
**
** References to the page pPg remain valid. Updating any
** meta-data associated with pPg (i.e. data stored in the nExtra bytes
** allocated along with the page) is the responsibility of the caller.
**
** A transaction must be active when this routine is called. It used to be
** required that a statement transaction was not active, but this restriction
** has been removed (CREATE INDEX needs to move a page when a statement
** transaction is active).
**
** If the fourth argument, isCommit, is non-zero, then this page is being
** moved as part of a database reorganization just before the transaction 
** is being committed. In this case, it is guaranteed that the database page 
** pPg refers to will not be written to again within this transaction.
**
** This function may return SQLITE_NOMEM or an IO error code if an error
** occurs. Otherwise, it returns SQLITE_OK.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerMovepage</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isCommit</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPgOld</name></decl>;</decl_stmt>               <comment type="block">/* The page being overwritten. */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>needSyncPgno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Old value of pPg-&gt;pgno, if sync is required */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                      <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>origPgno</name></decl>;</decl_stmt>               <comment type="block">/* The original page number */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_CACHEMOD</name>
       <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_WRITER_DBMOD</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* In order to be able to rollback, an in-memory database must journal
  ** the page we are moving from.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name> <operator>||</operator> <operator>!</operator><name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the page being moved is dirty and has not been saved by the latest
  ** savepoint, then save the current contents of the page into the 
  ** sub-journal now. This is required to handle the following scenario:
  **
  **   BEGIN;
  **     &lt;journal page X, then modify it in memory&gt;
  **     SAVEPOINT one;
  **       &lt;Move page X to location Y&gt;
  **     ROLLBACK TO one;
  **
  ** If page X were not written to the sub-journal here, it would not
  ** be possible to restore its contents when the "ROLLBACK TO one"
  ** statement were is processed.
  **
  ** subjournalPage() may need to allocate space to store pPg-&gt;pgno into
  ** one or more savepoint bitvecs. This is the reason this function
  ** may return SQLITE_NOMEM.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_DIRTY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>subjournalPageIfRequired</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"MOVE %d page %d (needSync=%d) moves to %d\n"</literal><operator>,</operator> 
      <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>,</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>,</operator> <ternary><condition><expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator> <name>pgno</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>IOTRACE</name><argument_list>(<argument>(<literal type="string">"MOVE %p %d %d\n"</literal>, pPager, pPg-&gt;pgno, pgno)</argument>)</argument_list></macro>

  <comment type="block">/* If the journal needs to be sync()ed before page pPg-&gt;pgno can
  ** be written to, store pPg-&gt;pgno in local variable needSyncPgno.
  **
  ** If the isCommit flag is set, there is no need to remember that
  ** the journal needs to be sync()ed before database page pPg-&gt;pgno 
  ** can be written to. The caller has already promised not to write to it.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>isCommit</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>needSyncPgno</name> <operator>=</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_OFF</name> <operator>||</operator>
            <call><name>pageInJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>&gt;</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_DIRTY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the cache contains a page with page-number pgno, remove it
  ** from its hash chain. Also, if the PGHDR_NEED_SYNC flag was set for 
  ** page pgno before the 'move' operation, it needs to be retained 
  ** for the page moved there.
  */</comment>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PGHDR_NEED_SYNC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPgOld</name> <operator>=</operator> <call><name>sqlite3PagerLookup</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>pPgOld</name> <operator>||</operator> <name><name>pPgOld</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPgOld</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>pPgOld</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PagerUnrefNotNull</name><argument_list>(<argument><expr><name>pPgOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <operator>(</operator><name><name>pPgOld</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Do not discard pages from an in-memory database since we might
      ** need to rollback later.  Just move the page out of the way. */</comment>
      <expr_stmt><expr><call><name>sqlite3PcacheMove</name><argument_list>(<argument><expr><name>pPgOld</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>dbSize</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PcacheDrop</name><argument_list>(<argument><expr><name>pPgOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>origPgno</name> <operator>=</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PcacheMove</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PcacheMakeDirty</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* For an in-memory database, make sure the original page continues
  ** to exist, in case the transaction needs to roll back.  Use pPgOld
  ** as the original page since it has already been allocated.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name> <operator>&amp;&amp;</operator> <name>pPgOld</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3PcacheMove</name><argument_list>(<argument><expr><name>pPgOld</name></expr></argument>, <argument><expr><name>origPgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerUnrefNotNull</name><argument_list>(<argument><expr><name>pPgOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>needSyncPgno</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If needSyncPgno is non-zero, then the journal file needs to be 
    ** sync()ed before any data is written to database file page needSyncPgno.
    ** Currently, no such page exists in the page-cache and the 
    ** "is journaled" bitvec flag has been set. This needs to be remedied by
    ** loading the page into the pager-cache and setting the PGHDR_NEED_SYNC
    ** flag.
    **
    ** If the attempt to load the page into the page-cache fails, (due
    ** to a malloc() or IO failure), clear the bit in the pInJournal[]
    ** array. Otherwise, if the page is loaded and written again in
    ** this transaction, it may be written to the database file before
    ** it is synced into the journal file. This way, it may end up in
    ** the journal file twice, but that is not a problem.
    */</comment>
    <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPgHdr</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>needSyncPgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPgHdr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>needSyncPgno</name><operator>&lt;=</operator><name><name>pPager</name><operator>-&gt;</operator><name>dbOrigSize</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3BitvecClear</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pInJournal</name></name></expr></argument>, <argument><expr><name>needSyncPgno</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pPgHdr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PGHDR_NEED_SYNC</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PcacheMakeDirty</name><argument_list>(<argument><expr><name>pPgHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerUnrefNotNull</name><argument_list>(<argument><expr><name>pPgHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The page handle passed as the first argument refers to a dirty page 
** with a page number other than iNew. This function changes the page's 
** page number to iNew and sets the value of the PgHdr.flags field to 
** the value passed as the third parameter.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerRekey</name><parameter_list>(<parameter><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>iNew</name></decl></parameter>, <parameter><decl><type><name>u16</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name><operator>!=</operator><name>iNew</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PcacheMove</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>iNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the data for the specified page.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3PagerGetData</name><parameter_list>(<parameter><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pPager</name><operator>-&gt;</operator><name>memDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pPg</name><operator>-&gt;</operator><name>pData</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the Pager.nExtra bytes of "extra" space 
** allocated along with the specified page.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3PagerGetExtra</name><parameter_list>(<parameter><decl><type><name>DbPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pPg</name><operator>-&gt;</operator><name>pExtra</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Get/set the locking-mode for this pager. Parameter eMode must be one
** of PAGER_LOCKINGMODE_QUERY, PAGER_LOCKINGMODE_NORMAL or 
** PAGER_LOCKINGMODE_EXCLUSIVE. If the parameter is not _QUERY, then
** the locking-mode is set to the value specified.
**
** The returned value is either PAGER_LOCKINGMODE_NORMAL or
** PAGER_LOCKINGMODE_EXCLUSIVE, indicating the current (possibly updated)
** locking-mode.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerLockingMode</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMode</name><operator>==</operator><name>PAGER_LOCKINGMODE_QUERY</name>
            <operator>||</operator> <name>eMode</name><operator>==</operator><name>PAGER_LOCKINGMODE_NORMAL</name>
            <operator>||</operator> <name>eMode</name><operator>==</operator><name>PAGER_LOCKINGMODE_EXCLUSIVE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PAGER_LOCKINGMODE_QUERY</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PAGER_LOCKINGMODE_NORMAL</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>PAGER_LOCKINGMODE_EXCLUSIVE</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>||</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3WalHeapMemory</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eMode</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3WalHeapMemory</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>eMode</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the journal-mode for this pager. Parameter eMode must be one of:
**
**    PAGER_JOURNALMODE_DELETE
**    PAGER_JOURNALMODE_TRUNCATE
**    PAGER_JOURNALMODE_PERSIST
**    PAGER_JOURNALMODE_OFF
**    PAGER_JOURNALMODE_MEMORY
**    PAGER_JOURNALMODE_WAL
**
** The journalmode is set to the value specified if the change is allowed.
** The change may be disallowed for the following reasons:
**
**   *  An in-memory database can only have its journal_mode set to _OFF
**      or _MEMORY.
**
**   *  Temporary databases cannot have _WAL journalmode.
**
** The returned indicate the current (possibly updated) journal-mode.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerSetJournalMode</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name>eOld</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Prior journalmode */</comment>

  <comment type="block">/* The eMode parameter is always valid */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(      <argument><expr><name>eMode</name><operator>==</operator><name>PAGER_JOURNALMODE_DELETE</name>    <comment type="block">/* 0 */</comment>
            <operator>||</operator> <name>eMode</name><operator>==</operator><name>PAGER_JOURNALMODE_PERSIST</name>   <comment type="block">/* 1 */</comment>
            <operator>||</operator> <name>eMode</name><operator>==</operator><name>PAGER_JOURNALMODE_OFF</name>       <comment type="block">/* 2 */</comment>
            <operator>||</operator> <name>eMode</name><operator>==</operator><name>PAGER_JOURNALMODE_TRUNCATE</name>  <comment type="block">/* 3 */</comment>
            <operator>||</operator> <name>eMode</name><operator>==</operator><name>PAGER_JOURNALMODE_MEMORY</name>    <comment type="block">/* 4 */</comment>
            <operator>||</operator> <name>eMode</name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name></expr></argument>       <comment type="block">/* 5 */</comment> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This routine is only called from the OP_JournalMode opcode, and
  ** the logic there will never allow a temporary file to be changed
  ** to WAL mode.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>eMode</name><operator>!=</operator><name>PAGER_JOURNALMODE_WAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Do allow the journalmode of an in-memory database to be set to
  ** anything other than MEMORY or OFF
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>MEMDB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOld</name><operator>==</operator><name>PAGER_JOURNALMODE_MEMORY</name> <operator>||</operator> <name>eOld</name><operator>==</operator><name>PAGER_JOURNALMODE_OFF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eMode</name><operator>!=</operator><name>PAGER_JOURNALMODE_MEMORY</name> <operator>&amp;&amp;</operator> <name>eMode</name><operator>!=</operator><name>PAGER_JOURNALMODE_OFF</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>eMode</name> <operator>=</operator> <name>eOld</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>eMode</name><operator>!=</operator><name>eOld</name></expr> )</condition><block>{<block_content>

    <comment type="block">/* Change the journal mode. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>PAGER_ERROR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>eMode</name></expr>;</expr_stmt>

    <comment type="block">/* When transistioning from TRUNCATE or PERSIST to any other journal
    ** mode except WAL, unless the pager is in locking_mode=exclusive mode,
    ** delete the journal file.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>PAGER_JOURNALMODE_TRUNCATE</name> <operator>&amp;</operator> <literal type="number">5</literal><operator>)</operator><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>PAGER_JOURNALMODE_PERSIST</name> <operator>&amp;</operator> <literal type="number">5</literal><operator>)</operator><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>PAGER_JOURNALMODE_DELETE</name> <operator>&amp;</operator> <literal type="number">5</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>PAGER_JOURNALMODE_MEMORY</name> <operator>&amp;</operator> <literal type="number">5</literal><operator>)</operator><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>PAGER_JOURNALMODE_OFF</name> <operator>&amp;</operator> <literal type="number">5</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>PAGER_JOURNALMODE_WAL</name> <operator>&amp;</operator> <literal type="number">5</literal><operator>)</operator><operator>==</operator><literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>eOld</name> <operator>&amp;</operator> <literal type="number">5</literal><operator>)</operator><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>eMode</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* In this case we would like to delete the journal file. If it is
      ** not possible, then that is not a problem. Deleting the journal file
      ** here is an optimization only.
      **
      ** Before deleting the journal file, obtain a RESERVED lock on the
      ** database file. This ensures that the journal file is not deleted
      ** while it is in use by some other client.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>&gt;=</operator><name>RESERVED_LOCK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>state</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>state</name><operator>==</operator><name>PAGER_OPEN</name> <operator>||</operator> <name>state</name><operator>==</operator><name>PAGER_READER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>state</name><operator>==</operator><name>PAGER_OPEN</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSharedLock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_READER</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerLockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>RESERVED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zJournal</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>state</name><operator>==</operator><name>PAGER_READER</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>pagerUnlockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>state</name><operator>==</operator><name>PAGER_OPEN</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>pager_unlock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>state</name><operator>==</operator><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eMode</name><operator>==</operator><name>PAGER_JOURNALMODE_OFF</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return the new journal mode */</comment>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the current journal mode.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerGetJournalMode</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the pager is in a state where it is OK to change the
** journalmode.  Journalmode changes can only happen when the database
** is unmodified.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerOkToChangeJournalMode</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_WRITER_CACHEMOD</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><call><name>isOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalOff</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Get/set the size-limit used for persistent journal files.
**
** Setting the size limit to -1 means no limit is enforced.
** An attempt to set a limit smaller than -1 is a no-op.
*/</comment>
<function><type><name>i64</name></type> <name>sqlite3PagerJournalSizeLimit</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iLimit</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iLimit</name><operator>&gt;=</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalSizeLimit</name></name> <operator>=</operator> <name>iLimit</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalLimit</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>journalSizeLimit</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the pPager-&gt;pBackup variable. The backup module
** in backup.c maintains the content of this variable. This module
** uses it opaquely as an argument to sqlite3BackupRestart() and
** sqlite3BackupUpdate() only.
*/</comment>
<function><type><name>sqlite3_backup</name> <modifier>*</modifier><modifier>*</modifier></type><name>sqlite3PagerBackupPtr</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>pBackup</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VACUUM</name></cpp:ifndef>
<comment type="block">/*
** Unless this is an in-memory or temporary database, clear the pager cache.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerClearCache</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>MEMDB</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pager_reset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
<comment type="block">/*
** This function is called when the user invokes "PRAGMA wal_checkpoint",
** "PRAGMA wal_blocking_checkpoint" or calls the sqlite3_wal_checkpoint()
** or wal_blocking_checkpoint() API functions.
**
** Parameter eMode is one of SQLITE_CHECKPOINT_PASSIVE, FULL or RESTART.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerCheckpoint</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,                  <comment type="block">/* Checkpoint on this pager */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Db handle used to check for interrupts */</comment>
  <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>,                      <comment type="block">/* Type of checkpoint */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnLog</name></decl></parameter>,                     <comment type="block">/* OUT: Final number of frames in log */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnCkpt</name></decl></parameter>                     <comment type="block">/* OUT: Final number of checkpointed frames */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This only happens when a database file is zero bytes in size opened and
    ** then "PRAGMA journal_mode=WAL" is run and then sqlite3_wal_checkpoint()
    ** is invoked without any intervening transactions.  We need to start
    ** a transaction to initialize pWal.  The PRAGMA table_list statement is
    ** used for this since it starts transactions on every database file,
    ** including all ATTACHed databases.  This seems expensive for a single
    ** sqlite3_wal_checkpoint() call, but it happens very rarely.
    ** https://sqlite.org/forum/forumpost/fd0f19d229156939
    */</comment>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA table_list"</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalCheckpoint</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>eMode</name></expr></argument>,
        <argument><expr><operator>(</operator><ternary><condition><expr><name>eMode</name><operator>==</operator><name>SQLITE_CHECKPOINT_PASSIVE</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>pPager</name><operator>-&gt;</operator><name>xBusyHandler</name></name></expr></else></ternary><operator>)</operator></expr></argument>,
        <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pBusyHandlerArg</name></name></expr></argument>,
        <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>walSyncFlags</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr></argument>,
        <argument><expr><name>pnLog</name></expr></argument>, <argument><expr><name>pnCkpt</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlite3PagerWalCallback</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3WalCallback</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the underlying VFS for the given pager supports the
** primitives necessary for write-ahead logging.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerWalSupported</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_io_methods</name> <modifier>*</modifier></type><name>pMethods</name> <init>= <expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name><operator>-&gt;</operator><name>pMethods</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>noLock</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name> <operator>||</operator> <operator>(</operator><name><name>pMethods</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&gt;=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>pMethods</name><operator>-&gt;</operator><name>xShmMap</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to take an exclusive lock on the database file. If a PENDING lock
** is obtained instead, immediately release it.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerExclusiveLock</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>SHARED_LOCK</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerLockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If the attempt to grab the exclusive lock failed, release the 
    ** pending lock that may have been obtained instead.  */</comment>
    <expr_stmt><expr><call><name>pagerUnlockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Call sqlite3WalOpen() to open the WAL handle. If the pager is in 
** exclusive-locking mode when this function is called, take an EXCLUSIVE
** lock on the database file and use heap-memory to store the wal-index
** in. Otherwise, use the normal shared-memory.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pagerOpenWal</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>SHARED_LOCK</name> <operator>||</operator> <name><name>pPager</name><operator>-&gt;</operator><name>eLock</name></name><operator>==</operator><name>EXCLUSIVE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the pager is already in exclusive-mode, the WAL module will use 
  ** heap-memory for the wal-index instead of the VFS shared-memory 
  ** implementation. Take the exclusive lock now, before opening the WAL
  ** file, to make sure this is safe.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerExclusiveLock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Open the connection to the log file. If this operation fails, 
  ** (e.g. due to malloc() failure), return an error code.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>,
        <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zWal</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name></expr></argument>,
        <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalSizeLimit</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>pagerFixMaplimit</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** The caller must be holding a SHARED lock on the database file to call
** this function.
**
** If the pager passed as the first argument is open on a real database
** file (not a temp file or an in-memory database), and the WAL file
** is not already open, make an attempt to open it now. If successful,
** return SQLITE_OK. If an error occurs or the VFS used by the pager does 
** not support the xShmXXX() methods, return an error code. *pbOpen is
** not modified in either case.
**
** If the pager is open on a temp-file (or in-memory database), or if
** the WAL file is already open, set *pbOpen to 1 and return SQLITE_OK
** without doing anything.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerOpenWal</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>,                  <comment type="block">/* Pager object */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbOpen</name></decl></parameter>                     <comment type="block">/* OUT: Set to true if call is a no-op */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>assert_pager_state</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_OPEN</name>   <operator>||</operator> <name>pbOpen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>PAGER_READER</name> <operator>||</operator> <operator>!</operator><name>pbOpen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pbOpen</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>pbOpen</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pbOpen</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>tempFile</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3PagerWalSupported</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CANTOPEN</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Close any rollback journal previously open */</comment>
    <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>jfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerOpenWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name> <operator>=</operator> <name>PAGER_JOURNALMODE_WAL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_OPEN</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pbOpen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to close the connection to the log file prior
** to switching from WAL to rollback mode.
**
** Before closing the log file, this function attempts to take an 
** EXCLUSIVE lock on the database file. If this cannot be obtained, an
** error (SQLITE_BUSY) is returned and the log connection is not closed.
** If successful, the EXCLUSIVE lock is not released before returning.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerCloseWal</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>journalMode</name></name><operator>==</operator><name>PAGER_JOURNALMODE_WAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the log file is not already open, but does exist in the file-system,
  ** it may need to be checkpointed before the connection can switch to
  ** rollback mode. Open it now so this can happen.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>logexists</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerLockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsAccess</name><argument_list>(
          <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>zWal</name></name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>logexists</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>logexists</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerOpenWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
    
  <comment type="block">/* Checkpoint and close the log. Because an EXCLUSIVE lock is held on
  ** the database file, the log and log-summary files will be deleted.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pagerExclusiveLock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalClose</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>walSyncFlags</name></name></expr></argument>,
                           <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pageSize</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pPager</name><operator>-&gt;</operator><name>pTmpSpace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pagerFixMaplimit</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pagerUnlockDb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SETLK_TIMEOUT</name></cpp:ifdef>
<comment type="block">/*
** If pager pPager is a wal-mode database not in exclusive locking mode,
** invoke the sqlite3WalWriteLock() function on the associated Wal object 
** with the same db and bLock parameters as were passed to this function.
** Return an SQLite error code if an error occurs, or SQLITE_OK otherwise.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerWalWriteLock</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pPager</name><operator>-&gt;</operator><name>exclusiveMode</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalWriteLock</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name>bLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the database handle used by the wal layer to determine if 
** blocking locks are required.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerWalDb</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>pagerUseWal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3WalDb</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SNAPSHOT</name></cpp:ifdef>
<comment type="block">/*
** If this is a WAL database, obtain a snapshot handle for the snapshot
** currently open. Otherwise, return an error.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerSnapshotGet</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>sqlite3_snapshot</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppSnapshot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_ERROR</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalSnapshotGet</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name>ppSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If this is a WAL database, store a pointer to pSnapshot. Next time a
** read transaction is opened, attempt to read from the snapshot it 
** identifies. If this is not a WAL database, return an error.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerSnapshotOpen</name><parameter_list>(
  <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_snapshot</name> <modifier>*</modifier></type><name>pSnapshot</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3WalSnapshotOpen</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name>pSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If this is a WAL database, call sqlite3WalSnapshotRecover(). If this 
** is not a WAL database, return an error.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerSnapshotRecover</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalSnapshotRecover</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The caller currently has a read transaction open on the database.
** If this is not a WAL database, SQLITE_ERROR is returned. Otherwise,
** this function takes a SHARED lock on the CHECKPOINTER slot and then
** checks if the snapshot passed as the second argument is still 
** available. If so, SQLITE_OK is returned.
**
** If the snapshot is not available, SQLITE_ERROR is returned. Or, if
** the CHECKPOINTER lock cannot be obtained, SQLITE_BUSY. If any error
** occurs (any value other than SQLITE_OK is returned), the CHECKPOINTER
** lock is released before returning.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerSnapshotCheck</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>sqlite3_snapshot</name> <modifier>*</modifier></type><name>pSnapshot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3WalSnapshotCheck</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>, <argument><expr><name>pSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Release a lock obtained by an earlier successful call to
** sqlite3PagerSnapshotCheck().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerSnapshotUnlock</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalSnapshotUnlock</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_SNAPSHOT */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_OMIT_WAL */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ZIPVFS</name></cpp:ifdef>
<comment type="block">/*
** A read-lock must be held on the pager when this function is called. If
** the pager is in WAL mode and the WAL file currently contains one or more
** frames, return the size in bytes of the page images stored within the
** WAL frames. Otherwise, if this is not a WAL database or the WAL file
** is empty, return 0.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerWalFramesize</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name><operator>&gt;=</operator><name>PAGER_READER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3WalFramesize</name><argument_list>(<argument><expr><name><name>pPager</name><operator>-&gt;</operator><name>pWal</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_DISKIO */</comment>

<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>

<function><type><name>int</name></type> <name>sqlite3pager_is_sj_pgno</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><operator>(</operator><call><name>PAGER_SJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pgno</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sqlite3pager_error</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPager</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>PAGER_ERROR</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setGetterMethod</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sqlite3pager_reset</name><parameter_list>(<parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>pager_reset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>

</unit>
