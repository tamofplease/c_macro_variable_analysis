<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/main.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Main file for the SQLite library.  The routines in this file
** implement the programmer interface to the library.  Routines in
** other files are for internal use by SQLite and should not be
** accessed by users of the library.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS3</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"fts3.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_RTREE</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"rtree.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_ICU</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_ICU_COLLATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"sqliteicu.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This is an extension initializer that is a no-op and always
** succeeds, except that it fails if the fault-simulation is set
** to 500.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlite3TestExtInit</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>db</name></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3FaultSim</name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Forward declarations of external module initializer functions
** for modules that need them.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS1</name></cpp:ifdef>
<function_decl><type><name>int</name></type> <name>sqlite3Fts1Init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS2</name></cpp:ifdef>
<function_decl><type><name>int</name></type> <name>sqlite3Fts2Init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS5</name></cpp:ifdef>
<function_decl><type><name>int</name></type> <name>sqlite3Fts5Init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMTVTAB</name></cpp:ifdef>
<function_decl><type><name>int</name></type> <name>sqlite3StmtVtabInit</name><parameter_list>(<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** An array of pointers to extension initializer functions for
** built-in extensions.
*/</comment>
<expr_stmt><expr><specifier>static</specifier> <call><call><name>int</name> <argument_list>(<argument><expr><operator>*</operator><specifier>const</specifier> <name><name>sqlite3BuiltinExtensions</name><index>[]</index></name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>)</argument_list></call> <operator>=</operator> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS1</name></cpp:ifdef>
  <expr><name>sqlite3Fts1Init</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS2</name></cpp:ifdef>
  <expr><name>sqlite3Fts2Init</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS3</name></cpp:ifdef>
  <expr><name>sqlite3Fts3Init</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS5</name></cpp:ifdef>
  <expr><name>sqlite3Fts5Init</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_ICU</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_ICU_COLLATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><name>sqlite3IcuInit</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_RTREE</name></cpp:ifdef>
  <expr><name>sqlite3RtreeInit</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_DBPAGE_VTAB</name></cpp:ifdef>
  <expr><name>sqlite3DbpageRegister</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_DBSTAT_VTAB</name></cpp:ifdef>
  <expr><name>sqlite3DbstatRegister</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><name>sqlite3TestExtInit</name></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_JSON</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><name>sqlite3JsonTableFunctions</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMTVTAB</name></cpp:ifdef>
  <expr><name>sqlite3StmtVtabInit</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_BYTECODE_VTAB</name></cpp:ifdef>
  <expr><name>sqlite3VdbeBytecodeVtabInit</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>
<comment type="block">/* IMPLEMENTATION-OF: R-46656-45156 The sqlite3_version[] string constant
** contains the text of SQLITE_VERSION macro.
*/</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>sqlite3_version</name><index>[]</index></name> <init>= <expr><name>SQLITE_VERSION</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* IMPLEMENTATION-OF: R-53536-42575 The sqlite3_libversion() function returns
** a pointer to the to the sqlite3_version[] string constant. 
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_libversion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><name>sqlite3_version</name></expr>;</return> </block_content>}</block></function>

<comment type="block">/* IMPLEMENTATION-OF: R-25063-23286 The sqlite3_sourceid() function returns a
** pointer to a string constant whose value is the same as the
** SQLITE_SOURCE_ID C preprocessor macro. Except if SQLite is built using
** an edited copy of the amalgamation, then the last four characters of
** the hash might be different from SQLITE_SOURCE_ID.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_sourceid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><name>SQLITE_SOURCE_ID</name></expr>;</return> </block_content>}</block></function>

<comment type="block">/* IMPLEMENTATION-OF: R-35210-63508 The sqlite3_libversion_number() function
** returns an integer equal to SQLITE_VERSION_NUMBER.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_libversion_number</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><name>SQLITE_VERSION_NUMBER</name></expr>;</return> </block_content>}</block></function>

<comment type="block">/* IMPLEMENTATION-OF: R-20790-14025 The sqlite3_threadsafe() function returns
** zero if and only if SQLite was compiled with mutexing code omitted due to
** the SQLITE_THREADSAFE compile-time option being set to 0.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_threadsafe</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><name>SQLITE_THREADSAFE</name></expr>;</return> </block_content>}</block></function>

<comment type="block">/*
** When compiling the test fixture or with debugging enabled (on Win32),
** this variable being set to non-zero will cause OSTRACE macros to emit
** extra diagnostic information.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAVE_OS_TRACE</name></cpp:ifdef>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>SQLITE_DEBUG_OS_TRACE</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_DEBUG_OS_TRACE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>sqlite3OSTrace</name> <init>= <expr><name>SQLITE_DEBUG_OS_TRACE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRACE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_IOTRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** If the following function pointer is not NULL and if
** SQLITE_ENABLE_IOTRACE is enabled, then messages describing
** I/O active are written using this function.  These messages
** are intended for debugging activity only.
*/</comment>
<function_decl><type><name>SQLITE_API</name> <name>void</name></type> (<name>SQLITE_CDECL</name> <modifier>*</modifier><name>sqlite3IoTrace</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** If the following global variable points to a string which is the
** name of a directory, then that directory will be used to store
** temporary files.
**
** See also the "PRAGMA temp_store_directory" SQL command.
*/</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sqlite3_temp_directory</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** If the following global variable points to a string which is the
** name of a directory, then that directory will be used to store
** all database files specified with a relative pathname.
**
** See also the "PRAGMA data_store_directory" SQL command.
*/</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sqlite3_data_directory</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Initialize SQLite.  
**
** This routine must be called to initialize the memory allocation,
** VFS, and mutex subsystems prior to doing any serious work with
** SQLite.  But as long as you do not compile with SQLITE_OMIT_AUTOINIT
** this routine will be called automatically by key routines such as
** sqlite3_open().  
**
** This routine is a no-op except on its very first call for the process,
** or for the first call after a call to sqlite3_shutdown.
**
** The first thread to call this routine runs the initialization to
** completion.  If subsequent threads call this routine before the first
** thread has finished the initialization process, then the subsequent
** threads must block until the first thread finishes with the initialization.
**
** The first thread might call this routine recursively.  Recursive
** calls to this routine should not block, of course.  Otherwise the
** initialization process would never complete.
**
** Let X be the first thread to enter this routine.  Let Y be some other
** thread.  Then while the initial invocation of this routine by X is
** incomplete, it is required that:
**
**    *  Calls to this routine from Y must block until the outer-most
**       call by X completes.
**
**    *  Recursive calls to this routine from thread X return immediately
**       without blocking.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_initialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <macro><name>MUTEX_LOGIC</name><argument_list>( <argument>sqlite3_mutex *pMainMtx;</argument> )</argument_list></macro>      <comment type="block">/* The main static mutex */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                                      <comment type="block">/* Result code */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EXTRA_INIT</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>bRunExtraInit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                       <comment type="block">/* Extra initialization needed */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_WSD</name></cpp:ifdef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_wsd_init</name><argument_list>(<argument><expr><literal type="number">4096</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If the following assert() fails on some obscure processor/compiler
  ** combination, the work-around is to set the correct pointer
  ** size at compile-time using -DSQLITE_PTRSIZE=n compile-time option */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_PTRSIZE</name><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If SQLite is already completely initialized, then this call
  ** to sqlite3_initialize() should be a no-op.  But the initialization
  ** must be complete.  So isInit must not be set until the very end
  ** of this routine.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isInit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3MemoryBarrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make sure the mutex subsystem is initialized.  If unable to 
  ** initialize the mutex subsystem, return early with the error.
  ** If the system is so sick that we are unable to allocate a mutex,
  ** there is not much SQLite is going to be able to do.
  **
  ** The mutex subsystem must take care of serializing its own
  ** initialization.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3MutexInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Initialize the malloc() system and the recursive pInitMutex mutex.
  ** This operation is protected by the STATIC_MAIN mutex.  Note that
  ** MutexAlloc() is called for a static mutex prior to initializing the
  ** malloc subsystem - this implies that the allocation of a static
  ** mutex must not require support from the malloc subsystem.
  */</comment>
  <macro><name>MUTEX_LOGIC</name><argument_list>( <argument>pMainMtx = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);</argument> )</argument_list></macro>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>pMainMtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isMutexInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isMallocInit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3MallocInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isMallocInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pInitMutex</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pInitMutex</name></name> <operator>=</operator>
           <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_RECURSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pInitMutex</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nRefInitMutex</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>pMainMtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If rc is not SQLITE_OK at this point, then either the malloc
  ** subsystem could not be initialized or the system failed to allocate
  ** the pInitMutex mutex. Return an error in either case.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Do the rest of the initialization under the recursive mutex so
  ** that we will be able to handle recursive calls into
  ** sqlite3_initialize().  The recursive calls normally come through
  ** sqlite3_os_init() when it invokes sqlite3_vfs_register(), but other
  ** recursive calls might also be possible.
  **
  ** IMPLEMENTATION-OF: R-00140-37445 SQLite automatically serializes calls
  ** to the xInit method, so the xInit method need not be threadsafe.
  **
  ** The following mutex is what serializes access to the appdef pcache xInit
  ** methods.  The sqlite3_pcache_methods.xInit() all is embedded in the
  ** call to sqlite3PcacheInitialize().
  */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pInitMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isInit</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>inProgress</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>inProgress</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SQLLOG</name></cpp:ifdef>
    <block>{<block_content>
      <decl_stmt><decl><type><specifier>extern</specifier> <name>void</name></type> <name>sqlite3_init_sqllog</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_init_sqllog</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sqlite3BuiltinFunctions</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3BuiltinFunctions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3RegisterBuiltinFunctions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isPCacheInit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PcacheInitialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isPCacheInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DESERIALIZE</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3MemdbInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PCacheBufferSetup</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pPage</name></name></expr></argument>, 
          <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szPage</name></name></expr></argument>, <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3MemoryBarrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EXTRA_INIT</name></cpp:ifdef>
      <expr_stmt><expr><name>bRunExtraInit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>inProgress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pInitMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Go back under the static mutex and clean up the recursive
  ** mutex to prevent a resource leak.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>pMainMtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nRefInitMutex</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nRefInitMutex</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nRefInitMutex</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_free</name><argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pInitMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pInitMutex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>pMainMtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The following is just a sanity check to make sure SQLite has
  ** been compiled correctly.  It is important to run this code, but
  ** we don't want to run it too often and soak up CPU cycles for no
  ** reason.  So we run it once during initialization.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
  <comment type="block">/* This section of code's only "output" is via assert() statements. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>x</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">63</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>y</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Do extra initialization steps requested by the SQLITE_EXTRA_INIT
  ** compile-time option.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EXTRA_INIT</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>bRunExtraInit</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>SQLITE_EXTRA_INIT</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SQLITE_EXTRA_INIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Undo the effects of sqlite3_initialize().  Must not be called while
** there are outstanding database connections or memory allocations or
** while any part of SQLite is otherwise in use in any thread.  This
** routine is not threadsafe.  But it is safe to invoke this routine
** on when SQLite is already shut down.  If SQLite is already shut down
** when this routine is invoked, then this routine is a harmless no-op.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_shutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_WSD</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_wsd_init</name><argument_list>(<argument><expr><literal type="number">4096</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isInit</name></name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EXTRA_SHUTDOWN</name></cpp:ifdef>
    <decl_stmt><decl><type><name>void</name></type> <name>SQLITE_EXTRA_SHUTDOWN</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SQLITE_EXTRA_SHUTDOWN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3_os_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_reset_auto_extension</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isPCacheInit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3PcacheShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isPCacheInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isMallocInit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3MallocEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isMallocInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHUTDOWN_DIRECTORIES</name></cpp:ifndef>
    <comment type="block">/* The heap subsystem has now been shutdown and these values are supposed
    ** to be NULL or point to memory that was obtained from sqlite3_malloc(),
    ** which would rely on that heap subsystem; therefore, make sure these
    ** values cannot refer to heap memory that was just invalidated when the
    ** heap subsystem was shutdown.  This is only done if the current call to
    ** this function resulted in the heap subsystem actually being shutdown.
    */</comment>
    <expr_stmt><expr><name>sqlite3_data_directory</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>sqlite3_temp_directory</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isMutexInit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3MutexEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isMutexInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This API allows applications to modify the global configuration of
** the SQLite library at run-time.
**
** This routine should only be called when there are no outstanding
** database connections or memory allocations.  This routine is not
** threadsafe.  Failure to heed these warnings can lead to unpredictable
** behavior.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_config</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* sqlite3_config() shall return SQLITE_MISUSE if it is invoked while
  ** the SQLite library is in use. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isInit</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>

    <comment type="block">/* Mutex configuration options are only available in a threadsafe
    ** compile.
    */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_THREADSAFE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>  <comment type="block">/* IMP: R-54466-46756 */</comment>
    <case>case <expr><name>SQLITE_CONFIG_SINGLETHREAD</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-02748-19096 This option sets the threading mode to
      ** Single-thread. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Disable mutex on core */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bFullMutex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Disable mutex on connections */</comment>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_THREADSAFE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* IMP: R-20520-54086 */</comment>
    <case>case <expr><name>SQLITE_CONFIG_MULTITHREAD</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-14374-42468 This option sets the threading mode to
      ** Multi-thread. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Enable mutex on core */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bFullMutex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Disable mutex on connections */</comment>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_THREADSAFE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* IMP: R-59593-21810 */</comment>
    <case>case <expr><name>SQLITE_CONFIG_SERIALIZED</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-41220-51800 This option sets the threading mode to
      ** Serialized. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Enable mutex on core */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bFullMutex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Enable mutex on connections */</comment>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_THREADSAFE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* IMP: R-63666-48755 */</comment>
    <case>case <expr><name>SQLITE_CONFIG_MUTEX</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* Specify an alternative mutex implementation */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mutex</name></name> <operator>=</operator> <operator>*</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_mutex_methods</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_THREADSAFE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* IMP: R-14450-37597 */</comment>
    <case>case <expr><name>SQLITE_CONFIG_GETMUTEX</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* Retrieve the current mutex implementation */</comment>
      <expr_stmt><expr><operator>*</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_mutex_methods</name><operator>*</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mutex</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>SQLITE_CONFIG_MALLOC</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-55594-21030 The SQLITE_CONFIG_MALLOC option takes a
      ** single argument which is a pointer to an instance of the
      ** sqlite3_mem_methods structure. The argument specifies alternative
      ** low-level memory allocation routines to be used in place of the memory
      ** allocation routines built into SQLite. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>m</name></name> <operator>=</operator> <operator>*</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_mem_methods</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_CONFIG_GETMALLOC</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-51213-46414 The SQLITE_CONFIG_GETMALLOC option takes a
      ** single argument which is a pointer to an instance of the
      ** sqlite3_mem_methods structure. The sqlite3_mem_methods structure is
      ** filled with the currently defined memory allocation routines. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>m</name><operator>.</operator><name>xMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3MemSetDefault</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_mem_methods</name><operator>*</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>m</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_CONFIG_MEMSTATUS</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-61275-35157 The SQLITE_CONFIG_MEMSTATUS option takes
      ** single argument of type int, interpreted as a boolean, which enables
      ** or disables the collection of memory allocation statistics. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bMemstat</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_CONFIG_SMALL_MALLOC</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bSmallMalloc</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_CONFIG_PAGECACHE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-18761-36601 There are three arguments to
      ** SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem),
      ** the size of each page cache line (sz), and the number of cache lines
      ** (N). */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pPage</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szPage</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nPage</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_CONFIG_PCACHE_HDRSZ</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-39100-27317 The SQLITE_CONFIG_PCACHE_HDRSZ option takes
      ** a single parameter which is a pointer to an integer and writes into
      ** that integer the number of extra bytes per page required for each page
      ** in SQLITE_CONFIG_PAGECACHE. */</comment>
      <expr_stmt><expr><operator>*</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name><operator>*</operator></expr></argument>)</argument_list></call> <operator>=</operator> 
          <call><name>sqlite3HeaderSizeBtree</name><argument_list>()</argument_list></call> <operator>+</operator>
          <call><name>sqlite3HeaderSizePcache</name><argument_list>()</argument_list></call> <operator>+</operator>
          <call><name>sqlite3HeaderSizePcache1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>SQLITE_CONFIG_PCACHE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* no-op */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_CONFIG_GETPCACHE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* now an error */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>SQLITE_CONFIG_PCACHE2</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-63325-48378 The SQLITE_CONFIG_PCACHE2 option takes a
      ** single argument which is a pointer to an sqlite3_pcache_methods2
      ** object. This object specifies the interface to a custom page cache
      ** implementation. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name></name> <operator>=</operator> <operator>*</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_pcache_methods2</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_CONFIG_GETPCACHE2</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-22035-46182 The SQLITE_CONFIG_GETPCACHE2 option takes a
      ** single argument which is a pointer to an sqlite3_pcache_methods2
      ** object. SQLite copies of the current page cache implementation into
      ** that object. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xInit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3PCacheSetDefault</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_pcache_methods2</name><operator>*</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

<comment type="block">/* EVIDENCE-OF: R-06626-12911 The SQLITE_CONFIG_HEAP option is only
** available if SQLite is compiled with either SQLITE_ENABLE_MEMSYS3 or
** SQLITE_ENABLE_MEMSYS5 and returns SQLITE_ERROR if invoked otherwise. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_MEMSYS3</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_MEMSYS5</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <case>case <expr><name>SQLITE_CONFIG_HEAP</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-19854-42126 There are three arguments to
      ** SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the
      ** number of bytes in the memory buffer, and the minimum allocation size.
      */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pHeap</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nHeap</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mnReq</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mnReq</name></name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mnReq</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mnReq</name></name><operator>&gt;</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">12</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <comment type="block">/* cap min request size at 2^12 */</comment>
        <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mnReq</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pHeap</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* EVIDENCE-OF: R-49920-60189 If the first pointer (the memory pointer)
        ** is NULL, then SQLite reverts to using its default memory allocator
        ** (the system malloc() implementation), undoing any prior invocation of
        ** SQLITE_CONFIG_MALLOC.
        **
        ** Setting sqlite3GlobalConfig.m to all zeros will cause malloc to
        ** revert to its default implementation when sqlite3_initialize() is run
        */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>m</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>m</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* EVIDENCE-OF: R-61006-08918 If the memory pointer is not NULL then the
        ** alternative memory allocator is engaged to handle all of SQLites
        ** memory allocation needs. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMSYS3</name></cpp:ifdef>
        <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>m</name></name> <operator>=</operator> <operator>*</operator><call><name>sqlite3MemGetMemsys3</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMSYS5</name></cpp:ifdef>
        <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>m</name></name> <operator>=</operator> <operator>*</operator><call><name>sqlite3MemGetMemsys5</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>SQLITE_CONFIG_LOOKASIDE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szLookaside</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nLookaside</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    
    <comment type="block">/* Record a pointer to the logger function and its first argument.
    ** The default is NULL.  Logging is disabled if the function pointer is
    ** NULL.
    */</comment>
    <case>case <expr><name>SQLITE_CONFIG_LOG</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* MSVC is picky about pulling func ptrs from va lists.
      ** http://support.microsoft.com/kb/47961
      ** sqlite3GlobalConfig.xLog = va_arg(ap, void(*)(void*,int,const char*));
      */</comment>
      <typedef>typedef <function_decl><type><name>void</name></type>(<modifier>*</modifier><name>LOGFUNC_t</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>LOGFUNC_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pLogArg</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/* EVIDENCE-OF: R-55548-33817 The compile-time setting for URI filenames
    ** can be changed at start-time using the
    ** sqlite3_config(SQLITE_CONFIG_URI,1) or
    ** sqlite3_config(SQLITE_CONFIG_URI,0) configuration calls.
    */</comment>
    <case>case <expr><name>SQLITE_CONFIG_URI</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-25451-61125 The SQLITE_CONFIG_URI option takes a single
      ** argument of type int. If non-zero, then URI handling is globally
      ** enabled. If the parameter is zero, then URI handling is globally
      ** disabled. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bOpenUri</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>SQLITE_CONFIG_COVERING_INDEX_SCAN</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-36592-02772 The SQLITE_CONFIG_COVERING_INDEX_SCAN
      ** option takes a single integer argument which is interpreted as a
      ** boolean in order to enable or disable the use of covering indices for
      ** full table scans in the query optimizer. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bUseCis</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SQLLOG</name></cpp:ifdef>
    <case>case <expr><name>SQLITE_CONFIG_SQLLOG</name></expr>:</case> <block>{<block_content>
      <typedef>typedef <function_decl><type><name>void</name></type>(<modifier>*</modifier><name>SQLLOGFUNC_t</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xSqllog</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>SQLLOGFUNC_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pSqllogArg</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>SQLITE_CONFIG_MMAP_SIZE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-58063-38258 SQLITE_CONFIG_MMAP_SIZE takes two 64-bit
      ** integer (sqlite3_int64) values that are the default mmap size limit
      ** (the default setting for PRAGMA mmap_size) and the maximum allowed
      ** mmap size limit. */</comment>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>szMmap</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_int64</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>mxMmap</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_int64</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="block">/* EVIDENCE-OF: R-53367-43190 If either argument to this option is
      ** negative, then that argument is changed to its compile-time default.
      **
      ** EVIDENCE-OF: R-34993-45031 The maximum allowed mmap size will be
      ** silently truncated if necessary so that it does not exceed the
      ** compile-time maximum mmap size set by the SQLITE_MAX_MMAP_SIZE
      ** compile-time option.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>mxMmap</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>mxMmap</name></expr></argument>&gt;</argument_list></name><name>SQLITE_MAX_MMAP_SIZE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>mxMmap</name> <operator>=</operator> <name>SQLITE_MAX_MMAP_SIZE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>szMmap</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>szMmap</name> <operator>=</operator> <name>SQLITE_DEFAULT_MMAP_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>szMmap</name><operator>&gt;</operator><name>mxMmap</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>szMmap</name> <operator>=</operator> <name>mxMmap</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mxMmap</name></name> <operator>=</operator> <name>mxMmap</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szMmap</name></name> <operator>=</operator> <name>szMmap</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_MALLOC</name></expr></argument>)</argument_list></call></expr></cpp:if> <comment type="block">/* IMP: R-04780-55815 */</comment>
    <case>case <expr><name>SQLITE_CONFIG_WIN32_HEAPSIZE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-34926-03360 SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit
      ** unsigned integer value that specifies the maximum size of the created
      ** heap. */</comment>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nHeap</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>SQLITE_CONFIG_PMASZ</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szPma</name></name> <operator>=</operator> <macro><name>va_arg</name><argument_list>(<argument>ap</argument>, <argument>unsigned int</argument>)</argument_list></macro></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>SQLITE_CONFIG_STMTJRNL_SPILL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nStmtSpill</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
    <case>case <expr><name>SQLITE_CONFIG_SORTERREF_SIZE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iVal</name> <operator>=</operator> <name>SQLITE_DEFAULT_SORTERREF_SIZE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szSorterRef</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>iVal</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_SORTER_REFERENCES */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DESERIALIZE</name></cpp:ifndef>
    <case>case <expr><name>SQLITE_CONFIG_MEMDB_MAXSIZE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mxMemdbSize</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_int64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_DESERIALIZE */</comment>

    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set up the lookaside buffers for a database connection.
** Return SQLITE_OK on success.  
** If lookaside is already active, return SQLITE_BUSY.
**
** The sz parameter is the number of bytes in each lookaside slot.
** The cnt parameter is the number of slots.  If pStart is NULL the
** space for the lookaside memory is obtained from sqlite3_malloc().
** If pStart is not NULL then it is sz*cnt bytes of memory to use for
** the lookaside memory.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>setupLookaside</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOOKASIDE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>szAlloc</name> <init>= <expr><name>sz</name><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>cnt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBig</name></decl>;</decl_stmt>   <comment type="block">/* Number of full-size slots */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSm</name></decl>;</decl_stmt>    <comment type="block">/* Number smaller LOOKASIDE_SMALL-byte slots */</comment>
  
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3LookasideUsed</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Free any existing lookaside buffer for this handle before
  ** allocating a new one so we don't have to have space for 
  ** both at the same time.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>bMalloced</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* The size of a lookaside slot after ROUNDDOWN8 needs to be larger
  ** than a pointer to be useful.
  */</comment>
  <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>ROUNDDOWN8</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* IMP: R-33038-09382 */</comment>
  <if_stmt><if>if<condition>( <expr><name>sz</name><operator>&lt;=</operator><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>LookasideSlot</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>sz</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>cnt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStart</name> <operator>=</operator> <call><name>sqlite3Malloc</name><argument_list>( <argument><expr><name>szAlloc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* IMP: R-61949-35727 */</comment>
    <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pStart</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>szAlloc</name> <operator>=</operator> <call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>pStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pStart</name> <operator>=</operator> <name>pBuf</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TWOSIZE_LOOKASIDE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>sz</name><operator>&gt;=</operator><name>LOOKASIDE_SMALL</name><operator>*</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nBig</name> <operator>=</operator> <name>szAlloc</name><operator>/</operator><operator>(</operator><literal type="number">3</literal><operator>*</operator><name>LOOKASIDE_SMALL</name><operator>+</operator><name>sz</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSm</name> <operator>=</operator> <operator>(</operator><name>szAlloc</name> <operator>-</operator> <name>sz</name><operator>*</operator><name>nBig</name><operator>)</operator><operator>/</operator><name>LOOKASIDE_SMALL</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>sz</name><operator>&gt;=</operator><name>LOOKASIDE_SMALL</name><operator>*</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nBig</name> <operator>=</operator> <name>szAlloc</name><operator>/</operator><operator>(</operator><name>LOOKASIDE_SMALL</name><operator>+</operator><name>sz</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSm</name> <operator>=</operator> <operator>(</operator><name>szAlloc</name> <operator>-</operator> <name>sz</name><operator>*</operator><name>nBig</name><operator>)</operator><operator>/</operator><name>LOOKASIDE_SMALL</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TWOSIZE_LOOKASIDE */</comment>
  if<condition>( <expr><name>sz</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nBig</name> <operator>=</operator> <name>szAlloc</name><operator>/</operator><name>sz</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nBig</name> <operator>=</operator> <name>nSm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pStart</name></name> <operator>=</operator> <name>pStart</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>sz</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>sz</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>szTrue</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>sz</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStart</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LookasideSlot</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>LookasideSlot</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>LookasideSlot</name><operator>*</operator><operator>)</operator><name>pStart</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nBig</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pInit</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pInit</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>LookasideSlot</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><name>sz</name></expr>]</index></expr>;</expr_stmt>
    </block_content>}</block></for>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TWOSIZE_LOOKASIDE</name></cpp:ifndef>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pSmallInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pSmallFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pMiddle</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nSm</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pSmallInit</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pSmallInit</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>LookasideSlot</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><name>LOOKASIDE_SMALL</name></expr>]</index></expr>;</expr_stmt>
    </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TWOSIZE_LOOKASIDE */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><name>uptr</name><operator>)</operator><name>p</name><operator>)</operator><operator>&lt;=</operator><name>szAlloc</name> <operator>+</operator> <operator>(</operator><name>uptr</name><operator>)</operator><name>pStart</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pEnd</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>bDisable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>bMalloced</name></name> <operator>=</operator> <ternary><condition><expr><name>pBuf</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>nSlot</name></name> <operator>=</operator> <name>nBig</name><operator>+</operator><name>nSm</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pStart</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TWOSIZE_LOOKASIDE</name></cpp:ifndef>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pSmallInit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pSmallFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pMiddle</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TWOSIZE_LOOKASIDE */</comment>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pEnd</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>bDisable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>sz</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>bMalloced</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>nSlot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3LookasideUsed</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_LOOKASIDE */</comment>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the mutex associated with a database connection.
*/</comment>
<function><type><name>sqlite3_mutex</name> <modifier>*</modifier></type><name>sqlite3_db_mutex</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free up as much memory as we can from the given database
** connection.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_db_release_memory</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerShrink</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Flush any dirty pages in the pager-cache for any attached database
** to disk.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_db_cacheflush</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bSeenBusy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBt</name> <operator>&amp;&amp;</operator> <call><name>sqlite3BtreeTxnState</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_TXN_WRITE</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerFlush</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bSeenBusy</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bSeenBusy</name><operator>)</operator></expr> ?</condition><then> <expr><name>SQLITE_BUSY</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Configuration settings for an individual database connection
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_db_config</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_DBCONFIG_MAINDBNAME</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* IMP: R-06824-28531 */</comment>
      <comment type="block">/* IMP: R-36257-52125 */</comment>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zDbSName</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_DBCONFIG_LOOKASIDE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* IMP: R-26835-10964 */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>       <comment type="block">/* IMP: R-47871-25994 */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>      <comment type="block">/* IMP: R-04460-53386 */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>setupLookaside</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>      <comment type="block">/* The opcode */</comment>
        <decl_stmt><decl><type><name>u32</name></type> <name>mask</name></decl>;</decl_stmt>    <comment type="block">/* Mask of the bit in sqlite3.flags to set/clear */</comment>
      }</block> <decl><name><name>aFlagOp</name><index>[]</index></name> <init>= <expr><block>{
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_ENABLE_FKEY</name></expr>,           <expr><name>SQLITE_ForeignKeys</name></expr>    }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_ENABLE_TRIGGER</name></expr>,        <expr><name>SQLITE_EnableTrigger</name></expr>  }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_ENABLE_VIEW</name></expr>,           <expr><name>SQLITE_EnableView</name></expr>     }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER</name></expr>, <expr><name>SQLITE_Fts3Tokenizer</name></expr>  }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION</name></expr>, <expr><name>SQLITE_LoadExtension</name></expr>  }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE</name></expr>,      <expr><name>SQLITE_NoCkptOnClose</name></expr>  }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_ENABLE_QPSG</name></expr>,           <expr><name>SQLITE_EnableQPSG</name></expr>     }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_TRIGGER_EQP</name></expr>,           <expr><name>SQLITE_TriggerEQP</name></expr>     }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_RESET_DATABASE</name></expr>,        <expr><name>SQLITE_ResetDatabase</name></expr>  }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_DEFENSIVE</name></expr>,             <expr><name>SQLITE_Defensive</name></expr>      }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_WRITABLE_SCHEMA</name></expr>,       <expr><name>SQLITE_WriteSchema</name><operator>|</operator>
                                                 <name>SQLITE_NoSchemaError</name></expr>  }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_LEGACY_ALTER_TABLE</name></expr>,    <expr><name>SQLITE_LegacyAlter</name></expr>    }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_DQS_DDL</name></expr>,               <expr><name>SQLITE_DqsDDL</name></expr>         }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_DQS_DML</name></expr>,               <expr><name>SQLITE_DqsDML</name></expr>         }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_LEGACY_FILE_FORMAT</name></expr>,    <expr><name>SQLITE_LegacyFileFmt</name></expr>  }</block></expr>,
        <expr><block>{ <expr><name>SQLITE_DBCONFIG_TRUSTED_SCHEMA</name></expr>,        <expr><name>SQLITE_TrustedSchema</name></expr>  }</block></expr>,
      }</block></expr></init></decl>;</struct>
      <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt> <comment type="block">/* IMP: R-42790-23372 */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aFlagOp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aFlagOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>op</name><operator>==</operator><name>op</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>onoff</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pRes</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>u64</name></type> <name>oldFlags</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>onoff</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name><name>aFlagOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mask</name></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>onoff</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>aFlagOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mask</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>oldFlags</name><operator>!=</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>pRes</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name><name>aFlagOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mask</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the default collating function named "BINARY" which is always
** available.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>binCollFunc</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><name>nKey1</name><operator>&lt;</operator><name>nKey2</name></expr> ?</condition><then> <expr><name>nKey1</name></expr> </then><else>: <expr><name>nKey2</name></expr></else></ternary></expr>;</expr_stmt>
  <comment type="block">/* EVIDENCE-OF: R-65033-28449 The built-in BINARY collation compares
  ** strings byte by byte using the memcmp() function from the standard C
  ** library. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pKey1</name> <operator>&amp;&amp;</operator> <name>pKey2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>nKey1</name> <operator>-</operator> <name>nKey2</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the collating function named "RTRIM" which is always
** available.  Ignore trailing spaces.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rtrimCollFunc</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUser</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>pK1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><name>pKey1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>pK2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><name>pKey2</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>nKey1</name> <operator>&amp;&amp;</operator> <name><name>pK1</name><index>[<expr><name>nKey1</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">' '</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nKey1</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
  <while>while<condition>( <expr><name>nKey2</name> <operator>&amp;&amp;</operator> <name><name>pK2</name><index>[<expr><name>nKey2</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">' '</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nKey2</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><call><name>binCollFunc</name><argument_list>(<argument><expr><name>pUser</name></expr></argument>, <argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if CollSeq is the default built-in BINARY.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IsBinary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CollSeq</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>xCmp</name></name><operator>!=</operator><name>binCollFunc</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,<argument><expr><literal type="string">"BINARY"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>xCmp</name></name><operator>==</operator><name>binCollFunc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Another built-in collating sequence: NOCASE. 
**
** This collating sequence is intended to be used for "case independent
** comparison". SQLite's knowledge of upper and lower case equivalents
** extends only to the 26 characters used in the English language.
**
** At the moment there is only a UTF-8 implementation.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nocaseCollatingFunc</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>sqlite3StrNICmp</name><argument_list>(
      <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pKey1</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pKey2</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>nKey1</name><operator>&lt;</operator><name>nKey2</name><operator>)</operator></expr>?</condition><then><expr><name>nKey1</name></expr></then><else>:<expr><name>nKey2</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>r</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <name>nKey1</name><operator>-</operator><name>nKey2</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the ROWID of the most recent insert
*/</comment>
<function><type><name>sqlite_int64</name></type> <name>sqlite3_last_insert_rowid</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the value returned by the sqlite3_last_insert_rowid() API function.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_set_last_insert_rowid</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name> <operator>=</operator> <name>iRowid</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of changes in the most recent call to sqlite3_exec().
*/</comment>
<function><type><name>sqlite3_int64</name></type> <name>sqlite3_changes64</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>nChange</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_changes</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>sqlite3_changes64</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of changes since the database handle was opened.
*/</comment>
<function><type><name>sqlite3_int64</name></type> <name>sqlite3_total_changes64</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>nTotalChange</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_total_changes</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>sqlite3_total_changes64</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close all open savepoints. This function only manipulates fields of the
** database handle object, it does not close any savepoints that may be open
** at the b-tree/pager level.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CloseSavepoints</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Savepoint</name> <modifier>*</modifier></type><name>pTmp</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pSavepoint</name></name> <operator>=</operator> <name><name>pTmp</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>isTransactionSavepoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Invoke the destructor function associated with FuncDef p, if any. Except,
** if this is not the last copy of the function, do not invoke it. Multiple
** copies of a single function are created when create_function() is called
** with SQLITE_ANY as the encoding.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>functionDestroy</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FuncDestructor</name> <modifier>*</modifier></type><name>pDestructor</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_BUILTIN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDestructor</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pDestructor</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pDestructor</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pDestructor</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDestructor</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>pDestructor</name><operator>-&gt;</operator><name>xDestroy</name></name><argument_list>(<argument><expr><name><name>pDestructor</name><operator>-&gt;</operator><name>pUserData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDestructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Disconnect all sqlite3_vtab objects that belong to database connection
** db. This is called when db is being closed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>disconnectAllVtab</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HashElem</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type><name>pSchema</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSchema</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSchema</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Table</name> <operator>*</operator><operator>)</operator><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VtabDisconnect</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>pMod</name> <init>= <expr><operator>(</operator><name>Module</name> <operator>*</operator><operator>)</operator><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMod</name><operator>-&gt;</operator><name>pEpoTab</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VtabDisconnect</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pMod</name><operator>-&gt;</operator><name>pEpoTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3VtabUnlockList</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if database connection db has unfinalized prepared
** statements or unfinished sqlite3_backup objects.  
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>connectionIsBusy</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBt</name> <operator>&amp;&amp;</operator> <call><name>sqlite3BtreeIsInBackup</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close an existing SQLite database
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlite3Close</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forceZombie</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>db</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* EVIDENCE-OF: R-63257-11740 Calling sqlite3_close() or
    ** sqlite3_close_v2() with a NULL pointer argument is a harmless no-op. */</comment>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mTrace</name></name> <operator>&amp;</operator> <name>SQLITE_TRACE_CLOSE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>trace</name><operator>.</operator><name>xV2</name></name><argument_list>(<argument><expr><name>SQLITE_TRACE_CLOSE</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pTraceArg</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Force xDisconnect calls on all virtual tables */</comment>
  <expr_stmt><expr><call><name>disconnectAllVtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If a transaction is open, the disconnectAllVtab() call above
  ** will not have called the xDisconnect() method on any virtual
  ** tables in the db-&gt;aVTrans[] array. The following sqlite3VtabRollback()
  ** call will do so. We need to do this before the check for active
  ** SQL statements below, as the v-table implementation may be storing
  ** some prepared statements internally.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VtabRollback</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Legacy behavior (sqlite3_close() behavior) is to return
  ** SQLITE_BUSY if the connection can not be closed immediately.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>forceZombie</name> <operator>&amp;&amp;</operator> <call><name>connectionIsBusy</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_BUSY</name></expr></argument>, <argument><expr><literal type="string">"unable to close due to unfinalized "</literal>
       <literal type="string">"statements or unfinished backups"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SQLLOG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xSqllog</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Closing the handle. Fourth parameter is passed the value 2. */</comment>
    <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xSqllog</name></name><argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pSqllogArg</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Convert the connection into a zombie and then close it.
  */</comment>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>eOpenState</name></name> <operator>=</operator> <name>SQLITE_STATE_ZOMBIE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3LeaveMutexAndCloseZombie</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the transaction state for a single databse, or the maximum
** transaction state over all attached databases if zSchema is null.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_txn_state</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSchema</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>, <decl><type ref="prev"/><name>nDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iTxn</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSchema</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nDb</name> <operator>=</operator> <name>iDb</name> <operator>=</operator> <call><name>sqlite3FindDbName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nDb</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nDb</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init>;</init> <condition><expr><name>iDb</name><operator>&lt;=</operator><name>nDb</name></expr>;</condition> <incr><expr><name>iDb</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><ternary><condition><expr><name>pBt</name><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>sqlite3BtreeTxnState</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>SQLITE_TXN_NONE</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;</operator><name>iTxn</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iTxn</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>iTxn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Two variations on the public interface for closing a database
** connection. The sqlite3_close() version returns SQLITE_BUSY and
** leaves the connection open if there are unfinalized prepared
** statements or unfinished sqlite3_backups.  The sqlite3_close_v2()
** version forces the connection to become a zombie if there are
** unclosed resources, and arranges for deallocation when the last
** prepare statement or sqlite3_backup closes.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_close</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><call><name>sqlite3Close</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_close_v2</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><call><name>sqlite3Close</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>


<comment type="block">/*
** Close the mutex on database connection db.
**
** Furthermore, if database connection db is a zombie (meaning that there
** has been a prior call to sqlite3_close(db) or sqlite3_close_v2(db)) and
** every sqlite3_stmt has now been finalized and every sqlite3_backup has
** finished, then free all resources.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3LeaveMutexAndCloseZombie</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HashElem</name> <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>                    <comment type="block">/* Hash table iterator */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

  <comment type="block">/* If there are outstanding sqlite3_stmt or sqlite3_backup objects
  ** or if the connection has not yet been closed by sqlite3_close_v2(),
  ** then just leave the mutex and return.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>eOpenState</name></name><operator>!=</operator><name>SQLITE_STATE_ZOMBIE</name> <operator>||</operator> <call><name>connectionIsBusy</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we reach this point, it means that the database connection has
  ** closed all sqlite3_stmt and sqlite3_backup objects and has been
  ** passed to sqlite3_close (meaning that it is a zombie).  Therefore,
  ** go ahead and free all resources.
  */</comment>

  <comment type="block">/* If a transaction is open, roll it back. This also ensures that if
  ** any database schemas have been modified by an uncommitted transaction
  ** they are reset. And that the required b-tree mutex is held to make
  ** the pager rollback and schema reset an atomic operation. */</comment>
  <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Free any outstanding Savepoint structures. */</comment>
  <expr_stmt><expr><call><name>sqlite3CloseSavepoints</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Close all database connections */</comment>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>Db</name></name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BtreeClose</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <comment type="block">/* Clear the TEMP schema separately and last */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3SchemaClear</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabUnlockList</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Free up the array of auxiliary databases */</comment>
  <expr_stmt><expr><call><name>sqlite3CollapseDatabaseArray</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name><operator>&lt;=</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name></name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>aDbStatic</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Tell the code in notify.c that the connection no longer holds any
  ** locks and does not require any further unlock-notify callbacks.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3ConnectionClosed</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aFunc</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pNext</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqliteHashData</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><call><name>functionDestroy</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>p</name></expr> )</condition>;</do>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aCollSeq</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><operator>(</operator><name>CollSeq</name> <operator>*</operator><operator>)</operator><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Invoke any destructors registered for collation sequence user data. */</comment>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pColl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>xDel</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pColl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><call><name>xDel</name><argument_list>(<argument><expr><name><name>pColl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aCollSeq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><call><name>sqliteHashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>=</operator><call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>pMod</name> <init>= <expr><operator>(</operator><name>Module</name> <operator>*</operator><operator>)</operator><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VtabEponymousTableClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VtabModuleUnref</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Deallocates any cached error strings. */</comment>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3CloseExtensions</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_USER_AUTHENTICATION</name></expr></cpp:if>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>auth</name><operator>.</operator><name>zAuthUser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>auth</name><operator>.</operator><name>zAuthPW</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>eOpenState</name></name> <operator>=</operator> <name>SQLITE_STATE_ERROR</name></expr>;</expr_stmt>

  <comment type="block">/* The temp-database schema is allocated differently from the other schema
  ** objects (using sqliteMalloc() directly, instead of sqlite3BtreeSchema()).
  ** So it needs to be freed here. Todo: Why not roll the temp schema into
  ** the same sqliteMalloc() as the one that allocates the database 
  ** structure?
  */</comment>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xAutovacDestr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>xAutovacDestr</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pAutovacPagesArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>eOpenState</name></name> <operator>=</operator> <name>SQLITE_STATE_CLOSED</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_free</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3LookasideUsed</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>bMalloced</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>pStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Rollback all database files.  If tripCode is not SQLITE_OK, then
** any write cursors are invalidated ("tripped" - as in "tripping a circuit
** breaker") and made to return tripCode if there are any further
** attempts to use that cursor.  Read cursors remain open and valid
** but are "saved" in case the table pages are moved around.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RollbackAll</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tripCode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>inTrans</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>schemaChange</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Obtain all b-tree mutexes before making any calls to BtreeRollback(). 
  ** This is important in case the transaction being rolled back has
  ** modified the database schema. If the b-tree mutexes are not taken
  ** here, then another shared-cache connection might sneak in between
  ** the database rollback and schema reset, which can cause false
  ** corruption reports in some cases.  */</comment>
  <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>schemaChange</name> <operator>=</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_SchemaChange</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeTxnState</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_TXN_WRITE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>inTrans</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeRollback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>tripCode</name></expr></argument>, <argument><expr><operator>!</operator><name>schemaChange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3VtabRollback</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>schemaChange</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ResetAllSchemasOfConnection</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Any deferred constraint violations have now been resolved. */</comment>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>u64</name><operator>)</operator><operator>(</operator><name>SQLITE_DeferFKs</name><operator>|</operator><name>SQLITE_CorruptRdOnly</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* If one has been configured, invoke the rollback-hook callback */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xRollbackCallback</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>inTrans</name> <operator>||</operator> <operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>xRollbackCallback</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pRollbackArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return a static string containing the name corresponding to the error code
** specified in the argument.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_NEED_ERR_NAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3ErrName</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>origRc</name> <init>= <expr><name>rc</name></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>zName</name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>rc</name> <operator>&amp;=</operator> <literal type="number">0xff</literal></expr></incr>)</control><block>{<block_content>
    <switch>switch<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SQLITE_OK</name></expr>:</case>                 <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_OK"</literal></expr>;</expr_stmt>                <break>break;</break>
      <case>case <expr><name>SQLITE_ERROR</name></expr>:</case>              <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_ERROR"</literal></expr>;</expr_stmt>             <break>break;</break>
      <case>case <expr><name>SQLITE_ERROR_SNAPSHOT</name></expr>:</case>     <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_ERROR_SNAPSHOT"</literal></expr>;</expr_stmt>    <break>break;</break>
      <case>case <expr><name>SQLITE_INTERNAL</name></expr>:</case>           <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_INTERNAL"</literal></expr>;</expr_stmt>          <break>break;</break>
      <case>case <expr><name>SQLITE_PERM</name></expr>:</case>               <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_PERM"</literal></expr>;</expr_stmt>              <break>break;</break>
      <case>case <expr><name>SQLITE_ABORT</name></expr>:</case>              <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_ABORT"</literal></expr>;</expr_stmt>             <break>break;</break>
      <case>case <expr><name>SQLITE_ABORT_ROLLBACK</name></expr>:</case>     <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_ABORT_ROLLBACK"</literal></expr>;</expr_stmt>    <break>break;</break>
      <case>case <expr><name>SQLITE_BUSY</name></expr>:</case>               <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_BUSY"</literal></expr>;</expr_stmt>              <break>break;</break>
      <case>case <expr><name>SQLITE_BUSY_RECOVERY</name></expr>:</case>      <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_BUSY_RECOVERY"</literal></expr>;</expr_stmt>     <break>break;</break>
      <case>case <expr><name>SQLITE_BUSY_SNAPSHOT</name></expr>:</case>      <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_BUSY_SNAPSHOT"</literal></expr>;</expr_stmt>     <break>break;</break>
      <case>case <expr><name>SQLITE_LOCKED</name></expr>:</case>             <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_LOCKED"</literal></expr>;</expr_stmt>            <break>break;</break>
      <case>case <expr><name>SQLITE_LOCKED_SHAREDCACHE</name></expr>:</case> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_LOCKED_SHAREDCACHE"</literal></expr>;</expr_stmt><break>break;</break>
      <case>case <expr><name>SQLITE_NOMEM</name></expr>:</case>              <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_NOMEM"</literal></expr>;</expr_stmt>             <break>break;</break>
      <case>case <expr><name>SQLITE_READONLY</name></expr>:</case>           <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_READONLY"</literal></expr>;</expr_stmt>          <break>break;</break>
      <case>case <expr><name>SQLITE_READONLY_RECOVERY</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_READONLY_RECOVERY"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_READONLY_CANTINIT</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_READONLY_CANTINIT"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_READONLY_ROLLBACK</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_READONLY_ROLLBACK"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_READONLY_DBMOVED</name></expr>:</case>   <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_READONLY_DBMOVED"</literal></expr>;</expr_stmt>  <break>break;</break>
      <case>case <expr><name>SQLITE_READONLY_DIRECTORY</name></expr>:</case> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_READONLY_DIRECTORY"</literal></expr>;</expr_stmt><break>break;</break>
      <case>case <expr><name>SQLITE_INTERRUPT</name></expr>:</case>          <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_INTERRUPT"</literal></expr>;</expr_stmt>         <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR</name></expr>:</case>              <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR"</literal></expr>;</expr_stmt>             <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_READ</name></expr>:</case>         <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_READ"</literal></expr>;</expr_stmt>        <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_SHORT_READ</name></expr>:</case>   <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_SHORT_READ"</literal></expr>;</expr_stmt>  <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_WRITE</name></expr>:</case>        <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_WRITE"</literal></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_FSYNC</name></expr>:</case>        <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_FSYNC"</literal></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_DIR_FSYNC</name></expr>:</case>    <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_DIR_FSYNC"</literal></expr>;</expr_stmt>   <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_TRUNCATE</name></expr>:</case>     <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_TRUNCATE"</literal></expr>;</expr_stmt>    <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_FSTAT</name></expr>:</case>        <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_FSTAT"</literal></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_UNLOCK</name></expr>:</case>       <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_UNLOCK"</literal></expr>;</expr_stmt>      <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_RDLOCK</name></expr>:</case>       <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_RDLOCK"</literal></expr>;</expr_stmt>      <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_DELETE</name></expr>:</case>       <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_DELETE"</literal></expr>;</expr_stmt>      <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_NOMEM</name></expr>:</case>        <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_NOMEM"</literal></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_ACCESS</name></expr>:</case>       <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_ACCESS"</literal></expr>;</expr_stmt>      <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_CHECKRESERVEDLOCK</name></expr>:</case>
                                <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_CHECKRESERVEDLOCK"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_LOCK</name></expr>:</case>         <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_LOCK"</literal></expr>;</expr_stmt>        <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_CLOSE</name></expr>:</case>        <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_CLOSE"</literal></expr>;</expr_stmt>       <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_DIR_CLOSE</name></expr>:</case>    <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_DIR_CLOSE"</literal></expr>;</expr_stmt>   <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_SHMOPEN</name></expr>:</case>      <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_SHMOPEN"</literal></expr>;</expr_stmt>     <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_SHMSIZE</name></expr>:</case>      <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_SHMSIZE"</literal></expr>;</expr_stmt>     <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_SHMLOCK</name></expr>:</case>      <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_SHMLOCK"</literal></expr>;</expr_stmt>     <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_SHMMAP</name></expr>:</case>       <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_SHMMAP"</literal></expr>;</expr_stmt>      <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_SEEK</name></expr>:</case>         <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_SEEK"</literal></expr>;</expr_stmt>        <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_DELETE_NOENT</name></expr>:</case> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_DELETE_NOENT"</literal></expr>;</expr_stmt><break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_MMAP</name></expr>:</case>         <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_MMAP"</literal></expr>;</expr_stmt>        <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_GETTEMPPATH</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_GETTEMPPATH"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_IOERR_CONVPATH</name></expr>:</case>     <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_IOERR_CONVPATH"</literal></expr>;</expr_stmt>    <break>break;</break>
      <case>case <expr><name>SQLITE_CORRUPT</name></expr>:</case>            <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CORRUPT"</literal></expr>;</expr_stmt>           <break>break;</break>
      <case>case <expr><name>SQLITE_CORRUPT_VTAB</name></expr>:</case>       <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CORRUPT_VTAB"</literal></expr>;</expr_stmt>      <break>break;</break>
      <case>case <expr><name>SQLITE_NOTFOUND</name></expr>:</case>           <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_NOTFOUND"</literal></expr>;</expr_stmt>          <break>break;</break>
      <case>case <expr><name>SQLITE_FULL</name></expr>:</case>               <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_FULL"</literal></expr>;</expr_stmt>              <break>break;</break>
      <case>case <expr><name>SQLITE_CANTOPEN</name></expr>:</case>           <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CANTOPEN"</literal></expr>;</expr_stmt>          <break>break;</break>
      <case>case <expr><name>SQLITE_CANTOPEN_NOTEMPDIR</name></expr>:</case> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CANTOPEN_NOTEMPDIR"</literal></expr>;</expr_stmt><break>break;</break>
      <case>case <expr><name>SQLITE_CANTOPEN_ISDIR</name></expr>:</case>     <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CANTOPEN_ISDIR"</literal></expr>;</expr_stmt>    <break>break;</break>
      <case>case <expr><name>SQLITE_CANTOPEN_FULLPATH</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CANTOPEN_FULLPATH"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_CANTOPEN_CONVPATH</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CANTOPEN_CONVPATH"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_CANTOPEN_SYMLINK</name></expr>:</case>   <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CANTOPEN_SYMLINK"</literal></expr>;</expr_stmt>  <break>break;</break>
      <case>case <expr><name>SQLITE_PROTOCOL</name></expr>:</case>           <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_PROTOCOL"</literal></expr>;</expr_stmt>          <break>break;</break>
      <case>case <expr><name>SQLITE_EMPTY</name></expr>:</case>              <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_EMPTY"</literal></expr>;</expr_stmt>             <break>break;</break>
      <case>case <expr><name>SQLITE_SCHEMA</name></expr>:</case>             <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_SCHEMA"</literal></expr>;</expr_stmt>            <break>break;</break>
      <case>case <expr><name>SQLITE_TOOBIG</name></expr>:</case>             <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_TOOBIG"</literal></expr>;</expr_stmt>            <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT</name></expr>:</case>         <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT"</literal></expr>;</expr_stmt>        <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_UNIQUE</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_UNIQUE"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_TRIGGER</name></expr>:</case> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_TRIGGER"</literal></expr>;</expr_stmt><break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_FOREIGNKEY</name></expr>:</case>
                                <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_FOREIGNKEY"</literal></expr>;</expr_stmt>   <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_CHECK</name></expr>:</case>   <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_CHECK"</literal></expr>;</expr_stmt>  <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_PRIMARYKEY</name></expr>:</case>
                                <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_PRIMARYKEY"</literal></expr>;</expr_stmt>   <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_NOTNULL</name></expr>:</case> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_NOTNULL"</literal></expr>;</expr_stmt><break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_COMMITHOOK</name></expr>:</case>
                                <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_COMMITHOOK"</literal></expr>;</expr_stmt>   <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_VTAB</name></expr>:</case>    <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_VTAB"</literal></expr>;</expr_stmt>   <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_FUNCTION</name></expr>:</case>
                                <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_FUNCTION"</literal></expr>;</expr_stmt>     <break>break;</break>
      <case>case <expr><name>SQLITE_CONSTRAINT_ROWID</name></expr>:</case>   <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_CONSTRAINT_ROWID"</literal></expr>;</expr_stmt>  <break>break;</break>
      <case>case <expr><name>SQLITE_MISMATCH</name></expr>:</case>           <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_MISMATCH"</literal></expr>;</expr_stmt>          <break>break;</break>
      <case>case <expr><name>SQLITE_MISUSE</name></expr>:</case>             <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_MISUSE"</literal></expr>;</expr_stmt>            <break>break;</break>
      <case>case <expr><name>SQLITE_NOLFS</name></expr>:</case>              <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_NOLFS"</literal></expr>;</expr_stmt>             <break>break;</break>
      <case>case <expr><name>SQLITE_AUTH</name></expr>:</case>               <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_AUTH"</literal></expr>;</expr_stmt>              <break>break;</break>
      <case>case <expr><name>SQLITE_FORMAT</name></expr>:</case>             <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_FORMAT"</literal></expr>;</expr_stmt>            <break>break;</break>
      <case>case <expr><name>SQLITE_RANGE</name></expr>:</case>              <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_RANGE"</literal></expr>;</expr_stmt>             <break>break;</break>
      <case>case <expr><name>SQLITE_NOTADB</name></expr>:</case>             <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_NOTADB"</literal></expr>;</expr_stmt>            <break>break;</break>
      <case>case <expr><name>SQLITE_ROW</name></expr>:</case>                <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_ROW"</literal></expr>;</expr_stmt>               <break>break;</break>
      <case>case <expr><name>SQLITE_NOTICE</name></expr>:</case>             <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_NOTICE"</literal></expr>;</expr_stmt>            <break>break;</break>
      <case>case <expr><name>SQLITE_NOTICE_RECOVER_WAL</name></expr>:</case> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_NOTICE_RECOVER_WAL"</literal></expr>;</expr_stmt><break>break;</break>
      <case>case <expr><name>SQLITE_NOTICE_RECOVER_ROLLBACK</name></expr>:</case>
                                <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_NOTICE_RECOVER_ROLLBACK"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_WARNING</name></expr>:</case>            <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_WARNING"</literal></expr>;</expr_stmt>           <break>break;</break>
      <case>case <expr><name>SQLITE_WARNING_AUTOINDEX</name></expr>:</case>  <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_WARNING_AUTOINDEX"</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>SQLITE_DONE</name></expr>:</case>               <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"SQLITE_DONE"</literal></expr>;</expr_stmt>              <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"SQLITE_UNKNOWN(%d)"</literal></expr></argument>, <argument><expr><name>origRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zName</name> <operator>=</operator> <name>zBuf</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zName</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return a static string that describes the kind of error specified in the
** argument.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3ErrStr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name><name>aMsg</name><index>[]</index></name> <init>= <expr><block>{
    <comment type="block">/* SQLITE_OK          */</comment> <expr><literal type="string">"not an error"</literal></expr>,
    <comment type="block">/* SQLITE_ERROR       */</comment> <expr><literal type="string">"SQL logic error"</literal></expr>,
    <comment type="block">/* SQLITE_INTERNAL    */</comment> <expr><literal type="number">0</literal></expr>,
    <comment type="block">/* SQLITE_PERM        */</comment> <expr><literal type="string">"access permission denied"</literal></expr>,
    <comment type="block">/* SQLITE_ABORT       */</comment> <expr><literal type="string">"query aborted"</literal></expr>,
    <comment type="block">/* SQLITE_BUSY        */</comment> <expr><literal type="string">"database is locked"</literal></expr>,
    <comment type="block">/* SQLITE_LOCKED      */</comment> <expr><literal type="string">"database table is locked"</literal></expr>,
    <comment type="block">/* SQLITE_NOMEM       */</comment> <expr><literal type="string">"out of memory"</literal></expr>,
    <comment type="block">/* SQLITE_READONLY    */</comment> <expr><literal type="string">"attempt to write a readonly database"</literal></expr>,
    <comment type="block">/* SQLITE_INTERRUPT   */</comment> <expr><literal type="string">"interrupted"</literal></expr>,
    <comment type="block">/* SQLITE_IOERR       */</comment> <expr><literal type="string">"disk I/O error"</literal></expr>,
    <comment type="block">/* SQLITE_CORRUPT     */</comment> <expr><literal type="string">"database disk image is malformed"</literal></expr>,
    <comment type="block">/* SQLITE_NOTFOUND    */</comment> <expr><literal type="string">"unknown operation"</literal></expr>,
    <comment type="block">/* SQLITE_FULL        */</comment> <expr><literal type="string">"database or disk is full"</literal></expr>,
    <comment type="block">/* SQLITE_CANTOPEN    */</comment> <expr><literal type="string">"unable to open database file"</literal></expr>,
    <comment type="block">/* SQLITE_PROTOCOL    */</comment> <expr><literal type="string">"locking protocol"</literal></expr>,
    <comment type="block">/* SQLITE_EMPTY       */</comment> <expr><literal type="number">0</literal></expr>,
    <comment type="block">/* SQLITE_SCHEMA      */</comment> <expr><literal type="string">"database schema has changed"</literal></expr>,
    <comment type="block">/* SQLITE_TOOBIG      */</comment> <expr><literal type="string">"string or blob too big"</literal></expr>,
    <comment type="block">/* SQLITE_CONSTRAINT  */</comment> <expr><literal type="string">"constraint failed"</literal></expr>,
    <comment type="block">/* SQLITE_MISMATCH    */</comment> <expr><literal type="string">"datatype mismatch"</literal></expr>,
    <comment type="block">/* SQLITE_MISUSE      */</comment> <expr><literal type="string">"bad parameter or other API misuse"</literal></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DISABLE_LFS</name></cpp:ifdef>
    <comment type="block">/* SQLITE_NOLFS       */</comment> <expr><literal type="string">"large file support is disabled"</literal></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* SQLITE_NOLFS       */</comment> <expr><literal type="number">0</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* SQLITE_AUTH        */</comment> <expr><literal type="string">"authorization denied"</literal></expr>,
    <comment type="block">/* SQLITE_FORMAT      */</comment> <expr><literal type="number">0</literal></expr>,
    <comment type="block">/* SQLITE_RANGE       */</comment> <expr><literal type="string">"column index out of range"</literal></expr>,
    <comment type="block">/* SQLITE_NOTADB      */</comment> <expr><literal type="string">"file is not a database"</literal></expr>,
    <comment type="block">/* SQLITE_NOTICE      */</comment> <expr><literal type="string">"notification message"</literal></expr>,
    <comment type="block">/* SQLITE_WARNING     */</comment> <expr><literal type="string">"warning message"</literal></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="string">"unknown error"</literal></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_ABORT_ROLLBACK</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>zErr</name> <operator>=</operator> <literal type="string">"abort due to ROLLBACK"</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_ROW</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>zErr</name> <operator>=</operator> <literal type="string">"another row available"</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_DONE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>zErr</name> <operator>=</operator> <literal type="string">"no more rows available"</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>&amp;=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>rc</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>rc</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>aMsg</name><index>[<expr><name>rc</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zErr</name> <operator>=</operator> <name><name>aMsg</name><index>[<expr><name>rc</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>zErr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine implements a busy callback that sleeps and tries
** again until a timeout value is reached.  The timeout value is
** an integer number of milliseconds passed in as the first
** argument.
**
** Return non-zero to retry the lock.  Return zero to stop trying
** and cause SQLite to return SQLITE_BUSY.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqliteDefaultBusyCallback</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,               <comment type="block">/* Database connection */</comment>
  <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>                <comment type="block">/* Number of times table has been busy */</comment>
)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name> <operator>||</operator> <name>HAVE_USLEEP</name></expr></cpp:if>
  <comment type="block">/* This case is for systems that have support for sleeping for fractions of
  ** a second.  Examples:  All windows systems, unix systems with usleep() */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>delays</name><index>[]</index></name> <init>=
     <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>,  <expr><literal type="number">25</literal></expr>,  <expr><literal type="number">50</literal></expr>,  <expr><literal type="number">50</literal></expr>, <expr><literal type="number">100</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>totals</name><index>[]</index></name> <init>=
     <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">8</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">33</literal></expr>, <expr><literal type="number">53</literal></expr>, <expr><literal type="number">78</literal></expr>, <expr><literal type="number">103</literal></expr>, <expr><literal type="number">128</literal></expr>, <expr><literal type="number">178</literal></expr>, <expr><literal type="number">228</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NDELAY</name></cpp:macro> <cpp:value>ArraySize(delays)</cpp:value></cpp:define>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><operator>(</operator><name>sqlite3</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tmout</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>busyTimeout</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>delay</name></decl>, <decl><type ref="prev"/><name>prior</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>count</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>count</name> <operator>&lt;</operator> <name>NDELAY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>delay</name> <operator>=</operator> <name><name>delays</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prior</name> <operator>=</operator> <name><name>totals</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>delay</name> <operator>=</operator> <name><name>delays</name><index>[<expr><name>NDELAY</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prior</name> <operator>=</operator> <name><name>totals</name><index>[<expr><name>NDELAY</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>delay</name><operator>*</operator><operator>(</operator><name>count</name><operator>-</operator><operator>(</operator><name>NDELAY</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>prior</name> <operator>+</operator> <name>delay</name> <operator>&gt;</operator> <name>tmout</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>delay</name> <operator>=</operator> <name>tmout</name> <operator>-</operator> <name>prior</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>delay</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3OsSleep</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name>delay</name><operator>*</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* This case for unix systems that lack usleep() support.  Sleeping
  ** must be done in increments of whole seconds */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><operator>(</operator><name>sqlite3</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tmout</name> <init>= <expr><operator>(</operator><operator>(</operator><name>sqlite3</name> <operator>*</operator><operator>)</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>busyTimeout</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>count</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">1000</literal> <operator>&gt;</operator> <name>tmout</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3OsSleep</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Invoke the given busy handler.
**
** This routine is called when an operation failed to acquire a
** lock on VFS file pFile.
**
** If this routine returns non-zero, the lock is retried.  If it
** returns 0, the operation aborts with an SQLITE_BUSY error.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3InvokeBusyHandler</name><parameter_list>(<parameter><decl><type><name>BusyHandler</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>xBusyHandler</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>nBusy</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>xBusyHandler</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBusyArg</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nBusy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBusy</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBusy</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block">/*
** This routine sets the busy callback for an Sqlite database to the
** given callback function with the given argument.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_busy_handler</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xBusy</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyHandler</name><operator>.</operator><name>xBusyHandler</name></name> <operator>=</operator> <name>xBusy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyHandler</name><operator>.</operator><name>pBusyArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyHandler</name><operator>.</operator><name>nBusy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyTimeout</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
<comment type="block">/*
** This routine sets the progress callback for an Sqlite database to the
** given callback function with the given argument. The progress callback will
** be invoked every nOps opcodes.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_progress_handler</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nOps</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xProgress</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nOps</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xProgress</name></name> <operator>=</operator> <name>xProgress</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>nOps</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pProgressArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xProgress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nProgressOps</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pProgressArg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** This routine installs a default busy handler that waits for the
** specified number of milliseconds before returning 0.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_busy_timeout</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ms</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>ms</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_busy_handler</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><call><call><name>int</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call><operator>)</operator><name>sqliteDefaultBusyCallback</name></expr></argument>,
                             <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyTimeout</name></name> <operator>=</operator> <name>ms</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_busy_handler</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Cause any pending operation to stop at its earliest opportunity.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_interrupt</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>db</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>eOpenState</name></name><operator>!=</operator><name>SQLITE_STATE_ZOMBIE</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>AtomicStore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** This function is exactly the same as sqlite3_create_function(), except
** that it is designed to be called by internal code. The difference is
** that if a malloc() fails in sqlite3_create_function(), an error code
** is returned and the mallocFailed flag cleared. 
*/</comment>
<function><type><name>int</name></type> <name>sqlite3CreateFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunctionName</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUserData</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xSFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xStep</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFinal</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xValue</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xInverse</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>FuncDestructor</name> <modifier>*</modifier></type><name>pDestructor</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>extraFlags</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xValue</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>xSFunc</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFunctionName</name><operator>==</operator><literal type="number">0</literal>                <comment type="block">/* Must have a valid name */</comment>
   <operator>||</operator> <operator>(</operator><name>xSFunc</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>xFinal</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator>        <comment type="block">/* Not both xSFunc and xFinal */</comment>
   <operator>||</operator> <operator>(</operator><operator>(</operator><name>xFinal</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>!=</operator><operator>(</operator><name>xStep</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator>       <comment type="block">/* Both or neither of xFinal and xStep */</comment>
   <operator>||</operator> <operator>(</operator><operator>(</operator><name>xValue</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>!=</operator><operator>(</operator><name>xInverse</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator>    <comment type="block">/* Both or neither of xValue, xInverse */</comment>
   <operator>||</operator> <operator>(</operator><name><name>nArg</name><argument_list type="generic">&lt;<argument><expr><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>nArg</name></expr></argument>&gt;</argument_list></name><name>SQLITE_MAX_FUNCTION_ARG</name><operator>)</operator>
   <operator>||</operator> <operator>(</operator><literal type="number">255</literal><operator>&lt;</operator><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFunctionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_FUNC_CONSTANT</name><operator>==</operator><name>SQLITE_DETERMINISTIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_FUNC_DIRECT</name><operator>==</operator><name>SQLITE_DIRECTONLY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>extraFlags</name> <operator>=</operator> <name>enc</name> <operator>&amp;</operator>  <operator>(</operator><name>SQLITE_DETERMINISTIC</name><operator>|</operator><name>SQLITE_DIRECTONLY</name><operator>|</operator>
                       <name>SQLITE_SUBTYPE</name><operator>|</operator><name>SQLITE_INNOCUOUS</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>enc</name> <operator>&amp;=</operator> <operator>(</operator><name>SQLITE_FUNC_ENCMASK</name><operator>|</operator><name>SQLITE_ANY</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* The SQLITE_INNOCUOUS flag is the same bit as SQLITE_FUNC_UNSAFE.  But
  ** the meaning is inverted.  So flip the bit. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_FUNC_UNSAFE</name><operator>==</operator><name>SQLITE_INNOCUOUS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>extraFlags</name> <operator>^=</operator> <name>SQLITE_FUNC_UNSAFE</name></expr>;</expr_stmt>

  
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
  <comment type="block">/* If SQLITE_UTF16 is specified as the encoding type, transform this
  ** to one of SQLITE_UTF16LE or SQLITE_UTF16BE using the
  ** SQLITE_UTF16NATIVE macro. SQLITE_UTF16 is not used internally.
  **
  ** If SQLITE_ANY is specified, add three versions of the function
  ** to the hash table.
  */</comment>
  <switch>switch<condition>( <expr><name>enc</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_UTF16</name></expr>:</case>
      <expr_stmt><expr><name>enc</name> <operator>=</operator> <name>SQLITE_UTF16NATIVE</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>SQLITE_ANY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>,
           <argument><expr><operator>(</operator><name>SQLITE_UTF8</name><operator>|</operator><name>extraFlags</name><operator>)</operator><operator>^</operator><name>SQLITE_FUNC_UNSAFE</name></expr></argument>,
           <argument><expr><name>pUserData</name></expr></argument>, <argument><expr><name>xSFunc</name></expr></argument>, <argument><expr><name>xStep</name></expr></argument>, <argument><expr><name>xFinal</name></expr></argument>, <argument><expr><name>xValue</name></expr></argument>, <argument><expr><name>xInverse</name></expr></argument>, <argument><expr><name>pDestructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>,
             <argument><expr><operator>(</operator><name>SQLITE_UTF16LE</name><operator>|</operator><name>extraFlags</name><operator>)</operator><operator>^</operator><name>SQLITE_FUNC_UNSAFE</name></expr></argument>,
             <argument><expr><name>pUserData</name></expr></argument>, <argument><expr><name>xSFunc</name></expr></argument>, <argument><expr><name>xStep</name></expr></argument>, <argument><expr><name>xFinal</name></expr></argument>, <argument><expr><name>xValue</name></expr></argument>, <argument><expr><name>xInverse</name></expr></argument>, <argument><expr><name>pDestructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>enc</name> <operator>=</operator> <name>SQLITE_UTF16BE</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_UTF8</name></expr>:</case>
    <case>case <expr><name>SQLITE_UTF16LE</name></expr>:</case>
    <case>case <expr><name>SQLITE_UTF16BE</name></expr>:</case>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><name>enc</name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>enc</name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <comment type="block">/* Check if an existing function is being overridden or deleted. If so,
  ** and there are active VMs, then return SQLITE_BUSY. If a function
  ** is being overridden/deleted but there are no active VMs, allow the
  ** operation to continue but invalidate all precompiled statements.
  */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_ENCMASK</name><operator>)</operator><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name>enc</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nArg</name></name><operator>==</operator><name>nArg</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_BUSY</name></expr></argument>, 
        <argument><expr><literal type="string">"unable to delete/modify user-function due to active statements"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>xSFunc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>xFinal</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Trying to delete a function that does not exist.  This is a no-op.
    ** https://sqlite.org/forum/forumpost/726219164b */</comment>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>enc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If an older version of the function with a configured destructor is
  ** being replaced invoke the destructor function here. */</comment>
  <expr_stmt><expr><call><name>functionDestroy</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pDestructor</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pDestructor</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pDestructor</name></name> <operator>=</operator> <name>pDestructor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_ENCMASK</name><operator>)</operator> <operator>|</operator> <name>extraFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_DETERMINISTIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_DIRECTONLY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>xSFunc</name></name> <operator>=</operator> <ternary><condition><expr><name>xSFunc</name></expr> ?</condition><then> <expr><name>xSFunc</name></expr> </then><else>: <expr><name>xStep</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>xFinalize</name></name> <operator>=</operator> <name>xFinal</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>xValue</name></name> <operator>=</operator> <name>xValue</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>xInverse</name></name> <operator>=</operator> <name>xInverse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name>pUserData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nArg</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nArg</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Worker function used by utf-8 APIs that create new functions:
**
**    sqlite3_create_function()
**    sqlite3_create_function_v2()
**    sqlite3_create_window_function()
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>createFunctionApi</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunc</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xSFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xStep</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFinal</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xValue</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xInverse</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier><name>xDestroy</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncDestructor</name> <modifier>*</modifier></type><name>pArg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>xDestroy</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pArg</name> <operator>=</operator> <operator>(</operator><name>FuncDestructor</name> <operator>*</operator><operator>)</operator><call><name>sqlite3Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FuncDestructor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pArg</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>xDestroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>xDestroy</name></name> <operator>=</operator> <name>xDestroy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunc</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, 
      <argument><expr><name>xSFunc</name></expr></argument>, <argument><expr><name>xStep</name></expr></argument>, <argument><expr><name>xFinal</name></expr></argument>, <argument><expr><name>xValue</name></expr></argument>, <argument><expr><name>xInverse</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pArg</name> <operator>&amp;&amp;</operator> <name><name>pArg</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name>xStep</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>xFinal</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>xDestroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

 <label><name>out</name>:</label>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create new user functions.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_function</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunc</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xSFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xStep</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFinal</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>createFunctionApi</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunc</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>xSFunc</name></expr></argument>, <argument><expr><name>xStep</name></expr></argument>,
                                    <argument><expr><name>xFinal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_create_function_v2</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunc</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xSFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xStep</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFinal</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestroy</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>createFunctionApi</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunc</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>xSFunc</name></expr></argument>, <argument><expr><name>xStep</name></expr></argument>,
                                    <argument><expr><name>xFinal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xDestroy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_create_window_function</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFunc</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xStep</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFinal</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xValue</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xInverse</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestroy</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>createFunctionApi</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunc</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xStep</name></expr></argument>,
                                    <argument><expr><name>xFinal</name></expr></argument>, <argument><expr><name>xValue</name></expr></argument>, <argument><expr><name>xInverse</name></expr></argument>, <argument><expr><name>xDestroy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3_create_function16</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zFunctionName</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>eTextRep</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xSFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xStep</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFinal</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFunc8</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zFunctionName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFunc8</name> <operator>=</operator> <call><name>sqlite3Utf16to8</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunc8</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>eTextRep</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>xSFunc</name></expr></argument>,<argument><expr><name>xStep</name></expr></argument>,<argument><expr><name>xFinal</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunc8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** The following is the implementation of an SQL function that always
** fails with an error message stating that the function is used in the
** wrong context.  The sqlite3_overload_function() API might construct
** SQL function that use this routine so that the functions will exist
** for name resolution but are actually overloaded by the xFindFunction
** method of virtual tables.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3InvalidFunction</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,  <comment type="block">/* The function calling context */</comment>
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,               <comment type="block">/* Number of arguments to the function */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>NotUsed2</name></decl></parameter>   <comment type="block">/* Value of each argument */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
      <argument><expr><literal type="string">"unable to use function %s in the requested context"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Declare that a function has been overloaded by a virtual table.
**
** If the function already exists as a regular global function, then
** this routine is a no-op.  If the function does not exist, then create
** a new one that always throws a run-time error.  
**
** When virtual tables intend to provide an overloaded function, they
** should call this routine to make sure the global function exists.
** A global function must exist in order for name resolution to work
** properly.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_overload_function</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCopy</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zName</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nArg</name><operator>&lt;</operator><operator>-</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zCopy</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zCopy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sqlite3_create_function_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>,
                           <argument><expr><name>zCopy</name></expr></argument>, <argument><expr><name>sqlite3InvalidFunction</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
<comment type="block">/*
** Register a trace function.  The pArg from the previously registered trace
** is returned.  
**
** A NULL trace function means that no tracing is executes.  A non-NULL
** trace is a pointer to a function that is invoked at the start of each
** SQL statement.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_trace</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier><name>xTrace</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pOld</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOld</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pTraceArg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mTrace</name></name> <operator>=</operator> <ternary><condition><expr><name>xTrace</name></expr> ?</condition><then> <expr><name>SQLITE_TRACE_LEGACY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>trace</name><operator>.</operator><name>xLegacy</name></name> <operator>=</operator> <name>xTrace</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pTraceArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pOld</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_DEPRECATED */</comment>

<comment type="block">/* Register a trace callback using the version-2 interface.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_trace_v2</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                               <comment type="block">/* Trace this connection */</comment>
  <parameter><decl><type><name>unsigned</name></type> <name>mTrace</name></decl></parameter>,                           <comment type="block">/* Mask of events to be traced */</comment>
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xTrace</name>)<parameter_list>(<parameter><decl><type><name>unsigned</name></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,  <comment type="block">/* Callback to invoke */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>                                 <comment type="block">/* Context */</comment>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>mTrace</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>xTrace</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>xTrace</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mTrace</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mTrace</name></name> <operator>=</operator> <name>mTrace</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>trace</name><operator>.</operator><name>xV2</name></name> <operator>=</operator> <name>xTrace</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pTraceArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<comment type="block">/*
** Register a profile function.  The pArg from the previously registered 
** profile function is returned.  
**
** A NULL profile function means that no profiling is executes.  A non-NULL
** profile is a pointer to a function that is invoked at the conclusion of
** each SQL statement that is run.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_profile</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xProfile</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite_uint64</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pOld</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOld</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pProfileArg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xProfile</name></name> <operator>=</operator> <name>xProfile</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pProfileArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mTrace</name></name> <operator>&amp;=</operator> <name>SQLITE_TRACE_NONLEGACY_MASK</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xProfile</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mTrace</name></name> <operator>|=</operator> <name>SQLITE_TRACE_XPROFILE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pOld</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_DEPRECATED */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TRACE */</comment>

<comment type="block">/*
** Register a function to be invoked when a transaction commits.
** If the invoked function returns non-zero, then the commit becomes a
** rollback.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_commit_hook</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,              <comment type="block">/* Attach the hook to this database */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCallback</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,  <comment type="block">/* Function to invoke on each commit */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>                <comment type="block">/* Argument to the function */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pOld</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOld</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pCommitArg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xCommitCallback</name></name> <operator>=</operator> <name>xCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pCommitArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pOld</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Register a callback to be invoked each time a row is updated,
** inserted or deleted using this database connection.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_update_hook</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,              <comment type="block">/* Attach the hook to this database */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xCallback</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite_int64</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>                <comment type="block">/* Argument to the function */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pUpdateArg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xUpdateCallback</name></name> <operator>=</operator> <name>xCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pUpdateArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Register a callback to be invoked each time a transaction is rolled
** back by this database connection.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_rollback_hook</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,              <comment type="block">/* Attach the hook to this database */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xCallback</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* Callback function */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>                <comment type="block">/* Argument to the function */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pRollbackArg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xRollbackCallback</name></name> <operator>=</operator> <name>xCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pRollbackArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_PREUPDATE_HOOK</name></cpp:ifdef>
<comment type="block">/*
** Register a callback to be invoked each time a row is updated,
** inserted or deleted using this database connection.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_preupdate_hook</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,              <comment type="block">/* Attach the hook to this database */</comment>
  <parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier><name>xCallback</name>)<parameter_list>(         <comment type="block">/* Callback function */</comment>
    <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>char</name> <specifier>const</specifier><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>char</name> <specifier>const</specifier><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite3_int64</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_int64</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>                <comment type="block">/* First callback argument */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pPreUpdateArg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xPreUpdateCallback</name></name> <operator>=</operator> <name>xCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pPreUpdateArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_PREUPDATE_HOOK */</comment>

<comment type="block">/*
** Register a function to be invoked prior to each autovacuum that
** determines the number of pages to vacuum.
*/</comment>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_autovacuum_pages</name><argument_list>(
  <argument><expr><name>sqlite3</name> <operator>*</operator><name>db</name></expr></argument>,                 <comment type="block">/* Attach the hook to this database */</comment>
  <argument><expr><name>unsigned</name> <call><call><name>int</name> <argument_list>(<argument><expr><operator>*</operator><name>xCallback</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>,<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>,<argument><expr><name>u32</name></expr></argument>,<argument><expr><name>u32</name></expr></argument>,<argument><expr><name>u32</name></expr></argument>)</argument_list></call></expr></argument>, 
  <argument><expr><name>void</name> <operator>*</operator><name>pArg</name></expr></argument>,                  <comment type="block">/* Argument to the function */</comment>
  <argument><expr><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator><name>xDestructor</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr></argument>   <comment type="block">/* Destructor for pArg */</comment>
)</argument_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>xDestructor</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xDestructor</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xAutovacDestr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>xAutovacDestr</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pAutovacPagesArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xAutovacPages</name></name> <operator>=</operator> <name>xCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pAutovacPagesArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xAutovacDestr</name></name> <operator>=</operator> <name>xDestructor</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
<comment type="block">/*
** The sqlite3_wal_hook() callback registered by sqlite3_wal_autocheckpoint().
** Invoke sqlite3_wal_checkpoint if the number of frames in the log file
** is greater than sqlite3.pWalArg cast to an integer (the value configured by
** wal_autocheckpoint()).
*/</comment> 
<function><type><name>int</name></type> <name>sqlite3WalDefaultHook</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pClientData</name></decl></parameter>,     <comment type="block">/* Argument */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,           <comment type="block">/* Connection */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,       <comment type="block">/* Database */</comment>
  <parameter><decl><type><name>int</name></type> <name>nFrame</name></decl></parameter>             <comment type="block">/* Size of WAL */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nFrame</name><operator>&gt;=</operator><call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><name>pClientData</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_wal_checkpoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_WAL */</comment>

<comment type="block">/*
** Configure an sqlite3_wal_hook() callback to automatically checkpoint
** a database after committing a transaction if there are nFrame or
** more frames in the log file. Passing zero or a negative value as the
** nFrame parameter disables automatic checkpoints entirely.
**
** The callback registered by this function replaces any existing callback
** registered using sqlite3_wal_hook(). Likewise, registering a callback
** using sqlite3_wal_hook() disables the automatic checkpoint mechanism
** configured by this function.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_wal_autocheckpoint</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nFrame</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifdef>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>nFrame</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_wal_hook</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sqlite3WalDefaultHook</name></expr></argument>, <argument><expr><call><name>SQLITE_INT_TO_PTR</name><argument_list>(<argument><expr><name>nFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_wal_hook</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Register a callback to be invoked each time a transaction is written
** into the write-ahead-log by this database connection.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_wal_hook</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Attach the hook to this db handle */</comment>
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xCallback</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>                      <comment type="block">/* First argument passed to xCallback() */</comment>
)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pWalArg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xWalCallback</name></name> <operator>=</operator> <name>xCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pWalArg</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Checkpoint database zDb.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_wal_checkpoint_v2</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,                <comment type="block">/* Name of attached database (or NULL) */</comment>
  <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>,                      <comment type="block">/* SQLITE_CHECKPOINT_* value */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnLog</name></decl></parameter>,                     <comment type="block">/* OUT: Size of WAL log in frames */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnCkpt</name></decl></parameter>                     <comment type="block">/* OUT: Total number of frames checkpointed */</comment>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifdef>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                        <comment type="block">/* Schema to checkpoint */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Initialize the output variables to -1 in case an error occurs. */</comment>
  <if_stmt><if>if<condition>( <expr><name>pnLog</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnLog</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pnCkpt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnCkpt</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_CHECKPOINT_PASSIVE</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_CHECKPOINT_FULL</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_CHECKPOINT_RESTART</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_CHECKPOINT_TRUNCATE</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>eMode</name><argument_list type="generic">&lt;<argument><expr><name>SQLITE_CHECKPOINT_PASSIVE</name> <operator>||</operator> <name>eMode</name></expr></argument>&gt;</argument_list></name><name>SQLITE_CHECKPOINT_TRUNCATE</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* EVIDENCE-OF: R-03996-12088 The M parameter must be a valid checkpoint
    ** mode: */</comment>
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zDb</name> <operator>&amp;&amp;</operator> <name><name>zDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3FindDbName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <name>SQLITE_MAX_DB</name></expr>;</expr_stmt>   <comment type="block">/* This means process all schemas */</comment>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown database: %s"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyHandler</name><operator>.</operator><name>nBusy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Checkpoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>eMode</name></expr></argument>, <argument><expr><name>pnLog</name></expr></argument>, <argument><expr><name>pnCkpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there are no active statements, clear the interrupt flag at this
  ** point.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>AtomicStore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
** Checkpoint database zDb. If zDb is NULL, or if the buffer zDb points
** to contains a zero-length string, all attached databases are 
** checkpointed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_wal_checkpoint</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* EVIDENCE-OF: R-41613-20553 The sqlite3_wal_checkpoint(D,X) is equivalent to
  ** sqlite3_wal_checkpoint_v2(D,X,SQLITE_CHECKPOINT_PASSIVE,0,0). */</comment>
  <return>return <expr><call><name>sqlite3_wal_checkpoint_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>zDb</name></expr></argument>,<argument><expr><name>SQLITE_CHECKPOINT_PASSIVE</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
<comment type="block">/*
** Run a checkpoint on database iDb. This is a no-op if database iDb is
** not currently open in WAL mode.
**
** If a transaction is open on the database being checkpointed, this 
** function returns SQLITE_LOCKED and a checkpoint is not attempted. If 
** an error occurs while running the checkpoint, an SQLite error code is 
** returned (i.e. SQLITE_IOERR). Otherwise, SQLITE_OK.
**
** The mutex on database handle db should be held by the caller. The mutex
** associated with the specific b-tree being checkpointed is taken by
** this function while the checkpoint is running.
**
** If iDb is passed SQLITE_MAX_DB then all attached databases are
** checkpointed. If an error is encountered it is returned immediately -
** no attempt is made to checkpoint any remaining databases.
**
** Parameter eMode is one of SQLITE_CHECKPOINT_PASSIVE, FULL, RESTART
** or TRUNCATE.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Checkpoint</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnLog</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnCkpt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Used to iterate through attached dbs */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bBusy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* True if SQLITE_BUSY has been encountered */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>pnLog</name> <operator>||</operator> <operator>*</operator><name>pnLog</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>pnCkpt</name> <operator>||</operator> <operator>*</operator><name>pnCkpt</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iDb</name><operator>==</operator><name>SQLITE_MAX_ATTACHED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* See forum post a006d86f72 */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iDb</name><operator>==</operator><name>SQLITE_MAX_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>iDb</name> <operator>||</operator> <name>iDb</name><operator>==</operator><name>SQLITE_MAX_DB</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCheckpoint</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><name>eMode</name></expr></argument>, <argument><expr><name>pnLog</name></expr></argument>, <argument><expr><name>pnCkpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pnLog</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>pnCkpt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bBusy</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><ternary><condition><expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bBusy</name><operator>)</operator></expr> ?</condition><then> <expr><name>SQLITE_BUSY</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_WAL */</comment>

<comment type="block">/*
** This function returns true if main-memory should be used instead of
** a temporary file for transient pager files and statement journals.
** The value returned depends on the value of db-&gt;temp_store (runtime
** parameter) and the compile time value of SQLITE_TEMP_STORE. The
** following table describes the relationship between these two values
** and this functions return value.
**
**   SQLITE_TEMP_STORE     db-&gt;temp_store     Location of temporary database
**   -----------------     --------------     ------------------------------
**   0                     any                file      (return 0)
**   1                     1                  file      (return 0)
**   1                     2                  memory    (return 1)
**   1                     0                  file      (return 0)
**   2                     1                  file      (return 0)
**   2                     2                  memory    (return 1)
**   2                     0                  memory    (return 1)
**   3                     any                memory    (return 1)
*/</comment>
<function><type><name>int</name></type> <name>sqlite3TempInMemory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_TEMP_STORE</name><operator>==</operator><literal type="number">1</literal></expr></cpp:if>
  <return>return <expr><operator>(</operator> <name><name>db</name><operator>-&gt;</operator><name>temp_store</name></name><operator>==</operator><literal type="number">2</literal> <operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_TEMP_STORE</name><operator>==</operator><literal type="number">2</literal></expr></cpp:if>
  <return>return <expr><operator>(</operator> <name><name>db</name><operator>-&gt;</operator><name>temp_store</name></name><operator>!=</operator><literal type="number">1</literal> <operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_TEMP_STORE</name><operator>==</operator><literal type="number">3</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name><name>SQLITE_TEMP_STORE</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal> <operator>||</operator> <name>SQLITE_TEMP_STORE</name></expr></argument>&gt;</argument_list></name><literal type="number">3</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Return UTF-8 encoded English language explanation of the most recent
** error.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_errmsg</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>db</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>SQLITE_NOMEM_BKPT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>SQLITE_MISUSE_BKPT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>SQLITE_NOMEM_BKPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <ternary><condition><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the byte offset of the most recent error
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_error_offset</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iOffset</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>db</name> <operator>&amp;&amp;</operator> <call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>errCode</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOffset</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>errByteOffset</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>iOffset</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** Return UTF-16 encoded English language explanation of the most recent
** error.
*/</comment>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_errmsg16</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u16</name></type> <name><name>outOfMem</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="char">'o'</literal></expr>, <expr><literal type="char">'u'</literal></expr>, <expr><literal type="char">'t'</literal></expr>, <expr><literal type="char">' '</literal></expr>, <expr><literal type="char">'o'</literal></expr>, <expr><literal type="char">'f'</literal></expr>, <expr><literal type="char">' '</literal></expr>, <expr><literal type="char">'m'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="char">'m'</literal></expr>, <expr><literal type="char">'o'</literal></expr>, <expr><literal type="char">'r'</literal></expr>, <expr><literal type="char">'y'</literal></expr>, <expr><literal type="number">0</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u16</name></type> <name><name>misuse</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'a'</literal></expr>, <expr><literal type="char">'d'</literal></expr>, <expr><literal type="char">' '</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><literal type="char">'a'</literal></expr>, <expr><literal type="char">'r'</literal></expr>, <expr><literal type="char">'a'</literal></expr>, <expr><literal type="char">'m'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="char">'t'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="char">'r'</literal></expr>, <expr><literal type="char">' '</literal></expr>,
    <expr><literal type="char">'o'</literal></expr>, <expr><literal type="char">'r'</literal></expr>, <expr><literal type="char">' '</literal></expr>, <expr><literal type="char">'o'</literal></expr>, <expr><literal type="char">'t'</literal></expr>, <expr><literal type="char">'h'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="char">'r'</literal></expr>, <expr><literal type="char">' '</literal></expr>, <expr><literal type="char">'A'</literal></expr>, <expr><literal type="char">'P'</literal></expr>, <expr><literal type="char">'I'</literal></expr>, <expr><literal type="char">' '</literal></expr>,
    <expr><literal type="char">'m'</literal></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'s'</literal></expr>, <expr><literal type="char">'u'</literal></expr>, <expr><literal type="char">'s'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="number">0</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>db</name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>outOfMem</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>misuse</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>outOfMem</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_value_text16</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_value_text16</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* A malloc() may have failed within the call to sqlite3_value_text16()
    ** above. If this is the case, then the db-&gt;mallocFailed flag needs to
    ** be cleared before returning. Do this directly, instead of via
    ** sqlite3ApiExit(), to avoid setting the database handle error message.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3OomClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>

<comment type="block">/*
** Return the most recent error code generated by an SQLite routine. If NULL is
** passed to this function, we assume a malloc() failed during sqlite3_open().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_errcode</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>db</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>db</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name> <operator>&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>errMask</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_extended_errcode</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>db</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>db</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_system_errno</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>db</name></expr> ?</condition><then> <expr><name><name>db</name><operator>-&gt;</operator><name>iSysErrno</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>  

<comment type="block">/*
** Return a string that describes the kind of error specified in the
** argument.  For now, this simply calls the internal sqlite3ErrStr()
** function.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_errstr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new collating function for database "db".  The name is zName
** and the encoding is enc.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>createCollation</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, 
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>,
  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xCompare</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>enc2</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If SQLITE_UTF16 is specified as the encoding type, transform this
  ** to one of SQLITE_UTF16LE or SQLITE_UTF16BE using the
  ** SQLITE_UTF16NATIVE macro. SQLITE_UTF16 is not used internally.
  */</comment>
  <expr_stmt><expr><name>enc2</name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>enc2</name><operator>==</operator><name>SQLITE_UTF16</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>enc2</name><operator>==</operator><name>SQLITE_UTF16_ALIGNED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>enc2</name><operator>==</operator><name>SQLITE_UTF16</name> <operator>||</operator> <name>enc2</name><operator>==</operator><name>SQLITE_UTF16_ALIGNED</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>enc2</name> <operator>=</operator> <name>SQLITE_UTF16NATIVE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>enc2</name><argument_list type="generic">&lt;<argument><expr><name>SQLITE_UTF8</name> <operator>||</operator> <name>enc2</name></expr></argument>&gt;</argument_list></name><name>SQLITE_UTF16BE</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check if this call is removing or replacing an existing collation 
  ** sequence. If so, and there are active VMs, return busy. If there
  ** are no active VMs, invalidate any pre-compiled statements.
  */</comment>
  <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>enc2</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pColl</name> <operator>&amp;&amp;</operator> <name><name>pColl</name><operator>-&gt;</operator><name>xCmp</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_BUSY</name></expr></argument>, 
        <argument><expr><literal type="string">"unable to delete/modify collation sequence due to active statements"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If collation sequence pColl was created directly by a call to
    ** sqlite3_create_collation, and not generated by synthCollSeq(),
    ** then any copies made by synthCollSeq() need to be invalidated.
    ** Also, collation destructor - CollSeq.xDel() - function may need
    ** to be called.
    */</comment> 
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pColl</name><operator>-&gt;</operator><name>enc</name></name> <operator>&amp;</operator> <operator>~</operator><name>SQLITE_UTF16_ALIGNED</name><operator>)</operator><operator>==</operator><name>enc2</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>aColl</name> <init>= <expr><call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aCollSeq</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>aColl</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name><name>pColl</name><operator>-&gt;</operator><name>enc</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>xDel</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name><name>p</name><operator>-&gt;</operator><name>xDel</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>xCmp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>enc2</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pColl</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pColl</name><operator>-&gt;</operator><name>xCmp</name></name> <operator>=</operator> <name>xCompare</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pColl</name><operator>-&gt;</operator><name>pUser</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pColl</name><operator>-&gt;</operator><name>xDel</name></name> <operator>=</operator> <name>xDel</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pColl</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>enc2</name> <operator>|</operator> <operator>(</operator><name>enc</name> <operator>&amp;</operator> <name>SQLITE_UTF16_ALIGNED</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This array defines hard upper bounds on limit values.  The
** initializer must be kept in sync with the SQLITE_LIMIT_*
** #defines in sqlite3.h.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>aHardLimit</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>SQLITE_MAX_LENGTH</name></expr>,
  <expr><name>SQLITE_MAX_SQL_LENGTH</name></expr>,
  <expr><name>SQLITE_MAX_COLUMN</name></expr>,
  <expr><name>SQLITE_MAX_EXPR_DEPTH</name></expr>,
  <expr><name>SQLITE_MAX_COMPOUND_SELECT</name></expr>,
  <expr><name>SQLITE_MAX_VDBE_OP</name></expr>,
  <expr><name>SQLITE_MAX_FUNCTION_ARG</name></expr>,
  <expr><name>SQLITE_MAX_ATTACHED</name></expr>,
  <expr><name>SQLITE_MAX_LIKE_PATTERN_LENGTH</name></expr>,
  <expr><name>SQLITE_MAX_VARIABLE_NUMBER</name></expr>,      <comment type="block">/* IMP: R-38091-32352 */</comment>
  <expr><name>SQLITE_MAX_TRIGGER_DEPTH</name></expr>,
  <expr><name>SQLITE_MAX_WORKER_THREADS</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Make sure the hard limits are set to reasonable values
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_LENGTH</name><operator>&lt;</operator><literal type="number">100</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_LENGTH must be at least 100</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_SQL_LENGTH</name><operator>&lt;</operator><literal type="number">100</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_SQL_LENGTH must be at least 100</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_SQL_LENGTH</name><operator>&gt;</operator><name>SQLITE_MAX_LENGTH</name></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_SQL_LENGTH must not be greater than SQLITE_MAX_LENGTH</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_COMPOUND_SELECT</name><operator>&lt;</operator><literal type="number">2</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_COMPOUND_SELECT must be at least 2</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_VDBE_OP</name><operator>&lt;</operator><literal type="number">40</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_VDBE_OP must be at least 40</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name><name>SQLITE_MAX_FUNCTION_ARG</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>SQLITE_MAX_FUNCTION_ARG</name></expr></argument>&gt;</argument_list></name><literal type="number">127</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_FUNCTION_ARG must be between 0 and 127</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name><name>SQLITE_MAX_ATTACHED</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>SQLITE_MAX_ATTACHED</name></expr></argument>&gt;</argument_list></name><literal type="number">125</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_ATTACHED must be between 0 and 125</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_LIKE_PATTERN_LENGTH</name><operator>&lt;</operator><literal type="number">1</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_LIKE_PATTERN_LENGTH must be at least 1</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_COLUMN</name><operator>&gt;</operator><literal type="number">32767</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_COLUMN must not exceed 32767</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_TRIGGER_DEPTH</name><operator>&lt;</operator><literal type="number">1</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_TRIGGER_DEPTH must be at least 1</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name><name>SQLITE_MAX_WORKER_THREADS</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>SQLITE_MAX_WORKER_THREADS</name></expr></argument>&gt;</argument_list></name><literal type="number">50</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_WORKER_THREADS must be between 0 and 50</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Change the value of a limit.  Report the old value.
** If an invalid limit index is supplied, report -1.
** Make no changes but still report the old value if the
** new limit is negative.
**
** A new lower limit does not shrink existing constructs.
** It merely prevents new constructs that exceed the limit
** from forming.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_limit</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limitId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newLimit</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>oldLimit</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* EVIDENCE-OF: R-30189-54097 For each limit category SQLITE_LIMIT_NAME
  ** there is a hard upper bound set at compile-time by a C preprocessor
  ** macro called SQLITE_MAX_NAME. (The "_LIMIT_" in the name is changed to
  ** "_MAX_".)
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_LENGTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_SQL_LENGTH</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_SQL_LENGTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_COLUMN</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_EXPR_DEPTH</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_EXPR_DEPTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_COMPOUND_SELECT</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_COMPOUND_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_VDBE_OP</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_VDBE_OP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_FUNCTION_ARG</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_FUNCTION_ARG</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_ATTACHED</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_ATTACHED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_LIKE_PATTERN_LENGTH</name></expr>]</index></name><operator>==</operator>
                                               <name>SQLITE_MAX_LIKE_PATTERN_LENGTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_VARIABLE_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_TRIGGER_DEPTH</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_TRIGGER_DEPTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aHardLimit</name><index>[<expr><name>SQLITE_LIMIT_WORKER_THREADS</name></expr>]</index></name><operator>==</operator><name>SQLITE_MAX_WORKER_THREADS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_LIMIT_WORKER_THREADS</name><operator>==</operator><operator>(</operator><name>SQLITE_N_LIMIT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>


  <if_stmt><if>if<condition>( <expr><name>limitId</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>limitId</name><operator>&gt;=</operator><name>SQLITE_N_LIMIT</name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>oldLimit</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>limitId</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>newLimit</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>                   <comment type="block">/* IMP: R-52476-28732 */</comment>
    <if_stmt><if>if<condition>( <expr><name>newLimit</name><operator>&gt;</operator><name><name>aHardLimit</name><index>[<expr><name>limitId</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>newLimit</name> <operator>=</operator> <name><name>aHardLimit</name><index>[<expr><name>limitId</name></expr>]</index></name></expr>;</expr_stmt>  <comment type="block">/* IMP: R-51463-25634 */</comment>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>newLimit</name><operator>&lt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>limitId</name><operator>==</operator><name>SQLITE_LIMIT_LENGTH</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>newLimit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>limitId</name></expr>]</index></name> <operator>=</operator> <name>newLimit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>oldLimit</name></expr>;</return>                     <comment type="block">/* IMP: R-53341-35419 */</comment>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to parse both URIs and non-URI filenames passed by the
** user to API functions sqlite3_open() or sqlite3_open_v2(), and for database
** URIs specified as part of ATTACH statements.
**
** The first argument to this function is the name of the VFS to use (or
** a NULL to signify the default VFS) if the URI does not contain a "vfs=xxx"
** query parameter. The second argument contains the URI (or non-URI filename)
** itself. When this function is called the *pFlags variable should contain
** the default flags to open the database handle with. The value stored in
** *pFlags may be updated before returning if the URI filename contains 
** "cache=xxx" or "mode=xxx" query parameters.
**
** If successful, SQLITE_OK is returned. In this case *ppVfs is set to point to
** the VFS that should be used to open the database file. *pzFile is set to
** point to a buffer containing the name of the file to open.  The value
** stored in *pzFile is a database name acceptable to sqlite3_uri_parameter()
** and is in the same format as names created using sqlite3_create_filename().
** The caller must invoke sqlite3_free_filename() (not sqlite3_free()!) on
** the value returned in *pzFile to avoid a memory leak.
**
** If an error occurs, then an SQLite error code is returned and *pzErrMsg
** may be set to point to a buffer containing an English language error 
** message. It is the responsibility of the caller to eventually release
** this buffer by calling sqlite3_free().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ParseUri</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDefaultVfs</name></decl></parameter>,        <comment type="block">/* VFS to use if no "vfs=xxx" query option */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUri</name></decl></parameter>,               <comment type="block">/* Nul-terminated URI to parse */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>pFlags</name></decl></parameter>,           <comment type="block">/* IN/OUT: SQLITE_OPEN_XXX flags */</comment>
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVfs</name></decl></parameter>,            <comment type="block">/* OUT: VFS to use */</comment> 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzFile</name></decl></parameter>,                  <comment type="block">/* OUT: Filename component of URI */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>                 <comment type="block">/* OUT: Error message (if rc!=SQLITE_OK) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name> <init>= <expr><operator>*</operator><name>pFlags</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVfs</name> <init>= <expr><name>zDefaultVfs</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nUri</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zUri</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pzErrMsg</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_URI</name><operator>)</operator>             <comment type="block">/* IMP: R-48725-32206 */</comment>
            <operator>||</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bOpenUri</name></name><operator>)</operator> <comment type="block">/* IMP: R-51689-46548 */</comment>
   <operator>&amp;&amp;</operator> <name>nUri</name><operator>&gt;=</operator><literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>zUri</name></expr></argument>, <argument><expr><literal type="string">"file:"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> <comment type="block">/* IMP: R-57884-37496 */</comment>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOpt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eState</name></decl>;</decl_stmt>                   <comment type="block">/* Parser state when parsing URI */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iIn</name></decl>;</decl_stmt>                      <comment type="block">/* Input character index */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Output character index */</comment>
    <decl_stmt><decl><type><name>u64</name></type> <name>nByte</name> <init>= <expr><name>nUri</name><operator>+</operator><literal type="number">8</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Bytes of space to allocate */</comment>

    <comment type="block">/* Make sure the SQLITE_OPEN_URI flag is set to indicate to the VFS xOpen 
    ** method that there may be extra parameters following the file-name.  */</comment>
    <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>SQLITE_OPEN_URI</name></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>iIn</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iIn</name><operator>&lt;</operator><name>nUri</name></expr>;</condition> <incr><expr><name>iIn</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <operator>(</operator><name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>==</operator><literal type="char">'&amp;'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name>zFile</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zFile</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 4-byte of 0x00 is the start of DB name marker */</comment>
    <expr_stmt><expr><name>zFile</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>iIn</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ALLOW_URI_AUTHORITY</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zUri</name><operator>+</operator><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"///"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iIn</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
      <comment type="block">/* The following condition causes URIs with five leading / characters
      ** like file://///host/path to be converted into UNCs like //host/path.
      ** The correct URI for that UNC has only two or four leading / characters
      ** file://host/path or file:////host/path.  But 5 leading slashes is a 
      ** common error, we are told, so we handle it as a special case. */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zUri</name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"///"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zUri</name><operator>+</operator><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"//localhost/"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iIn</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Discard the scheme and authority segments of the URI. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>zUri</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>zUri</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iIn</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <if_stmt><if>if<condition>( <expr><name>iIn</name><operator>!=</operator><literal type="number">7</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>iIn</name><operator>!=</operator><literal type="number">16</literal> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"localhost"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zUri</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"invalid uri authority: %.*s"</literal></expr></argument>, 
            <argument><expr><name>iIn</name><operator>-</operator><literal type="number">7</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zUri</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
        <goto>goto <name>parse_uri_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Copy the filename and any query parameters into the zFile buffer. 
    ** Decode %HH escape codes along the way. 
    **
    ** Within this loop, variable eState may be set to 0, 1 or 2, depending
    ** on the parsing context. As follows:
    **
    **   0: Parsing file-name.
    **   1: Parsing name section of a name=value query parameter.
    **   2: Parsing value section of a name=value query parameter.
    */</comment>
    <expr_stmt><expr><name>eState</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'#'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'%'</literal> 
       <operator>&amp;&amp;</operator> <call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name></expr></argument>)</argument_list></call> 
       <operator>&amp;&amp;</operator> <call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>zUri</name><index>[<expr><name>iIn</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> 
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>octet</name> <init>= <expr><operator>(</operator><call><name>sqlite3HexToInt</name><argument_list>(<argument><expr><name><name>zUri</name><index>[<expr><name>iIn</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>octet</name> <operator>+=</operator> <call><name>sqlite3HexToInt</name><argument_list>(<argument><expr><name><name>zUri</name><index>[<expr><name>iIn</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>octet</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>octet</name><operator>&lt;</operator><literal type="number">256</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>octet</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_URI_00_ERROR</name></cpp:ifndef>
          <comment type="block">/* This branch is taken when "%00" appears within the URI. In this
          ** case we ignore all text in the remainder of the path, name or
          ** value currently being parsed. So ignore the current character
          ** and skip to the next "?", "=" or "&amp;", as appropriate. */</comment>
          <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'#'</literal> 
              <operator>&amp;&amp;</operator> <operator>(</operator><name>eState</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>c</name><operator>!=</operator><literal type="char">'?'</literal><operator>)</operator>
              <operator>&amp;&amp;</operator> <operator>(</operator><name>eState</name><operator>!=</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>c</name><operator>!=</operator><literal type="char">'='</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'&amp;'</literal><operator>)</operator><operator>)</operator>
              <operator>&amp;&amp;</operator> <operator>(</operator><name>eState</name><operator>!=</operator><literal type="number">2</literal> <operator>||</operator> <name>c</name><operator>!=</operator><literal type="char">'&amp;'</literal><operator>)</operator></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></while>
          <continue>continue;</continue>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <comment type="block">/* If ENABLE_URI_00_ERROR is defined, "%00" in a URI is an error. */</comment>
          <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"unexpected %%00 in uri"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
          <goto>goto <name>parse_uri_out</name>;</goto>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name>octet</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eState</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="char">'&amp;'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'='</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zFile</name><index>[<expr><name>iOut</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* An empty option name. Ignore this option altogether. */</comment>
          <while>while<condition>( <expr><name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zUri</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>!=</operator><literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name><name>zUri</name><index>[<expr><name>iIn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'&amp;'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'&amp;'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>zFile</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>eState</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>eState</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>==</operator><literal type="char">'?'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>eState</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>==</operator><literal type="char">'&amp;'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>eState</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>zFile</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>eState</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zFile</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>zFile</name><operator>+</operator><name>iOut</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* end-of-options + empty journal filenames */</comment>

    <comment type="block">/* Check if there were any options specified that should be interpreted 
    ** here. Options that are interpreted here include "vfs" and those that
    ** correspond to flags that may be passed to the sqlite3_open_v2()
    ** method. */</comment>
    <expr_stmt><expr><name>zOpt</name> <operator>=</operator> <operator>&amp;</operator><name><name>zFile</name><index>[<expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>zOpt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nOpt</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zOpt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVal</name> <init>= <expr><operator>&amp;</operator><name><name>zOpt</name><index>[<expr><name>nOpt</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>nOpt</name><operator>==</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"vfs"</literal></expr></argument>, <argument><expr><name>zOpt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zVfs</name> <operator>=</operator> <name>zVal</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <struct>struct <name>OpenMode</name> <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>
        }</block> <decl><modifier>*</modifier><name>aMode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</struct>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zModeType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>limit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><name>nOpt</name><operator>==</operator><literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"cache"</literal></expr></argument>, <argument><expr><name>zOpt</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>OpenMode</name></name></type> <name><name>aCacheMode</name><index>[]</index></name> <init>= <expr><block>{
            <expr><block>{ <expr><literal type="string">"shared"</literal></expr>,  <expr><name>SQLITE_OPEN_SHAREDCACHE</name></expr> }</block></expr>,
            <expr><block>{ <expr><literal type="string">"private"</literal></expr>, <expr><name>SQLITE_OPEN_PRIVATECACHE</name></expr> }</block></expr>,
            <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
          }</block></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>SQLITE_OPEN_SHAREDCACHE</name><operator>|</operator><name>SQLITE_OPEN_PRIVATECACHE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>aMode</name> <operator>=</operator> <name>aCacheMode</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>limit</name> <operator>=</operator> <name>mask</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>zModeType</name> <operator>=</operator> <literal type="string">"cache"</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>nOpt</name><operator>==</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"mode"</literal></expr></argument>, <argument><expr><name>zOpt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>OpenMode</name></name></type> <name><name>aOpenMode</name><index>[]</index></name> <init>= <expr><block>{
            <expr><block>{ <expr><literal type="string">"ro"</literal></expr>,  <expr><name>SQLITE_OPEN_READONLY</name></expr> }</block></expr>,
            <expr><block>{ <expr><literal type="string">"rw"</literal></expr>,  <expr><name>SQLITE_OPEN_READWRITE</name></expr> }</block></expr>, 
            <expr><block>{ <expr><literal type="string">"rwc"</literal></expr>, <expr><name>SQLITE_OPEN_READWRITE</name> <operator>|</operator> <name>SQLITE_OPEN_CREATE</name></expr> }</block></expr>,
            <expr><block>{ <expr><literal type="string">"memory"</literal></expr>, <expr><name>SQLITE_OPEN_MEMORY</name></expr> }</block></expr>,
            <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
          }</block></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>SQLITE_OPEN_READONLY</name> <operator>|</operator> <name>SQLITE_OPEN_READWRITE</name>
                   <operator>|</operator> <name>SQLITE_OPEN_CREATE</name> <operator>|</operator> <name>SQLITE_OPEN_MEMORY</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>aMode</name> <operator>=</operator> <name>aOpenMode</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>limit</name> <operator>=</operator> <name>mask</name> <operator>&amp;</operator> <name>flags</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>zModeType</name> <operator>=</operator> <literal type="string">"access"</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><name>aMode</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>aMode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>aMode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>==</operator><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>mode</name> <operator>=</operator> <name><name>aMode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mode</name></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if<condition>( <expr><name>mode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"no such %s mode: %s"</literal></expr></argument>, <argument><expr><name>zModeType</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
            <goto>goto <name>parse_uri_out</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name>mode</name> <operator>&amp;</operator> <operator>~</operator><name>SQLITE_OPEN_MEMORY</name><operator>)</operator><operator>&gt;</operator><name>limit</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s mode not allowed: %s"</literal></expr></argument>,
                                        <argument><expr><name>zModeType</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_PERM</name></expr>;</expr_stmt>
            <goto>goto <name>parse_uri_out</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>mask</name><operator>)</operator> <operator>|</operator> <name>mode</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name>zOpt</name> <operator>=</operator> <operator>&amp;</operator><name><name>zVal</name><index>[<expr><name>nVal</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></while>

  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zFile</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nUri</name><operator>+</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zFile</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zFile</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nUri</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>zUri</name></expr></argument>, <argument><expr><name>nUri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>zFile</name><operator>+</operator><name>nUri</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>SQLITE_OPEN_URI</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><name>zVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>ppVfs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"no such vfs: %s"</literal></expr></argument>, <argument><expr><name>zVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
 <label><name>parse_uri_out</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free_filename</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zFile</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pFlags</name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pzFile</name> <operator>=</operator> <name>zFile</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine does the core work of extracting URI parameters from a
** database filename for the sqlite3_uri_parameter() interface.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uriParameter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParam</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>zFilename</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>zFilename</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>zFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>zParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zFilename</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zFilename</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zFilename</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAS_CODEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Process URI filename query parameters relevant to the SQLite Encryption
** Extension.  Return true if any of the relevant query parameters are
** seen and return false if not.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3CodecQueryParameters</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,           <comment type="block">/* Database connection */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,       <comment type="block">/* Which schema is being created/attached */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUri</name></decl></parameter>       <comment type="block">/* URI filename */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zUri</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>zKey</name> <operator>=</operator> <call><name>uriParameter</name><argument_list>(<argument><expr><name>zUri</name></expr></argument>, <argument><expr><literal type="string">"hexkey"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>iByte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zDecoded</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>iByte</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zDecoded</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>zKey</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>iByte</name> <operator>=</operator> <operator>(</operator><name>iByte</name><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>+</operator> <call><name>sqlite3HexToInt</name><argument_list>(<argument><expr><name><name>zKey</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>i</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zDecoded</name><index>[<expr><name>i</name><operator>/</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>iByte</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_key_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zDecoded</name></expr></argument>, <argument><expr><name>i</name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>zKey</name> <operator>=</operator> <call><name>uriParameter</name><argument_list>(<argument><expr><name>zUri</name></expr></argument>, <argument><expr><literal type="string">"key"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_key_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>zKey</name> <operator>=</operator> <call><name>uriParameter</name><argument_list>(<argument><expr><name>zUri</name></expr></argument>, <argument><expr><literal type="string">"textkey"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_key_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>


<comment type="block">/*
** This routine does the work of opening a database on behalf of
** sqlite3_open() and sqlite3_open16(). The database filename "zFilename"  
** is UTF-8 encoded.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>openDatabase</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <comment type="block">/* Database filename UTF-8 encoded */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>,        <comment type="block">/* OUT: Returned database handle */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>,    <comment type="block">/* Operational flags */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVfs</name></decl></parameter>       <comment type="block">/* Name of the VFS to use */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                    <comment type="block">/* Store allocated handle here */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isThreadsafe</name></decl>;</decl_stmt>               <comment type="block">/* True for threadsafe connections */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOpen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Filename argument to pass to BtreeOpen() */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Error message from sqlite3ParseUri() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Loop counter */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>ppDb</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><operator>*</operator><name>ppDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINIT</name></cpp:ifndef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>isThreadsafe</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_NOMUTEX</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>isThreadsafe</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_FULLMUTEX</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>isThreadsafe</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>isThreadsafe</name> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bFullMutex</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_PRIVATECACHE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>SQLITE_OPEN_SHAREDCACHE</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>sharedCacheEnabled</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>SQLITE_OPEN_SHAREDCACHE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Remove harmful bits from the flags parameter
  **
  ** The SQLITE_OPEN_NOMUTEX and SQLITE_OPEN_FULLMUTEX flags were
  ** dealt with in the previous code block.  Besides these, the only
  ** valid input flags for sqlite3_open_v2() are SQLITE_OPEN_READONLY,
  ** SQLITE_OPEN_READWRITE, SQLITE_OPEN_CREATE, SQLITE_OPEN_SHAREDCACHE,
  ** SQLITE_OPEN_PRIVATECACHE, SQLITE_OPEN_EXRESCODE, and some reserved
  ** bits.  Silently mask off all other flags.
  */</comment>
  <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator>  <operator>~</operator><operator>(</operator> <name>SQLITE_OPEN_DELETEONCLOSE</name> <operator>|</operator>
               <name>SQLITE_OPEN_EXCLUSIVE</name> <operator>|</operator>
               <name>SQLITE_OPEN_MAIN_DB</name> <operator>|</operator>
               <name>SQLITE_OPEN_TEMP_DB</name> <operator>|</operator> 
               <name>SQLITE_OPEN_TRANSIENT_DB</name> <operator>|</operator> 
               <name>SQLITE_OPEN_MAIN_JOURNAL</name> <operator>|</operator> 
               <name>SQLITE_OPEN_TEMP_JOURNAL</name> <operator>|</operator> 
               <name>SQLITE_OPEN_SUBJOURNAL</name> <operator>|</operator> 
               <name>SQLITE_OPEN_SUPER_JOURNAL</name> <operator>|</operator>
               <name>SQLITE_OPEN_NOMUTEX</name> <operator>|</operator>
               <name>SQLITE_OPEN_FULLMUTEX</name> <operator>|</operator>
               <name>SQLITE_OPEN_WAL</name>
             <operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Allocate the sqlite data structure */</comment>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>db</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>opendb_out</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isThreadsafe</name> 
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MULTITHREADED_CHECKS</name></cpp:ifdef>
   <operator>||</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name> <operator>=</operator> <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_RECURSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>db</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <goto>goto <name>opendb_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>isThreadsafe</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3MutexWarnOnContention</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errMask</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_EXRESCODE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0xffffffff</literal></expr> </then><else>: <expr><literal type="number">0xff</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>eOpenState</name></name> <operator>=</operator> <name>SQLITE_STATE_BUSY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDbStatic</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>bDisable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>lookaside</name><operator>.</operator><name>sz</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name></name></expr></argument>)</argument_list></sizeof><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aHardLimit</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name></name></expr></argument>, <argument><expr><name>aHardLimit</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_WORKER_THREADS</name></expr>]</index></name> <operator>=</operator> <name>SQLITE_DEFAULT_WORKER_THREADS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nextAutovac</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>szMmap</name></name> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szMmap</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nextPagesize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>azInit</name></name> <operator>=</operator> <name>sqlite3StdType</name></expr>;</expr_stmt> <comment type="block">/* Any array of string ptrs will do */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_MMAP</name></cpp:ifdef>
  <comment type="block">/* Beginning with version 3.37.0, using the VFS xFetch() API to memory-map 
  ** the temporary files used to do external sorts (see code in vdbesort.c)
  ** is disabled. It can still be used either by defining
  ** SQLITE_ENABLE_SORTER_MMAP at compile time or by using the
  ** SQLITE_TESTCTRL_SORTER_MMAP test-control at runtime. */</comment>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nMaxSorterMmap</name></name> <operator>=</operator> <literal type="number">0x7FFFFFFF</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SQLITE_ShortColNames</name>
                 <operator>|</operator> <name>SQLITE_EnableTrigger</name>
                 <operator>|</operator> <name>SQLITE_EnableView</name>
                 <operator>|</operator> <name>SQLITE_CacheSpill</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TRUSTED_SCHEMA</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_TRUSTED_SCHEMA</name><operator>+</operator><literal type="number">0</literal><operator>!=</operator><literal type="number">0</literal></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_TrustedSchema</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* The SQLITE_DQS compile-time option determines the default settings
** for SQLITE_DBCONFIG_DQS_DDL and SQLITE_DBCONFIG_DQS_DML.
**
**    SQLITE_DQS     SQLITE_DBCONFIG_DQS_DDL    SQLITE_DBCONFIG_DQS_DML
**    ----------     -----------------------    -----------------------
**     undefined               on                          on   
**         3                   on                          on
**         2                   on                         off
**         1                  off                          on
**         0                  off                         off
**
** Legacy behavior is 3 (double-quoted string literals are allowed anywhere)
** and so that is the default.  But developers are encouranged to use
** -DSQLITE_DQS=0 (best) or -DSQLITE_DQS=1 (second choice) if possible.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DQS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_DQS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>SQLITE_DQS</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">1</literal></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_DqsDML</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>SQLITE_DQS</name><operator>&amp;</operator><literal type="number">2</literal><operator>)</operator><operator>==</operator><literal type="number">2</literal></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_DqsDDL</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEFAULT_AUTOMATIC_INDEX</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_DEFAULT_AUTOMATIC_INDEX</name></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_AutoIndex</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEFAULT_CKPTFULLFSYNC</name></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_CkptFullFSync</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEFAULT_FILE_FORMAT</name><operator>&lt;</operator><literal type="number">4</literal></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_LegacyFileFmt</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_LOAD_EXTENSION</name></cpp:ifdef>
                 <operator>|</operator> <name>SQLITE_LoadExtension</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEFAULT_RECURSIVE_TRIGGERS</name></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_RecTriggers</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEFAULT_FOREIGN_KEYS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_DEFAULT_FOREIGN_KEYS</name></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_ForeignKeys</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_REVERSE_UNORDERED_SELECTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_ReverseOrder</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_OVERSIZE_CELL_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_CellSizeCk</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS3_TOKENIZER</name></expr></argument>)</argument_list></call></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_Fts3Tokenizer</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_QPSG</name></expr></argument>)</argument_list></call></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_EnableQPSG</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEFAULT_DEFENSIVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_Defensive</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEFAULT_LEGACY_ALTER_TABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
                 <operator>|</operator> <name>SQLITE_LegacyAlter</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      ;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aCollSeq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>sqlite3HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Add the default collation sequence BINARY. BINARY works for both UTF-8
  ** and UTF-16, so add a version for each to avoid any unnecessary
  ** conversions. The only error that can occur here is a malloc() failure.
  **
  ** EVIDENCE-OF: R-52786-44878 SQLite defines three built-in collating
  ** functions:
  */</comment>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sqlite3StrBINARY</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>binCollFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sqlite3StrBINARY</name></expr></argument>, <argument><expr><name>SQLITE_UTF16BE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>binCollFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sqlite3StrBINARY</name></expr></argument>, <argument><expr><name>SQLITE_UTF16LE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>binCollFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"NOCASE"</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nocaseCollatingFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"RTRIM"</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rtrimCollFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>opendb_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Parse the filename/URI argument
  **
  ** Only allow sensible combinations of bits in the flags argument.  
  ** Throw an error if any non-sense combination is used.  If we
  ** do not block illegal combinations here, it could trigger
  ** assert() statements in deeper layers.  Sensible combinations
  ** are:
  **
  **  1:  SQLITE_OPEN_READONLY
  **  2:  SQLITE_OPEN_READWRITE
  **  6:  SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE
  */</comment>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>openFlags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_OPEN_READONLY</name>  <operator>==</operator> <literal type="number">0x01</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_OPEN_READWRITE</name> <operator>==</operator> <literal type="number">0x02</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_OPEN_CREATE</name>    <operator>==</operator> <literal type="number">0x04</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0x02</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* READONLY */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0x04</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* READWRITE */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0x40</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* READWRITE | CREATE */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x46</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>  <comment type="block">/* IMP: R-18321-05872 */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ParseUri</name><argument_list>(<argument><expr><name>zVfs</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zOpen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><ternary><condition><expr><name>zErrMsg</name></expr> ?</condition><then> <expr><literal type="string">"%s"</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>opendb_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Open the backend database driver */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeOpen</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name>zOpen</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                        <argument><expr><name>flags</name> <operator>|</operator> <name>SQLITE_OPEN_MAIN_DB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_IOERR_NOMEM</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>opendb_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSchema</name> <operator>=</operator> <call><name>sqlite3SchemaGet</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3SetTextEncoding</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>SCHEMA_ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pSchema</name> <operator>=</operator> <call><name>sqlite3SchemaGet</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The default safety_level for the main database is FULL; for the temp
  ** database it is OFF. This matches the pager layer defaults.  
  */</comment>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zDbSName</name> <operator>=</operator> <literal type="string">"main"</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>safety_level</name> <operator>=</operator> <name>SQLITE_DEFAULT_SYNCHRONOUS</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>zDbSName</name> <operator>=</operator> <literal type="string">"temp"</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>safety_level</name> <operator>=</operator> <name>PAGER_SYNCHRONOUS_OFF</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>eOpenState</name></name> <operator>=</operator> <name>SQLITE_STATE_OPEN</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>opendb_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Register all built-in functions, but do not attempt to read the
  ** database schema yet. This is delayed until the first time the database
  ** is accessed.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3RegisterPerConnectionBuiltinFunctions</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Load compiled-in extensions */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>sqlite3BuiltinExtensions</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>sqlite3BuiltinExtensions</name><index>[<expr><name>i</name></expr>]</index></name><operator>(</operator><name>db</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Load automatic extensions - extensions that have been registered
  ** using the sqlite3_automatic_extension() API.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3AutoLoadExtensions</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>opendb_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLCIPHER_EXT</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>sqlcipherVtabInit</name><argument_list>(<argument><expr><name>sqlite3</name> <operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlcipherVtabInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_INTERNAL_FUNCTIONS</name></cpp:ifdef>
  <comment type="block">/* Testing use only!!! The -DSQLITE_ENABLE_INTERNAL_FUNCTIONS=1 compile-time
  ** option gives access to internal functions by default.  
  ** Testing use only!!! */</comment>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>|=</operator> <name>DBFLAG_InternalFunc</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* -DSQLITE_DEFAULT_LOCKING_MODE=1 makes EXCLUSIVE the default locking
  ** mode.  -DSQLITE_DEFAULT_LOCKING_MODE=0 make NORMAL the default locking
  ** mode.  Doing nothing at all also makes NORMAL the default.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEFAULT_LOCKING_MODE</name></cpp:ifdef>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>dfltLockMode</name></name> <operator>=</operator> <name>SQLITE_DEFAULT_LOCKING_MODE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PagerLockingMode</name><argument_list>(<argument><expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>SQLITE_DEFAULT_LOCKING_MODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Enable the lookaside-malloc subsystem */</comment>
  <expr_stmt><expr><call><name>setupLookaside</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szLookaside</name></name></expr></argument>,
                        <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nLookaside</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_wal_autocheckpoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DEFAULT_WAL_AUTOCHECKPOINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>opendb_out</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>db</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>isThreadsafe</name><operator>==</operator><literal type="number">0</literal>
           <operator>||</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bFullMutex</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>eOpenState</name></name> <operator>=</operator> <name>SQLITE_STATE_SICK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppDb</name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SQLLOG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xSqllog</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Opening a db handle. Fourth parameter is passed 0. */</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name> <init>= <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pSqllogArg</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xSqllog</name></name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAS_CODEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3CodecQueryParameters</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>
  <expr_stmt><expr><call><name>sqlite3_free_filename</name><argument_list>(<argument><expr><name>zOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Open a new database handle.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_open</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter> 
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>openDatabase</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>,
                      <argument><expr><name>SQLITE_OPEN_READWRITE</name> <operator>|</operator> <name>SQLITE_OPEN_CREATE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_open_v2</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,   <comment type="block">/* Database filename (UTF-8) */</comment>
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>,         <comment type="block">/* OUT: SQLite db handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,              <comment type="block">/* Flags */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVfs</name></decl></parameter>        <comment type="block">/* Name of VFS module to use */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>openDatabase</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>flags</name></expr></argument>, <argument><expr><name>zVfs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** Open a new database handle.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_open16</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zFilename8</name></decl>;</decl_stmt>   <comment type="block">/* zFilename encoded in UTF-8 instead of UTF-16 */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>ppDb</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><operator>*</operator><name>ppDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINIT</name></cpp:ifndef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>zFilename</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <literal type="string">"\000\000"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFilename8</name> <operator>=</operator> <call><name>sqlite3ValueText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFilename8</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>openDatabase</name><argument_list>(<argument><expr><name>zFilename8</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>,
                      <argument><expr><name>SQLITE_OPEN_READWRITE</name> <operator>|</operator> <name>SQLITE_OPEN_CREATE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>ppDb</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>DbHasProperty</name><argument_list>(<argument><expr><operator>*</operator><name>ppDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DB_SchemaLoaded</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>SCHEMA_ENC</name><argument_list>(<argument><expr><operator>*</operator><name>ppDb</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ENC</name><argument_list>(<argument><expr><operator>*</operator><name>ppDb</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>SQLITE_UTF16NATIVE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>

<comment type="block">/*
** Register a new collation sequence with the database handle db.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_collation</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>, 
  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xCompare</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3_create_collation_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>xCompare</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Register a new collation sequence with the database handle db.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_collation_v2</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>, 
  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xCompare</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>enc</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>xCompare</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** Register a new collation sequence with the database handle db.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_collation16</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>, 
  <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>xCompare</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName8</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zName8</name> <operator>=</operator> <call><name>sqlite3Utf16to8</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName8</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName8</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>)</operator><name>enc</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>xCompare</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>

<comment type="block">/*
** Register a collation sequence factory callback with the database handle
** db. Replace any previously installed collation sequence factory.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_collation_needed</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCollNeededArg</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier><name>xCollNeeded</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>eTextRep</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xCollNeeded</name></name> <operator>=</operator> <name>xCollNeeded</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xCollNeeded16</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pCollNeededArg</name></name> <operator>=</operator> <name>pCollNeededArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** Register a collation sequence factory callback with the database handle
** db. Replace any previously installed collation sequence factory.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_collation_needed16</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCollNeededArg</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier><name>xCollNeeded16</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>eTextRep</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xCollNeeded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>xCollNeeded16</name></name> <operator>=</operator> <name>xCollNeeded16</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pCollNeededArg</name></name> <operator>=</operator> <name>pCollNeededArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<comment type="block">/*
** This function is now an anachronism. It used to be used to recover from a
** malloc() failure, but SQLite now does this automatically.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_global_recover</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Test to see whether or not the database connection is in autocommit
** mode.  Return TRUE if it is and FALSE if not.  Autocommit mode is on
** by default.  Autocommit is disabled by a BEGIN statement and reenabled
** by the next COMMIT or ROLLBACK.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_get_autocommit</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following routines are substitutes for constants SQLITE_CORRUPT,
** SQLITE_MISUSE, SQLITE_CANTOPEN, SQLITE_NOMEM and possibly other error
** constants.  They serve two purposes:
**
**   1.  Serve as a convenient place to set a breakpoint in a debugger
**       to detect when version error conditions occurs.
**
**   2.  Invoke sqlite3_log() to provide the source code location where
**       a low-level error is first detected.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ReportError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iErr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>iErr</name></expr></argument>, <argument><expr><literal type="string">"%s at line %d of [%.10s]"</literal></expr></argument>,
              <argument><expr><name>zType</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><literal type="number">20</literal><operator>+</operator><call><name>sqlite3_sourceid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>iErr</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3CorruptError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ReportError</name><argument_list>(<argument><expr><name>SQLITE_CORRUPT</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><literal type="string">"database corruption"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3MisuseError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ReportError</name><argument_list>(<argument><expr><name>SQLITE_MISUSE</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><literal type="string">"misuse"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3CantopenError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ReportError</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><literal type="string">"cannot open file"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_CORRUPT_PGNO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>int</name></type> <name>sqlite3CorruptPgnoError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zMsg</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><literal type="string">"database corruption page %d"</literal></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ReportError</name><argument_list>(<argument><expr><name>SQLITE_CORRUPT</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<function><type><name>int</name></type> <name>sqlite3NomemError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ReportError</name><argument_list>(<argument><expr><name>SQLITE_NOMEM</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><literal type="string">"OOM"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3IoerrnomemError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ReportError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_NOMEM</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><literal type="string">"I/O OOM error"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<comment type="block">/*
** This is a convenience routine that makes sure that all thread-specific
** data for this thread has been deallocated.
**
** SQLite no longer uses thread-specific data so this routine is now a
** no-op.  It is retained for historical compatibility.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_thread_cleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return meta information about a specific column of a database table.
** See comment in sqlite3.h (sqlite.h.in) for details.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_table_column_metadata</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                <comment type="block">/* Connection handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name></decl></parameter>,        <comment type="block">/* Database name or NULL */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTableName</name></decl></parameter>,     <comment type="block">/* Table name */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColumnName</name></decl></parameter>,    <comment type="block">/* Column name */</comment>
  <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>pzDataType</name></decl></parameter>,    <comment type="block">/* OUTPUT: Declared data type */</comment>
  <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>pzCollSeq</name></decl></parameter>,     <comment type="block">/* OUTPUT: Collation sequence name */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pNotNull</name></decl></parameter>,              <comment type="block">/* OUTPUT: True if NOT NULL constraint exists */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pPrimaryKey</name></decl></parameter>,           <comment type="block">/* OUTPUT: True if column part of PK */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pAutoinc</name></decl></parameter>               <comment type="block">/* OUTPUT: True if column is auto-increment */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zDataType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zCollSeq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>notnull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>primarykey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>autoinc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zTableName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Ensure the database schema has been loaded */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><name>rc</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>error_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Locate the table in question */</comment>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTab</name> <operator>||</operator> <call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <goto>goto <name>error_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Find the column for which info is requested */</comment>
  <if_stmt><if>if<condition>( <expr><name>zColumnName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Query for existance of table only */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pCol</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>, <argument><expr><name>zColumnName</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>sqlite3IsRowid</name><argument_list>(<argument><expr><name>zColumnName</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pCol</name> <operator>=</operator> <ternary><condition><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>error_out</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* The following block stores the meta information that will be returned
  ** to the caller in local variables zDataType, zCollSeq, notnull, primarykey
  ** and autoinc. At this point there are two possibilities:
  ** 
  **     1. The specified column name was rowid", "oid" or "_rowid_" 
  **        and there is no explicitly declared IPK column. 
  **
  **     2. The table is not a view and the column name identified an 
  **        explicitly declared column. Copy meta information from *pCol.
  */</comment> 
  <if_stmt><if>if<condition>( <expr><name>pCol</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zDataType</name> <operator>=</operator> <call><name>sqlite3ColumnType</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCollSeq</name> <operator>=</operator> <call><name>sqlite3ColumnColl</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>notnull</name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>notNull</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>primarykey</name>  <operator>=</operator> <operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_PRIMKEY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>autoinc</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name><operator>==</operator><name>iCol</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Autoincrement</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zDataType</name> <operator>=</operator> <literal type="string">"INTEGER"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>primarykey</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zCollSeq</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zCollSeq</name> <operator>=</operator> <name>sqlite3StrBINARY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>error_out</name>:</label>
  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Whether the function call succeeded or failed, set the output parameters
  ** to whatever their local counterparts contain. If an error did occur,
  ** this has the effect of zeroing all output parameters.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pzDataType</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pzDataType</name> <operator>=</operator> <name>zDataType</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pzCollSeq</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pzCollSeq</name> <operator>=</operator> <name>zCollSeq</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNotNull</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pNotNull</name> <operator>=</operator> <name>notnull</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPrimaryKey</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pPrimaryKey</name> <operator>=</operator> <name>primarykey</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pAutoinc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pAutoinc</name> <operator>=</operator> <name>autoinc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><name>rc</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pTab</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zErrMsg</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"no such table column: %s.%s"</literal></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>,
        <argument><expr><name>zColumnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>zErrMsg</name></expr>?</condition><then><expr><literal type="string">"%s"</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Sleep for a little while.  Return the amount of time slept.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_sleep</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ms</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pVfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVfs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* This function works in milliseconds, but the underlying OsSleep() 
  ** API uses microseconds. Hence the 1000's.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><call><name>sqlite3OsSleep</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><literal type="number">1000</literal><operator>*</operator><name>ms</name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Enable or disable the extended result codes.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_extended_result_codes</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>onoff</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errMask</name></name> <operator>=</operator> <ternary><condition><expr><name>onoff</name></expr> ?</condition><then> <expr><literal type="number">0xffffffff</literal></expr> </then><else>: <expr><literal type="number">0xff</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Invoke the xFileControl method on a particular database.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_file_control</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBtree</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBtree</name> <operator>=</operator> <call><name>sqlite3DbNameToBtree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBtree</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name> <operator>=</operator> <call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>sqlite3PagerFile</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>fd</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_FCNTL_FILE_POINTER</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_FCNTL_VFS_POINTER</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>sqlite3_vfs</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <call><name>sqlite3PagerVfs</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_FCNTL_JOURNAL_POINTER</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <call><name>sqlite3PagerJrnlFile</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_FCNTL_DATA_VERSION</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>unsigned</name> <name>int</name><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <call><name>sqlite3PagerDataVersion</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_FCNTL_RESERVE_BYTES</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iNew</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <call><name>sqlite3BtreeGetRequestedReserve</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iNew</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iNew</name><operator>&lt;=</operator><literal type="number">255</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3BtreeSetPageSize</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nSave</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>busyHandler</name><operator>.</operator><name>nBusy</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFileControl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>busyHandler</name><operator>.</operator><name>nBusy</name></name> <operator>=</operator> <name>nSave</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Interface to the testing logic.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_test_control</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_UNTESTABLE</name></cpp:ifdef>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>

    <comment type="block">/*
    ** Save the current state of the PRNG.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_PRNG_SAVE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PrngSaveState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    ** Restore the state of the PRNG to the last state saved using
    ** PRNG_SAVE.  If PRNG_SAVE has never before been called, then
    ** this verb acts like PRNG_RESET.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_PRNG_RESTORE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3PrngRestoreState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*  sqlite3_test_control(SQLITE_TESTCTRL_PRNG_SEED, int x, sqlite3 *db);
    **
    ** Control the seed for the pseudo-random number generator (PRNG) that
    ** is built into SQLite.  Cases:
    **
    **    x!=0 &amp;&amp; db!=0       Seed the PRNG to the current value of the
    **                        schema cookie in the main database for db, or
    **                        x if the schema cookie is zero.  This case
    **                        is convenient to use with database fuzzers
    **                        as it allows the fuzzer some control over the
    **                        the PRNG seed.
    **
    **    x!=0 &amp;&amp; db==0       Seed the PRNG to the value of x.
    **
    **    x==0 &amp;&amp; db==0       Revert to default behavior of using the
    **                        xRandomness method on the primary VFS.
    **
    ** This test-control also resets the PRNG so that the new seed will
    ** be used for the next call to sqlite3_randomness().
    */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WSD</name></cpp:ifndef>
    <case>case <expr><name>SQLITE_TESTCTRL_PRNG_SEED</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSchema</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>db</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>y</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>schema_cookie</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>x</name> <operator>=</operator> <name>y</name></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>sqlite3Config</name><operator>.</operator><name>iPrngSeed</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
    **  sqlite3_test_control(BITVEC_TEST, size, program)
    **
    ** Run a test against a Bitvec object of size.  The program argument
    ** is an array of integers that defines the test.  Return -1 on a
    ** memory allocation error, 0 on success, or non-zero for an error.
    ** See the sqlite3BitvecBuiltinTest() for additional information.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_BITVEC_TEST</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aProg</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BitvecBuiltinTest</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><name>aProg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    **  sqlite3_test_control(FAULT_INSTALL, xCallback)
    **
    ** Arrange to invoke xCallback() whenever sqlite3FaultSim() is called,
    ** if xCallback is not NULL.
    **
    ** As a test of the fault simulator mechanism itself, sqlite3FaultSim(0)
    ** is called immediately after installing the new callback and the return
    ** value from sqlite3FaultSim(0) becomes the return from
    ** sqlite3_test_control().
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_FAULT_INSTALL</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* A bug in MSVC prevents it from understanding pointers to functions
      ** types in the second argument to va_arg().  Work around the problem
      ** using a typedef.
      ** http://support.microsoft.com/kb/47961  &lt;-- dead hyperlink
      ** Search at http://web.archive.org/ to find the 2015-03-16 archive
      ** of the link above to see the original text.
      ** sqlite3GlobalConfig.xTestCallback = va_arg(ap, int(*)(int));
      */</comment>
      <typedef>typedef <function_decl><type><name>int</name></type>(<modifier>*</modifier><name>sqlite3FaultFuncType</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xTestCallback</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3FaultFuncType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3FaultSim</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    **  sqlite3_test_control(BENIGN_MALLOC_HOOKS, xBegin, xEnd)
    **
    ** Register hooks to call to indicate which malloc() failures 
    ** are benign.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS</name></expr>:</case> <block>{<block_content>
      <typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>void_function</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
      <decl_stmt><decl><type><name>void_function</name></type> <name>xBenignBegin</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void_function</name></type> <name>xBenignEnd</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>xBenignBegin</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>xBenignEnd</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BenignMallocHooks</name><argument_list>(<argument><expr><name>xBenignBegin</name></expr></argument>, <argument><expr><name>xBenignEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    **  sqlite3_test_control(SQLITE_TESTCTRL_PENDING_BYTE, unsigned int X)
    **
    ** Set the PENDING byte to the value in the argument, if X&gt;0.
    ** Make no changes if X==0.  Return the value of the pending byte
    ** as it existing before this routine was called.
    **
    ** IMPORTANT:  Changing the PENDING byte from 0x40000000 results in
    ** an incompatible database file format.  Changing the PENDING byte
    ** while any database connection is open results in undefined and
    ** deleterious behavior.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_PENDING_BYTE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PENDING_BYTE</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WSD</name></cpp:ifndef>
      <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>newVal</name> <init>= <macro><name>va_arg</name><argument_list>(<argument>ap</argument>, <argument>unsigned int</argument>)</argument_list></macro></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>newVal</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sqlite3PendingByte</name> <operator>=</operator> <name>newVal</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    **  sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, int X)
    **
    ** This action provides a run-time test to see whether or not
    ** assert() was enabled at compile-time.  If X is true and assert()
    ** is enabled, then the return value is true.  If X is true and
    ** assert() is disabled, then the return value is zero.  If X is
    ** false and assert() is enabled, then the assertion fires and the
    ** process aborts.  If X is false and assert() is disabled, then the
    ** return value is zero.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_ASSERT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <comment type="block">/*side-effects-ok*/</comment> <argument><expr><operator>(</operator><name>x</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <comment type="block">/* Invoke these debugging routines so that the compiler does not
      ** issue "defined but not used" warnings. */</comment>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><literal type="number">9999</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ShowExpr</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ShowExpr</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ShowExprList</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ShowIdList</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ShowSrcList</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ShowWith</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ShowUpsert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ShowTriggerStep</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ShowTriggerStepList</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ShowTrigger</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ShowTriggerList</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
        <expr_stmt><expr><call><name>sqlite3ShowWindow</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ShowWinFunc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>sqlite3ShowSelect</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    </block_content>}</block>


    <comment type="block">/*
    **  sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, int X)
    **
    ** This action provides a run-time test to see how the ALWAYS and
    ** NEVER macros were defined at compile-time.
    **
    ** The return value is ALWAYS(X) if X is true, or 0 if X is false.
    **
    ** The recommended test is X==2.  If the return value is 2, that means
    ** ALWAYS() and NEVER() are both no-op pass-through macros, which is the
    ** default setting.  If the return value is 1, then ALWAYS() is either
    ** hard-coded to true or else it asserts if its argument is false.
    ** The first behavior (hard-coded to true) is the case if
    ** SQLITE_TESTCTRL_ASSERT shows that assert() is disabled and the second
    ** behavior (assert if the argument to ALWAYS() is false) is the case if
    ** SQLITE_TESTCTRL_ASSERT shows that assert() is enabled.
    **
    ** The run-time test procedure might look something like this:
    **
    **    if( sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, 2)==2 ){
    **      // ALWAYS() and NEVER() are no-op pass-through macros
    **    }else if( sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, 1) ){
    **      // ALWAYS(x) asserts that x is true. NEVER(x) asserts x is false.
    **    }else{
    **      // ALWAYS(x) is a constant 1.  NEVER(x) is a constant 0.
    **    }
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_ALWAYS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name>x</name></expr> ?</condition><then> <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*
    **   sqlite3_test_control(SQLITE_TESTCTRL_BYTEORDER);
    **
    ** The integer returned reveals the byte-order of the computer on which
    ** SQLite is running:
    **
    **       1     big-endian,    determined at run-time
    **      10     little-endian, determined at run-time
    **  432101     big-endian,    determined at compile-time
    **  123410     little-endian, determined at compile-time
    */</comment> 
    <case>case <expr><name>SQLITE_TESTCTRL_BYTEORDER</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BYTEORDER</name><operator>*</operator><literal type="number">100</literal> <operator>+</operator> <name>SQLITE_LITTLEENDIAN</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>SQLITE_BIGENDIAN</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*  sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS, sqlite3 *db, int N)
    **
    ** Enable or disable various optimizations for testing purposes.  The 
    ** argument N is a bitmask of optimizations to be disabled.  For normal
    ** operation N should be 0.  The idea is that a test program (like the
    ** SQL Logic Test or SLT test module) can run the same SQL multiple times
    ** with various optimizations disabled to verify that the same answer
    ** is obtained in every case.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_OPTIMIZATIONS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>dbOptFlags</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>u32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*   sqlite3_test_control(SQLITE_TESTCTRL_LOCALTIME_FAULT, onoff, xAlt);
    **
    ** If parameter onoff is 1, subsequent calls to localtime() fail.
    ** If 2, then invoke xAlt() instead of localtime().  If 0, normal
    ** processing.
    **
    ** xAlt arguments are void pointers, but they really want to be:
    **
    **    int xAlt(const time_t*, struct tm*);
    **
    ** xAlt should write results in to struct tm object of its 2nd argument
    ** and return zero on success, or return non-zero on failure.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_LOCALTIME_FAULT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bLocaltimeFault</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bLocaltimeFault</name></name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
        <typedef>typedef <function_decl><type><name>int</name></type>(<modifier>*</modifier><name>sqlite3LocaltimeType</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
        <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xAltLocaltime</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3LocaltimeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xAltLocaltime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*   sqlite3_test_control(SQLITE_TESTCTRL_INTERNAL_FUNCTIONS, sqlite3*);
    **
    ** Toggle the ability to use internal functions on or off for
    ** the database connection given in the argument.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_INTERNAL_FUNCTIONS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>^=</operator> <name>DBFLAG_InternalFunc</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*   sqlite3_test_control(SQLITE_TESTCTRL_NEVER_CORRUPT, int);
    **
    ** Set or clear a flag that indicates that the database file is always well-
    ** formed and never corrupt.  This flag is clear by default, indicating that
    ** database files might have arbitrary corruption.  Setting the flag during
    ** testing causes certain assert() statements in the code to be activated
    ** that demonstrat invariants on well-formed database files.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_NEVER_CORRUPT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>neverCorrupt</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*   sqlite3_test_control(SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS, int);
    **
    ** Set or clear a flag that causes SQLite to verify that type, name,
    ** and tbl_name fields of the sqlite_schema table.  This is normally
    ** on, but it is sometimes useful to turn it off for testing.
    **
    ** 2020-07-22:  Disabling EXTRA_SCHEMA_CHECKS also disables the
    ** verification of rootpage numbers when parsing the schema.  This
    ** is useful to make it easier to reach strange internal error states
    ** during testing.  The EXTRA_SCHEMA_CHECKS setting is always enabled
    ** in production.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bExtraSchemaChecks</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/* Set the threshold at which OP_Once counters reset back to zero.
    ** By default this is 0x7ffffffe (over 2 billion), but that value is
    ** too big to test in a reasonable amount of time, so this control is
    ** provided to set a small and easily reachable reset value.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>iOnceResetThreshold</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*   sqlite3_test_control(SQLITE_TESTCTRL_VDBE_COVERAGE, xCallback, ptr);
    **
    ** Set the VDBE coverage callback function to xCallback with context 
    ** pointer ptr.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_VDBE_COVERAGE</name></expr>:</case> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_VDBE_COVERAGE</name></cpp:ifdef>
      <typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>branch_callback</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>unsigned</name></type> <name>int</name></decl></parameter>,
                                      <parameter><decl><type><name>unsigned</name></type> <name>char</name></decl></parameter>,<parameter><decl><type><name>unsigned</name></type> <name>char</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xVdbeBranch</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>branch_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pVdbeBranchArg</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*   sqlite3_test_control(SQLITE_TESTCTRL_SORTER_MMAP, db, nMax); */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_SORTER_MMAP</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nMaxSorterMmap</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*   sqlite3_test_control(SQLITE_TESTCTRL_ISINIT);
    **
    ** Return SQLITE_OK if SQLite has been initialized and SQLITE_ERROR if
    ** not.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_ISINIT</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>isInit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*  sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, db, dbName, onOff, tnum);
    **
    ** This test control is used to create imposter tables.  "db" is a pointer
    ** to the database connection.  dbName is the database name (ex: "main" or
    ** "temp") which will receive the imposter.  "onOff" turns imposter mode on
    ** or off.  "tnum" is the root page of the b-tree to which the imposter
    ** table should connect.
    **
    ** Enable imposter mode only when the schema has already been parsed.  Then
    ** run a single CREATE TABLE statement to construct the imposter table in
    ** the parsed schema.  Then turn imposter mode back off again.
    **
    ** If onOff==0 and tnum&gt;0 then reset the schema for all databases, causing
    ** the schema to be reparsed the next time it is needed.  This has the
    ** effect of erasing all imposter tables.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_IMPOSTER</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3FindDbName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>iDb</name></name> <operator>=</operator> <name>iDb</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>imposterTable</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>newTnum</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>newTnum</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ResetAllSchemasOfConnection</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYCOVERAGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/*  sqlite3_test_control(SQLITE_TESTCTRL_PARSER_COVERAGE, FILE *out)
    **
    ** This test control (only available when SQLite is compiled with
    ** -DYYCOVERAGE) writes a report onto "out" that shows all
    ** state/lookahead combinations in the parser state machine
    ** which are never exercised.  If any state is missed, make the
    ** return code SQLITE_ERROR.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_PARSER_COVERAGE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>FILE</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ParserCoverage</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(YYCOVERAGE) */</comment>

    <comment type="block">/*  sqlite3_test_control(SQLITE_TESTCTRL_RESULT_INTREAL, sqlite3_context*);
    **
    ** This test-control causes the most recent sqlite3_result_int64() value
    ** to be interpreted as a MEM_IntReal instead of as an MEM_Int.  Normally,
    ** MEM_IntReal values only arise during an INSERT operation of integer
    ** values into a REAL column, so they can be challenging to test.  This
    ** test-control enables us to write an intreal() SQL function that can
    ** inject an intreal() value at arbitrary places in an SQL statement,
    ** for testing purposes.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_RESULT_INTREAL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_context</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3ResultIntReal</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*  sqlite3_test_control(SQLITE_TESTCTRL_SEEK_COUNT,
    **    sqlite3 *db,    // Database connection
    **    u64 *pnSeek     // Write seek count here
    **  );
    **
    ** This test-control queries the seek-counter on the "main" database
    ** file.  The seek-counter is written into *pnSeek and is then reset.
    ** The seek-count is only available if compiled with SQLITE_DEBUG.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_SEEK_COUNT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u64</name> <modifier>*</modifier></type><name>pn</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_uint64</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>pn</name> <operator>=</operator> <call><name>sqlite3BtreeSeekCount</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>db</name></expr>;</expr_stmt>  <comment type="block">/* Silence harmless unused variable warning */</comment>
      <break>break;</break>
    </block_content>}</block>

    <comment type="block">/*  sqlite3_test_control(SQLITE_TESTCTRL_TRACEFLAGS, op, ptr)
    **
    **  "ptr" is a pointer to a u32.  
    **
    **   op==0       Store the current sqlite3TreeTrace in *ptr
    **   op==1       Set sqlite3TreeTrace to the value *ptr
    **   op==3       Store the current sqlite3WhereTrace in *ptr
    **   op==3       Set sqlite3WhereTrace to the value *ptr
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_TRACEFLAGS</name></expr>:</case> <block>{<block_content>
       <decl_stmt><decl><type><name>int</name></type> <name>opTrace</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>u32</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <switch>switch<condition>( <expr><name>opTrace</name></expr> )</condition><block>{<block_content>
         <case>case <expr><literal type="number">0</literal></expr>:</case>   <expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>sqlite3TreeTrace</name></expr>;</expr_stmt>      <break>break;</break>
         <case>case <expr><literal type="number">1</literal></expr>:</case>   <expr_stmt><expr><name>sqlite3TreeTrace</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>      <break>break;</break>
         <case>case <expr><literal type="number">2</literal></expr>:</case>   <expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>sqlite3WhereTrace</name></expr>;</expr_stmt>     <break>break;</break>
         <case>case <expr><literal type="number">3</literal></expr>:</case>   <expr_stmt><expr><name>sqlite3WhereTrace</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>     <break>break;</break>
       </block_content>}</block></switch>
       <break>break;</break>
    </block_content>}</block>

    <comment type="block">/* sqlite3_test_control(SQLITE_TESTCTRL_LOGEST,
    **      double fIn,     // Input value
    **      int *pLogEst,   // sqlite3LogEstFromDouble(fIn)
    **      u64 *pInt,      // sqlite3LogEstToInt(*pLogEst)
    **      int *pLogEst2   // sqlite3LogEst(*pInt)
    ** );
    **
    ** Test access for the LogEst conversion routines.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_LOGEST</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>double</name></type> <name>rIn</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>double</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>LogEst</name></type> <name>rLogEst</name> <init>= <expr><call><name>sqlite3LogEstFromDouble</name><argument_list>(<argument><expr><name>rIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pI1</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u64</name> <modifier>*</modifier></type><name>pU64</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>u64</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pI2</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>pI1</name> <operator>=</operator> <name>rLogEst</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pU64</name> <operator>=</operator> <call><name>sqlite3LogEstToInt</name><argument_list>(<argument><expr><name>rLogEst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pI2</name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><operator>*</operator><name>pU64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_WSD</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* sqlite3_test_control(SQLITE_TESTCTRL_TUNE, id, *piValue)
    **
    ** If "id" is an integer between 1 and SQLITE_NTUNE then set the value
    ** of the id-th tuning parameter to *piValue.  If "id" is between -1
    ** and -SQLITE_NTUNE, then write the current value of the (-id)-th
    ** tuning parameter into *piValue.
    **
    ** Tuning parameters are for use during transient development builds,
    ** to help find the best values for constants in the query planner.
    ** Access tuning parameters using the Tuning(ID) macro.  Set the
    ** parameters in the CLI using ".testctrl tune ID VALUE".
    **
    ** Transient use only.  Tuning parameters should not be used in
    ** checked-in code.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_TUNE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>piValue</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>id</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>id</name><operator>&lt;=</operator><name>SQLITE_NTUNE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>Tuning</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>*</operator><name>piValue</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>id</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>id</name><operator>&gt;=</operator><operator>-</operator><name>SQLITE_NTUNE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>piValue</name> <operator>=</operator> <call><name>Tuning</name><argument_list>(<argument><expr><operator>-</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOTFOUND</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_UNTESTABLE */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The Pager stores the Database filename, Journal filename, and WAL filename
** consecutively in memory, in that order.  The database filename is prefixed
** by four zero bytes.  Locate the start of the database filename by searching
** backwards for the first byte following four consecutive zero bytes.
**
** This only works if the filename passed in was obtained from the Pager.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>databaseName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name><name>zName</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zName</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zName</name><index>[<expr><operator>-</operator><literal type="number">3</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zName</name><index>[<expr><operator>-</operator><literal type="number">4</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zName</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>zName</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append text z[] to the end of p[].  Return a pointer to the first
** character after then zero terminator on the new text in p[].
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>appendText</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name><operator>+</operator><name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate memory to hold names for a database, journal file, WAL file,
** and query parameters.  The pointer returned is valid for use by
** sqlite3_filename_database() and sqlite3_uri_parameter() and related
** functions.
**
** Memory layout must be compatible with that generated by the pager
** and expected by sqlite3_uri_parameter() and databaseName().
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3_create_filename</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDatabase</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zJournal</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWal</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nParam</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azParam</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pResult</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zDatabase</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zJournal</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zWal</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nParam</name><operator>*</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>azParam</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>pResult</name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>appendText</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nParam</name><operator>*</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>appendText</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>azParam</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>appendText</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zJournal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>appendText</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>pResult</name><operator>)</operator><operator>==</operator><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pResult</name> <operator>+</operator> <literal type="number">4</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free memory obtained from sqlite3_create_filename().  It is a severe
** error to call this routine with any parameter other than a pointer
** previously obtained from sqlite3_create_filename() or a NULL pointer.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_free_filename</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>databaseName</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** This is a utility routine, useful to VFS implementations, that checks
** to see if a database file was a URI that contained a specific query 
** parameter, and if so obtains the value of the query parameter.
**
** The zFilename argument is the filename pointer passed into the xOpen()
** method of a VFS implementation.  The zParam argument is the name of the
** query parameter we seek.  This routine returns the value of the zParam
** parameter if it exists.  If the parameter does not exist, this routine
** returns a NULL pointer.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_uri_parameter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParam</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>zFilename</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zParam</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <call><name>databaseName</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>uriParameter</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>zParam</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the name of Nth query parameter of the filename.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_uri_key</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>zFilename</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>N</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <call><name>databaseName</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFilename</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>zFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>N</name><operator>--</operator><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zFilename</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zFilename</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><ternary><condition><expr><name><name>zFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><name>zFilename</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a boolean value for a query parameter.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_uri_boolean</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParam</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bDflt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_uri_parameter</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>zParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>bDflt</name> <operator>=</operator> <name>bDflt</name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>z</name></expr> ?</condition><then> <expr><call><name>sqlite3GetBoolean</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>bDflt</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>bDflt</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a 64-bit integer value for a query parameter.
*/</comment>
<function><type><name>sqlite3_int64</name></type> <name>sqlite3_uri_int64</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,    <comment type="block">/* Filename as passed to xOpen */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParam</name></decl></parameter>,       <comment type="block">/* URI parameter sought */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>bDflt</name></decl></parameter>       <comment type="block">/* return if parameter is missing */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_uri_parameter</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>zParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>v</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name> <operator>&amp;&amp;</operator> <call><name>sqlite3DecOrHexToI64</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>bDflt</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>bDflt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Translate a filename that was handed to a VFS routine into the corresponding
** database, journal, or WAL file.
**
** It is an error to pass this routine a filename string that was not
** passed into the VFS from the SQLite core.  Doing so is similar to
** passing free() a pointer that was not obtained from malloc() - it is
** an error that we cannot easily detect but that will likely cause memory
** corruption.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_filename_database</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>zFilename</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>databaseName</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_filename_journal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>zFilename</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <call><name>databaseName</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFilename</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>zFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zFilename</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zFilename</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>zFilename</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_filename_wal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifdef>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>zFilename</name> <operator>=</operator> <call><name>sqlite3_filename_journal</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFilename</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zFilename</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>zFilename</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Return the Btree pointer identified by zDbName.  Return NULL if not found.
*/</comment>
<function><type><name>Btree</name> <modifier>*</modifier></type><name>sqlite3DbNameToBtree</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> <init>= <expr><ternary><condition><expr><name>zDbName</name></expr> ?</condition><then> <expr><call><name>sqlite3FindDbName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><name>iDb</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the name of the N-th database schema.  Return NULL if N is out
** of range.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_db_name</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>N</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>N</name><operator>&gt;=</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>N</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the filename of the database associated with a database
** connection.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_db_filename</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <call><name>sqlite3DbNameToBtree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>pBt</name></expr> ?</condition><then> <expr><call><name>sqlite3BtreeGetFilename</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return 1 if database is read-only or 0 if read/write.  Return -1 if
** no such database exists.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_db_readonly</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pBt</name> <operator>=</operator> <call><name>sqlite3DbNameToBtree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>pBt</name></expr> ?</condition><then> <expr><call><name>sqlite3BtreeIsReadonly</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SNAPSHOT</name></cpp:ifdef>
<comment type="block">/*
** Obtain a snapshot handle for the snapshot of database zDb currently 
** being read by handle db.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_snapshot_get</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_snapshot</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppSnapshot</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_ERROR</name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> <init>= <expr><call><name>sqlite3FindDbName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iDb</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_TXN_WRITE</name><operator>!=</operator><call><name>sqlite3BtreeTxnState</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeBeginTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSnapshotGet</name><argument_list>(<argument><expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ppSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* SQLITE_OMIT_WAL */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a read-transaction on the snapshot idendified by pSnapshot.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_snapshot_open</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_snapshot</name> <modifier>*</modifier></type><name>pSnapshot</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_ERROR</name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3FindDbName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iDb</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeTxnState</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_TXN_WRITE</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name> <init>= <expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bUnlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeTxnState</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_TXN_NONE</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSnapshotCheck</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>bUnlock</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCommit</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSnapshotOpen</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeBeginTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3PagerSnapshotOpen</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>bUnlock</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3PagerSnapshotUnlock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* SQLITE_OMIT_WAL */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Recover as many snapshots as possible from the wal file associated with
** schema zDb of database db.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_snapshot_recover</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3FindDbName</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iDb</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iDb</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_TXN_NONE</name><operator>==</operator><call><name>sqlite3BtreeTxnState</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeBeginTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerSnapshotRecover</name><argument_list>(<argument><expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3BtreeCommit</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* SQLITE_OMIT_WAL */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free a snapshot handle obtained from sqlite3_snapshot_get().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_snapshot_free</name><parameter_list>(<parameter><decl><type><name>sqlite3_snapshot</name> <modifier>*</modifier></type><name>pSnapshot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_SNAPSHOT */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPILEOPTION_DIAGS</name></cpp:ifndef>
<comment type="block">/*
** Given the name of a compile-time option, return true if that option
** was used and false if not.
**
** The name can optionally begin with "SQLITE_" but the "SQLITE_" prefix
** is not required for a match.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_compileoption_used</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOptName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOpt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCompileOpt</name></decl>;</decl_stmt>
 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_API_ARMOR</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>zOptName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>azCompileOpt</name> <operator>=</operator> <call><name>sqlite3CompileOptions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nOpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zOptName</name></expr></argument>, <argument><expr><literal type="string">"SQLITE_"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zOptName</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zOptName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Since nOpt is normally in single digits, a linear search is 
  ** adequate. No need for a binary search. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nOpt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zOptName</name></expr></argument>, <argument><expr><name><name>azCompileOpt</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <call><name>sqlite3IsIdChar</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>azCompileOpt</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the N-th compile-time option string.  If N is out of range,
** return a NULL pointer.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_compileoption_get</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nOpt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCompileOpt</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>azCompileOpt</name> <operator>=</operator> <call><name>sqlite3CompileOptions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nOpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>N</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>N</name><operator>&lt;</operator><name>nOpt</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>azCompileOpt</name><index>[<expr><name>N</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_COMPILEOPTION_DIAGS */</comment>
</unit>
