<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/insert.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that are called by the parser
** to handle INSERT statements in SQLite.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Generate code that will 
**
**   (1) acquire a lock for table pTab then
**   (2) open pTab as cursor iCur.
**
** If pTab is a WITHOUT ROWID table, then it is the PRIMARY KEY index
** for that table that is actually opened.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3OpenTable</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,  <comment type="block">/* Generate code into this VDBE */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>,       <comment type="block">/* The cursor number of the table */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>,        <comment type="block">/* The database index in sqlite3.aDb[] */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,    <comment type="block">/* The table to be opened */</comment>
  <parameter><decl><type><name>int</name></type> <name>opcode</name></decl></parameter>      <comment type="block">/* OP_OpenRead or OP_OpenWrite */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>opcode</name><operator>==</operator><name>OP_OpenWrite</name> <operator>||</operator> <name>opcode</name><operator>==</operator><name>OP_OpenRead</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, 
                   <argument><expr><ternary><condition><expr><operator>(</operator><name>opcode</name><operator>==</operator><name>OP_OpenWrite</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nNVCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPk</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>tnum</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the column affinity string associated with index
** pIdx. A column affinity string has one character for each column in 
** the table, according to the affinity of the column:
**
**  Character      Column affinity
**  ------------------------------
**  'A'            BLOB
**  'B'            TEXT
**  'C'            NUMERIC
**  'D'            INTEGER
**  'F'            REAL
**
** An extra 'D' is appended to the end of the string to cover the
** rowid that appears as the last column in every index.
**
** Memory for the buffer containing the column index affinity string
** is managed along with the rest of the Index structure. It will be
** released when sqlite3DeleteIndex() is called.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3IndexAffinityStr</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The first time a column affinity string for a particular index is
    ** required, it is allocated and populated here. It is then stored as
    ** a member of the Index structure for subsequent use.
    **
    ** The column affinity string will eventually be deleted by
    ** sqliteDeleteIndex() when the Index structure itself is cleaned
    ** up.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>i16</name></type> <name>x</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name>aff</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>aff</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>affinity</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>x</name><operator>==</operator><name>XN_ROWID</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>aff</name> <operator>=</operator> <name>SQLITE_AFF_INTEGER</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>x</name><operator>==</operator><name>XN_EXPR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aff</name> <operator>=</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>aff</name><operator>&lt;</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>aff</name> <operator>=</operator> <name>SQLITE_AFF_BLOB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>aff</name><operator>&gt;</operator><name>SQLITE_AFF_NUMERIC</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>aff</name> <operator>=</operator> <name>SQLITE_AFF_NUMERIC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>aff</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
 
  <return>return <expr><name><name>pIdx</name><operator>-&gt;</operator><name>zColAff</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Make changes to the evolving bytecode to do affinity transformations
** of values that are about to be gathered into a row for table pTab.
**
** For ordinary (legacy, non-strict) tables:
** -----------------------------------------
**
** Compute the affinity string for table pTab, if it has not already been
** computed.  As an optimization, omit trailing SQLITE_AFF_BLOB affinities.
**
** If the affinity string is empty (because it was all SQLITE_AFF_BLOB entries
** which were then optimized out) then this routine becomes a no-op.
**
** Otherwise if iReg&gt;0 then code an OP_Affinity opcode that will set the
** affinities for register iReg and following.  Or if iReg==0,
** then just set the P4 operand of the previous opcode (which should  be
** an OP_MakeRecord) to the affinity string.
**
** A column affinity string has one character per column:
**
**    Character      Column affinity
**    ---------      ---------------
**    'A'            BLOB
**    'B'            TEXT
**    'C'            NUMERIC
**    'D'            INTEGER
**    'E'            REAL
**
** For STRICT tables:
** ------------------
**
** Generate an appropropriate OP_TypeCheck opcode that will verify the
** datatypes against the column definitions in pTab.  If iReg==0, that
** means an OP_MakeRecord opcode has already been generated and should be
** the last opcode generated.  The new OP_TypeCheck needs to be inserted
** before the OP_MakeRecord.  The new OP_TypeCheck should use the same
** register set as the OP_MakeRecord.  If iReg&gt;0 then register iReg is
** the first of a series of registers that will form the new record.
** Apply the type checking to that array of registers.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3TableAffinity</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zColAff</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Strict</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iReg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Move the previous opcode (which should be OP_MakeRecord) forward
      ** by one slot and insert a new OP_TypeCheck where the current
      ** OP_MakeRecord is found */</comment>
      <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pPrev</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>P4_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPrev</name> <operator>=</operator> <call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPrev</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPrev</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_MakeRecord</name> <operator>||</operator> <call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPrev</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_TypeCheck</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name><name>pPrev</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pPrev</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name><name>pPrev</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Insert an isolated OP_Typecheck */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_TypeCheck</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nNVCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>P4_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zColAff</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zColAff</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zColAff</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zColAff</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zColAff</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>affinity</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3VdbeParser</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nErr</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>zColAff</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>affinity</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name><name>zColAff</name><index>[<expr><name>j</name><operator>--</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zColAff</name><index>[<expr><name>j</name></expr>]</index></name><operator>&lt;=</operator><name>SQLITE_AFF_BLOB</name></expr> )</condition>;</do>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>zColAff</name></name> <operator>=</operator> <name>zColAff</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zColAff</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>sqlite3Strlen30NN</name><argument_list>(<argument><expr><name>zColAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iReg</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Affinity</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zColAff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>opcode</name><operator>==</operator><name>OP_MakeRecord</name>
              <operator>||</operator> <call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zColAff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return non-zero if the table pTab in database iDb or any of its indices
** have been opened at any point in the VDBE program. This is used to see if 
** a statement of the form  "INSERT INTO &lt;iDb, pTab&gt; SELECT ..." can 
** run without using a temporary table for the results of the SELECT. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>readsTable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name> <init>= <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTab</name> <init>= <expr><ternary><condition><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iEnd</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenRead</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><name>iDb</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIndex</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>tnum</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>tnum</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>pIndex</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIndex</name></expr>;</condition> <incr><expr><name>pIndex</name><operator>=</operator><name><name>pIndex</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>tnum</name><operator>==</operator><name><name>pIndex</name><operator>-&gt;</operator><name>tnum</name></name></expr> )</condition><block>{<block_content>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_VOpen</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name></name><operator>==</operator><name>pVTab</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This walker callback will compute the union of colFlags flags for all
** referenced columns in a CHECK constraint or generated column expression.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprColumnFlagUnion</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>&lt;</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>|=</operator> <name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>]</index></name><operator>.</operator><name>colFlags</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
<comment type="block">/*
** All regular columns for table pTab have been puts into registers
** starting with iRegStore.  The registers that correspond to STORED
** or VIRTUAL columns have not yet been initialized.  This routine goes
** back and computes the values for those columns based on the previously
** computed normal columns.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ComputeGeneratedColumns</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iRegStore</name></decl></parameter>,    <comment type="block">/* Register holding the first column */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>       <comment type="block">/* The table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pRedo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eProgress</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasGenerated</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasVirtual</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasStored</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Before computing generated columns, first go through and make sure
  ** that appropriate affinity has been applied to the regular columns
  */</comment>
  <expr_stmt><expr><call><name>sqlite3TableAffinity</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iRegStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasStored</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pOp</name> <operator>=</operator> <call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Affinity</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Change the OP_Affinity argument to '@' (NONE) for all stored
      ** columns.  '@' is the no-op affinity and those columns have not
      ** yet been computed. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>jj</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zP4</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zP4</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_DYNAMIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zP4</name><index>[<expr><name>jj</name></expr>]</index></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr> )</condition><block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_STORED</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>zP4</name><index>[<expr><name>jj</name></expr>]</index></name> <operator>=</operator> <name>SQLITE_AFF_NONE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>jj</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_TypeCheck</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If an OP_TypeCheck was generated because the table is STRICT,
      ** then set the P3 operand to indicate that generated columns should
      ** not be checked */</comment>
      <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Because there can be multiple generated columns that refer to one another,
  ** this is a two-pass algorithm.  On the first pass, mark all generated
  ** columns as "not available".
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_STORED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>|=</operator> <name>COLFLAG_NOTAVAIL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>exprColumnFlagUnion</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xSelectCallback2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* On the second pass, compute the value of each NOT-AVAILABLE column.
  ** Companion code in the TK_COLUMN case of sqlite3ExprCodeTarget() will
  ** compute dependencies and mark remove the COLSPAN_NOTAVAIL mark, as
  ** they are needed.
  */</comment>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <operator>-</operator><name>iRegStore</name></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><name>eProgress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRedo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_NOTAVAIL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|=</operator> <name>COLFLAG_BUSY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>COLFLAG_BUSY</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>&amp;</operator> <name>COLFLAG_NOTAVAIL</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pRedo</name> <operator>=</operator> <name>pCol</name></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>eProgress</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>iRegStore</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeGeneratedColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>COLFLAG_NOTAVAIL</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block>while<condition>( <expr><name>pRedo</name> <operator>&amp;&amp;</operator> <name>eProgress</name></expr> )</condition>;</do>
  <if_stmt><if>if<condition>( <expr><name>pRedo</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"generated column loop on \"%s\""</literal></expr></argument>, <argument><expr><name><name>pRedo</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_GENERATED_COLUMNS */</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
<comment type="block">/*
** Locate or create an AutoincInfo structure associated with table pTab
** which is in database iDb.  Return the register number for the register
** that holds the maximum rowid.  Return zero if pTab is not an AUTOINCREMENT
** table.  (Also return zero when doing a VACUUM since we do not want to
** update the AUTOINCREMENT counters during a VACUUM.)
**
** There is at most one AutoincInfo structure per table even if the
** same table is autoincremented multiple times due to inserts within
** triggers.  A new AutoincInfo structure is created if this is the
** first use of table pTab.  On 2nd and subsequent uses, the original
** AutoincInfo structure is used.
**
** Four consecutive registers are allocated:
**
**   (1)  The name of the pTab table.
**   (2)  The maximum ROWID of pTab.
**   (3)  The rowid in sqlite_sequence of pTab
**   (4)  The original value of the max ROWID in pTab, or NULL if none
**
** The 2nd register is the one that is returned.  That is all the
** insert routine needs to know about.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>autoIncBegin</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>,            <comment type="block">/* Index of the database holding pTab */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>         <comment type="block">/* The table we are writing to */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>memId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Register holding maximum rowid */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>pSchema</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Autoincrement</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_Vacuum</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pToplevel</name> <init>= <expr><call><name>sqlite3ParseToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AutoincInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pSeqTab</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>pSeqTab</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Verify that the sqlite_sequence table exists and is an ordinary
    ** rowid table with exactly two columns.
    ** Ticket d8dc2b3a58cd5dc2918a1d4acb 2018-05-23 */</comment>
    <if_stmt><if>if<condition>( <expr><name>pSeqTab</name><operator>==</operator><literal type="number">0</literal>
     <operator>||</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pSeqTab</name></expr></argument>)</argument_list></call>
     <operator>||</operator> <call><name>NEVER</name><argument_list>(<argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pSeqTab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
     <operator>||</operator> <name><name>pSeqTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>!=</operator><literal type="number">2</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_CORRUPT_SEQUENCE</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <name><name>pToplevel</name><operator>-&gt;</operator><name>pAinc</name></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pInfo</name> <operator>&amp;&amp;</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pTab</name></name><operator>!=</operator><name>pTab</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt> </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>pInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ParserAddCleanup</name><argument_list>(<argument><expr><name>pToplevel</name></expr></argument>, <argument><expr><name>sqlite3DbFree</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>earlyCleanup</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pToplevel</name><operator>-&gt;</operator><name>pAinc</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>pAinc</name></name> <operator>=</operator> <name>pInfo</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>iDb</name></name> <operator>=</operator> <name>iDb</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>nMem</name></name><operator>++</operator></expr>;</expr_stmt>                  <comment type="block">/* Register to hold name of table */</comment>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>regCtr</name></name> <operator>=</operator> <operator>++</operator><name><name>pToplevel</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>  <comment type="block">/* Max rowid register */</comment>
      <expr_stmt><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>       <comment type="block">/* Rowid in sqlite_sequence + orig max val */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>memId</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>regCtr</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>memId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine generates code that will initialize all of the
** register used by the autoincrement tracker.  
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AutoincrementBegin</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AutoincInfo</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>            <comment type="block">/* Information about an AUTOINCREMENT */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                   <comment type="block">/* Database only autoinc table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>memId</name></decl>;</decl_stmt>                 <comment type="block">/* Register holding max rowid */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* VDBE under construction */</comment>

  <comment type="block">/* This routine is never called during trigger-generation.  It is
  ** only called from the top-level */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3IsToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* We failed long ago if this is not so */</comment>
  <for>for<control>(<init><expr><name>p</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pAinc</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>iLn</name> <init>= <expr><call><name>VDBE_OFFSET_LINENO</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>VdbeOpList</name></type> <name><name>autoInc</name><index>[]</index></name> <init>= <expr><block>{
      <comment type="block">/* 0  */</comment> <expr><block>{<expr><name>OP_Null</name></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 1  */</comment> <expr><block>{<expr><name>OP_Rewind</name></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 2  */</comment> <expr><block>{<expr><name>OP_Column</name></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 3  */</comment> <expr><block>{<expr><name>OP_Ne</name></expr>,      <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">9</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 4  */</comment> <expr><block>{<expr><name>OP_Rowid</name></expr>,   <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 5  */</comment> <expr><block>{<expr><name>OP_Column</name></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 6  */</comment> <expr><block>{<expr><name>OP_AddImm</name></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 7  */</comment> <expr><block>{<expr><name>OP_Copy</name></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 8  */</comment> <expr><block>{<expr><name>OP_Goto</name></expr>,    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 9  */</comment> <expr><block>{<expr><name>OP_Next</name></expr>,    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 10 */</comment> <expr><block>{<expr><name>OP_Integer</name></expr>, <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 11 */</comment> <expr><block>{<expr><name>OP_Close</name></expr>,   <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr> 
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>aOp</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iDb</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>memId</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>regCtr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iDb</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>pSeqTab</name></name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeLoadString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>memId</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aOp</name> <operator>=</operator> <call><name>sqlite3VdbeAddOpList</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>autoInc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>autoInc</name></expr></argument>, <argument><expr><name>iLn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aOp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p2</name> <operator>=</operator> <name>memId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p3</name> <operator>=</operator> <name>memId</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>p3</name> <operator>=</operator> <name>memId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>p1</name> <operator>=</operator> <name>memId</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>p3</name> <operator>=</operator> <name>memId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>p5</name> <operator>=</operator> <name>SQLITE_JUMPIFNULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>p2</name> <operator>=</operator> <name>memId</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>p3</name> <operator>=</operator> <name>memId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>p1</name> <operator>=</operator> <name>memId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>.</operator><name>p2</name> <operator>=</operator> <name>memId</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>.</operator><name>p1</name> <operator>=</operator> <name>memId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">10</literal></expr>]</index></name><operator>.</operator><name>p2</name> <operator>=</operator> <name>memId</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Update the maximum rowid for an autoincrement calculation.
**
** This routine should be called when the regRowid register holds a
** new rowid that is about to be inserted.  If that new rowid is
** larger than the maximum rowid in the memId memory cell, then the
** memory cell is updated.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>autoIncStep</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>memId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>regRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>memId</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>OP_MemMax</name></expr></argument>, <argument><expr><name>memId</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine generates the code needed to write autoincrement
** maximum rowid values back into the sqlite_sequence register.
** Every statement that might do an INSERT into an autoincrement
** table (either directly or through triggers) needs to call this
** routine just before the "exit" code.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>autoIncrementEnd</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AutoincInfo</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pAinc</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>iLn</name> <init>= <expr><call><name>VDBE_OFFSET_LINENO</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>VdbeOpList</name></type> <name><name>autoIncEnd</name><index>[]</index></name> <init>= <expr><block>{
      <comment type="block">/* 0 */</comment> <expr><block>{<expr><name>OP_NotNull</name></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 1 */</comment> <expr><block>{<expr><name>OP_NewRowid</name></expr>,    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 2 */</comment> <expr><block>{<expr><name>OP_MakeRecord</name></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 3 */</comment> <expr><block>{<expr><name>OP_Insert</name></expr>,      <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
      <comment type="block">/* 4 */</comment> <expr><block>{<expr><name>OP_Close</name></expr>,       <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>aOp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iDb</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iRec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>memId</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>regCtr</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>iRec</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Le</name></expr></argument>, <argument><expr><name>memId</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><name>memId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iDb</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>pSeqTab</name></name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aOp</name> <operator>=</operator> <call><name>sqlite3VdbeAddOpList</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>autoIncEnd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>autoIncEnd</name></expr></argument>, <argument><expr><name>iLn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aOp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p1</name> <operator>=</operator> <name>memId</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p2</name> <operator>=</operator> <name>memId</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>p1</name> <operator>=</operator> <name>memId</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>p3</name> <operator>=</operator> <name>iRec</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>p2</name> <operator>=</operator> <name>iRec</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>p3</name> <operator>=</operator> <name>memId</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>p5</name> <operator>=</operator> <name>OPFLAG_APPEND</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3AutoincrementEnd</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pAinc</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>autoIncrementEnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/*
** If SQLITE_OMIT_AUTOINCREMENT is defined, then the three routines
** above are all no-ops
*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>autoIncBegin</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>,<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>autoIncStep</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>,<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_AUTOINCREMENT */</comment>


<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>xferOptimization</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parser context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>,         <comment type="block">/* The table we are inserting into */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,      <comment type="block">/* A SELECT statement to use as the data source */</comment>
  <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>,          <comment type="block">/* How to handle constraint errors */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDbDest</name></decl></parameter>           <comment type="block">/* The database of pDest */</comment>
)</parameter_list>;</function_decl>

<comment type="block">/*
** This routine is called to handle SQL of the following forms:
**
**    insert into TABLE (IDLIST) values(EXPRLIST),(EXPRLIST),...
**    insert into TABLE (IDLIST) select
**    insert into TABLE (IDLIST) default values
**
** The IDLIST following the table name is always optional.  If omitted,
** then a list of all (non-hidden) columns for the table is substituted.
** The IDLIST appears in the pColumn parameter.  pColumn is NULL if IDLIST
** is omitted.
**
** For the pSelect parameter holds the values to be inserted for the
** first two forms shown above.  A VALUES clause is really just short-hand
** for a SELECT statement that omits the FROM clause and everything else
** that follows.  If the pSelect parameter is NULL, that means that the
** DEFAULT VALUES form of the INSERT statement is intended.
**
** The code generated follows one of four templates.  For a simple
** insert with data coming from a single-row VALUES clause, the code executes
** once straight down through.  Pseudo-code follows (we call this
** the "1st template"):
**
**         open write cursor to &lt;table&gt; and its indices
**         put VALUES clause expressions into registers
**         write the resulting record into &lt;table&gt;
**         cleanup
**
** The three remaining templates assume the statement is of the form
**
**   INSERT INTO &lt;table&gt; SELECT ...
**
** If the SELECT clause is of the restricted form "SELECT * FROM &lt;table2&gt;" -
** in other words if the SELECT pulls all columns from a single table
** and there is no WHERE or LIMIT or GROUP BY or ORDER BY clauses, and
** if &lt;table2&gt; and &lt;table1&gt; are distinct tables but have identical
** schemas, including all the same indices, then a special optimization
** is invoked that copies raw records from &lt;table2&gt; over to &lt;table1&gt;.
** See the xferOptimization() function for the implementation of this
** template.  This is the 2nd template.
**
**         open a write cursor to &lt;table&gt;
**         open read cursor on &lt;table2&gt;
**         transfer all records in &lt;table2&gt; over to &lt;table&gt;
**         close cursors
**         foreach index on &lt;table&gt;
**           open a write cursor on the &lt;table&gt; index
**           open a read cursor on the corresponding &lt;table2&gt; index
**           transfer all records from the read to the write cursors
**           close cursors
**         end foreach
**
** The 3rd template is for when the second template does not apply
** and the SELECT clause does not read from &lt;table&gt; at any time.
** The generated code follows this template:
**
**         X &lt;- A
**         goto B
**      A: setup for the SELECT
**         loop over the rows in the SELECT
**           load values into registers R..R+n
**           yield X
**         end loop
**         cleanup after the SELECT
**         end-coroutine X
**      B: open write cursor to &lt;table&gt; and its indices
**      C: yield X, at EOF goto D
**         insert the select result into &lt;table&gt; from R..R+n
**         goto C
**      D: cleanup
**
** The 4th template is used if the insert statement takes its
** values from a SELECT but the data is being inserted into a table
** that is also read as part of the SELECT.  In the third form,
** we have to use an intermediate table to store the results of
** the select.  The template is like this:
**
**         X &lt;- A
**         goto B
**      A: setup for the SELECT
**         loop over the tables in the SELECT
**           load value into register R..R+n
**           yield X
**         end loop
**         cleanup after the SELECT
**         end co-routine R
**      B: open temp table
**      L: yield X, at EOF goto M
**         insert row from R..R+n into temp table
**         goto L
**      M: open write cursor to &lt;table&gt; and its indices
**         rewind temp table
**      C: loop over rows of intermediate table
**           transfer values form intermediate table into &lt;table&gt;
**         end loop
**      D: cleanup
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Insert</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parser context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>,    <comment type="block">/* Name of table into which we are inserting */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,      <comment type="block">/* A SELECT statement to use as the data source */</comment>
  <parameter><decl><type><name>IdList</name> <modifier>*</modifier></type><name>pColumn</name></decl></parameter>,      <comment type="block">/* Column names corresponding to IDLIST, or NULL. */</comment>
  <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>,          <comment type="block">/* How to handle constraint errors */</comment>
  <parameter><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pUpsert</name></decl></parameter>       <comment type="block">/* ON CONFLICT clauses for upsert, or NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>          <comment type="block">/* The main database structure */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>          <comment type="block">/* The table to insert into.  aka TABLE */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>             <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>              <comment type="block">/* Generate code into this virtual machine */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>          <comment type="block">/* For looping over indices of the table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nColumn</name></decl>;</decl_stmt>          <comment type="block">/* Number of columns in the data */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nHidden</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Number of hidden columns if TABLE is virtual */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDataCur</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* VDBE cursor that is the main data repository */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* First index cursor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ipkColumn</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Column that is the INTEGER PRIMARY KEY */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>endOfLoop</name></decl>;</decl_stmt>        <comment type="block">/* Label for the end of the insertion loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>srcTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Data comes from this temporary cursor if &gt;=0 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrInsTop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Jump to label "D" */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrCont</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Top of insert loop. Label "C" in templates 3 and 4 */</comment>
  <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>      <comment type="block">/* Destination for SELECT on rhs of INSERT */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>              <comment type="block">/* Index of database holding TABLE */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>useTempTable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Store SELECT results in intermediate table */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>appendFlag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* True if the insert is likely to be an append */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>withoutRowid</name></decl>;</decl_stmt>      <comment type="block">/* 0 for normal table.  1 for WITHOUT ROWID table */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bIdListInOrder</name></decl>;</decl_stmt>    <comment type="block">/* True if IDLIST is in table order */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* List of VALUES() to be inserted  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iRegStore</name></decl>;</decl_stmt>        <comment type="block">/* Register in which to store next column */</comment>

  <comment type="block">/* Register allocations */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regFromSelect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt><comment type="block">/* Base register for data coming from SELECT */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regAutoinc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Register holding the AUTOINCREMENT counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Memory cell used for the row counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regIns</name></decl>;</decl_stmt>           <comment type="block">/* Block of regs holding rowid+data being inserted */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name></decl>;</decl_stmt>         <comment type="block">/* registers holding insert rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regData</name></decl>;</decl_stmt>          <comment type="block">/* register holding first column to insert */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aRegIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* One register allocated to each index */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>isView</name></decl>;</decl_stmt>                 <comment type="block">/* True if attempting to insert into a view */</comment>
  <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pTrigger</name></decl>;</decl_stmt>          <comment type="block">/* List of triggers on pTab, if required */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>tmask</name></decl>;</decl_stmt>                  <comment type="block">/* Mask of trigger times */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pParse</name></name><operator>==</operator><name>pParse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>insert_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>iSDParm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Suppress a harmless compiler warning */</comment>

  <comment type="block">/* If the Select object is really just a simple VALUES() list with a
  ** single row (the common case) then keep that one row of values
  ** and discard the other (unused) parts of the pSelect object
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pSelect</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Values</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Locate the table into which we will be inserting new information.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3SrcListLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>insert_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_INSERT</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                       <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>insert_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>withoutRowid</name> <operator>=</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Figure out if we have any triggers and if the table being
  ** inserted into is a view
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <expr_stmt><expr><name>pTrigger</name> <operator>=</operator> <call><name>sqlite3TriggersExist</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>TK_INSERT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>isView</name> <operator>=</operator> <call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pTrigger</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>tmask</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>isView</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifdef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>isView</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>isView</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>pTrigger</name> <operator>&amp;&amp;</operator> <name>tmask</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pTrigger</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tmask</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x10000</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3TreeViewLine</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"In sqlite3Insert() at %s:%d"</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewInsert</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pColumn</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>,
                          <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>pUpsert</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If pTab is really a view, make sure it has been initialized.
  ** ViewGetColumnNames() is a no-op if pTab is not a view.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>insert_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Cannot insert into a read-only table.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3IsReadOnly</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>tmask</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>insert_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Allocate a VDBE
  */</comment>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>insert_cleanup</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeCountChanges</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name> <operator>||</operator> <name>pTrigger</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_XFER_OPT</name></cpp:ifndef>
  <comment type="block">/* If the statement is of the form
  **
  **       INSERT INTO &lt;table1&gt; SELECT * FROM &lt;table2&gt;;
  **
  ** Then special optimizations can be applied that make the transfer
  ** very fast and which reduce fragmentation of indices.
  **
  ** This is the 2nd template.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pColumn</name><operator>==</operator><literal type="number">0</literal> 
   <operator>&amp;&amp;</operator> <name>pSelect</name><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name>pTrigger</name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <call><name>xferOptimization</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>pTrigger</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>insert_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_XFER_OPT */</comment>

  <comment type="block">/* If this is an AUTOINCREMENT table, look up the sequence number in the
  ** sqlite_sequence table and store it in memory cell regAutoinc.
  */</comment>
  <expr_stmt><expr><name>regAutoinc</name> <operator>=</operator> <call><name>autoIncBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate a block registers to hold the rowid and the values
  ** for all columns of the new row.
  */</comment>
  <expr_stmt><expr><name>regRowid</name> <operator>=</operator> <name>regIns</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>regRowid</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>regData</name> <operator>=</operator> <name>regRowid</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

  <comment type="block">/* If the INSERT statement included an IDLIST term, then make sure
  ** all elements of the IDLIST really are columns of the table and 
  ** remember the column indices.
  **
  ** If the table has an INTEGER PRIMARY KEY column and that column
  ** is named in the IDLIST, then record in the ipkColumn variable
  ** the index into IDLIST of the primary key column.  ipkColumn is
  ** the index of the primary key as it appears in IDLIST, not as
  ** is appears in the original table.  (The index of the INTEGER
  ** PRIMARY KEY in the original table is pTab-&gt;iPKey.)  After this
  ** loop, if ipkColumn==(-1), that means that integer primary key
  ** is unspecified, and hence the table is either WITHOUT ROWID or
  ** it will automatically generated an integer primary key.
  **
  ** bIdListInOrder is true if the columns in IDLIST are in storage
  ** order.  This enables an optimization that avoids shuffling the
  ** columns into storage order.  False negatives are harmless,
  ** but false positives will cause database corruption.
  */</comment>
  <expr_stmt><expr><name>bIdListInOrder</name> <operator>=</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TF_OOOHidden</name><operator>|</operator><name>TF_HasStored</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pColumn</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pColumn</name><operator>-&gt;</operator><name>eU4</name></name><operator>!=</operator><name>EU4_EXPR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pColumn</name><operator>-&gt;</operator><name>eU4</name></name> <operator>=</operator> <name>EU4_IDX</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pColumn</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>pColumn</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u4</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pColumn</name><operator>-&gt;</operator><name>nId</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pColumn</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pColumn</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u4</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><name>j</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bIdListInOrder</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>ipkColumn</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>withoutRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
          <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <operator>(</operator><name>COLFLAG_STORED</name><operator>|</operator><name>COLFLAG_VIRTUAL</name><operator>)</operator></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
               <argument><expr><literal type="string">"cannot INSERT into generated column \"%s\""</literal></expr></argument>,
               <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>insert_cleanup</name>;</goto>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3IsRowid</name><argument_list>(<argument><expr><name><name>pColumn</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>withoutRowid</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>ipkColumn</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>bIdListInOrder</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"table %S has no column named %s"</literal></expr></argument>,
              <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pColumn</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>checkSchema</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <goto>goto <name>insert_cleanup</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Figure out how many columns of data are supplied.  If the data
  ** is coming from a SELECT statement, then generate a co-routine that
  ** produces a single row of the SELECT on each invocation.  The
  ** co-routine is the common header to the 3rd and 4th templates.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Data is coming from a SELECT or from a multi-row VALUES clause.
    ** Generate a co-routine to run the SELECT. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>regYield</name></decl>;</decl_stmt>       <comment type="block">/* Register holding co-routine entry-point */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>addrTop</name></decl>;</decl_stmt>        <comment type="block">/* Top of the co-routine */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>             <comment type="block">/* Result code */</comment>

    <expr_stmt><expr><name>regYield</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrTop</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_InitCoroutine</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addrTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><name>SRT_Coroutine</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>iSdst</name></name> <operator>=</operator> <ternary><condition><expr><name>bIdListInOrder</name></expr> ?</condition><then> <expr><name>regData</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>nSdst</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>regFromSelect</name> <operator>=</operator> <name><name>dest</name><operator>.</operator><name>iSdst</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pParse</name></name><operator>==</operator><name>pParse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>insert_cleanup</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeEndCoroutine</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrTop</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>                       <comment type="block">/* label B: */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>

    <comment type="block">/* Set useTempTable to TRUE if the result of the SELECT statement
    ** should be written into a temporary table (template 4).  Set to
    ** FALSE if each output row of the SELECT can be written directly into
    ** the destination table (template 3).
    **
    ** A temp table must be used if the table being updated is also one
    ** of the tables being read by the SELECT statement.  Also use a 
    ** temp table in the case of row triggers.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>pTrigger</name> <operator>||</operator> <call><name>readsTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>useTempTable</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>useTempTable</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Invoke the coroutine to extract information from the SELECT
      ** and add it to a transient table srcTab.  The code generated
      ** here is from the 4th template:
      **
      **      B: open temp table
      **      L: yield X, goto M at EOF
      **         insert row from R..R+n into temp table
      **         goto L
      **      M: ...
      */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>regRec</name></decl>;</decl_stmt>          <comment type="block">/* Register to hold packed record */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>regTempRowid</name></decl>;</decl_stmt>    <comment type="block">/* Register to hold temp table ROWID */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrL</name></decl>;</decl_stmt>           <comment type="block">/* Label "L" */</comment>

      <expr_stmt><expr><name>srcTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>regRec</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>regTempRowid</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrL</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regFromSelect</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>regTempRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>, <argument><expr><name>regTempRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regTempRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* This is the case if the data for the INSERT is coming from a 
    ** single-row VALUES clause
    */</comment>
    <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>srcTab</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>useTempTable</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprListNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <goto>goto <name>insert_cleanup</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* If there is no IDLIST term but the table has an integer primary
  ** key, the set the ipkColumn variable to the integer primary key 
  ** column index in the original table definition.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pColumn</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nColumn</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>ipkColumn</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>ipkColumn</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasGenerated</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasVirtual</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasStored</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>ipkColumn</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_STORED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>ipkColumn</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Make sure the number of columns in the source data matches the number
    ** of columns to be inserted into the table.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TF_HasHidden</name><operator>==</operator><name>COLFLAG_HIDDEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TF_HasGenerated</name><operator>==</operator><name>COLFLAG_GENERATED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>COLFLAG_NOINSERT</name><operator>==</operator><operator>(</operator><name>COLFLAG_GENERATED</name><operator>|</operator><name>COLFLAG_HIDDEN</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TF_HasGenerated</name><operator>|</operator><name>TF_HasHidden</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_NOINSERT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nHidden</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nColumn</name><operator>!=</operator><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><name>nHidden</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
         <argument><expr><literal type="string">"table %S has %d columns but %d values were supplied"</literal></expr></argument>,
         <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><name>nHidden</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <goto>goto <name>insert_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pColumn</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nColumn</name><operator>!=</operator><name><name>pColumn</name><operator>-&gt;</operator><name>nId</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%d values for %d columns"</literal></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><name><name>pColumn</name><operator>-&gt;</operator><name>nId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>insert_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
    
  <comment type="block">/* Initialize the count of rows to be inserted
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_CountRows</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>bReturning</name></name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>regRowCount</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regRowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If this is not a view, open the table and and all indices */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nIdx</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nIdx</name> <operator>=</operator> <call><name>sqlite3OpenTableAndIndices</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>iDataCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iIdxCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aRegIdx</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nIdx</name><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aRegIdx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <goto>goto <name>insert_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>  <comment type="block">/* Register to store the table record */</comment>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UPSERT</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>pUpsert</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pNx</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"UPSERT not implemented for virtual table \"%s\""</literal></expr></argument>,
              <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>insert_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"cannot UPSERT a view"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>insert_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3HasExplicitNulls</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertTarget</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>insert_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name> <operator>=</operator> <name>iDataCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNx</name> <operator>=</operator> <name>pUpsert</name></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name><name>pNx</name><operator>-&gt;</operator><name>pUpsertSrc</name></name> <operator>=</operator> <name>pTabList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNx</name><operator>-&gt;</operator><name>regData</name></name> <operator>=</operator> <name>regData</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNx</name><operator>-&gt;</operator><name>iDataCur</name></name> <operator>=</operator> <name>iDataCur</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNx</name><operator>-&gt;</operator><name>iIdxCur</name></name> <operator>=</operator> <name>iIdxCur</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNx</name><operator>-&gt;</operator><name>pUpsertTarget</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3UpsertAnalyzeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pNx</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <goto>goto <name>insert_cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pNx</name> <operator>=</operator> <name><name>pNx</name><operator>-&gt;</operator><name>pNextUpsert</name></name></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>pNx</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


  <comment type="block">/* This is the top of the main insertion loop */</comment>
  <if_stmt><if>if<condition>( <expr><name>useTempTable</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This block codes the top of loop only.  The complete loop is the
    ** following pseudocode (template 4):
    **
    **         rewind temp table, if empty goto D
    **      C: loop over rows of intermediate table
    **           transfer values form intermediate table into &lt;table&gt;
    **         end loop
    **      D: ...
    */</comment>
    <expr_stmt><expr><name>addrInsTop</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrCont</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This block codes the top of loop only.  The complete loop is the
    ** following pseudocode (template 3):
    **
    **      C: yield X, at EOF goto D
    **         insert the select result into &lt;table&gt; from R..R+n
    **         goto C
    **      D: ...
    */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeReleaseRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrInsTop</name> <operator>=</operator> <name>addrCont</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>iSDParm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>ipkColumn</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* tag-20191021-001: If the INTEGER PRIMARY KEY is being generated by the
      ** SELECT, go ahead and copy the value into the rowid slot now, so that
      ** the value does not get overwritten by a NULL at tag-20191021-002. */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>regFromSelect</name><operator>+</operator><name>ipkColumn</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Compute data for ordinary columns of the new entry.  Values
  ** are written in storage order into registers starting with regData.
  ** Only ordinary columns are computed in this loop. The rowid
  ** (if there is one) is computed later and generated columns are
  ** computed after the rowid since they might depend on the value
  ** of the rowid.
  */</comment>
  <expr_stmt><expr><name>nHidden</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>iRegStore</name> <operator>=</operator> <name>regData</name></expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>regData</name><operator>==</operator><name>regRowid</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>iRegStore</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>colFlags</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><name>nHidden</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* tag-20191021-002: References to the INTEGER PRIMARY KEY are filled
      ** using the rowid. So put a NULL in the IPK slot of the record to avoid
      ** using excess space.  The file format definition requires this extra
      ** NULL - we cannot optimize further by skipping the column completely */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SoftNull</name></expr></argument>, <argument><expr><name>iRegStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>colFlags</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name><operator>)</operator> <operator>&amp;</operator> <name>COLFLAG_NOINSERT</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nHidden</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Virtual columns do not participate in OP_MakeRecord.  So back up
        ** iRegStore by one slot to compensate for the iRegStore++ in the
        ** outer for() loop */</comment>
        <expr_stmt><expr><name>iRegStore</name><operator>--</operator></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_STORED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Stored columns are computed later.  But if there are BEFORE
        ** triggers, the slots used for stored columns will be OP_Copy-ed
        ** to a second block of registers, so the register needs to be
        ** initialized to NULL to avoid an uninitialized register read */</comment>
        <if_stmt><if>if<condition>( <expr><name>tmask</name> <operator>&amp;</operator> <name>TRIGGER_BEFORE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SoftNull</name></expr></argument>, <argument><expr><name>iRegStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pColumn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Hidden columns that are not explicitly named in the INSERT
        ** get there default value */</comment>
        <expr_stmt><expr><call><name>sqlite3ExprCodeFactorable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
            <argument><expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>iRegStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pColumn</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pColumn</name><operator>-&gt;</operator><name>eU4</name></name><operator>==</operator><name>EU4_IDX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pColumn</name><operator>-&gt;</operator><name>nId</name></name> <operator>&amp;&amp;</operator> <name><name>pColumn</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u4</name><operator>.</operator><name>idx</name></name><operator>!=</operator><name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><name><name>pColumn</name><operator>-&gt;</operator><name>nId</name></name></expr> )</condition><block>{<block_content>
        <comment type="block">/* A column not named in the insert column list gets its
        ** default value */</comment>
        <expr_stmt><expr><call><name>sqlite3ExprCodeFactorable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
            <argument><expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>iRegStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nColumn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* This is INSERT INTO ... DEFAULT VALUES.  Load the default value. */</comment>
      <expr_stmt><expr><call><name>sqlite3ExprCodeFactorable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
          <argument><expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><name>iRegStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <name>i</name> <operator>-</operator> <name>nHidden</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>useTempTable</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>iRegStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>regFromSelect</name><operator>!=</operator><name>regData</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>regFromSelect</name><operator>+</operator><name>k</name></expr></argument>, <argument><expr><name>iRegStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>iRegStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>


  <comment type="block">/* Run the BEFORE and INSTEAD OF triggers, if there are any
  */</comment>
  <expr_stmt><expr><name>endOfLoop</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>tmask</name> <operator>&amp;</operator> <name>TRIGGER_BEFORE</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>regCols</name> <init>= <expr><call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* build the NEW.* reference row.  Note that if there is an INTEGER
    ** PRIMARY KEY into which a NULL is being inserted, that NULL will be
    ** translated into a unique ID for the row.  But on a BEFORE trigger,
    ** we do not know what the unique ID will be (because the insert has
    ** not happened yet) so we substitute a rowid of -1
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>ipkColumn</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>regCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>withoutRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>useTempTable</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>ipkColumn</name></expr></argument>, <argument><expr><name>regCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSelect</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Otherwise useTempTable is true */</comment>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ipkColumn</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>regCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>regCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>regCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>regCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Copy the new data already generated. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nNVCol</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>regRowid</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>regCols</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nNVCol</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
    <comment type="block">/* Compute the new value for generated columns after all other
    ** columns have already been computed.  This must be done after
    ** computing the ROWID in case one of the generated columns
    ** refers to the ROWID. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasGenerated</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasVirtual</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasStored</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ComputeGeneratedColumns</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regCols</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* If this is an INSERT on a view with an INSTEAD OF INSERT trigger,
    ** do not attempt any conversions before assembling the record.
    ** If this is a real table, attempt conversions as required by the
    ** table column affinities.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3TableAffinity</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regCols</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Fire BEFORE or INSTEAD OF triggers */</comment>
    <expr_stmt><expr><call><name>sqlite3CodeRowTrigger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, <argument><expr><name>TK_INSERT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRIGGER_BEFORE</name></expr></argument>, 
        <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regCols</name><operator>-</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>endOfLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regCols</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* The row that the VUpdate opcode will delete: none */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>ipkColumn</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Compute the new rowid */</comment>
      <if_stmt><if>if<condition>( <expr><name>useTempTable</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>ipkColumn</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Rowid already initialized at tag-20191021-001 */</comment>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pIpk</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ipkColumn</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pIpk</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>, <argument><expr><name>regAutoinc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>appendFlag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ipkColumn</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <comment type="block">/* If the PRIMARY KEY expression is NULL, then use OP_NewRowid
      ** to generate a unique primary key value.
      */</comment>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>appendFlag</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>, <argument><expr><name>regAutoinc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>, <argument><expr><name>addr1</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>withoutRowid</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>, <argument><expr><name>regAutoinc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>appendFlag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>autoIncStep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regAutoinc</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
    <comment type="block">/* Compute the new value for generated columns after all other
    ** columns have already been computed.  This must be done after
    ** computing the ROWID in case one of the generated columns
    ** is derived from the INTEGER PRIMARY KEY. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasGenerated</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ComputeGeneratedColumns</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRowid</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Generate code to check constraints and generate index keys and
    ** do the insertion.
    */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pVTab</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VtabMakeWritable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VUpdate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>regIns</name></expr></argument>, <argument><expr><name>pVTab</name></expr></argument>, <argument><expr><name>P4_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><ternary><condition><expr><name>onError</name><operator>==</operator><name>OE_Default</name></expr> ?</condition><then> <expr><name>OE_Abort</name></expr> </then><else>: <expr><name>onError</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>isReplace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt><comment type="block">/* Set to true if constraints may cause a replace */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>bUseSeek</name></decl>;</decl_stmt>     <comment type="block">/* True to use OPFLAG_SEEKRESULT */</comment>
      <expr_stmt><expr><call><name>sqlite3GenerateConstraintChecks</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>aRegIdx</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>,
          <argument><expr><name>regIns</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ipkColumn</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>endOfLoop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isReplace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pUpsert</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3FkCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regIns</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set the OPFLAG_USESEEKRESULT flag if either (a) there are no REPLACE
      ** constraints or (b) there are no triggers and this table is not a
      ** parent table in a foreign key constraint. It is safe to set the
      ** flag in the second case as if any REPLACE constraint is hit, an
      ** OP_Delete or OP_IdxDelete instruction will be executed on each 
      ** cursor that is disturbed. And these instructions both clear the
      ** VdbeCursor.seekResult variable, disabling the OPFLAG_USESEEKRESULT
      ** functionality.  */</comment>
      <expr_stmt><expr><name>bUseSeek</name> <operator>=</operator> <operator>(</operator><name>isReplace</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>sqlite3VdbeHasSubProgram</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3CompleteInsertion</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>,
          <argument><expr><name>regIns</name></expr></argument>, <argument><expr><name>aRegIdx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>appendFlag</name></expr></argument>, <argument><expr><name>bUseSeek</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ALLOW_ROWID_IN_VIEW</name></cpp:ifdef>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>bReturning</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there is a RETURNING clause, populate the rowid register with
    ** constant value -1, in case one or more of the returned expressions
    ** refer to the "rowid" of the view.  */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Update the count of rows that are inserted
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>regRowCount</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>regRowCount</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pTrigger</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Code AFTER triggers */</comment>
    <expr_stmt><expr><call><name>sqlite3CodeRowTrigger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, <argument><expr><name>TK_INSERT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRIGGER_AFTER</name></expr></argument>, 
        <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regData</name><operator>-</operator><literal type="number">2</literal><operator>-</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>endOfLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The bottom of the main insertion loop, if the data source
  ** is a SELECT statement.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>endOfLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>useTempTable</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrInsTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <comment type="block">/* If we are jumping back to an OP_Yield that is preceded by an
    ** OP_ReleaseReg, set the p5 flag on the OP_Goto so that the
    ** OP_ReleaseReg will be included in the loop. */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrCont</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>opcode</name><operator>==</operator><name>OP_ReleaseReg</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>opcode</name><operator>==</operator><name>OP_Yield</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrInsTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_XFER_OPT</name></cpp:ifndef>
<label><name>insert_end</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_XFER_OPT */</comment>
  <comment type="block">/* Update the sqlite_sequence table by storing the content of the
  ** maximum rowid counter values recorded while inserting into
  ** autoincrement tables.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3AutoincrementEnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
  ** Return the number of rows inserted. If this routine is 
  ** generating code because of a call to sqlite3NestedParse(), do not
  ** invoke the callback function.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>regRowCount</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3CodeChangeCount</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>regRowCount</name></expr></argument>, <argument><expr><literal type="string">"rows inserted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>insert_cleanup</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3UpsertDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pUpsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aRegIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Make sure "isView" and other macros defined above are undefined. Otherwise
** they may interfere with compilation of other functions in this file
** (or in another file, if this file becomes part of the amalgamation).  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>isView</name></cpp:ifdef>
 <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isView</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>pTrigger</name></cpp:ifdef>
 <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>pTrigger</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>tmask</name></cpp:ifdef>
 <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>tmask</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Meanings of bits in of pWalker-&gt;eCode for 
** sqlite3ExprReferencesUpdatedColumn()
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CKCNSTRNT_COLUMN</name></cpp:macro>   <cpp:value>0x01</cpp:value></cpp:define>    <comment type="block">/* CHECK constraint uses a changing column */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CKCNSTRNT_ROWID</name></cpp:macro>    <cpp:value>0x02</cpp:value></cpp:define>    <comment type="block">/* CHECK constraint references the ROWID */</comment>

<comment type="block">/* This is the Walker callback from sqlite3ExprReferencesUpdatedColumn().
*  Set bit 0x01 of pWalker-&gt;eCode if pWalker-&gt;eCode to 0 and if this
** expression node references any of the
** columns that are being modifed by an UPDATE statement.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>checkConstraintExprNode</name><parameter_list>(<parameter><decl><type><name>Walker</name> <modifier>*</modifier></type><name>pWalker</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pWalker</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>aiCol</name><index>[<expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>|=</operator> <name>CKCNSTRNT_COLUMN</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pWalker</name><operator>-&gt;</operator><name>eCode</name></name> <operator>|=</operator> <name>CKCNSTRNT_ROWID</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pExpr is a CHECK constraint on a row that is being UPDATE-ed.  The
** only columns that are modified by the UPDATE are those for which
** aiChng[i]&gt;=0, and also the ROWID is modified if chngRowid is true.
**
** Return true if CHECK constraint pExpr uses any of the
** changing columns (or the rowid if it is changing).  In other words,
** return true if this CHECK constraint must be validated for
** the new row in the UPDATE statement.
**
** 2018-09-15: pExpr might also be an expression for an index-on-expressions.
** The operation of this routine is the same - return true if an only if
** the expression uses one or more of columns identified by the second and
** third arguments.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprReferencesUpdatedColumn</name><parameter_list>(
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,    <comment type="block">/* The expression to be checked */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aiChng</name></decl></parameter>,    <comment type="block">/* aiChng[x]&gt;=0 if column x changed by the UPDATE */</comment>
  <parameter><decl><type><name>int</name></type> <name>chngRowid</name></decl></parameter>   <comment type="block">/* True if UPDATE changes the rowid */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>xExprCallback</name></name> <operator>=</operator> <name>checkConstraintExprNode</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>.</operator><name>u</name><operator>.</operator><name>aiCol</name></name> <operator>=</operator> <name>aiChng</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>chngRowid</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>&amp;</operator> <name>CKCNSTRNT_ROWID</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>w</name><operator>.</operator><name>eCode</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CKCNSTRNT_ROWID</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>w</name><operator>.</operator><name>eCode</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>w</name><operator>.</operator><name>eCode</name></name><operator>==</operator><name>CKCNSTRNT_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>w</name><operator>.</operator><name>eCode</name></name><operator>==</operator><name>CKCNSTRNT_ROWID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>w</name><operator>.</operator><name>eCode</name></name><operator>==</operator><operator>(</operator><name>CKCNSTRNT_ROWID</name><operator>|</operator><name>CKCNSTRNT_COLUMN</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>w</name><operator>.</operator><name>eCode</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The sqlite3GenerateConstraintChecks() routine usually wants to visit
** the indexes of a table in the order provided in the Table-&gt;pIndex list.
** However, sometimes (rarely - when there is an upsert) it wants to visit
** the indexes in a different order.  The following data structures accomplish
** this.
**
** The IndexIterator object is used to walk through all of the indexes
** of a table in either Index.pNext order, or in some other order established
** by an array of IndexListTerm objects.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>IndexListTerm</name></name></type> <name>IndexListTerm</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>IndexIterator</name></name></type> <name>IndexIterator</name>;</typedef>
<struct>struct <name>IndexIterator</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>    <comment type="block">/* 0 for Index.pNext list.  1 for an array of IndexListTerm */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>        <comment type="block">/* Index of the current item from the list */</comment>
  <union>union <block>{
    <struct>struct <block>{    <comment type="block">/* Use this object for eType==0: A Index.pNext list */</comment>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>   <comment type="block">/* The current Index */</comment>
    }</block> <decl><name>lx</name></decl>;</struct>      
    <struct>struct <block>{    <comment type="block">/* Use this object for eType==1; Array of IndexListTerm */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nIdx</name></decl>;</decl_stmt>               <comment type="block">/* Size of the array */</comment>
      <decl_stmt><decl><type><name>IndexListTerm</name> <modifier>*</modifier></type><name>aIdx</name></decl>;</decl_stmt>    <comment type="block">/* Array of IndexListTerms */</comment>
    }</block> <decl><name>ax</name></decl>;</struct>
  }</block> <decl><name>u</name></decl>;</union>
}</block>;</struct>

<comment type="block">/* When IndexIterator.eType==1, then each index is an array of instances
** of the following object
*/</comment>
<struct>struct <name>IndexListTerm</name> <block>{
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>  <comment type="block">/* The index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ix</name></decl>;</decl_stmt>    <comment type="block">/* Which entry in the original Table.pIndex list is this index*/</comment>
}</block>;</struct>

<comment type="block">/* Return the first index on the list */</comment>
<function><type><specifier>static</specifier> <name>Index</name> <modifier>*</modifier></type><name>indexIteratorFirst</name><parameter_list>(<parameter><decl><type><name>IndexIterator</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pIx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>i</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pIx</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>aIdx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ix</name></expr>;</expr_stmt>
    <return>return <expr><name><name>pIter</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>aIdx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>p</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pIx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name><name>pIter</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>lx</name><operator>.</operator><name>pIdx</name></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the next index from the list.  Return NULL when out of indexes */</comment>
<function><type><specifier>static</specifier> <name>Index</name> <modifier>*</modifier></type><name>indexIteratorNext</name><parameter_list>(<parameter><decl><type><name>IndexIterator</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pIx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>++</operator><name><name>pIter</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name><name>pIter</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>nIdx</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pIx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pIx</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>aIdx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ix</name></expr>;</expr_stmt>
    <return>return <expr><name><name>pIter</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>aIdx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>++</operator><operator>(</operator><operator>*</operator><name>pIx</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>lx</name><operator>.</operator><name>pIdx</name></name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>lx</name><operator>.</operator><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <return>return <expr><name><name>pIter</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>lx</name><operator>.</operator><name>pIdx</name></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
  
<comment type="block">/*
** Generate code to do constraint checks prior to an INSERT or an UPDATE
** on table pTab.
**
** The regNewData parameter is the first register in a range that contains
** the data to be inserted or the data after the update.  There will be
** pTab-&gt;nCol+1 registers in this range.  The first register (the one
** that regNewData points to) will contain the new rowid, or NULL in the
** case of a WITHOUT ROWID table.  The second register in the range will
** contain the content of the first table column.  The third register will
** contain the content of the second table column.  And so forth.
**
** The regOldData parameter is similar to regNewData except that it contains
** the data prior to an UPDATE rather than afterwards.  regOldData is zero
** for an INSERT.  This routine can distinguish between UPDATE and INSERT by
** checking regOldData for zero.
**
** For an UPDATE, the pkChng boolean is true if the true primary key (the
** rowid for a normal table or the PRIMARY KEY for a WITHOUT ROWID table)
** might be modified by the UPDATE.  If pkChng is false, then the key of
** the iDataCur content table is guaranteed to be unchanged by the UPDATE.
**
** For an INSERT, the pkChng boolean indicates whether or not the rowid
** was explicitly specified as part of the INSERT statement.  If pkChng
** is zero, it means that the either rowid is computed automatically or
** that the table is a WITHOUT ROWID table and has no rowid.  On an INSERT,
** pkChng will only be true if the INSERT statement provides an integer
** value for either the rowid column or its INTEGER PRIMARY KEY alias.
**
** The code generated by this routine will store new index entries into
** registers identified by aRegIdx[].  No index entry is created for
** indices where aRegIdx[i]==0.  The order of indices in aRegIdx[] is
** the same as the order of indices on the linked list of indices
** at pTab-&gt;pIndex.
**
** (2019-05-07) The generated code also creates a new record for the
** main table, if pTab is a rowid table, and stores that record in the
** register identified by aRegIdx[nIdx] - in other words in the first
** entry of aRegIdx[] past the last index.  It is important that the
** record be generated during constraint checks to avoid affinity changes
** to the register content that occur after constraint checks but before
** the new record is inserted.
**
** The caller must have already opened writeable cursors on the main
** table and all applicable indices (that is to say, all indices for which
** aRegIdx[] is not zero).  iDataCur is the cursor for the main table when
** inserting or updating a rowid table, or the cursor for the PRIMARY KEY
** index when operating on a WITHOUT ROWID table.  iIdxCur is the cursor
** for the first index in the pTab-&gt;pIndex list.  Cursors for other indices
** are at iIdxCur+N for the N-th element of the pTab-&gt;pIndex list.
**
** This routine also generates code to check constraints.  NOT NULL,
** CHECK, and UNIQUE constraints are all checked.  If a constraint fails,
** then the appropriate action is performed.  There are five possible
** actions: ROLLBACK, ABORT, FAIL, REPLACE, and IGNORE.
**
**  Constraint type  Action       What Happens
**  ---------------  ----------   ----------------------------------------
**  any              ROLLBACK     The current transaction is rolled back and
**                                sqlite3_step() returns immediately with a
**                                return code of SQLITE_CONSTRAINT.
**
**  any              ABORT        Back out changes from the current command
**                                only (do not do a complete rollback) then
**                                cause sqlite3_step() to return immediately
**                                with SQLITE_CONSTRAINT.
**
**  any              FAIL         Sqlite3_step() returns immediately with a
**                                return code of SQLITE_CONSTRAINT.  The
**                                transaction is not rolled back and any
**                                changes to prior rows are retained.
**
**  any              IGNORE       The attempt in insert or update the current
**                                row is skipped, without throwing an error.
**                                Processing continues with the next row.
**                                (There is an immediate jump to ignoreDest.)
**
**  NOT NULL         REPLACE      The NULL value is replace by the default
**                                value for that column.  If the default value
**                                is NULL, the action is the same as ABORT.
**
**  UNIQUE           REPLACE      The other row that conflicts with the row
**                                being inserted is removed.
**
**  CHECK            REPLACE      Illegal.  The results in an exception.
**
** Which action to take is determined by the overrideError parameter.
** Or if overrideError==OE_Default, then the pParse-&gt;onError parameter
** is used.  Or if pParse-&gt;onError==OE_Default then the onError value
** for the constraint is used.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3GenerateConstraintChecks</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* The parser context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,         <comment type="block">/* The table being inserted or updated */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aRegIdx</name></decl></parameter>,        <comment type="block">/* Use register aRegIdx[i] for index i.  0 for unused */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDataCur</name></decl></parameter>,        <comment type="block">/* Canonical data cursor (main table or PK index) */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdxCur</name></decl></parameter>,         <comment type="block">/* First index cursor */</comment>
  <parameter><decl><type><name>int</name></type> <name>regNewData</name></decl></parameter>,      <comment type="block">/* First register in a range holding values to insert */</comment>
  <parameter><decl><type><name>int</name></type> <name>regOldData</name></decl></parameter>,      <comment type="block">/* Previous content.  0 for INSERTs */</comment>
  <parameter><decl><type><name>u8</name></type> <name>pkChng</name></decl></parameter>,           <comment type="block">/* Non-zero if the rowid or PRIMARY KEY changed */</comment>
  <parameter><decl><type><name>u8</name></type> <name>overrideError</name></decl></parameter>,    <comment type="block">/* Override onError to this if not OE_Default */</comment>
  <parameter><decl><type><name>int</name></type> <name>ignoreDest</name></decl></parameter>,      <comment type="block">/* Jump to this label on an OE_Ignore resolution */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbMayReplace</name></decl></parameter>,   <comment type="block">/* OUT: Set to true if constraint may cause a replace */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aiChng</name></decl></parameter>,         <comment type="block">/* column i is unchanged if aiChng[i]&lt;0 */</comment>
  <parameter><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pUpsert</name></decl></parameter>      <comment type="block">/* ON CONFLICT clauses, if any.  NULL otherwise */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>             <comment type="block">/* VDBE under constrution */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>         <comment type="block">/* Pointer to one of the indices */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* The PRIMARY KEY index for WITHOUT ROWID tables */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>         <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>               <comment type="block">/* loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ix</name></decl>;</decl_stmt>              <comment type="block">/* Index loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>            <comment type="block">/* Number of columns */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>onError</name></decl>;</decl_stmt>         <comment type="block">/* Conflict resolution strategy */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>seenReplace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* True if REPLACE is used to resolve INT PK conflict */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPkField</name></decl>;</decl_stmt>        <comment type="block">/* Number of fields in PRIMARY KEY. 1 for ROWID tables */</comment>
  <decl_stmt><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pUpsertClause</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* The specific ON CONFLICT clause for pIdx */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>isUpdate</name></decl>;</decl_stmt>           <comment type="block">/* True if this is an UPDATE operation */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bAffinityDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* True if the OP_Affinity operation has been run */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>upsertIpkReturn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Address of Goto at end of IPK uniqueness check */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>upsertIpkDelay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Address of Goto to bypass initial IPK check */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ipkTop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Top of the IPK uniqueness check */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ipkBottom</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* OP_Goto at the end of the IPK uniqueness check */</comment>
  <comment type="block">/* Variables associated with retesting uniqueness constraints after
  ** replace triggers fire have run */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regTrigCnt</name></decl>;</decl_stmt>       <comment type="block">/* Register used to count replace trigger invocations */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrRecheck</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Jump here to recheck all uniqueness constraints */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>lblRecheckOk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Each recheck jumps to this label if it passes */</comment>
  <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pTrigger</name></decl>;</decl_stmt>    <comment type="block">/* List of DELETE triggers on the table pTab */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nReplaceTrig</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Number of replace triggers coded */</comment>
  <decl_stmt><decl><type><name>IndexIterator</name></type> <name>sIdxIter</name></decl>;</decl_stmt>  <comment type="block">/* Index iterator */</comment>

  <expr_stmt><expr><name>isUpdate</name> <operator>=</operator> <name>regOldData</name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* This table is not a VIEW */</comment>
  <expr_stmt><expr><name>nCol</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
  
  <comment type="block">/* pPk is the PRIMARY KEY index for WITHOUT ROWID tables and NULL for
  ** normal rowid tables.  nPkField is the number of key fields in the 
  ** pPk index or 1 for a rowid table.  In other words, nPkField is the
  ** number of fields in the true primary key of the table. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pPk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nPkField</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pPk</name> <operator>=</operator> <call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nPkField</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Record that this module has started */</comment>
  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"BEGIN: GenCnstCks(%d,%d,%d,%d,%d)"</literal><operator>,</operator>
                     <name>iDataCur</name><operator>,</operator> <name>iIdxCur</name><operator>,</operator> <name>regNewData</name><operator>,</operator> <name>regOldData</name><operator>,</operator> <name>pkChng</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Test all NOT NULL constraints.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasNotNull</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>b2ndPass</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* True if currently running 2nd pass */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nSeenReplace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Number of ON CONFLICT REPLACE operations */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nGenerated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Number of generated columns with NOT NULL */</comment>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>  <comment type="block">/* Make 2 passes over columns. Exit loop via "break" */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iReg</name></decl>;</decl_stmt>                        <comment type="block">/* Register holding column value */</comment>
        <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The column to check for NOT NULL */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>isGenerated</name></decl>;</decl_stmt>                 <comment type="block">/* non-zero if column is generated */</comment>
        <expr_stmt><expr><name>onError</name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>notNull</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_None</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* No NOT NULL on this column */</comment>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
          <continue>continue;</continue>        <comment type="block">/* ROWID is never NULL */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>isGenerated</name> <operator>=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>isGenerated</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>b2ndPass</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nGenerated</name><operator>++</operator></expr>;</expr_stmt>
          <continue>continue;</continue>        <comment type="block">/* Generated columns processed on 2nd pass */</comment>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>aiChng</name> <operator>&amp;&amp;</operator> <name><name>aiChng</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>isGenerated</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* Do not check NOT NULL on columns that do not change */</comment>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>overrideError</name><operator>!=</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>overrideError</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Replace</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>b2ndPass</name>        <comment type="block">/* REPLACE becomes ABORT on the 2nd pass */</comment>
           <operator>||</operator> <name><name>pCol</name><operator>-&gt;</operator><name>iDflt</name></name><operator>==</operator><literal type="number">0</literal></expr>  <comment type="block">/* REPLACE is ABORT if no DEFAULT value */</comment>
          )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_STORED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>isGenerated</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>b2ndPass</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isGenerated</name></expr> )</condition><block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Rollback</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Abort</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Fail</name>
            <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Ignore</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Replace</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>!=</operator><call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iReg</name> <operator>=</operator> <call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>regNewData</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <switch>switch<condition>( <expr><name>onError</name></expr> )</condition><block>{<block_content>
          <case>case <expr><name>OE_Replace</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>addr1</name> <init>= <expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nSeenReplace</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3ExprCodeCopy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
               <argument><expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block>
          <case>case <expr><name>OE_Abort</name></expr>:</case>
            <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* no break */</comment> <macro><name>deliberate_fall_through</name></macro>
          <case>case <expr><name>OE_Rollback</name></expr>:</case>
          <case>case <expr><name>OE_Fail</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name> <init>= <expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
                                        <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_HaltIfNull</name></expr></argument>, <argument><expr><name>SQLITE_CONSTRAINT_NOTNULL</name></expr></argument>,
                              <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>P5_ConstraintNotNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block>
          <default>default:</default> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Ignore</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>ignoreDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block>
        </block_content>}</block></switch> <comment type="block">/* end switch(onError) */</comment>
      </block_content>}</block></for> <comment type="block">/* end loop i over columns */</comment>
      <if_stmt><if>if<condition>( <expr><name>nGenerated</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nSeenReplace</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* If there are no generated columns with NOT NULL constraints
        ** and no NOT NULL ON CONFLICT REPLACE constraints, then a single
        ** pass is sufficient */</comment>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>b2ndPass</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Never need more than 2 passes */</comment>
      <expr_stmt><expr><name>b2ndPass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name>nSeenReplace</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasGenerated</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* If any NOT NULL ON CONFLICT REPLACE constraints fired on the
        ** first pass, recomputed values for all generated columns, as
        ** those values might depend on columns affected by the REPLACE.
        */</comment>
        <expr_stmt><expr><call><name>sqlite3ComputeGeneratedColumns</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regNewData</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></while> <comment type="block">/* end of 2-pass loop */</comment>
  </block_content>}</block></if></if_stmt> <comment type="block">/* end if( has-not-null-constraints ) */</comment>

  <comment type="block">/* Test all CHECK constraints
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CHECK</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pCheck</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_IgnoreChecks</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pCheck</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>pCheck</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>regNewData</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>onError</name> <operator>=</operator> <ternary><condition><expr><name>overrideError</name><operator>!=</operator><name>OE_Default</name></expr> ?</condition><then> <expr><name>overrideError</name></expr> </then><else>: <expr><name>OE_Abort</name></expr></else></ternary></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCheck</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>allOk</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pCopy</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pCheck</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>aiChng</name>
       <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3ExprReferencesUpdatedColumn</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>aiChng</name></expr></argument>, <argument><expr><name>pkChng</name></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <comment type="block">/* The check constraints do not reference any of the columns being
        ** updated so there is no point it verifying the check constraint */</comment>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>bAffinityDone</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3TableAffinity</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regNewData</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bAffinityDone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>allOk</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeVerifyAbortable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCopy</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>, <argument><expr><name>allOk</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Ignore</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ignoreDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>pCheck</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zName</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Replace</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* IMP: R-26383-51744 */</comment>
        <expr_stmt><expr><call><name>sqlite3HaltConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_CONSTRAINT_CHECK</name></expr></argument>,
                              <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>P4_TRANSIENT</name></expr></argument>,
                              <argument><expr><name>P5_ConstraintCheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>allOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_CHECK) */</comment>

  <comment type="block">/* UNIQUE and PRIMARY KEY constraints should be handled in the following
  ** order:
  **
  **   (1)  OE_Update
  **   (2)  OE_Abort, OE_Fail, OE_Rollback, OE_Ignore
  **   (3)  OE_Replace
  **
  ** OE_Fail and OE_Ignore must happen before any changes are made.
  ** OE_Update guarantees that only a single row will change, so it
  ** must happen before OE_Replace.  Technically, OE_Abort and OE_Rollback
  ** could happen in any order, but they are grouped up front for
  ** convenience.
  **
  ** 2018-08-14: Ticket https://www.sqlite.org/src/info/908f001483982c43
  ** The order of constraints used to have OE_Update as (2) and OE_Abort
  ** and so forth as (1). But apparently PostgreSQL checks the OE_Update
  ** constraint before any others, so it had to be moved.
  **
  ** Constraint checking code is generated in this order:
  **   (A)  The rowid constraint
  **   (B)  Unique index constraints that do not have OE_Replace as their
  **        default conflict resolution strategy
  **   (C)  Unique index that do use OE_Replace by default.
  **
  ** The ordering of (2) and (3) is accomplished by making sure the linked
  ** list of indexes attached to a table puts all OE_Replace indexes last
  ** in the list.  See sqlite3CreateIndex() for where that happens.
  */</comment>
  <expr_stmt><expr><name><name>sIdxIter</name><operator>.</operator><name>eType</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sIdxIter</name><operator>.</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sIdxIter</name><operator>.</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>aIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Silence harmless compiler warning */</comment>
  <expr_stmt><expr><name><name>sIdxIter</name><operator>.</operator><name>u</name><operator>.</operator><name>lx</name><operator>.</operator><name>pIdx</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pUpsert</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pUpsertTarget</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* There is just on ON CONFLICT clause and it has no constraint-target */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pNextUpsert</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pUpsert</name><operator>-&gt;</operator><name>isDoUpdate</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* A single ON CONFLICT DO NOTHING clause, without a constraint-target.
        ** Make all unique constraint resolution be OE_Ignore */</comment>
        <expr_stmt><expr><name>overrideError</name> <operator>=</operator> <name>OE_Ignore</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pUpsert</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* A single ON CONFLICT DO UPDATE.  Make all resolutions OE_Update */</comment>
        <expr_stmt><expr><name>overrideError</name> <operator>=</operator> <name>OE_Update</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Otherwise, we'll need to run the IndexListTerm array version of the
      ** iterator to ensure that all of the ON CONFLICT conditions are
      ** checked first and in order. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nIdx</name></decl>, <decl><type ref="prev"/><name>jj</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u64</name></type> <name>nByte</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>bUsed</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>nIdx</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>nIdx</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
         <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aRegIdx</name><index>[<expr><name>nIdx</name></expr>]</index></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>sIdxIter</name><operator>.</operator><name>eType</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sIdxIter</name><operator>.</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>nIdx</name></name> <operator>=</operator> <name>nIdx</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nByte</name> <operator>=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>IndexListTerm</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>nIdx</name> <operator>+</operator> <name>nIdx</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sIdxIter</name><operator>.</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>aIdx</name></name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>sIdxIter</name><operator>.</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>aIdx</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* OOM */</comment>
      <expr_stmt><expr><name>bUsed</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>sIdxIter</name><operator>.</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>aIdx</name><index>[<expr><name>nIdx</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pUpsert</name><operator>-&gt;</operator><name>pToFree</name></name> <operator>=</operator> <name><name>sIdxIter</name><operator>.</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>aIdx</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pTerm</name><operator>=</operator><name>pUpsert</name></expr>;</init> <condition><expr><name>pTerm</name></expr>;</condition> <incr><expr><name>pTerm</name><operator>=</operator><name><name>pTerm</name><operator>-&gt;</operator><name>pNextUpsert</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pUpsertTarget</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pUpsertIdx</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Skip ON CONFLICT for the IPK */</comment>
        <expr_stmt><expr><name>jj</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</expr_stmt>
        <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pIdx</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>pIdx</name><operator>!=</operator><name><name>pTerm</name><operator>-&gt;</operator><name>pUpsertIdx</name></name></expr> )</condition><block>{<block_content>
           <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
           <expr_stmt><expr><name>jj</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name><name>bUsed</name><index>[<expr><name>jj</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* Duplicate ON CONFLICT clause ignored */</comment>
        <expr_stmt><expr><name><name>bUsed</name><index>[<expr><name>jj</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sIdxIter</name><operator>.</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>aIdx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sIdxIter</name><operator>.</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>aIdx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ix</name> <operator>=</operator> <name>jj</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></for>
      <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>bUsed</name><index>[<expr><name>jj</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>sIdxIter</name><operator>.</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>aIdx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sIdxIter</name><operator>.</operator><name>u</name><operator>.</operator><name>ax</name><operator>.</operator><name>aIdx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ix</name> <operator>=</operator> <name>jj</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name>nIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Determine if it is possible that triggers (either explicitly coded
  ** triggers or FK resolution actions) might run as a result of deletes
  ** that happen when OE_Replace conflict resolution occurs. (Call these
  ** "replace triggers".)  If any replace triggers run, we will need to
  ** recheck all of the uniqueness constraints after they have all run.
  ** But on the recheck, the resolution is OE_Abort instead of OE_Replace.
  **
  ** If replace triggers are a possibility, then
  **
  **   (1) Allocate register regTrigCnt and initialize it to zero.
  **       That register will count the number of replace triggers that
  **       fire.  Constraint recheck only occurs if the number is positive.
  **   (2) Initialize pTrigger to the list of all DELETE triggers on pTab.
  **   (3) Initialize addrRecheck and lblRecheckOk
  **
  ** The uniqueness rechecking code will create a series of tests to run
  ** in a second pass.  The addrRecheck and lblRecheckOk variables are
  ** used to link together these tests which are separated from each other
  ** in the generate bytecode.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SQLITE_RecTriggers</name><operator>|</operator><name>SQLITE_ForeignKeys</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* There are not DELETE triggers nor FK constraints.  No constraint
    ** rechecks are needed. */</comment>
    <expr_stmt><expr><name>pTrigger</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>regTrigCnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_RecTriggers</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pTrigger</name> <operator>=</operator> <call><name>sqlite3TriggersExist</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>TK_DELETE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>regTrigCnt</name> <operator>=</operator> <name>pTrigger</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3FkRequired</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pTrigger</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>regTrigCnt</name> <operator>=</operator> <call><name>sqlite3FkRequired</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>regTrigCnt</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Replace triggers might exist.  Allocate the counter and
      ** initialize it to zero. */</comment>
      <expr_stmt><expr><name>regTrigCnt</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regTrigCnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"trigger count"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>lblRecheckOk</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrRecheck</name> <operator>=</operator> <name>lblRecheckOk</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* If rowid is changing, make sure the new rowid does not previously
  ** exist in the table.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pkChng</name> <operator>&amp;&amp;</operator> <name>pPk</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>addrRowidOk</name> <init>= <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Figure out what action to take in case of a rowid collision */</comment>
    <expr_stmt><expr><name>onError</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>keyConf</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>overrideError</name><operator>!=</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>overrideError</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* figure out whether or not upsert applies in this case */</comment>
    <if_stmt><if>if<condition>( <expr><name>pUpsert</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pUpsertClause</name> <operator>=</operator> <call><name>sqlite3UpsertOfIndex</name><argument_list>(<argument><expr><name>pUpsert</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pUpsertClause</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pUpsertClause</name><operator>-&gt;</operator><name>isDoUpdate</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Ignore</name></expr>;</expr_stmt>  <comment type="block">/* DO NOTHING is the same as INSERT OR IGNORE */</comment>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Update</name></expr>;</expr_stmt>  <comment type="block">/* DO UPDATE */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pUpsertClause</name><operator>!=</operator><name>pUpsert</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* The first ON CONFLICT clause has a conflict target other than
        ** the IPK.  We have to jump ahead to that first ON CONFLICT clause
        ** and then come back here and deal with the IPK afterwards */</comment>
        <expr_stmt><expr><name>upsertIpkDelay</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the response to a rowid conflict is REPLACE but the response
    ** to some other UNIQUE constraint is FAIL or IGNORE, then we need
    ** to defer the running of the rowid conflict checking until after
    ** the UNIQUE constraints have run.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Replace</name>      <comment type="block">/* IPK rule is REPLACE */</comment>
     <operator>&amp;&amp;</operator> <name>onError</name><operator>!=</operator><name>overrideError</name>   <comment type="block">/* Rules for other constraints are different */</comment>
     <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name>             <comment type="block">/* There exist other constraints */</comment>
     <operator>&amp;&amp;</operator> <operator>!</operator><name>upsertIpkDelay</name></expr>          <comment type="block">/* IPK check already deferred by UPSERT */</comment>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>ipkTop</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"defer IPK REPLACE until last"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>isUpdate</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* pkChng!=0 does not mean that the rowid has changed, only that
      ** it might have changed.  Skip the conflict logic below if the rowid
      ** is unchanged. */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Eq</name></expr></argument>, <argument><expr><name>regNewData</name></expr></argument>, <argument><expr><name>addrRowidOk</name></expr></argument>, <argument><expr><name>regOldData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check to see if the new rowid already exists in the table.  Skip
    ** the following conflict logic if it does not. */</comment>
    <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"uniqueness check for ROWID"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeVerifyAbortable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>addrRowidOk</name></expr></argument>, <argument><expr><name>regNewData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch<condition>( <expr><name>onError</name></expr> )</condition><block>{<block_content>
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
        <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
      </block_content>}</block>
      <case>case <expr><name>OE_Rollback</name></expr>:</case>
      <case>case <expr><name>OE_Abort</name></expr>:</case>
      <case>case <expr><name>OE_Fail</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Rollback</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Abort</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Fail</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3RowidConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>OE_Replace</name></expr>:</case> <block>{<block_content>
        <comment type="block">/* If there are DELETE triggers on this table and the
        ** recursive-triggers flag is set, call GenerateRowDelete() to
        ** remove the conflicting row from the table. This will fire
        ** the triggers and remove both the table and index b-tree entries.
        **
        ** Otherwise, if there are no triggers or the recursive-triggers
        ** flag is not set, but the table has one or more indexes, call 
        ** GenerateRowIndexDelete(). This removes the index b-tree entries 
        ** only. The table b-tree entry will be replaced by the new entry 
        ** when it is inserted.  
        **
        ** If either GenerateRowDelete() or GenerateRowIndexDelete() is called,
        ** also invoke MultiWrite() to indicate that this VDBE may require
        ** statement rollback (if the statement is aborted after the delete
        ** takes place). Earlier versions called sqlite3MultiWrite() regardless,
        ** but being more selective here allows statements like:
        **
        **   REPLACE INTO t(rowid) VALUES($newrowid)
        **
        ** to run without a statement journal if there are no indexes on the
        ** table.
        */</comment>
        <if_stmt><if>if<condition>( <expr><name>regTrigCnt</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3MultiWrite</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3GenerateRowDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>,
                                   <argument><expr><name>regNewData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OE_Replace</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>regTrigCnt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* incr trigger cnt */</comment>
          <expr_stmt><expr><name>nReplaceTrig</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_PREUPDATE_HOOK</name></cpp:ifdef>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* This OP_Delete opcode fires the pre-update-hook only. It does
          ** not modify the b-tree. It is more efficient to let the coming
          ** OP_Insert replace the existing entry than it is to delete the
          ** existing entry and then insert a new one. */</comment>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Delete</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>OPFLAG_ISNOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>P4_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_PREUPDATE_HOOK */</comment>
          <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3MultiWrite</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3GenerateRowIndexDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>seenReplace</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UPSERT</name></cpp:ifndef>
      <case>case <expr><name>OE_Update</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3UpsertDoUpdate</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pUpsert</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
      </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <case>case <expr><name>OE_Ignore</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Ignore</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ignoreDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrRowidOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pUpsert</name> <operator>&amp;&amp;</operator> <name>pUpsertClause</name><operator>!=</operator><name>pUpsert</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>upsertIpkReturn</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>ipkTop</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>ipkBottom</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ipkTop</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Test all UNIQUE constraints by creating entries for each UNIQUE
  ** index and making sure that duplicate entries do not already exist.
  ** Compute the revised record entries for indices as we go.
  **
  ** This loop also handles the case of the PRIMARY KEY index for a
  ** WITHOUT ROWID table.
  */</comment>
  <for>for<control>(<init><expr><name>pIdx</name> <operator>=</operator> <call><name>indexIteratorFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sIdxIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>)</argument_list></call></expr>;</init>
      <condition><expr><name>pIdx</name></expr>;</condition>
      <incr><expr><name>pIdx</name> <operator>=</operator> <call><name>indexIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sIdxIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>)</argument_list></call></expr></incr>
  )</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>regIdx</name></decl>;</decl_stmt>          <comment type="block">/* Range of registers hold conent for pIdx */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>regR</name></decl>;</decl_stmt>            <comment type="block">/* Range of registers holding conflicting PK */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iThisCur</name></decl>;</decl_stmt>        <comment type="block">/* Cursor for this UNIQUE index */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>addrUniqueOk</name></decl>;</decl_stmt>    <comment type="block">/* Jump here if the UNIQUE constraint is satisfied */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>addrConflictCk</name></decl>;</decl_stmt>  <comment type="block">/* First opcode in the conflict check logic */</comment>

    <if_stmt><if>if<condition>( <expr><name><name>aRegIdx</name><index>[<expr><name>ix</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Skip indices that do not change */</comment>
    <if_stmt><if>if<condition>( <expr><name>pUpsert</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pUpsertClause</name> <operator>=</operator> <call><name>sqlite3UpsertOfIndex</name><argument_list>(<argument><expr><name>pUpsert</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>upsertIpkDelay</name> <operator>&amp;&amp;</operator> <name>pUpsertClause</name><operator>==</operator><name>pUpsert</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>upsertIpkDelay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>addrUniqueOk</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bAffinityDone</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3TableAffinity</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regNewData</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bAffinityDone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"prep index %s"</literal><operator>,</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iThisCur</name> <operator>=</operator> <name>iIdxCur</name><operator>+</operator><name>ix</name></expr>;</expr_stmt>


    <comment type="block">/* Skip partial indices for which the WHERE clause is not true */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>aRegIdx</name><index>[<expr><name>ix</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>regNewData</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalseDup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>, <argument><expr><name>addrUniqueOk</name></expr></argument>,
                            <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create a record for this index entry as it should appear after
    ** the insert or update.  Store that record in the aRegIdx[ix] register
    */</comment>
    <expr_stmt><expr><name>regIdx</name> <operator>=</operator> <name><name>aRegIdx</name><index>[<expr><name>ix</name></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iField</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iField</name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>regNewData</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeCopy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>regIdx</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s column %d"</literal><operator>,</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iField</name><operator>==</operator><name>XN_ROWID</name> <operator>||</operator> <name>iField</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <name>regNewData</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IntCopy</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>regIdx</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"rowid"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iField</name></expr></argument>)</argument_list></call><operator>!=</operator><name>iField</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iField</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>regNewData</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>regIdx</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iField</name></expr>]</index></name><operator>.</operator><name>zCnName</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regIdx</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name><name>aRegIdx</name><index>[<expr><name>ix</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"for %s"</literal><operator>,</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_NULL_TRIM</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>idxType</name></name><operator>==</operator><name>SQLITE_IDXTYPE_PRIMARYKEY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3SetMakeRecordP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3VdbeReleaseRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regIdx</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* In an UPDATE operation, if this index is the PRIMARY KEY index 
    ** of a WITHOUT ROWID table and there has been no change the
    ** primary key, then no collision is possible.  The collision detection
    ** logic below can all be skipped. */</comment>
    <if_stmt><if>if<condition>( <expr><name>isUpdate</name> <operator>&amp;&amp;</operator> <name>pPk</name><operator>==</operator><name>pIdx</name> <operator>&amp;&amp;</operator> <name>pkChng</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrUniqueOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find out what action to take in case there is a uniqueness conflict */</comment>
    <expr_stmt><expr><name>onError</name> <operator>=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>onError</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_None</name></expr> )</condition><block>{<block_content> 
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrUniqueOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>  <comment type="block">/* pIdx is not a UNIQUE index */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>overrideError</name><operator>!=</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>overrideError</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Figure out if the upsert clause applies to this index */</comment>
    <if_stmt><if>if<condition>( <expr><name>pUpsertClause</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pUpsertClause</name><operator>-&gt;</operator><name>isDoUpdate</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Ignore</name></expr>;</expr_stmt>  <comment type="block">/* DO NOTHING is the same as INSERT OR IGNORE */</comment>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Update</name></expr>;</expr_stmt>  <comment type="block">/* DO UPDATE */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Collision detection may be omitted if all of the following are true:
    **   (1) The conflict resolution algorithm is REPLACE
    **   (2) The table is a WITHOUT ROWID table
    **   (3) There are no secondary indexes on the table
    **   (4) No delete triggers need to be fired if there is a conflict
    **   (5) No FK constraint counters need to be updated if a conflict occurs.
    **
    ** This is not possible for ENABLE_PREUPDATE_HOOK builds, as the row
    ** must be explicitly deleted in order to ensure any pre-update hook
    ** is invoked.  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_PREUPDATE_HOOK</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>ix</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator>                   <comment type="block">/* Condition 3 */</comment>
     <operator>&amp;&amp;</operator> <name>pPk</name><operator>==</operator><name>pIdx</name>                                   <comment type="block">/* Condition 2 */</comment>
     <operator>&amp;&amp;</operator> <name>onError</name><operator>==</operator><name>OE_Replace</name>                         <comment type="block">/* Condition 1 */</comment>
     <operator>&amp;&amp;</operator> <operator>(</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_RecTriggers</name><operator>)</operator> <operator>||</operator>      <comment type="block">/* Condition 4 */</comment>
          <literal type="number">0</literal><operator>==</operator><call><name>sqlite3TriggersExist</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>TK_DELETE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator>
     <operator>&amp;&amp;</operator> <operator>(</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_ForeignKeys</name><operator>)</operator> <operator>||</operator>      <comment type="block">/* Condition 5 */</comment>
         <operator>(</operator><literal type="number">0</literal><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3FkReferences</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrUniqueOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_ENABLE_PREUPDATE_HOOK */</comment>

    <comment type="block">/* Check to see if the new index entry will be unique */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeVerifyAbortable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrConflictCk</name> <operator>=</operator> 
      <call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NoConflict</name></expr></argument>, <argument><expr><name>iThisCur</name></expr></argument>, <argument><expr><name>addrUniqueOk</name></expr></argument>,
                           <argument><expr><name>regIdx</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate code to handle collisions */</comment>
    <expr_stmt><expr><name>regR</name> <operator>=</operator> <ternary><condition><expr><name>pIdx</name><operator>==</operator><name>pPk</name></expr> ?</condition><then> <expr><name>regIdx</name></expr> </then><else>: <expr><call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nPkField</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>isUpdate</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Replace</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxRowid</name></expr></argument>, <argument><expr><name>iThisCur</name></expr></argument>, <argument><expr><name>regR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Conflict only if the rowid of the existing index entry
        ** is different from old-rowid */</comment>
        <if_stmt><if>if<condition>( <expr><name>isUpdate</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Eq</name></expr></argument>, <argument><expr><name>regR</name></expr></argument>, <argument><expr><name>addrUniqueOk</name></expr></argument>, <argument><expr><name>regOldData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
        <comment type="block">/* Extract the PRIMARY KEY from the end of the index entry and
        ** store it in registers regR..regR+nPk-1 */</comment>
        <if_stmt><if>if<condition>( <expr><name>pIdx</name><operator>!=</operator><name>pPk</name></expr> )</condition><block>{<block_content>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3TableColumnToIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iThisCur</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>regR</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s.%s"</literal><operator>,</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator>
                         <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>zCnName</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>isUpdate</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* If currently processing the PRIMARY KEY of a WITHOUT ROWID 
          ** table, only conflict if the new PRIMARY KEY values are actually
          ** different from the old.  See TH3 withoutrowid04.test.
          **
          ** For a UNIQUE index, only conflict if the PRIMARY KEY values
          ** of the matched index row are different from the original PRIMARY
          ** KEY values of this row before the update.  */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>addrJump</name> <init>= <expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><name>OP_Ne</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>regCmp</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>regIdx</name></expr> </then><else>: <expr><name>regR</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p4</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3LocateCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><operator>(</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>addrJump</name> <operator>=</operator> <name>addrUniqueOk</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_Eq</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, 
                <argument><expr><name>regOldData</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>x</name></expr></argument>, <argument><expr><name>addrJump</name></expr></argument>, <argument><expr><name>regCmp</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>p4</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Generate code that executes if the new index entry is not unique */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Rollback</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Abort</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Fail</name>
        <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Ignore</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Replace</name> <operator>||</operator> <name>onError</name><operator>==</operator><name>OE_Update</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>onError</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>OE_Rollback</name></expr>:</case>
      <case>case <expr><name>OE_Abort</name></expr>:</case>
      <case>case <expr><name>OE_Fail</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Rollback</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Abort</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Fail</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3UniqueConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UPSERT</name></cpp:ifndef>
      <case>case <expr><name>OE_Update</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3UpsertDoUpdate</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pUpsert</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>iIdxCur</name><operator>+</operator><name>ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
      </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <case>case <expr><name>OE_Ignore</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Ignore</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ignoreDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nConflictCk</name></decl>;</decl_stmt>   <comment type="block">/* Number of opcodes in conflict check logic */</comment>

        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>onError</name><operator>==</operator><name>OE_Replace</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nConflictCk</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>addrConflictCk</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nConflictCk</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nConflictCk</name><operator>&lt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nConflictCk</name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>regTrigCnt</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3MultiWrite</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>nReplaceTrig</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>pTrigger</name> <operator>&amp;&amp;</operator> <name>isUpdate</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_CursorLock</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3GenerateRowDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>,
            <argument><expr><name>regR</name></expr></argument>, <argument><expr><name>nPkField</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OE_Replace</name></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><name>pIdx</name><operator>==</operator><name>pPk</name></expr> ?</condition><then> <expr><name>ONEPASS_SINGLE</name></expr> </then><else>: <expr><name>ONEPASS_OFF</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>iThisCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pTrigger</name> <operator>&amp;&amp;</operator> <name>isUpdate</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_CursorUnlock</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>regTrigCnt</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>addrBypass</name></decl>;</decl_stmt>  <comment type="block">/* Jump destination to bypass recheck logic */</comment>

          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>regTrigCnt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* incr trigger cnt */</comment>
          <expr_stmt><expr><name>addrBypass</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Bypass recheck */</comment>
          <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"bypass recheck"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Here we insert code that will be invoked after all constraint
          ** checks have run, if and only if one or more replace triggers
          ** fired. */</comment>
          <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lblRecheckOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>lblRecheckOk</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr> )</condition><block>{<block_content>
            <comment type="block">/* Bypass the recheck if this partial index is not defined
            ** for the current row */</comment>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regIdx</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>lblRecheckOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <comment type="block">/* Copy the constraint check code from above, except change
          ** the constraint-ok jump destination to be the address of
          ** the next retest block */</comment>
          <while>while<condition>( <expr><name>nConflictCk</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>VdbeOp</name></type> <name>x</name></decl>;</decl_stmt>    <comment type="block">/* Conflict check opcode to copy */</comment>
            <comment type="block">/* The sqlite3VdbeAddOp4() call might reallocate the opcode array.
            ** Hence, make a complete copy of the opcode, rather than using
            ** a pointer to the opcode. */</comment>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>*</operator><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrConflictCk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>opcode</name></name><operator>!=</operator><name>OP_IdxRowid</name></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>int</name></type> <name>p2</name></decl>;</decl_stmt>      <comment type="block">/* New P2 value for copied conflict check opcode */</comment>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zP4</name></decl>;</decl_stmt>
              <if_stmt><if>if<condition>( <expr><name><name>sqlite3OpcodeProperty</name><index>[<expr><name><name>x</name><operator>.</operator><name>opcode</name></name></expr>]</index></name><operator>&amp;</operator><name>OPFLG_JUMP</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>p2</name> <operator>=</operator> <name>lblRecheckOk</name></expr>;</expr_stmt>
              </block_content>}</block></if><else>else<block>{<block_content>
                <expr_stmt><expr><name>p2</name> <operator>=</operator> <name><name>x</name><operator>.</operator><name>p2</name></name></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
              <expr_stmt><expr><name>zP4</name> <operator>=</operator> <ternary><condition><expr><name><name>x</name><operator>.</operator><name>p4type</name></name><operator>==</operator><name>P4_INT32</name></expr> ?</condition><then> <expr><call><name>SQLITE_INT_TO_PTR</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>p4</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>x</name><operator>.</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></else></ternary></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>opcode</name></name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>p1</name></name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>p3</name></name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>p4type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>p5</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>p2</name><operator>!=</operator><name><name>x</name><operator>.</operator><name>p2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>nConflictCk</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>addrConflictCk</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></while>
          <comment type="block">/* If the retest fails, issue an abort */</comment>
          <expr_stmt><expr><call><name>sqlite3UniqueConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>OE_Abort</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrBypass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Terminate the recheck bypass */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>seenReplace</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrUniqueOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>regR</name><operator>!=</operator><name>regIdx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regR</name></expr></argument>, <argument><expr><name>nPkField</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pUpsertClause</name> 
     <operator>&amp;&amp;</operator> <name>upsertIpkReturn</name>
     <operator>&amp;&amp;</operator> <call><name>sqlite3UpsertNextIsIPK</name><argument_list>(<argument><expr><name>pUpsertClause</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>upsertIpkDelay</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>upsertIpkReturn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>upsertIpkReturn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* If the IPK constraint is a REPLACE, run it last */</comment>
  <if_stmt><if>if<condition>( <expr><name>ipkTop</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ipkTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"Do IPK REPLACE"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>ipkBottom</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ipkBottom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Recheck all uniqueness constraints after replace triggers have run */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regTrigCnt</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nReplaceTrig</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>regTrigCnt</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>nReplaceTrig</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nReplaceTrig</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNot</name></expr></argument>, <argument><expr><name>regTrigCnt</name></expr></argument>, <argument><expr><name>lblRecheckOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pPk</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>isUpdate</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Eq</name></expr></argument>, <argument><expr><name>regNewData</name></expr></argument>, <argument><expr><name>addrRecheck</name></expr></argument>, <argument><expr><name>regOldData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_NOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>addrRecheck</name></expr></argument>, <argument><expr><name>regNewData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3RowidConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>OE_Abort</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrRecheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lblRecheckOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Generate the table record */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>regRec</name> <init>= <expr><name><name>aRegIdx</name><index>[<expr><name>ix</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regNewData</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>nNVCol</name></name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SetMakeRecordP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bAffinityDone</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3TableAffinity</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pbMayReplace</name> <operator>=</operator> <name>seenReplace</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"END: GenCnstCks(%d)"</literal><operator>,</operator> <name>seenReplace</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_NULL_TRIM</name></cpp:ifdef>
<comment type="block">/*
** Change the P5 operand on the last opcode (which should be an OP_MakeRecord)
** to be the number of columns in table pTab that must not be NULL-trimmed.
**
** Or if no columns of pTab may be NULL-trimmed, leave P5 at zero.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SetMakeRecordP5</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Records with omitted columns are only allowed for schema format
  ** version 2 and later (SQLite version 3.1.4, 2005-02-20). */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name><operator>-&gt;</operator><name>file_format</name></name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iDflt</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_PRIMKEY</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Table pTab is a WITHOUT ROWID table that is being written to. The cursor
** number is iCur, and register regData contains the new record for the
** PK index. This function adds code to invoke the pre-update hook,
** if one is registered.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_PREUPDATE_HOOK</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeWithoutRowidPreupdate</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                    <comment type="block">/* Table being updated */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>,                       <comment type="block">/* Cursor number for table */</comment>
  <parameter><decl><type><name>int</name></type> <name>regData</name></decl></parameter>                     <comment type="block">/* Data containing new record */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_Vacuum</name><operator>)</operator> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pTab</name></expr></argument>, <argument><expr><name>P4_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_ISNOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>codeWithoutRowidPreupdate</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine generates code to finish the INSERT or UPDATE operation
** that was started by a prior call to sqlite3GenerateConstraintChecks.
** A consecutive range of registers starting at regNewData contains the
** rowid and the content to be inserted.
**
** The arguments to this routine should be the same as the first six
** arguments to sqlite3GenerateConstraintChecks.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CompleteInsertion</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* The parser context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,        <comment type="block">/* the table into which we are inserting */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDataCur</name></decl></parameter>,       <comment type="block">/* Cursor of the canonical data source */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdxCur</name></decl></parameter>,        <comment type="block">/* First index cursor */</comment>
  <parameter><decl><type><name>int</name></type> <name>regNewData</name></decl></parameter>,     <comment type="block">/* Range of content */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aRegIdx</name></decl></parameter>,       <comment type="block">/* Register used by each index.  0 for unused indices */</comment>
  <parameter><decl><type><name>int</name></type> <name>update_flags</name></decl></parameter>,   <comment type="block">/* True for UPDATE, False for INSERT */</comment>
  <parameter><decl><type><name>int</name></type> <name>appendBias</name></decl></parameter>,     <comment type="block">/* True if this is likely to be an append */</comment>
  <parameter><decl><type><name>int</name></type> <name>useSeekResult</name></decl></parameter>   <comment type="block">/* True to set the USESEEKRESULT flag on OP_[Idx]Insert */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>            <comment type="block">/* Prepared statements under construction */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>        <comment type="block">/* An index being inserted or updated */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>pik_flags</name></decl>;</decl_stmt>       <comment type="block">/* flag values passed to the btree insert */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>              <comment type="block">/* Loop counter */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>update_flags</name><operator>==</operator><literal type="number">0</literal>
       <operator>||</operator> <name>update_flags</name><operator>==</operator><name>OPFLAG_ISUPDATE</name>
       <operator>||</operator> <name>update_flags</name><operator>==</operator><operator>(</operator><name>OPFLAG_ISUPDATE</name><operator>|</operator><name>OPFLAG_SAVEPOSITION</name><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* This table is not a VIEW */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <comment type="block">/* All REPLACE indexes are at the end of the list */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>onError</name></name><operator>!=</operator><name>OE_Replace</name>
         <operator>||</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal>
         <operator>||</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>onError</name></name><operator>==</operator><name>OE_Replace</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pik_flags</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>useSeekResult</name></expr> ?</condition><then> <expr><name>OPFLAG_USESEEKRESULT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pik_flags</name> <operator>|=</operator> <name>OPFLAG_NCHANGE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pik_flags</name> <operator>|=</operator> <operator>(</operator><name>update_flags</name> <operator>&amp;</operator> <name>OPFLAG_SAVEPOSITION</name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>update_flags</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>codeWithoutRowidPreupdate</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iIdxCur</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iIdxCur</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                         <argument><expr><name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr></argument>,
                         <argument><expr><ternary><condition><expr><name><name>pIdx</name><operator>-&gt;</operator><name>uniqNotNull</name></name></expr> ?</condition><then> <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr></then><else>: <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pik_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pik_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pik_flags</name> <operator>=</operator> <name>OPFLAG_NCHANGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pik_flags</name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><name>update_flags</name></expr>?</condition><then><expr><name>update_flags</name></expr></then><else>:<expr><name>OPFLAG_LASTROWID</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>appendBias</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pik_flags</name> <operator>|=</operator> <name>OPFLAG_APPEND</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>useSeekResult</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pik_flags</name> <operator>|=</operator> <name>OPFLAG_USESEEKRESULT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>regNewData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>P4_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pik_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate cursors for the pTab table and all its indices and generate
** code to open and initialized those cursors.
**
** The cursor for the object that contains the complete data (normally
** the table itself, but the PRIMARY KEY index in the case of a WITHOUT
** ROWID table) is returned in *piDataCur.  The first index cursor is
** returned in *piIdxCur.  The number of indices is returned.
**
** Use iBase as the first cursor (either the *piDataCur for rowid tables
** or the first index for WITHOUT ROWID tables) if it is non-negative.
** If iBase is negative, then allocate the next available cursor.
**
** For a rowid table, *piDataCur will be exactly one less than *piIdxCur.
** For a WITHOUT ROWID table, *piDataCur will be somewhere in the range
** of *piIdxCurs, depending on where the PRIMARY KEY index appears on the
** pTab-&gt;pIndex list.
**
** If pTab is a virtual table, then this routine is a no-op and the
** *piDataCur and *piIdxCur values are left uninitialized.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3OpenTableAndIndices</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,   <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,     <comment type="block">/* Table to be opened */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,          <comment type="block">/* OP_OpenRead or OP_OpenWrite */</comment>
  <parameter><decl><type><name>u8</name></type> <name>p5</name></decl></parameter>,           <comment type="block">/* P5 value for OP_Open* opcodes (except on WITHOUT ROWID) */</comment>
  <parameter><decl><type><name>int</name></type> <name>iBase</name></decl></parameter>,       <comment type="block">/* Use this for the table cursor, if there is one */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aToOpen</name></decl></parameter>,     <comment type="block">/* If not NULL: boolean for each table and index */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piDataCur</name></decl></parameter>,  <comment type="block">/* Write the database source cursor number here */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piIdxCur</name></decl></parameter>    <comment type="block">/* Write the first index cursor number here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDataCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_OpenRead</name> <operator>||</operator> <name>op</name><operator>==</operator><name>OP_OpenWrite</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>OP_OpenWrite</name> <operator>||</operator> <name>p5</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* This routine is a no-op for virtual tables. Leave the output
    ** variables *piDataCur and *piIdxCur set to illegal cursor numbers
    ** for improved error detection. */</comment>
    <expr_stmt><expr><operator>*</operator><name>piDataCur</name> <operator>=</operator> <operator>*</operator><name>piIdxCur</name> <operator>=</operator> <operator>-</operator><literal type="number">999</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iBase</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iBase</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iDataCur</name> <operator>=</operator> <name>iBase</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>piDataCur</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piDataCur</name> <operator>=</operator> <name>iDataCur</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>aToOpen</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>aToOpen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>op</name><operator>==</operator><name>OP_OpenWrite</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>piIdxCur</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piIdxCur</name> <operator>=</operator> <name>iBase</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name> <init>= <expr><name>iBase</name><operator>++</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>piDataCur</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piDataCur</name> <operator>=</operator> <name>iIdxCur</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>p5</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>aToOpen</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>aToOpen</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>p5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>iBase</name><operator>&gt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name> <operator>=</operator> <name>iBase</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/*
** The following global variable is incremented whenever the
** transfer optimization is used.  This is used for testing
** purposes only - to make sure the transfer optimization really
** is happening when it is supposed to.
*/</comment>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_xferopt_count</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_TEST */</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_XFER_OPT</name></cpp:ifndef>
<comment type="block">/*
** Check to see if index pSrc is compatible as a source of data
** for index pDest in an insert transfer optimization.  The rules
** for a compatible index:
**
**    *   The index is over the same set of columns
**    *   The same DESC and ASC markings occurs on all columns
**    *   The same onError processing (OE_Abort, OE_Ignore, etc)
**    *   The same collating sequence on each column
**    *   The index has the exact same WHERE clause
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>xferCompatibleIndex</name><parameter_list>(<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDest</name> <operator>&amp;&amp;</operator> <name>pSrc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>pTable</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nKeyCol</name></name> <operator>||</operator> <name><name>pDest</name><operator>-&gt;</operator><name>nColumn</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nColumn</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Different number of columns */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>onError</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>onError</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Different conflict resolution strategies */</comment>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name><name>pDest</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Different columns indexed */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>XN_EXPR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>aColExpr</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDest</name><operator>-&gt;</operator><name>aColExpr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>,
                             <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Different expressions in the index */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name><name>pDest</name><operator>-&gt;</operator><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Different sort orders */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Different collating sequences */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>     <comment type="block">/* Different WHERE clauses */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If no test above fails then the indices must be compatible */</comment>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt the transfer optimization on INSERTs of the form
**
**     INSERT INTO tab1 SELECT * FROM tab2;
**
** The xfer optimization transfers raw records from tab2 over to tab1.  
** Columns are not decoded and reassembled, which greatly improves
** performance.  Raw index records are transferred in the same way.
**
** The xfer optimization is only attempted if tab1 and tab2 are compatible.
** There are lots of rules for determining compatibility - see comments
** embedded in the code for details.
**
** This routine returns TRUE if the optimization is guaranteed to be used.
** Sometimes the xfer optimization will only work if the destination table
** is empty - a factor that can only be determined at run-time.  In that
** case, this routine generates code for the xfer optimization but also
** does a test to see if the destination table is empty and jumps over the
** xfer optimization code if the test fails.  In that case, this routine
** returns FALSE so that the caller will know to go ahead and generate
** an unoptimized transfer.  This routine also returns FALSE if there
** is no chance that the xfer optimization can be applied.
**
** This optimization is particularly useful at making VACUUM run faster.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>xferOptimization</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parser context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pDest</name></decl></parameter>,         <comment type="block">/* The table we are inserting into */</comment>
  <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>,      <comment type="block">/* A SELECT statement to use as the data source */</comment>
  <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>,          <comment type="block">/* How to handle constraint errors */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDbDest</name></decl></parameter>           <comment type="block">/* The database of pDest */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name></decl>;</decl_stmt>                <comment type="block">/* The result set of the SELECT */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>                     <comment type="block">/* The table in the FROM clause of SELECT */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pSrcIdx</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pDestIdx</name></decl>;</decl_stmt>       <comment type="block">/* Source and destination indices */</comment>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl>;</decl_stmt>                  <comment type="block">/* An element of pSelect-&gt;pSrc */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                           <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDbSrc</name></decl>;</decl_stmt>                      <comment type="block">/* The database of pSrc */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSrc</name></decl>, <decl><type ref="prev"/><name>iDest</name></decl>;</decl_stmt>                 <comment type="block">/* Cursors from source and destination */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>, <decl><type ref="prev"/><name>addr2</name></decl>;</decl_stmt>                <comment type="block">/* Loop addresses */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>emptyDestTest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Address of test for empty pDest */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>emptySrcTest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Address of test for empty pSrc */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>                         <comment type="block">/* The VDBE we are building */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regAutoinc</name></decl>;</decl_stmt>                  <comment type="block">/* Memory register used by AUTOINC */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>destHasUniqueIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* True if pDest has a UNIQUE index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regData</name></decl>, <decl><type ref="prev"/><name>regRowid</name></decl>;</decl_stmt>           <comment type="block">/* Registers holding data and rowid */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSelect</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name> <operator>||</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pWith</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Do not attempt to process this query if there are an WITH clauses
    ** attached to it. Proceeding may generate a false "no such table: xxx"
    ** error if pSelect reads from a CTE named "xxx".  */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* tab1 must not be a virtual table */</comment>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Default</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>onError</name> <operator>=</operator> <name><name>pDest</name><operator>-&gt;</operator><name>keyConf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Default</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>onError</name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* allocated even if there is no FROM clause */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* FROM clause must have exactly one term */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSelect</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* FROM clause cannot contain a subquery */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pWhere</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* SELECT may not have a WHERE clause */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* SELECT may not have an ORDER BY clause */</comment>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Do not need to test for a HAVING clause.  If HAVING is present but
  ** there is no ORDER BY, we will get an error. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* SELECT may not have a GROUP BY clause */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pLimit</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* SELECT may not have a LIMIT clause */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* SELECT may not be a compound query */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Distinct</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* SELECT may not be DISTINCT */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pEList</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pEList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* The result set must have exactly one column */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pEList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_ASTERISK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* The result set must be the special operator "*" */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* At this point we have established that the statement is of the
  ** correct syntactic form to participate in this optimization.  Now
  ** we have to check the semantics.
  */</comment>
  <expr_stmt><expr><name>pItem</name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <call><name>sqlite3LocateTableItem</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSrc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* FROM clause does not contain a real table */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>tnum</name></name><operator>==</operator><name><name>pDest</name><operator>-&gt;</operator><name>tnum</name></name> <operator>&amp;&amp;</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><name><name>pDest</name><operator>-&gt;</operator><name>pSchema</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pSrc</name><operator>!=</operator><name>pDest</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Possible due to bad sqlite_schema.rootpage */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* tab1 and tab2 may not be the same table */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call><operator>!=</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* source and destination must both be WITHOUT ROWID or not */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* tab2 may not be a view or virtual table */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>nCol</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Number of columns must be the same in tab1 and tab2 */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>iPKey</name></name><operator>!=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Both tables must have the same INTEGER PRIMARY KEY */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDest</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Strict</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Strict</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Cannot feed from a non-strict into a strict table */</comment>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pDest</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pDestCol</name> <init>= <expr><operator>&amp;</operator><name><name>pDest</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pSrcCol</name> <init>= <expr><operator>&amp;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_HIDDEN_COLUMNS</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_Vacuum</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pDestCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>|</operator> <name><name>pSrcCol</name><operator>-&gt;</operator><name>colFlags</name></name><operator>)</operator> <operator>&amp;</operator> <name>COLFLAG_HIDDEN</name></expr> 
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* Neither table may have __hidden__ columns */</comment>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
    <comment type="block">/* Even if tables t1 and t2 have identical schemas, if they contain
    ** generated columns, then this statement is semantically incorrect:
    **
    **     INSERT INTO t2 SELECT * FROM t1;
    **
    ** The reason is that generated column values are returned by the
    ** the SELECT statement on the right but the INSERT statement on the
    ** left wants them to be omitted.
    **
    ** Nevertheless, this is a useful notational shorthand to tell SQLite
    ** to do a bulk transfer all of the content from t1 over to t2.
    ** 
    ** We could, in theory, disable this (except for internal use by the
    ** VACUUM command where it is actually needed).  But why do that?  It
    ** seems harmless enough, and provides a useful service.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDestCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name><operator>)</operator> <operator>!=</operator>
        <operator>(</operator><name><name>pSrcCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* Both columns have the same generated-column type */</comment>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* But the transfer is only allowed if both the source and destination
    ** tables have the exact same expressions for generated columns.
    ** This requirement could be relaxed for VIRTUAL columns, I suppose.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDestCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
             <argument><expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pSrcCol</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>pDestCol</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pDestCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pDestCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_STORED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Different generator expressions */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>pDestCol</name><operator>-&gt;</operator><name>affinity</name></name><operator>!=</operator><name><name>pSrcCol</name><operator>-&gt;</operator><name>affinity</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* Affinity must be the same on all columns */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><call><name>sqlite3ColumnColl</name><argument_list>(<argument><expr><name>pDestCol</name></expr></argument>)</argument_list></call></expr></argument>, 
                        <argument><expr><call><name>sqlite3ColumnColl</name><argument_list>(<argument><expr><name>pSrcCol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* Collating sequence must be the same on all columns */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDestCol</name><operator>-&gt;</operator><name>notNull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pSrcCol</name><operator>-&gt;</operator><name>notNull</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* tab2 must be NOT NULL if tab1 is */</comment>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Default values for second and subsequent columns need to match. */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDestCol</name><operator>-&gt;</operator><name>colFlags</name></name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pDestExpr</name> <init>= <expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>pDestCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pSrcExpr</name> <init>= <expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pSrcCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDestExpr</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDestExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SPAN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDestExpr</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pDestExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrcExpr</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pSrcExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_SPAN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrcExpr</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pSrcExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pDestExpr</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>!=</operator><operator>(</operator><name>pSrcExpr</name><operator>==</operator><literal type="number">0</literal><operator>)</operator> 
       <operator>||</operator> <operator>(</operator><name>pDestExpr</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pDestExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>,
                                       <argument><expr><name><name>pSrcExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* Default values must be the same for all columns */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>pDestIdx</name><operator>=</operator><name><name>pDest</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pDestIdx</name></expr>;</condition> <incr><expr><name>pDestIdx</name><operator>=</operator><name><name>pDestIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>IsUniqueIndex</name><argument_list>(<argument><expr><name>pDestIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>destHasUniqueIdx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>pSrcIdx</name><operator>=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pSrcIdx</name></expr>;</condition> <incr><expr><name>pSrcIdx</name><operator>=</operator><name><name>pSrcIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>xferCompatibleIndex</name><argument_list>(<argument><expr><name>pDestIdx</name></expr></argument>, <argument><expr><name>pSrcIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>pSrcIdx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* pDestIdx has no corresponding index in pSrc */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSrcIdx</name><operator>-&gt;</operator><name>tnum</name></name><operator>==</operator><name><name>pDestIdx</name><operator>-&gt;</operator><name>tnum</name></name> <operator>&amp;&amp;</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><name><name>pDest</name><operator>-&gt;</operator><name>pSchema</name></name>
         <operator>&amp;&amp;</operator> <call><name>sqlite3FaultSim</name><argument_list>(<argument><expr><literal type="number">411</literal></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The sqlite3FaultSim() call allows this corruption test to be
      ** bypassed during testing, in order to exercise other corruption tests
      ** further downstream. */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Corrupt schema - two indexes on the same btree */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CHECK</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>pCheck</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3ExprListCompare</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>,<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>pCheck</name></name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* Tables have different CHECK constraints.  Ticket #2252 */</comment>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
  <comment type="block">/* Disallow the transfer optimization if the destination table constains
  ** any foreign key constraints.  This is more restrictive than necessary.
  ** But the main beneficiary of the transfer optimization is the VACUUM 
  ** command, and the VACUUM command disables foreign key constraints.  So
  ** the extra complication to make this rule less restrictive is probably
  ** not worth the effort.  Ticket [6284df89debdfa61db8073e062908af0c9b6118e]
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsOrdinaryTable</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_ForeignKeys</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDest</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>tab</name><operator>.</operator><name>pFKey</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_CountRows</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* xfer opt does not play well with PRAGMA count_changes */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we get this far, it means that the xfer optimization is at
  ** least a possibility, though it might only work if the destination
  ** table (tab1) is initially empty.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <expr_stmt><expr><name>sqlite3_xferopt_count</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>iDbSrc</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3CodeVerifySchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDbSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iSrc</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDest</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>regAutoinc</name> <operator>=</operator> <call><name>autoIncBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDbDest</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regData</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regRowid</name> <operator>=</operator> <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name>iDbDest</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>destHasUniqueIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_Vacuum</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator>
      <operator>(</operator><name><name>pDest</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDest</name><operator>-&gt;</operator><name>pIndex</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator>          <comment type="block">/* (1) */</comment>
   <operator>||</operator> <name>destHasUniqueIdx</name>                              <comment type="block">/* (2) */</comment>
   <operator>||</operator> <operator>(</operator><name>onError</name><operator>!=</operator><name>OE_Abort</name> <operator>&amp;&amp;</operator> <name>onError</name><operator>!=</operator><name>OE_Rollback</name><operator>)</operator>   <comment type="block">/* (3) */</comment>
  <operator>)</operator></expr>)</condition><block>{<block_content>
    <comment type="block">/* In some circumstances, we are able to run the xfer optimization
    ** only if the destination table is initially empty. Unless the
    ** DBFLAG_Vacuum flag is set, this block generates code to make
    ** that determination. If DBFLAG_Vacuum is set, then the destination
    ** table is always empty.
    **
    ** Conditions under which the destination must be empty:
    **
    ** (1) There is no INTEGER PRIMARY KEY but there are indices.
    **     (If the destination is not initially empty, the rowid fields
    **     of index entries might need to change.)
    **
    ** (2) The destination has a unique index.  (The xfer optimization 
    **     is unable to test uniqueness.)
    **
    ** (3) onError is something other than OE_Abort and OE_Rollback.
    */</comment>
    <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>emptyDestTest</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>insFlags</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>iDbSrc</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>emptySrcTest</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>iPKey</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_Vacuum</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeVerifyAbortable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>addr2</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3RowidConstraint</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>autoIncStep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regAutoinc</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pDest</name><operator>-&gt;</operator><name>pIndex</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_VacuumInto</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pDest</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Autoincrement</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_Vacuum</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekEnd</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>insFlags</name> <operator>=</operator> <name>OPFLAG_APPEND</name><operator>|</operator><name>OPFLAG_USESEEKRESULT</name><operator>|</operator><name>OPFLAG_PREFORMAT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>insFlags</name> <operator>=</operator> <name>OPFLAG_NCHANGE</name><operator>|</operator><name>OPFLAG_LASTROWID</name><operator>|</operator><name>OPFLAG_APPEND</name><operator>|</operator><name>OPFLAG_PREFORMAT</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_PREUPDATE_HOOK</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_Vacuum</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowData</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>insFlags</name> <operator>&amp;=</operator> <operator>~</operator><name>OPFLAG_PREFORMAT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowCell</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_Vacuum</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pDest</name></expr></argument>, <argument><expr><name>P4_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>insFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDbDest</name></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDbSrc</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>pDestIdx</name><operator>=</operator><name><name>pDest</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pDestIdx</name></expr>;</condition> <incr><expr><name>pDestIdx</name><operator>=</operator><name><name>pDestIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>idxInsFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pSrcIdx</name><operator>=</operator><name><name>pSrc</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pSrcIdx</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pSrcIdx</name><operator>=</operator><name><name>pSrcIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>xferCompatibleIndex</name><argument_list>(<argument><expr><name>pDestIdx</name></expr></argument>, <argument><expr><name>pSrcIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrcIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name><name>pSrcIdx</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDbSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSrcIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pSrcIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name><name>pDestIdx</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDbDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDestIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_BULKCSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name><name>pDestIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addr1</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_Vacuum</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* This INSERT command is part of a VACUUM operation, which guarantees
      ** that the destination table is empty. If all indexed columns use
      ** collation sequence BINARY, then it can also be assumed that the
      ** index will be populated by inserting keys in strictly sorted 
      ** order. In this case, instead of seeking within the b-tree as part
      ** of every OP_IdxInsert opcode, an OP_SeekEnd is added before the
      ** OP_IdxInsert to seek to the point within the b-tree where each key 
      ** should be inserted. This is faster.
      **
      ** If any of the indexed columns use a collation sequence other than
      ** BINARY, this optimization is disabled. This is because the user 
      ** might change the definition of a collation sequence and then run
      ** a VACUUM command. In that case keys may not be written in strictly
      ** sorted order.  */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrcIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><name><name>pSrcIdx</name><operator>-&gt;</operator><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>sqlite3StrBINARY</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pSrcIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>idxInsFlags</name> <operator>=</operator> <name>OPFLAG_USESEEKRESULT</name><operator>|</operator><name>OPFLAG_PREFORMAT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SeekEnd</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowCell</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pDestIdx</name><operator>-&gt;</operator><name>idxType</name></name><operator>==</operator><name>SQLITE_IDXTYPE_PRIMARYKEY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>idxInsFlags</name> <operator>|=</operator> <name>OPFLAG_NCHANGE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>idxInsFlags</name><operator>!=</operator><operator>(</operator><name>OPFLAG_USESEEKRESULT</name><operator>|</operator><name>OPFLAG_PREFORMAT</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowData</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mDbFlags</name></name> <operator>&amp;</operator> <name>DBFLAG_Vacuum</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
       <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call> 
       <operator>&amp;&amp;</operator> <call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pDestIdx</name></expr></argument>)</argument_list></call></expr> 
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>codeWithoutRowidPreupdate</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>idxInsFlags</name><operator>|</operator><name>OPFLAG_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><name>addr1</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>emptySrcTest</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>emptySrcTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>emptyDestTest</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3AutoincrementEnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Halt</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>emptyDestTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_XFER_OPT */</comment>
</unit>
