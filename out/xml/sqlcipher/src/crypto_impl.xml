<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/crypto_impl.c"><comment type="block">/* 
** SQLCipher
** http://sqlcipher.net
** 
** Copyright (c) 2008 - 2013, ZETETIC LLC
** All rights reserved.
** 
** Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are met:
**     * Redistributions of source code must retain the above copyright
**       notice, this list of conditions and the following disclaimer.
**     * Redistributions in binary form must reproduce the above copyright
**       notice, this list of conditions and the following disclaimer in the
**       documentation and/or other materials provided with the distribution.
**     * Neither the name of the ZETETIC LLC nor the
**       names of its contributors may be used to endorse or promote products
**       derived from this software without specific prior written permission.
** 
** THIS SOFTWARE IS PROVIDED BY ZETETIC LLC ''AS IS'' AND ANY
** EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
** DISCLAIMED. IN NO EVENT SHALL ZETETIC LLC BE LIABLE FOR ANY
** DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
** LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
** ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**  
*/</comment>
<comment type="block">/* BEGIN SQLCIPHER */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlcipher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"crypto.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLCIPHER_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>unsigned</name> <name>int</name></type> <name>cipher_test_flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<function><type><name>unsigned</name> <name>int</name></type> <name>sqlcipher_get_test_flags</name><parameter_list>()</parameter_list> <block>{<block_content>
  <return>return <expr><name>cipher_test_flags</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlcipher_set_test_flags</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>cipher_test_flags</name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>cipher_test_rand</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<function><type><name>int</name></type> <name>sqlcipher_get_test_rand</name><parameter_list>()</parameter_list> <block>{<block_content>
  <return>return <expr><name>cipher_test_rand</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlcipher_set_test_rand</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rand</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>cipher_test_rand</name> <operator>=</operator> <name>rand</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlcipher_get_test_fail</name><parameter_list>()</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>

  <comment type="block">/* if cipher_test_rand is not set to a non-zero value always fail (return true) */</comment>
  <if_stmt><if>if <condition>(<expr><name>cipher_test_rand</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><operator>(</operator><name>x</name> <operator>%</operator> <name>cipher_test_rand</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Generate code to return a string value */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>unsigned</name> <name>int</name></type> <name>default_flags</name> <init>= <expr><name>DEFAULT_CIPHER_FLAGS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>unsigned</name> <name>char</name></type> <name>hmac_salt_mask</name> <init>= <expr><name>HMAC_SALT_MASK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>default_kdf_iter</name> <init>= <expr><name>PBKDF2_ITER</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>default_page_size</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>default_plaintext_header_sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>default_hmac_algorithm</name> <init>= <expr><name>SQLCIPHER_HMAC_SHA512</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>default_kdf_algorithm</name> <init>= <expr><name>SQLCIPHER_PBKDF2_HMAC_SHA512</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>sqlcipher_mem_security_on</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>sqlcipher_mem_executed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>sqlcipher_mem_initialized</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>unsigned</name> <name>int</name></type> <name>sqlcipher_activate_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sqlite3_mem_methods</name></type> <name>default_mem_methods</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlcipher_provider</name> <modifier>*</modifier></type><name>default_provider</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_mutex</name><modifier>*</modifier></type> <name><name>sqlcipher_static_mutex</name><index>[<expr><name>SQLCIPHER_MUTEX_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name><modifier>*</modifier></type> <name>sqlcipher_log_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>sqlcipher_log_logcat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>unsigned</name> <name>int</name></type> <name>sqlcipher_log_level</name> <init>= <expr><name>SQLCIPHER_LOG_NONE</name></expr></init></decl>;</decl_stmt>

<function><type><name>sqlite3_mutex</name><modifier>*</modifier></type> <name>sqlcipher_mutex</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mutex</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name>mutex</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>mutex</name> <operator>&gt;=</operator> <name>SQLCIPHER_MUTEX_COUNT</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>sqlcipher_static_mutex</name><index>[<expr><name>mutex</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlcipher_mem_init</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAppData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name><name>default_mem_methods</name><operator>.</operator><name>xInit</name></name><argument_list>(<argument><expr><name>pAppData</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlcipher_mem_shutdown</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAppData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name><name>default_mem_methods</name><operator>.</operator><name>xShutdown</name></name><argument_list>(<argument><expr><name>pAppData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlcipher_mem_malloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name><name>default_mem_methods</name><operator>.</operator><name>xMalloc</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name>sqlcipher_mem_executed</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sqlcipher_mem_executed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><name>sqlcipher_mem_security_on</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_mem_malloc: calling sqlcipher_mlock(%p,%d)"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlcipher_mlock</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlcipher_mem_size</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name><name>default_mem_methods</name><operator>.</operator><name>xSize</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlcipher_mem_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name>sqlcipher_mem_executed</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sqlcipher_mem_executed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><name>sqlcipher_mem_security_on</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>sqlcipher_mem_size</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_mem_free: calling sqlcipher_memset(%p,0,%d) and sqlcipher_munlock(%p, %d)"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlcipher_memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlcipher_munlock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name><name>default_mem_methods</name><operator>.</operator><name>xFree</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlcipher_mem_realloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>new</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>orig_sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><name>sqlcipher_mem_security_on</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>orig_sz</name> <operator>=</operator> <call><name>sqlcipher_mem_size</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlcipher_mem_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name>sqlcipher_mem_malloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>n</name> <operator>&lt;=</operator> <name>orig_sz</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>p</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>sqlcipher_mem_malloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><name>new</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>orig_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlcipher_mem_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>new</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><call><name><name>default_mem_methods</name><operator>.</operator><name>xRealloc</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlcipher_mem_roundup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name><name>default_mem_methods</name><operator>.</operator><name>xRoundup</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_mem_methods</name></type> <name>sqlcipher_mem_methods</name> <init>= <expr><block>{
  <expr><name>sqlcipher_mem_malloc</name></expr>,
  <expr><name>sqlcipher_mem_free</name></expr>,
  <expr><name>sqlcipher_mem_realloc</name></expr>,
  <expr><name>sqlcipher_mem_size</name></expr>,
  <expr><name>sqlcipher_mem_roundup</name></expr>,
  <expr><name>sqlcipher_mem_init</name></expr>,
  <expr><name>sqlcipher_mem_shutdown</name></expr>,
  <expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>sqlcipher_init_memmethods</name><parameter_list>()</parameter_list> <block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name>sqlcipher_mem_initialized</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_GETMALLOC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>default_mem_methods</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_OK</name> <operator>||</operator>
     <call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_MALLOC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sqlcipher_mem_methods</name></expr></argument>)</argument_list></call>  <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
     <expr_stmt><expr><name>sqlcipher_mem_security_on</name> <operator>=</operator> <name>sqlcipher_mem_executed</name> <operator>=</operator> <name>sqlcipher_mem_initialized</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>sqlcipher_mem_initialized</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_register_provider</name><parameter_list>(<parameter><decl><type><name>sqlcipher_provider</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_register_provider: entering SQLCIPHER_MUTEX_PROVIDER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlcipher_mutex</name><argument_list>(<argument><expr><name>SQLCIPHER_MUTEX_PROVIDER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_register_provider: entered SQLCIPHER_MUTEX_PROVIDER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>default_provider</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>default_provider</name> <operator>!=</operator> <name>p</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* only free the current registerd provider if it has been initialized
       and it isn't a pointer to the same provider passed to the function
       (i.e. protect against a caller calling register twice for the same provider) */</comment>
    <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>default_provider</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlcipher_provider</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>default_provider</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>   
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_register_provider: leaving SQLCIPHER_MUTEX_PROVIDER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlcipher_mutex</name><argument_list>(<argument><expr><name>SQLCIPHER_MUTEX_PROVIDER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_register_provider: left SQLCIPHER_MUTEX_PROVIDER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* return a pointer to the currently registered provider. This will
   allow an application to fetch the current registered provider and
   make minor changes to it */</comment>
<function><type><name>sqlcipher_provider</name><modifier>*</modifier></type> <name>sqlcipher_get_provider</name><parameter_list>()</parameter_list> <block>{<block_content>
  <return>return <expr><name>default_provider</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sqlcipher_activate</name><parameter_list>()</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_activate: entering static master mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_MASTER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_activate: entered static master mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* allocate new mutexes */</comment>
  <if_stmt><if>if<condition>(<expr><name>sqlcipher_activate_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SQLCIPHER_MUTEX_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>sqlcipher_static_mutex</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_FAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* check to see if there is a provider registered at this point
     if there no provider registered at this point, register the 
     default provider */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>sqlcipher_get_provider</name><argument_list>()</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>sqlcipher_provider</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlcipher_provider</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>SQLCIPHER_CRYPTO_CC</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>sqlcipher_cc_setup</name><argument_list>(<argument><expr><name>sqlcipher_provider</name> <operator>*</operator><name>p</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlcipher_cc_setup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>SQLCIPHER_CRYPTO_LIBTOMCRYPT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>sqlcipher_ltc_setup</name><argument_list>(<argument><expr><name>sqlcipher_provider</name> <operator>*</operator><name>p</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlcipher_ltc_setup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>SQLCIPHER_CRYPTO_NSS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>sqlcipher_nss_setup</name><argument_list>(<argument><expr><name>sqlcipher_provider</name> <operator>*</operator><name>p</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlcipher_nss_setup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>SQLCIPHER_CRYPTO_OPENSSL</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>sqlcipher_openssl_setup</name><argument_list>(<argument><expr><name>sqlcipher_provider</name> <operator>*</operator><name>p</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlcipher_openssl_setup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"NO DEFAULT SQLCIPHER CRYPTO PROVIDER DEFINED"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_activate: calling sqlcipher_register_provider(%p)"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLCIPHER_EXT</name></cpp:ifdef>
    <expr_stmt><expr><call><name>sqlcipher_ext_provider_setup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlcipher_register_provider</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_activate: called sqlcipher_register_provider(%p)"</literal></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>sqlcipher_activate_count</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* increment activation count */</comment>

  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_activate: leaving static master mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_MASTER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_activate: left static master mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sqlcipher_deactivate</name><parameter_list>()</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_deactivate: entering static master mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_MASTER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_deactivate: entered static master mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>sqlcipher_activate_count</name><operator>--</operator></expr>;</expr_stmt>
  <comment type="block">/* if no connections are using sqlcipher, cleanup globals */</comment>
  <if_stmt><if>if<condition>(<expr><name>sqlcipher_activate_count</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_deactivate: entering SQLCIPHER_MUTEX_PROVIDER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlcipher_mutex</name><argument_list>(<argument><expr><name>SQLCIPHER_MUTEX_PROVIDER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_deactivate: entered SQLCIPHER_MUTEX_PROVIDER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>default_provider</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>default_provider</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlcipher_provider</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>default_provider</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_deactivate: leaving SQLCIPHER_MUTEX_PROVIDER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlcipher_mutex</name><argument_list>(<argument><expr><name>SQLCIPHER_MUTEX_PROVIDER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_deactivate: left SQLCIPHER_MUTEX_PROVIDER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLCIPHER_EXT</name></cpp:ifdef>
    <expr_stmt><expr><call><name>sqlcipher_ext_provider_destroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* last connection closed, free mutexes */</comment>
    <if_stmt><if>if<condition>(<expr><name>sqlcipher_activate_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SQLCIPHER_MUTEX_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_mutex_free</name><argument_list>(<argument><expr><name><name>sqlcipher_static_mutex</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>sqlcipher_activate_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* reset activation count */</comment>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_deactivate: leaving static master mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_MASTER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_deactivate: left static master mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* constant time memset using volitile to avoid having the memset
   optimized out by the compiler. 
   Note: As suggested by Joachim Schipper (joachim.schipper@fox-it.com)
*/</comment>
<function><type><name>void</name><modifier>*</modifier></type> <name>sqlcipher_memset</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>sqlite_uint64</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_uint64</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>v</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_memset: setting %p[0-%llu]=%d)"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* constant time memory check tests every position of a memory segement
   matches a single value (i.e. the memory is all zeros)
   returns 0 if match, 1 of no match */</comment>
<function><type><name>int</name></type> <name>sqlcipher_ismemset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>sqlite_uint64</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_uint64</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>result</name> <operator>|=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^</operator> <name>value</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><operator>(</operator><name>result</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* constant time memory comparison routine. 
   returns 0 if match, 1 if no match */</comment>
<function><type><name>int</name></type> <name>sqlcipher_memcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v0</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a0</name> <init>= <expr><name>v0</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>a1</name> <init>= <expr><name>v1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>result</name> <operator>|=</operator> <name><name>a0</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^</operator> <name><name>a1</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  
  <return>return <expr><operator>(</operator><name>result</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sqlcipher_mlock</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>sqlite_uint64</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>OMIT_MEMLOCK</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__unix__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if> 
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>pagesize</name> <init>= <expr><call><name>sysconf</name><argument_list>(<argument><expr><name>_SC_PAGESIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>ptr</name> <operator>%</operator> <name>pagesize</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>sz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_mem_lock: calling mlock(%p,%lu); _SC_PAGESIZE=%lu"</literal></expr></argument>, <argument><expr><name>ptr</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><name>sz</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>pagesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>mlock</name><argument_list>(<argument><expr><name>ptr</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><name>sz</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_mem_lock: mlock(%p,%lu) returned %d errno=%d"</literal></expr></argument>, <argument><expr><name>ptr</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><name>sz</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>WINAPI_FAMILY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>WINAPI_FAMILY</name> <operator>==</operator> <name>WINAPI_FAMILY_PHONE_APP</name> <operator>||</operator> <name>WINAPI_FAMILY</name> <operator>==</operator> <name>WINAPI_FAMILY_APP</name><operator>)</operator><operator>)</operator></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_mem_lock: calling VirtualLock(%p,%d)"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>VirtualLock</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_mem_lock: VirtualLock(%p,%d) returned %d LastError=%d"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sqlcipher_munlock</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>sqlite_uint64</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>OMIT_MEMLOCK</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__unix__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if> 
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>pagesize</name> <init>= <expr><call><name>sysconf</name><argument_list>(<argument><expr><name>_SC_PAGESIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>ptr</name> <operator>%</operator> <name>pagesize</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>sz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_mem_unlock: calling munlock(%p,%lu)"</literal></expr></argument>, <argument><expr><name>ptr</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><name>sz</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>munlock</name><argument_list>(<argument><expr><name>ptr</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><name>sz</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_mem_unlock: munlock(%p,%lu) returned %d errno=%d"</literal></expr></argument>, <argument><expr><name>ptr</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><name>sz</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>WINAPI_FAMILY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>WINAPI_FAMILY</name> <operator>==</operator> <name>WINAPI_FAMILY_PHONE_APP</name> <operator>||</operator> <name>WINAPI_FAMILY</name> <operator>==</operator> <name>WINAPI_FAMILY_APP</name><operator>)</operator><operator>)</operator></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_mem_lock: calling VirtualUnlock(%p,%d)"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>VirtualUnlock</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name>rc</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_mem_unlock: VirtualUnlock(%p,%d) returned %d LastError=%d"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * Free and wipe memory. Uses SQLites internal sqlite3_free so that memory
  * can be countend and memory leak detection works in the test suite. 
  * If ptr is not null memory will be freed. 
  * If sz is greater than zero, the memory will be overwritten with zero before it is freed
  * If sz is &gt; 0, and not compiled with OMIT_MEMLOCK, system will attempt to unlock the
  * memory segment so it can be paged
  */</comment>
<function><type><name>void</name></type> <name>sqlcipher_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>sqlite_uint64</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_free: calling sqlcipher_memset(%p,0,%llu)"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_memset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_munlock</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * allocate memory. Uses sqlite's internall malloc wrapper so memory can be 
  * reference counted and leak detection works. Unless compiled with OMIT_MEMLOCK
  * attempts to lock the memory pages so sensitive information won't be swapped
  */</comment>
<function><type><name>void</name><modifier>*</modifier></type> <name>sqlcipher_malloc</name><parameter_list>(<parameter><decl><type><name>sqlite_uint64</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_malloc: calling sqlite3Malloc(%llu)"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_malloc: calling sqlcipher_memset(%p,0,%llu)"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_memset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_mlock</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier></type> <name>sqlcipher_version</name><parameter_list>()</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CIPHER_VERSION_QUALIFIER</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>version</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s %s"</literal></expr></argument>, <argument><expr><call><name>CIPHER_XSTR</name><argument_list>(<argument><expr><name>CIPHER_VERSION_NUMBER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CIPHER_XSTR</name><argument_list>(<argument><expr><name>CIPHER_VERSION_QUALIFIER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CIPHER_XSTR</name><argument_list>(<argument><expr><name>CIPHER_VERSION_BUILD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>version</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><call><name>CIPHER_XSTR</name><argument_list>(<argument><expr><name>CIPHER_VERSION_NUMBER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CIPHER_XSTR</name><argument_list>(<argument><expr><name>CIPHER_VERSION_BUILD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>version</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * Initialize new cipher_ctx struct. This function will allocate memory
  * for the cipher context and for the key
  * 
  * returns SQLITE_OK if initialization was successful
  * returns SQLITE_NOMEM if an error occured allocating memory
  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlcipher_cipher_ctx_init</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>cipher_ctx</name> <modifier>*</modifier><modifier>*</modifier></type><name>iCtx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>cipher_ctx</name> <modifier>*</modifier></type><name>c_ctx</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_cipher_ctx_init: allocating context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>iCtx</name> <operator>=</operator> <operator>(</operator><name>cipher_ctx</name> <operator>*</operator><operator>)</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cipher_ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>c_ctx</name> <operator>=</operator> <operator>*</operator><name>iCtx</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>c_ctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_cipher_ctx_init: allocating key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_cipher_ctx_init: allocating hmac_key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>hmac_key</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name><name>c_ctx</name><operator>-&gt;</operator><name>key</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>c_ctx</name><operator>-&gt;</operator><name>hmac_key</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * Free and wipe memory associated with a cipher_ctx
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlcipher_cipher_ctx_free</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>cipher_ctx</name> <modifier>*</modifier><modifier>*</modifier></type><name>iCtx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>cipher_ctx</name> <modifier>*</modifier></type><name>c_ctx</name> <init>= <expr><operator>*</operator><name>iCtx</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"cipher_ctx_free: iCtx=%p"</literal></expr></argument>, <argument><expr><name>iCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>hmac_key</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>pass</name></name></expr></argument>, <argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>pass_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>keyspec</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>keyspec_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>c_ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cipher_ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlcipher_codec_ctx_reserve_setup</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>base_reserve</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>iv_sz</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* base reserve size will be IV only */</comment> 
  <decl_stmt><decl><type><name>int</name></type> <name>reserve</name> <init>= <expr><name>base_reserve</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_sz</name></name> <operator>=</operator> <call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>get_hmac_sz</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_algorithm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

  <if_stmt><if>if<condition>(<expr><call><name>sqlcipher_codec_ctx_get_use_hmac</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>reserve</name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>hmac_sz</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* if reserve will include hmac, update that size */</comment>

  <comment type="block">/* calculate the amount of reserve needed in even increments of the cipher block size */</comment>
  <expr_stmt><expr><name>reserve</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>reserve</name> <operator>%</operator> <name><name>ctx</name><operator>-&gt;</operator><name>block_sz</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>reserve</name></expr> </then><else>:
               <expr><operator>(</operator><operator>(</operator><name>reserve</name> <operator>/</operator> <name><name>ctx</name><operator>-&gt;</operator><name>block_sz</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>block_sz</name></name></expr></else></ternary></expr>;</expr_stmt>  

  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_reserve_setup: base_reserve=%d block_sz=%d md_size=%d reserve=%d"</literal></expr></argument>, 
                <argument><expr><name>base_reserve</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>block_sz</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_sz</name></name></expr></argument>, <argument><expr><name>reserve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>reserve_sz</name></name> <operator>=</operator> <name>reserve</name></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * Compare one cipher_ctx to another.
  *
  * returns 0 if all the parameters (except the derived key data) are the same
  * returns 1 otherwise
  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlcipher_cipher_ctx_cmp</name><parameter_list>(<parameter><decl><type><name>cipher_ctx</name> <modifier>*</modifier></type><name>c1</name></decl></parameter>, <parameter><decl><type><name>cipher_ctx</name> <modifier>*</modifier></type><name>c2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>are_equal</name> <init>= <expr><operator>(</operator>
    <name><name>c1</name><operator>-&gt;</operator><name>pass_sz</name></name> <operator>==</operator> <name><name>c2</name><operator>-&gt;</operator><name>pass_sz</name></name>
    <operator>&amp;&amp;</operator> <operator>(</operator>
      <name><name>c1</name><operator>-&gt;</operator><name>pass</name></name> <operator>==</operator> <name><name>c2</name><operator>-&gt;</operator><name>pass</name></name>
      <operator>||</operator> <operator>!</operator><call><name>sqlcipher_memcmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>c1</name><operator>-&gt;</operator><name>pass</name></name></expr></argument>,
                           <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>c2</name><operator>-&gt;</operator><name>pass</name></name></expr></argument>,
                           <argument><expr><name><name>c1</name><operator>-&gt;</operator><name>pass_sz</name></name></expr></argument>)</argument_list></call>
    <operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_cipher_ctx_cmp: c1=%p c2=%p sqlcipher_memcmp(c1-&gt;pass, c2_pass)=%d are_equal=%d"</literal></expr></argument>,
    <argument><expr><name>c1</name></expr></argument>, <argument><expr><name>c2</name></expr></argument>,
    <argument><expr><ternary><condition><expr><operator>(</operator><name><name>c1</name><operator>-&gt;</operator><name>pass</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>c2</name><operator>-&gt;</operator><name>pass</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
      <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>:
      <expr><call><name>sqlcipher_memcmp</name><argument_list>(
        <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>c1</name><operator>-&gt;</operator><name>pass</name></name></expr></argument>,
        <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>c2</name><operator>-&gt;</operator><name>pass</name></name></expr></argument>,
        <argument><expr><name><name>c1</name><operator>-&gt;</operator><name>pass_sz</name></name></expr></argument>
      )</argument_list></call></expr></else></ternary></expr></argument>,
    <argument><expr><name>are_equal</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><operator>!</operator><name>are_equal</name></expr>;</return> <comment type="block">/* return 0 if they are the same, 1 otherwise */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * Copy one cipher_ctx to another. For instance, assuming that read_ctx is a 
  * fully initialized context, you could copy it to write_ctx and all yet data
  * and pass information across
  *
  * returns SQLITE_OK if initialization was successful
  * returns SQLITE_NOMEM if an error occured allocating memory
  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlcipher_cipher_ctx_copy</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>cipher_ctx</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>cipher_ctx</name> <modifier>*</modifier></type><name>source</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>target</name><operator>-&gt;</operator><name>key</name></name></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>hmac_key</name> <init>= <expr><name><name>target</name><operator>-&gt;</operator><name>hmac_key</name></name></expr></init></decl>;</decl_stmt> 

  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_cipher_ctx_copy: target=%p, source=%p"</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>pass</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>pass_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>keyspec</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>keyspec_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cipher_ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt> <comment type="block">/* restore pointer to previously allocated key data */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>source</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>hmac_key</name></name> <operator>=</operator> <name>hmac_key</name></expr>;</expr_stmt> <comment type="block">/* restore pointer to previously allocated hmac key data */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>hmac_key</name></name></expr></argument>, <argument><expr><name><name>source</name><operator>-&gt;</operator><name>hmac_key</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name><name>source</name><operator>-&gt;</operator><name>pass</name></name> <operator>&amp;&amp;</operator> <name><name>source</name><operator>-&gt;</operator><name>pass_sz</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>pass</name></name> <operator>=</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><name><name>source</name><operator>-&gt;</operator><name>pass_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>pass</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>pass</name></name></expr></argument>, <argument><expr><name><name>source</name><operator>-&gt;</operator><name>pass</name></name></expr></argument>, <argument><expr><name><name>source</name><operator>-&gt;</operator><name>pass_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>source</name><operator>-&gt;</operator><name>keyspec</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>keyspec</name></name> <operator>=</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>keyspec_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>keyspec</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>keyspec</name></name></expr></argument>, <argument><expr><name><name>source</name><operator>-&gt;</operator><name>keyspec</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>keyspec_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * Set the keyspec for the cipher_ctx
  * 
  * returns SQLITE_OK if assignment was successfull
  * returns SQLITE_NOMEM if an error occured allocating memory
  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlcipher_cipher_ctx_set_keyspec</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>cipher_ctx</name> <modifier>*</modifier></type><name>c_ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* free, zero existing pointers and size */</comment>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>keyspec</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>keyspec_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>keyspec</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>keyspec</name></name> <operator>=</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>keyspec_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>c_ctx</name><operator>-&gt;</operator><name>keyspec</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>keyspec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>keyspec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cipher_bin2hex</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name></expr></argument>, <argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>keyspec</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cipher_bin2hex</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name></expr></argument>, <argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>keyspec</name></name> <operator>+</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>keyspec</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>keyspec_sz</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_get_store_pass</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>store_pass</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sqlcipher_codec_set_store_pass</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>store_pass</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sqlcipher_codec_get_pass</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>zKey</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nKey</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>zKey</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name><operator>-&gt;</operator><name>pass</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>nKey</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name><operator>-&gt;</operator><name>pass_sz</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlcipher_set_derive_key</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>derive</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name><operator>-&gt;</operator><name>derive_key</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name><operator>-&gt;</operator><name>derive_key</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * Set the passphrase for the cipher_ctx
  * 
  * returns SQLITE_OK if assignment was successfull
  * returns SQLITE_NOMEM if an error occured allocating memory
  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlcipher_cipher_ctx_set_pass</name><parameter_list>(<parameter><decl><type><name>cipher_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* free, zero existing pointers and size */</comment>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pass</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pass_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pass</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pass_sz</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>zKey</name> <operator>&amp;&amp;</operator> <name>nKey</name></expr>)</condition> <block>{<block_content> <comment type="block">/* if new password is provided, copy it */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pass_sz</name></name> <operator>=</operator> <name>nKey</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pass</name></name> <operator>=</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>pass</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pass</name></name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt> 
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_set_pass</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>for_ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>cipher_ctx</name> <modifier>*</modifier></type><name>c_ctx</name> <init>= <expr><ternary><condition><expr><name>for_ctx</name></expr> ?</condition><then> <expr><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name></name></expr> </then><else>: <expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_cipher_ctx_set_pass</name><argument_list>(<argument><expr><name>c_ctx</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_set_pass: error %d from sqlcipher_cipher_ctx_set_pass"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>derive_key</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>for_ctx</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_cipher_ctx_copy</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><ternary><condition><expr><name>for_ctx</name></expr> ?</condition><then> <expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name></name></expr> </then><else>: <expr><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>c_ctx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_set_pass: error %d from sqlcipher_cipher_ctx_copy"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function> 

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>sqlcipher_codec_ctx_get_cipher</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>get_cipher</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* set the global default KDF iteration */</comment>
<function><type><name>void</name></type> <name>sqlcipher_set_default_kdf_iter</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iter</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>default_kdf_iter</name> <operator>=</operator> <name>iter</name></expr>;</expr_stmt> 
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_get_default_kdf_iter</name><parameter_list>()</parameter_list> <block>{<block_content>
  <return>return <expr><name>default_kdf_iter</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_set_kdf_iter</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kdf_iter</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_iter</name></name> <operator>=</operator> <name>kdf_iter</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_set_derive_key</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_get_kdf_iter</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_iter</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_set_fast_kdf_iter</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fast_kdf_iter</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>fast_kdf_iter</name></name> <operator>=</operator> <name>fast_kdf_iter</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_set_derive_key</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_get_fast_kdf_iter</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>fast_kdf_iter</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* set the global default flag for HMAC */</comment>
<function><type><name>void</name></type> <name>sqlcipher_set_default_use_hmac</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>use</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name>use</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>default_flags</name> <operator>|=</operator> <name>CIPHER_FLAG_HMAC</name></expr>;</expr_stmt></block_content></block></if> 
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>default_flags</name> <operator>&amp;=</operator> <operator>~</operator><name>CIPHER_FLAG_HMAC</name></expr>;</expr_stmt></block_content></block></else></if_stmt> 
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_get_default_use_hmac</name><parameter_list>()</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name>default_flags</name> <operator>&amp;</operator> <name>CIPHER_FLAG_HMAC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sqlcipher_set_hmac_salt_mask</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>hmac_salt_mask</name> <operator>=</operator> <name>mask</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>char</name></type> <name>sqlcipher_get_hmac_salt_mask</name><parameter_list>()</parameter_list> <block>{<block_content>
  <return>return <expr><name>hmac_salt_mask</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* set the codec flag for whether this individual database should be using hmac */</comment>
<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_set_use_hmac</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name>use</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_codec_ctx_set_flag</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>CIPHER_FLAG_HMAC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_codec_ctx_unset_flag</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>CIPHER_FLAG_HMAC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt> 

  <return>return <expr><call><name>sqlcipher_codec_ctx_reserve_setup</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_get_use_hmac</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CIPHER_FLAG_HMAC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* the length of plaintext header size must be:
 * 1. greater than or equal to zero
 * 2. a multiple of the cipher block size
 * 3. less than the usable size of the first database page
 */</comment>
<function><type><name>int</name></type> <name>sqlcipher_set_default_plaintext_header_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>default_plaintext_header_sz</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_set_plaintext_header_size</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name>size</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>size</name> <operator>%</operator> <name><name>ctx</name><operator>-&gt;</operator><name>block_sz</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>size</name> <operator>&lt;</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>page_sz</name></name> <operator>-</operator> <name><name>ctx</name><operator>-&gt;</operator><name>reserve_sz</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>plaintext_header_sz</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>plaintext_header_sz</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_set_plaintext_header_size: attempt to set invalid plantext_header_size %d"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function> 

<function><type><name>int</name></type> <name>sqlcipher_get_default_plaintext_header_size</name><parameter_list>()</parameter_list> <block>{<block_content>
  <return>return <expr><name>default_plaintext_header_sz</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_get_plaintext_header_size</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>plaintext_header_sz</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* manipulate HMAC algorithm */</comment>
<function><type><name>int</name></type> <name>sqlcipher_set_default_hmac_algorithm</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>algorithm</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>default_hmac_algorithm</name> <operator>=</operator> <name>algorithm</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_set_hmac_algorithm</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>algorithm</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_algorithm</name></name> <operator>=</operator> <name>algorithm</name></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlcipher_codec_ctx_reserve_setup</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function> 

<function><type><name>int</name></type> <name>sqlcipher_get_default_hmac_algorithm</name><parameter_list>()</parameter_list> <block>{<block_content>
  <return>return <expr><name>default_hmac_algorithm</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_get_hmac_algorithm</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_algorithm</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* manipulate KDF algorithm */</comment>
<function><type><name>int</name></type> <name>sqlcipher_set_default_kdf_algorithm</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>algorithm</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>default_kdf_algorithm</name> <operator>=</operator> <name>algorithm</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_set_kdf_algorithm</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>algorithm</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_algorithm</name></name> <operator>=</operator> <name>algorithm</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function> 

<function><type><name>int</name></type> <name>sqlcipher_get_default_kdf_algorithm</name><parameter_list>()</parameter_list> <block>{<block_content>
  <return>return <expr><name>default_kdf_algorithm</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_get_kdf_algorithm</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_algorithm</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_set_flag</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>flag</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_unset_flag</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>flag</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_get_flag</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>flag</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sqlcipher_codec_ctx_set_error</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_set_error: ctx=%p, error=%d"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3pager_error</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_get_reservesize</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>reserve_sz</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>sqlcipher_codec_ctx_get_data</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlcipher_codec_ctx_init_kdf_salt</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><call><name>sqlite3PagerFile</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>need_kdf_salt</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return> <comment type="block">/* don't reload salt when not needed */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* read salt from header, if present, otherwise generate a new random salt */</comment>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init_kdf_salt: obtaining salt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>fd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init_kdf_salt: unable to read salt from file header, generating random"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>random</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init_kdf_salt: error retrieving random bytes from provider"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>need_kdf_salt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return> 
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_set_kdf_salt</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>salt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name>size</name> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt</name></name></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>need_kdf_salt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_set_kdf_salt: attempt to set salt of incorrect size %d"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_get_kdf_salt</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>salt</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>need_kdf_salt</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_codec_ctx_init_kdf_salt</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_get_kdf_salt: error %d from sqlcipher_codec_ctx_init_kdf_salt"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>salt</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt</name></name></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sqlcipher_codec_get_keyspec</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>zKey</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nKey</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>zKey</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name><operator>-&gt;</operator><name>keyspec</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>nKey</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>keyspec_sz</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_set_pagesize</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>size</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>size</name> <operator>&amp;</operator> <operator>(</operator><name>size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator> <operator>||</operator> <name><name>size</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">512</literal> <operator>||</operator> <name>size</name></expr></argument> &gt;</argument_list></name> <literal type="number">65536</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"cipher_page_size not a power of 2 and between 512 and 65536 inclusive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* attempt to free the existing page buffer */</comment>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>page_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>page_sz</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

  <comment type="block">/* pre-allocate a page buffer of PageSize bytes. This will
     be used as a persistent buffer for encryption and decryption 
     operations to avoid overhead of multiple memory allocations*/</comment>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_get_pagesize</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>page_sz</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sqlcipher_set_default_pagesize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>page_size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>default_page_size</name> <operator>=</operator> <name>page_size</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_get_default_pagesize</name><parameter_list>()</parameter_list> <block>{<block_content>
  <return>return <expr><name>default_page_size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sqlcipher_set_mem_security</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>on</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* memory security can only be enabled, not disabled */</comment>
  <if_stmt><if>if<condition>(<expr><name>on</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_set_mem_security: on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sqlcipher_mem_security_on</name> <operator>=</operator> <name>on</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_get_mem_security</name><parameter_list>()</parameter_list> <block>{<block_content>
  <comment type="block">/* only report that memory security is enabled if pragma cipher_memory_security is ON and 
     SQLCipher's allocator/deallocator was run at least one timecurrently used */</comment> 
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_get_mem_security: sqlcipher_mem_security_on = %d, sqlcipher_mem_executed = %d"</literal></expr></argument>, <argument><expr><name>sqlcipher_mem_security_on</name></expr></argument>, <argument><expr><name>sqlcipher_mem_executed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>sqlcipher_mem_security_on</name> <operator>&amp;&amp;</operator> <name>sqlcipher_mem_executed</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_init</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier><modifier>*</modifier></type><name>iCtx</name></decl></parameter>, <parameter><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: allocating context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>iCtx</name> <operator>=</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>codec_ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ctx</name> <operator>=</operator> <operator>*</operator><name>iCtx</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>ctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pBt</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name></expr>;</expr_stmt> <comment type="block">/* assign pointer to database btree structure */</comment>

  <comment type="block">/* allocate space for salt data. Then read the first 16 bytes 
       directly off the database file. This is the salt for the
       key derivation function. If we get a short read allocate
       a new random salt value */</comment>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: allocating kdf_salt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name> <operator>=</operator> <name>FILE_HEADER_SZ</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt</name></name> <operator>=</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* allocate space for separate hmac salt data. We want the
     HMAC derivation salt to be different than the encryption
     key derivation salt */</comment>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: allocating hmac_kdf_salt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_kdf_salt</name></name> <operator>=</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_kdf_salt</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* setup default flags */</comment>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>default_flags</name></expr>;</expr_stmt>

  <comment type="block">/* defer attempt to read KDF salt until first use */</comment>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>need_kdf_salt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <comment type="block">/* setup the crypto provider  */</comment>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: allocating provider"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider</name></name> <operator>=</operator> <operator>(</operator><name>sqlcipher_provider</name> <operator>*</operator><operator>)</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlcipher_provider</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* make a copy of the provider to be used for the duration of the context */</comment>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: entering SQLCIPHER_MUTEX_PROVIDER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlcipher_mutex</name><argument_list>(<argument><expr><name>SQLCIPHER_MUTEX_PROVIDER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: entered SQLCIPHER_MUTEX_PROVIDER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider</name></name></expr></argument>, <argument><expr><name>default_provider</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlcipher_provider</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: leaving SQLCIPHER_MUTEX_PROVIDER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlcipher_mutex</name><argument_list>(<argument><expr><name>SQLCIPHER_MUTEX_PROVIDER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: left SQLCIPHER_MUTEX_PROVIDER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>ctx_init</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: error %d returned from ctx_init"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name> <operator>=</operator> <call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>get_key_sz</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>iv_sz</name></name> <operator>=</operator> <call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>get_iv_sz</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>block_sz</name></name> <operator>=</operator> <call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>get_block_sz</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* establic the size for a hex-formated key specification, containing the 
     raw encryption key and the salt used to generate it format. will be x'hexkey...hexsalt'
     so oversize by 3 bytes */</comment> 
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>keyspec_sz</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name> <operator>+</operator> <name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>

  <comment type="block">/*
     Always overwrite page size and set to the default because the first page of the database
     in encrypted and thus sqlite can't effectively determine the pagesize. this causes an issue in 
     cases where bytes 16 &amp; 17 of the page header are a power of 2 as reported by John Lehman
  */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_codec_ctx_set_pagesize</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>default_page_size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: error %d returned from sqlcipher_codec_ctx_set_pagesize with %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>default_page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* establish settings for the KDF iterations and fast (HMAC) KDF iterations */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_codec_ctx_set_kdf_iter</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>default_kdf_iter</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: error %d setting default_kdf_iter %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>default_kdf_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_codec_ctx_set_fast_kdf_iter</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>FAST_PBKDF2_ITER</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: error %d setting fast_kdf_iter to %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>FAST_PBKDF2_ITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* set the default HMAC and KDF algorithms which will determine the reserve size */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_codec_ctx_set_hmac_algorithm</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>default_hmac_algorithm</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: error %d setting sqlcipher_codec_ctx_set_hmac_algorithm with %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>default_hmac_algorithm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Note that use_hmac is a special case that requires recalculation of page size
     so we call set_use_hmac to perform setup */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_codec_ctx_set_use_hmac</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>default_flags</name> <operator>&amp;</operator> <name>CIPHER_FLAG_HMAC</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: error %d setting use_hmac %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>default_flags</name> <operator>&amp;</operator> <name>CIPHER_FLAG_HMAC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_codec_ctx_set_kdf_algorithm</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>default_kdf_algorithm</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: error %d setting sqlcipher_codec_ctx_set_kdf_algorithm with %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>default_kdf_algorithm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* setup the default plaintext header size */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_codec_ctx_set_plaintext_header_size</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>default_plaintext_header_sz</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: error %d setting sqlcipher_codec_ctx_set_plaintext_header_size with %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>default_plaintext_header_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* initialize the read and write sub-contexts. this must happen after key_sz is established  */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_cipher_ctx_init</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: error %d initializing read_ctx"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt> 

  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_cipher_ctx_init</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: error %d initializing write_ctx"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return> 
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* set the key material on one of the sub cipher contexts and sync them up */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_codec_ctx_set_pass</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: error %d setting pass key"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_cipher_ctx_copy</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_ctx_init: error %d copying write_ctx to read_ctx"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * Free and wipe memory associated with a cipher_ctx, including the allocated
  * read_ctx and write_ctx.
  */</comment>
<function><type><name>void</name></type> <name>sqlcipher_codec_ctx_free</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier><modifier>*</modifier></type><name>iCtx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>*</operator><name>iCtx</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"codec_ctx_free: iCtx=%p"</literal></expr></argument>, <argument><expr><name>iCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_kdf_salt</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>page_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>ctx_free</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlcipher_provider</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

  <expr_stmt><expr><call><name>sqlcipher_cipher_ctx_free</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_cipher_ctx_free</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>codec_ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/** convert a 32bit unsigned integer to little endian byte ordering */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlcipher_put4byte_le</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content> 
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlcipher_page_hmac</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>cipher_ctx</name> <modifier>*</modifier></type><name>c_ctx</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in_sz</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>pgno_raw</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgno</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
  <comment type="block">/* we may convert page number to consistent representation before calculating MAC for
     compatibility across big-endian and little-endian platforms. 

     Note: The public release of sqlcipher 2.0.0 to 2.0.6 had a bug where the bytes of pgno 
     were used directly in the MAC. SQLCipher convert's to little endian by default to preserve
     backwards compatibility on the most popular platforms, but can optionally be configured
     to use either big endian or native byte ordering via pragma. */</comment>

  <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CIPHER_FLAG_LE_PGNO</name></expr>)</condition> <block>{<block_content> <comment type="block">/* compute hmac using little endian pgno*/</comment>
    <expr_stmt><expr><call><name>sqlcipher_put4byte_le</name><argument_list>(<argument><expr><name>pgno_raw</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CIPHER_FLAG_BE_PGNO</name></expr>)</condition> <block>{<block_content> <comment type="block">/* compute hmac using big endian pgno */</comment>
    <expr_stmt><expr><call><name>sqlite3Put4byte</name><argument_list>(<argument><expr><name>pgno_raw</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* sqlite3Put4byte converts 32bit uint to big endian  */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content> <comment type="block">/* use native byte ordering */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pgno_raw</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgno</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgno</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* include the encrypted page data,  initialization vector, and page number in HMAC. This will 
     prevent both tampering with the ciphertext, manipulation of the IV, or resequencing otherwise
     valid pages out of order in a database */</comment> 
  <return>return <expr><call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>hmac</name></name><argument_list>(
    <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_algorithm</name></name></expr></argument>, <argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>hmac_key</name></name></expr></argument>,
    <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name></expr></argument>, <argument><expr><name>in</name></expr></argument>,
    <argument><expr><name>in_sz</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pgno_raw</name></expr></argument>,
    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgno</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ctx - codec context
 * pgno - page number in database
 * size - size in bytes of input and output buffers
 * mode - 1 to encrypt, 0 to decrypt
 * in - pointer to input bytes
 * out - pouter to output bytes
 */</comment>
<function><type><name>int</name></type> <name>sqlcipher_page_cipher</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>for_ctx</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>page_sz</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>cipher_ctx</name> <modifier>*</modifier></type><name>c_ctx</name> <init>= <expr><ternary><condition><expr><name>for_ctx</name></expr> ?</condition><then> <expr><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name></name></expr> </then><else>: <expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>iv_in</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iv_out</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>hmac_in</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>hmac_out</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>out_start</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

  <comment type="block">/* calculate some required positions into various buffers */</comment>
  <expr_stmt><expr><name>size</name> <operator>=</operator> <name>page_sz</name> <operator>-</operator> <name><name>ctx</name><operator>-&gt;</operator><name>reserve_sz</name></name></expr>;</expr_stmt> <comment type="block">/* adjust size to useable size and memset reserve at end of page */</comment>
  <expr_stmt><expr><name>iv_out</name> <operator>=</operator> <name>out</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iv_in</name> <operator>=</operator> <name>in</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>

  <comment type="block">/* hmac will be written immediately after the initialization vector. the remainder of the page reserve will contain
     random bytes. note, these pointers are only valid when using hmac */</comment>
  <expr_stmt><expr><name>hmac_in</name> <operator>=</operator> <name>in</name> <operator>+</operator> <name>size</name> <operator>+</operator> <name><name>ctx</name><operator>-&gt;</operator><name>iv_sz</name></name></expr>;</expr_stmt> 
  <expr_stmt><expr><name>hmac_out</name> <operator>=</operator> <name>out</name> <operator>+</operator> <name>size</name> <operator>+</operator> <name><name>ctx</name><operator>-&gt;</operator><name>iv_sz</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>out_start</name> <operator>=</operator> <name>out</name></expr>;</expr_stmt> <comment type="block">/* note the original position of the output buffer pointer, as out will be rewritten during encryption */</comment>

  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_page_cipher: pgno=%d, mode=%d, size=%d"</literal></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CODEC_HEXDUMP</name><argument_list>(<argument><expr><literal type="string">"sqlcipher_page_cipher: input page data"</literal></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>page_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* the key size should never be zero. If it is, error out. */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_page_cipher: error possible context corruption, key_sz is zero for pgno=%d"</literal></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt> 

  <if_stmt><if>if<condition>(<expr><name>mode</name> <operator>==</operator> <name>CIPHER_ENCRYPT</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* start at front of the reserve block, write random data to the end */</comment>
    <if_stmt><if>if<condition>(<expr><call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>random</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>, <argument><expr><name>iv_out</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reserve_sz</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content> <comment type="block">/* CIPHER_DECRYPT */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>iv_out</name></expr></argument>, <argument><expr><name>iv_in</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>iv_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* copy the iv from the input to output buffer */</comment>
  </block_content>}</block></else></if_stmt> 

  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CIPHER_FLAG_HMAC</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>mode</name> <operator>==</operator> <name>CIPHER_DECRYPT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>skip_read_hmac</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name>sqlcipher_page_hmac</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>c_ctx</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>size</name> <operator>+</operator> <name><name>ctx</name><operator>-&gt;</operator><name>iv_sz</name></name></expr></argument>, <argument><expr><name>hmac_out</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_page_cipher: hmac operation on decrypt failed for pgno=%d"</literal></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_page_cipher: comparing hmac on in=%p out=%p hmac_sz=%d"</literal></expr></argument>, <argument><expr><name>hmac_in</name></expr></argument>, <argument><expr><name>hmac_out</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><call><name>sqlcipher_memcmp</name><argument_list>(<argument><expr><name>hmac_in</name></expr></argument>, <argument><expr><name>hmac_out</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_sz</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* the hmac check failed */</comment> 
      <if_stmt><if>if<condition>(<expr><call><name>sqlite3BtreeGetAutoVacuum</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pBt</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BTREE_AUTOVACUUM_NONE</name> <operator>&amp;&amp;</operator> <call><name>sqlcipher_ismemset</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>page_sz</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* first check if the entire contents of the page is zeros. If so, this page 
           resulted from a short read (i.e. sqlite attempted to pull a page after the end of the file. these 
           short read failures must be ignored for autovaccum mode to work so wipe the output buffer 
           and return SQLITE_OK to skip the decryption step. */</comment>
        <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_WARN</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_page_cipher: zeroed page (short read) for pgno %d, encryption but returning SQLITE_OK"</literal></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlcipher_memset</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>page_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* if the page memory is not all zeros, it means the there was data and a hmac on the page. 
           since the check failed, the page was either tampered with or corrupted. wipe the output buffer,
           and return SQLITE_ERROR to the caller */</comment>
        <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_page_cipher: hmac check failed for pgno=%d returning SQLITE_ERROR"</literal></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>error</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt> 
  
  <if_stmt><if>if<condition>(<expr><call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>cipher</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name></expr></argument>, <argument><expr><name>iv_out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_page_cipher: cipher operation mode=%d failed for pgno=%d returning SQLITE_ERROR"</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>error</name>;</goto>
  </block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>

  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CIPHER_FLAG_HMAC</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>mode</name> <operator>==</operator> <name>CIPHER_ENCRYPT</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name>sqlcipher_page_hmac</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>c_ctx</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>out_start</name></expr></argument>, <argument><expr><name>size</name> <operator>+</operator> <name><name>ctx</name><operator>-&gt;</operator><name>iv_sz</name></name></expr></argument>, <argument><expr><name>hmac_out</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_page_cipher: hmac operation on encrypt failed for pgno=%d"</literal></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>error</name>;</goto>
    </block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt> 
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>CODEC_HEXDUMP</name><argument_list>(<argument><expr><literal type="string">"sqlcipher_page_cipher: output page data"</literal></expr></argument>, <argument><expr><name>out_start</name></expr></argument>, <argument><expr><name>page_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
<label><name>error</name>:</label>
  <expr_stmt><expr><call><name>sqlcipher_memset</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>page_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * Derive an encryption key for a cipher contex key based on the raw password.
  *
  * If the raw key data is formated as x'hex' and there are exactly enough hex chars to fill
  * the key (i.e 64 hex chars for a 256 bit key) then the key data will be used directly. 

  * Else, if the raw key data is formated as x'hex' and there are exactly enough hex chars to fill
  * the key and the salt (i.e 92 hex chars for a 256 bit key and 16 byte salt) then it will be unpacked
  * as the key followed by the salt.
  * 
  * Otherwise, a key data will be derived using PBKDF2
  * 
  * returns SQLITE_OK if initialization was successful
  * returns SQLITE_ERROR if the key could't be derived (for instance if pass is NULL or pass_sz is 0)
  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlcipher_cipher_ctx_key_derive</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>cipher_ctx</name> <modifier>*</modifier></type><name>c_ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_cipher_ctx_key_derive: ctx-&gt;kdf_salt_sz=%d ctx-&gt;kdf_iter=%d ctx-&gt;fast_kdf_iter=%d ctx-&gt;key_sz=%d"</literal></expr></argument>,
    <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_iter</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fast_kdf_iter</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name><name>c_ctx</name><operator>-&gt;</operator><name>pass</name></name> <operator>&amp;&amp;</operator> <name><name>c_ctx</name><operator>-&gt;</operator><name>pass_sz</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* if key material is present on the context for derivation */</comment> 
   
    <comment type="block">/* if necessary, initialize the salt from the header or random source */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>need_kdf_salt</name></name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_codec_ctx_init_kdf_salt</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_cipher_ctx_key_derive: error %d from sqlcipher_codec_ctx_init_kdf_salt"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
 
    <if_stmt><if>if <condition>(<expr><name><name>c_ctx</name><operator>-&gt;</operator><name>pass_sz</name></name> <operator>==</operator> <operator>(</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>c_ctx</name><operator>-&gt;</operator><name>pass</name></name></expr></argument> ,<argument><expr><literal type="string">"x'"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>cipher_isHex</name><argument_list>(<argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>pass</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>c_ctx</name><operator>-&gt;</operator><name>pass_sz</name></name> <operator>-</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* adjust for leading x' and tailing ' */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>c_ctx</name><operator>-&gt;</operator><name>pass</name></name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* adjust lead offset of x' */</comment>
      <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"cipher_ctx_key_derive: using raw key from hex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>cipher_hex2bin</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c_ctx</name><operator>-&gt;</operator><name>pass_sz</name></name> <operator>==</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name> <operator>+</operator> <name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>c_ctx</name><operator>-&gt;</operator><name>pass</name></name></expr></argument> ,<argument><expr><literal type="string">"x'"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>cipher_isHex</name><argument_list>(<argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>pass</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name> <operator>+</operator> <name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
      <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>c_ctx</name><operator>-&gt;</operator><name>pass</name></name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* adjust lead offset of x' */</comment>
      <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"cipher_ctx_key_derive: using raw key from hex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <expr_stmt><expr><call><name>cipher_hex2bin</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>, <argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>cipher_hex2bin</name><argument_list>(<argument><expr><name>z</name> <operator>+</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content> 
      <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"cipher_ctx_key_derive: deriving key using full PBKDF2 with %d iterations"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>kdf</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_algorithm</name></name></expr></argument>, <argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>pass</name></name></expr></argument>, <argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>pass_sz</name></name></expr></argument>, 
                    <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_iter</name></name></expr></argument>,
                    <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name></expr></argument>, <argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"cipher_ctx_key_derive: error occurred from provider kdf generating encryption key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* set the context "keyspec" containing the hex-formatted key and salt to be used when attaching databases */</comment>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_cipher_ctx_set_keyspec</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>c_ctx</name></expr></argument>, <argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_cipher_ctx_key_derive: error %d from sqlcipher_cipher_ctx_set_keyspec"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if this context is setup to use hmac checks, generate a seperate and different 
       key for HMAC. In this case, we use the output of the previous KDF as the input to 
       this KDF run. This ensures a distinct but predictable HMAC key. */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CIPHER_FLAG_HMAC</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <comment type="block">/* start by copying the kdf key into the hmac salt slot
         then XOR it with the fixed hmac salt defined at compile time
         this ensures that the salt passed in to derive the hmac key, while 
         easy to derive and publically known, is not the same as the salt used 
         to generate the encryption key */</comment> 
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_kdf_salt</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_kdf_salt</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^=</operator> <name>hmac_salt_mask</name></expr>;</expr_stmt>
      </block_content>}</block></for> 

      <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"cipher_ctx_key_derive: deriving hmac key from encryption key using PBKDF2 with %d iterations"</literal></expr></argument>, 
        <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fast_kdf_iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      
      <if_stmt><if>if<condition>(<expr><call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>kdf</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_algorithm</name></name></expr></argument>, <argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name></expr></argument>, 
                    <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_kdf_salt</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>kdf_salt_sz</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fast_kdf_iter</name></name></expr></argument>,
                    <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>key_sz</name></name></expr></argument>, <argument><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>hmac_key</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"cipher_ctx_key_derive: error occurred from provider kdf generating HMAC key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>c_ctx</name><operator>-&gt;</operator><name>derive_key</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"cipher_ctx_key_derive: key material is not present on the context for key derivation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_key_derive</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* derive key on first use if necessary */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name><operator>-&gt;</operator><name>derive_key</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name>sqlcipher_cipher_ctx_key_derive</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_key_derive: error occurred deriving read_ctx key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name><operator>-&gt;</operator><name>derive_key</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name>sqlcipher_cipher_ctx_cmp</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="block">/* the relevant parameters are the same, just copy read key */</comment>
      <if_stmt><if>if<condition>(<expr><call><name>sqlcipher_cipher_ctx_copy</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_key_derive: error occurred copying read_ctx to write_ctx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><call><name>sqlcipher_cipher_ctx_key_derive</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_key_derive: error occurred deriving write_ctx key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* TODO: wipe and free passphrase after key derivation */</comment>
  <if_stmt><if>if<condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>store_pass</name></name>  <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_cipher_ctx_set_pass</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlcipher_cipher_ctx_set_pass</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return> 
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_key_copy</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>source</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name>source</name> <operator>==</operator> <name>CIPHER_READ_CTX</name></expr>)</condition> <block>{<block_content> 
      <return>return <expr><call><name>sqlcipher_cipher_ctx_copy</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name></name></expr></argument>)</argument_list></call></expr>;</return> 
  </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><call><name>sqlcipher_cipher_ctx_copy</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>write_ctx</name></name></expr></argument>)</argument_list></call></expr>;</return> 
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>sqlcipher_codec_get_cipher_provider</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>get_provider_name</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlcipher_check_connection</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>key_sz</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>user_version</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>journal_mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>statement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query_journal_mode</name> <init>= <expr><literal type="string">"PRAGMA journal_mode;"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query_user_version</name> <init>= <expr><literal type="string">"PRAGMA user_version;"</literal></expr></init></decl>;</decl_stmt>
 
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt> 
    
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_key</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt> 
    
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt> 

  <comment type="block">/* start by querying the user version. 
     this will fail if the key is incorrect */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>query_user_version</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>statement</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt> 
    
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>==</operator> <name>SQLITE_ROW</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>user_version</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>statement</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <goto>goto <name>cleanup</name>;</goto>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>query_journal_mode</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>statement</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt> 
    
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>==</operator> <name>SQLITE_ROW</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>journal_mode</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>statement</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  </block_content>}</block></if> <else>else <block>{<block_content>
    <goto>goto <name>cleanup</name>;</goto> 
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  <comment type="block">/* cleanup will finalize open statement */</comment>
  
<label><name>cleanup</name>:</label>
  <if_stmt><if>if<condition>(<expr><name>statement</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 
  <if_stmt><if>if<condition>(<expr><name>db</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_integrity_check</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>column</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>page</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>hmac_out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><call><name>sqlite3PagerFile</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>file_sz</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeSetNumCols</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>, <argument><expr><name>column</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>fd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_String8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"database file is undefined"</literal></expr></argument>, <argument><expr><name>P4_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CIPHER_FLAG_HMAC</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_String8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"HMAC is not enabled, unable to integrity check"</literal></expr></argument>, <argument><expr><name>P4_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlcipher_codec_key_derive</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_String8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"unable to derive keys"</literal></expr></argument>, <argument><expr><name>P4_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>hmac_out</name> <operator>=</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>page</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>page</name> <operator>&lt;=</operator> <name>file_sz</name> <operator>/</operator> <name><name>ctx</name><operator>-&gt;</operator><name>page_sz</name></name></expr>;</condition> <incr><expr><name>page</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>page</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>page_sz</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>payload_sz</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>page_sz</name></name> <operator>-</operator> <name><name>ctx</name><operator>-&gt;</operator><name>reserve_sz</name></name> <operator>+</operator> <name><name>ctx</name><operator>-&gt;</operator><name>iv_sz</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>read_sz</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>page_sz</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* skip integrity check on PAGER_SJ_PGNO since it will have no valid content */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>sqlite3pager_is_sj_pgno</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>page</name><operator>==</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>page1_offset</name> <init>= <expr><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>plaintext_header_sz</name></name></expr> ?</condition><then> <expr><name><name>ctx</name><operator>-&gt;</operator><name>plaintext_header_sz</name></name></expr> </then><else>: <expr><name>FILE_HEADER_SZ</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>read_sz</name> <operator>=</operator> <name>read_sz</name> <operator>-</operator> <name>page1_offset</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>payload_sz</name> <operator>=</operator> <name>payload_sz</name> <operator>-</operator> <name>page1_offset</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>page1_offset</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlcipher_memset</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>page_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlcipher_memset</name><argument_list>(<argument><expr><name>hmac_out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>read_sz</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"error reading %d bytes from file page %d at offset %d"</literal></expr></argument>, <argument><expr><name>read_sz</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_String8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>sqlcipher_page_hmac</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>payload_sz</name></expr></argument>, <argument><expr><name>hmac_out</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"HMAC operation failed for page %d"</literal></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_String8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>sqlcipher_memcmp</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>payload_sz</name></expr></argument>, <argument><expr><name>hmac_out</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_sz</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"HMAC verification failed for page %d"</literal></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_String8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>(<expr><name>file_sz</name> <operator>%</operator> <name><name>ctx</name><operator>-&gt;</operator><name>page_sz</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"page %d has an invalid size of %lld bytes"</literal></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>file_sz</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>file_sz</name> <operator>/</operator> <name><name>ctx</name><operator>-&gt;</operator><name>page_sz</name></name><operator>)</operator> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>page_sz</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_String8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>cleanup</name>:</label>
  <if_stmt><if>if<condition>(<expr><name>hmac_out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>hmac_out</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>hmac_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_ctx_migrate</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pass_sz</name></decl>, <decl><type ref="prev"/><name>keyspec_sz</name></decl>, <decl><type ref="prev"/><name>nRes</name></decl>, <decl><type ref="prev"/><name>user_version</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>, <decl><type ref="prev"/><name>oflags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>db_filename</name> <init>= <expr><call><name>sqlite3_db_filename</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>set_user_version</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pass</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>attach_command</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>migrated_db_filename</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>keyspec</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>journal_mode</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>set_journal_mode</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pragma_compat</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pDest</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pSrc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>srcfile</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>destfile</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OS_WINRT</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>LPWSTR</name></type> <name>w_db_filename</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>w_migrated_db_filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>w_db_filename_sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>w_migrated_db_filename_sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pass_sz</name> <operator>=</operator> <name>keyspec_sz</name> <operator>=</operator> <name>rc</name> <operator>=</operator> <name>user_version</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><operator>!</operator><name>db_filename</name> <operator>||</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>db_filename</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> 
    <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt> <comment type="block">/* exit immediately if this is an in memory database */</comment> 
  
  <comment type="block">/* pull the provided password / key material off the current codec context */</comment>
  <expr_stmt><expr><name>pass_sz</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name><operator>-&gt;</operator><name>pass_sz</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pass</name> <operator>=</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><name>pass_sz</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pass</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pass_sz</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pass</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>read_ctx</name><operator>-&gt;</operator><name>pass</name></name></expr></argument>, <argument><expr><name>pass_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Version 4 - current, no upgrade required, so exit immediately */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlcipher_check_connection</name><argument_list>(<argument><expr><name>db_filename</name></expr></argument>, <argument><expr><name>pass</name></expr></argument>, <argument><expr><name>pass_sz</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>user_version</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>journal_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>==</operator> <name>SQLITE_OK</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"No upgrade required - exiting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">3</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>pragma_compat</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"PRAGMA cipher_compatibility = %d;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlcipher_check_connection</name><argument_list>(<argument><expr><name>db_filename</name></expr></argument>, <argument><expr><name>pass</name></expr></argument>, <argument><expr><name>pass_sz</name></expr></argument>, <argument><expr><name>pragma_compat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>user_version</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>journal_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>==</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Version %d format found"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>migrate</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><name>pragma_compat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>pragma_compat</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pragma_compat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 
    <expr_stmt><expr><name>pragma_compat</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  
  <comment type="block">/* if we exit the loop normally we failed to determine the version, this is an error */</comment>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Upgrade format not determined"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <goto>goto <name>handle_error</name>;</goto>

<label><name>migrate</name>:</label>

  <expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s-migrated"</literal></expr></argument>, <argument><expr><name>db_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* overallocate migrated_db_filename, because sqlite3OsOpen will read past the null terminator
   * to determine whether the filename was URI formatted */</comment>
  <expr_stmt><expr><name>migrated_db_filename</name> <operator>=</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>migrated_db_filename</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>attach_command</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"ATTACH DATABASE '%s' as migrate;"</literal></expr></argument>, <argument><expr><name>migrated_db_filename</name></expr></argument>, <argument><expr><name>pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <expr_stmt><expr><name>set_user_version</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"PRAGMA migrate.user_version = %d;"</literal></expr></argument>, <argument><expr><name>user_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pragma_compat</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"set compatibility mode failed, error code %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>handle_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* force journal mode to DELETE, we will set it back later if different */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA journal_mode = delete;"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"force journal mode DELETE failed, error code %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>handle_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>attach_command</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"attach failed, error code %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>handle_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_key_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"migrate"</literal></expr></argument>, <argument><expr><name>pass</name></expr></argument>, <argument><expr><name>pass_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"keying attached database failed, error code %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>handle_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"SELECT sqlcipher_export('migrate');"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_export failed, error code %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>handle_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLCIPHER_TEST</name></cpp:ifdef>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>sqlcipher_get_test_flags</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>TEST_FAIL_MIGRATE</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"simulated migrate failure, error code %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>handle_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>set_user_version</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"set user version failed, error code %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>handle_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot migrate from within a transaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>handle_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot migrate - SQL statements in progress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>handle_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pDest</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pBt</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>nRes</name> <operator>=</operator> <call><name>sqlite3BtreeGetRequestedReserve</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* unset the BTS_PAGESIZE_FIXED flag to avoid SQLITE_READONLY */</comment>
  <expr_stmt><expr><name><name>pDest</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>btsFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTS_PAGESIZE_FIXED</name></expr>;</expr_stmt> 
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeSetPageSize</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>default_page_size</name></expr></argument>, <argument><expr><name>nRes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"set btree page size to %d res %d rc %d"</literal></expr></argument>, <argument><expr><name>default_page_size</name></expr></argument>, <argument><expr><name>nRes</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>handle_error</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlcipherCodecGetKey</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>keyspec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keyspec_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipherCodecAttach</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>keyspec</name></expr></argument>, <argument><expr><name>keyspec_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>srcfile</name> <operator>=</operator> <call><name>sqlite3PagerFile</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>destfile</name> <operator>=</operator> <call><name>sqlite3PagerFile</name><argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>srcfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>destfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OS_WINRT</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"performing windows MoveFileExA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>w_db_filename_sz</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LPCCH</name><operator>)</operator> <name>db_filename</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>w_db_filename</name> <operator>=</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><name>w_db_filename_sz</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>w_db_filename_sz</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LPCCH</name><operator>)</operator> <name>db_filename</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>LPWSTR</name><operator>)</operator> <name>w_db_filename</name></expr></argument>, <argument><expr><name>w_db_filename_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>w_migrated_db_filename_sz</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LPCCH</name><operator>)</operator> <name>migrated_db_filename</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>w_migrated_db_filename</name> <operator>=</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><name>w_migrated_db_filename_sz</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>w_migrated_db_filename_sz</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LPCCH</name><operator>)</operator> <name>migrated_db_filename</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>LPWSTR</name><operator>)</operator> <name>w_migrated_db_filename</name></expr></argument>, <argument><expr><name>w_migrated_db_filename_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>MoveFileExW</name><argument_list>(<argument><expr><name>w_migrated_db_filename</name></expr></argument>, <argument><expr><name>w_db_filename</name></expr></argument>, <argument><expr><name>MOVEFILE_REPLACE_EXISTING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"error occurred while renaming %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>handle_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"performing POSIX rename"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>rename</name><argument_list>(<argument><expr><name>migrated_db_filename</name></expr></argument>, <argument><expr><name>db_filename</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"error occurred while renaming %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>handle_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"renamed migration database %s to main database %s: %d"</literal></expr></argument>, <argument><expr><name>migrated_db_filename</name></expr></argument>, <argument><expr><name>db_filename</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name>migrated_db_filename</name></expr></argument>, <argument><expr><name>srcfile</name></expr></argument>, <argument><expr><name>SQLITE_OPEN_READWRITE</name><operator>|</operator><name>SQLITE_OPEN_CREATE</name><operator>|</operator><name>SQLITE_OPEN_MAIN_DB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"reopened migration database: %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>handle_error</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name>db_filename</name></expr></argument>, <argument><expr><name>destfile</name></expr></argument>, <argument><expr><name>SQLITE_OPEN_READWRITE</name><operator>|</operator><name>SQLITE_OPEN_CREATE</name><operator>|</operator><name>SQLITE_OPEN_MAIN_DB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"reopened main database: %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>handle_error</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3pager_reset</name><argument_list>(<argument><expr><name><name>pDest</name><operator>-&gt;</operator><name>pBt</name><operator>-&gt;</operator><name>pPager</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"reset pager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"DETACH DATABASE migrate;"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"DETACH DATABASE called %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt> 

  <expr_stmt><expr><call><name>sqlite3ResetAllSchemasOfConnection</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"reset all schemas"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>set_journal_mode</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"PRAGMA journal_mode = %s;"</literal></expr></argument>, <argument><expr><name>journal_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>set_journal_mode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"%s: %d"</literal></expr></argument>, <argument><expr><name>set_journal_mode</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>handle_error</name>;</goto></block_content></block></if></if_stmt>

  <goto>goto <name>cleanup</name>;</goto>

<label><name>handle_error</name>:</label>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"An error occurred attempting to migrate the database - last error %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
  <if_stmt><if>if<condition>(<expr><name>migrated_db_filename</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>del_rc</name> <init>= <expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name>migrated_db_filename</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"deleted migration database: %d"</literal></expr></argument>, <argument><expr><name>del_rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>(<expr><name>pass</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>pass</name></expr></argument>, <argument><expr><name>pass_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><name>attach_command</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>attach_command</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>attach_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 
  <if_stmt><if>if<condition>(<expr><name>migrated_db_filename</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>migrated_db_filename</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>migrated_db_filename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 
  <if_stmt><if>if<condition>(<expr><name>set_user_version</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>set_user_version</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>set_user_version</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 
  <if_stmt><if>if<condition>(<expr><name>set_journal_mode</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>set_journal_mode</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>set_journal_mode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 
  <if_stmt><if>if<condition>(<expr><name>journal_mode</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>journal_mode</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>journal_mode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 
  <if_stmt><if>if<condition>(<expr><name>pragma_compat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>pragma_compat</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pragma_compat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OS_WINRT</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>(<expr><name>w_db_filename</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>w_db_filename</name></expr></argument>, <argument><expr><name>w_db_filename_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><name>w_migrated_db_filename</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>w_migrated_db_filename</name></expr></argument>, <argument><expr><name>w_migrated_db_filename_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_add_random</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>random_sz</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name> <init>= <expr><operator>&amp;</operator><name><name>zRight</name><index>[<expr><name>random_sz</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>random_sz</name> <operator>-</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* adjust for leading x' and tailing ' */</comment>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
      <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>zRight</name></expr></argument> ,<argument><expr><literal type="string">"x'"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
      <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
      <name>n</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>buffer_sz</name> <init>= <expr><name>n</name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>random</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zRight</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* adjust lead offset of x' */</comment>
    <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_add_random: using raw random blob from hex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>random</name> <operator>=</operator> <call><name>sqlcipher_malloc</name><argument_list>(<argument><expr><name>buffer_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>random</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cipher_hex2bin</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>random</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>add_random</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>, <argument><expr><name>random</name></expr></argument>, <argument><expr><name>buffer_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlcipher_free</name><argument_list>(<argument><expr><name>random</name></expr></argument>, <argument><expr><name>buffer_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_codec_add_random: attemt to add random with invalid format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlcipher_profile_callback</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>trace</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>run_time</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FILE</name><operator>*</operator><operator>)</operator> <name>file</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><literal type="string">"Elapsed time:%.3f ms - %s\n"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>elapsed</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>sqlite3_uint64</name><operator>*</operator><operator>)</operator><name>run_time</name><operator>)</operator><operator>)</operator><operator>/</operator><literal type="number">1000000.0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__ANDROID__</name></cpp:ifdef>
  <if_stmt><if>if<condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>__android_log_print</name><argument_list>(<argument><expr><name>ANDROID_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher"</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>elapsed</name></expr></argument>, <argument><expr><call><name>sqlite3_sql</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_stmt</name><operator>*</operator><operator>)</operator><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>(<expr><name>f</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>elapsed</name></expr></argument>, <argument><expr><call><name>sqlite3_sql</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_stmt</name><operator>*</operator><operator>)</operator><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type> <name>sqlcipher_cipher_profile</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>destination</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_trace_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* disable tracing */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"stdout"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name>f</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>(<expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"stderr"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name>f</name> <operator>=</operator> <name>stderr</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>(<expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"logcat"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name>f</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* file pointer will be NULL indicating logcat on android */</comment>
    </block_content>}</block></if><else>else<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLCIPHER_PROFILE_USE_FOPEN</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__STDC_VERSION__</name> <operator>&gt;</operator> <literal type="number">199901L</literal><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OS_WINRT</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
      <if_stmt><if>if<condition>(<expr><call><name>fopen_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_trace_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_TRACE_PROFILE</name></expr></argument>, <argument><expr><name>sqlcipher_profile_callback</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_codec_fips_status</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>fips_status</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>sqlcipher_codec_get_provider_version</name><parameter_list>(<parameter><decl><type><name>codec_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name><name>ctx</name><operator>-&gt;</operator><name>provider</name><operator>-&gt;</operator><name>get_provider_version</name></name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>provider_ctx</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLCIPHER_OMIT_LOG</name></cpp:ifndef>
<comment type="block">/* constants from https://github.com/Alexpux/mingw-w64/blob/master/mingw-w64-crt/misc/gettimeofday.c */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILETIME_1970</name></cpp:macro> <cpp:value>116444736000000000ull</cpp:value></cpp:define> <comment type="block">/* seconds between 1/1/1601 and 1/1/1970 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HECTONANOSEC_PER_SEC</name></cpp:macro> <cpp:value>10000000ull</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>sqlcipher_log</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>params</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CODEC_DEBUG</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__ANDROID__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>__android_log_vprint</name><argument_list>(<argument><expr><name>ANDROID_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>(<expr><name>level</name> <operator>&gt;</operator> <name>sqlcipher_log_level</name> <operator>||</operator> <operator>(</operator><name>sqlcipher_log_logcat</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>sqlcipher_log_file</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <comment type="block">/* no log target or tag not in included filters */</comment>
    <goto>goto <name>end</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><name>sqlcipher_log_file</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type> <name>tt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ms</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type> <name>sec</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
    <decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>st</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILETIME</name></type> <name>ft</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetSystemTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SystemTimeToFileTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sec</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>sqlite_int64</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ft</name><operator>)</operator> <operator>-</operator> <name>FILETIME_1970</name><operator>)</operator> <operator>/</operator> <name>HECTONANOSEC_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>ms</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>wMilliseconds</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>localtime_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sec</name> <operator>=</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ms</name> <operator>=</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name><operator>/</operator><literal type="number">1000.0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>localtime_r</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>(<expr><call><name>strftime</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><operator>(</operator><name>FILE</name><operator>*</operator><operator>)</operator><name>sqlcipher_log_file</name></expr></argument>, <argument><expr><literal type="string">"%s.%03d: "</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><operator>(</operator><name>FILE</name><operator>*</operator><operator>)</operator><name>sqlcipher_log_file</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><operator>(</operator><name>FILE</name><operator>*</operator><operator>)</operator><name>sqlcipher_log_file</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__ANDROID__</name></cpp:ifdef>
  <if_stmt><if>if<condition>(<expr><name>sqlcipher_log_logcat</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>__android_log_vprint</name><argument_list>(<argument><expr><name>ANDROID_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<label><name>end</name>:</label>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>sqlcipher_set_log_level</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>level</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>sqlcipher_log_level</name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlcipher_set_log</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>destination</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLCIPHER_OMIT_LOG</name></cpp:ifdef>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* close open trace file if it is not stdout or stderr, then
     reset trace settings */</comment>
  <if_stmt><if>if<condition>(<expr><name>sqlcipher_log_file</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>sqlcipher_log_file</name> <operator>!=</operator> <name>stdout</name> <operator>&amp;&amp;</operator> <name>sqlcipher_log_file</name> <operator>!=</operator> <name>stderr</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><operator>(</operator><name>FILE</name><operator>*</operator><operator>)</operator><name>sqlcipher_log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>sqlcipher_log_file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sqlcipher_log_logcat</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"logcat"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>sqlcipher_log_logcat</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"stdout"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>sqlcipher_log_file</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>(<expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"stderr"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>sqlcipher_log_file</name> <operator>=</operator> <name>stderr</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>(<expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLCIPHER_PROFILE_USE_FOPEN</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__STDC_VERSION__</name> <operator>&gt;</operator> <literal type="number">199901L</literal><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OS_WINRT</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if<condition>(<expr><call><name>fopen_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sqlcipher_log_file</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>sqlcipher_log_file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlcipher_log</name><argument_list>(<argument><expr><name>SQLCIPHER_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"sqlcipher_set_log: set log to %s"</literal></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* END SQLCIPHER */</comment>
</unit>
