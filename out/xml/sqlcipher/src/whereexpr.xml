<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/whereexpr.c"><comment type="block">/*
** 2015-06-08
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This module contains C code that generates VDBE code used to process
** the WHERE clause of SQL statements.
**
** This file was originally part of where.c but was split out to improve
** readability and editabiliity.  This file contains utility routines for
** analyzing Expr objects in the WHERE clause.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"whereInt.h"</cpp:file></cpp:include>

<comment type="block">/* Forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exprAnalyze</name><parameter_list>(<parameter><decl><type><name>SrcList</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>WhereClause</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Deallocate all memory associated with a WhereOrInfo object.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereOrInfoDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>WhereOrInfo</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3WhereClauseClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>wc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Deallocate all memory associated with a WhereAndInfo object.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereAndInfoDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>WhereAndInfo</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3WhereClauseClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>wc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add a single new WhereTerm entry to the WhereClause object pWC.
** The new WhereTerm object is constructed from Expr p and with wtFlags.
** The index in pWC-&gt;a[] of the new WhereTerm is returned on success.
** 0 is returned if the new WhereTerm could not be added due to a memory
** allocation error.  The memory allocation failure will be recorded in
** the db-&gt;mallocFailed flag so that higher-level functions can detect it.
**
** This routine will increase the size of the pWC-&gt;a[] array as necessary.
**
** If the wtFlags argument includes TERM_DYNAMIC, then responsibility
** for freeing the expression p is assumed by the WhereClause object pWC.
** This is true even if this routine fails to allocate a new WhereTerm.
**
** WARNING:  This routine might reallocate the space used to store
** WhereTerms.  All pointers to WhereTerms should be invalidated after
** calling this routine.  Such pointers may be reinitialized by referencing
** the pWC-&gt;a[] array.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>whereClauseInsert</name><parameter_list>(<parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u16</name></type> <name>wtFlags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>wtFlags</name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>&gt;=</operator><name><name>pWC</name><operator>-&gt;</operator><name>nSlot</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pOld</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <call><name>sqlite3WhereMalloc</name><argument_list>(<argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pWC</name><operator>-&gt;</operator><name>nSlot</name></name><operator>*</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>wtFlags</name> <operator>&amp;</operator> <name>TERM_DYNAMIC</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name>pOld</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>pOld</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>nSlot</name></name> <operator>=</operator> <name><name>pWC</name><operator>-&gt;</operator><name>nSlot</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idx</name> <operator>=</operator> <name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>wtFlags</name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>nBase</name></name> <operator>=</operator> <name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_Unlikely</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name> <operator>=</operator> <call><name>sqlite3LogEst</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">270</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>truthProb</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>=</operator> <name>wtFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pWC</name></name> <operator>=</operator> <name>pWC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>iParent</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
         <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WhereTerm</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>WhereTerm</name></expr></argument>,<argument><expr><name>eOperator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the given operator is one of the operators that is
** allowed for an indexable WHERE clause term.  The allowed operators are
** "=", "&lt;", "&gt;", "&lt;=", "&gt;=", "IN", "IS", and "IS NULL"
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>allowedOp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GT</name><operator>&gt;</operator><name>TK_EQ</name> <operator>&amp;&amp;</operator> <name>TK_GT</name><operator>&lt;</operator><name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LT</name><operator>&gt;</operator><name>TK_EQ</name> <operator>&amp;&amp;</operator> <name>TK_LT</name><operator>&lt;</operator><name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LE</name><operator>&gt;</operator><name>TK_EQ</name> <operator>&amp;&amp;</operator> <name>TK_LE</name><operator>&lt;</operator><name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GE</name><operator>==</operator><name>TK_EQ</name><operator>+</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>op</name><operator>==</operator><name>TK_IN</name> <operator>||</operator> <operator>(</operator><name>op</name><operator>&gt;=</operator><name>TK_EQ</name> <operator>&amp;&amp;</operator> <name>op</name><operator>&lt;=</operator><name>TK_GE</name><operator>)</operator> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_ISNULL</name> <operator>||</operator> <name>op</name><operator>==</operator><name>TK_IS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Commute a comparison operator.  Expressions of the form "X op Y"
** are converted into "Y op X".
*/</comment>
<function><type><specifier>static</specifier> <name>u16</name></type> <name>exprCommute</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_VECTOR</name>
   <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_VECTOR</name>
   <operator>||</operator> <call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call> <operator>!=</operator>
      <call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>flags</name></name> <operator>^=</operator> <name>EP_Commuted</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>Expr</name><operator>*</operator></expr></argument>,<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>,<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>&gt;=</operator><name>TK_GT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LT</name><operator>==</operator><name>TK_GT</name><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GE</name><operator>==</operator><name>TK_LE</name><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GT</name><operator>&gt;</operator><name>TK_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GT</name><operator>&lt;</operator><name>TK_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>&gt;=</operator><name>TK_GT</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>&lt;=</operator><name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>-</operator><name>TK_GT</name><operator>)</operator><operator>^</operator><literal type="number">2</literal><operator>)</operator><operator>+</operator><name>TK_GT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Translate from TK_xx operator to WO_xx bitmask.
*/</comment>
<function><type><specifier>static</specifier> <name>u16</name></type> <name>operatorMask</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>c</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>allowedOp</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_IN</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name>WO_IN</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>TK_ISNULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name>WO_ISNULL</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>TK_IS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name>WO_IS</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>WO_EQ</name><operator>&lt;&lt;</operator><operator>(</operator><name>op</name><operator>-</operator><name>TK_EQ</name><operator>)</operator><operator>)</operator> <operator>&lt;</operator> <literal type="number">0x7fff</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>WO_EQ</name><operator>&lt;&lt;</operator><operator>(</operator><name>op</name><operator>-</operator><name>TK_EQ</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>!=</operator><name>TK_ISNULL</name> <operator>||</operator> <name>c</name><operator>==</operator><name>WO_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>!=</operator><name>TK_IN</name> <operator>||</operator> <name>c</name><operator>==</operator><name>WO_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>!=</operator><name>TK_EQ</name> <operator>||</operator> <name>c</name><operator>==</operator><name>WO_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>!=</operator><name>TK_LT</name> <operator>||</operator> <name>c</name><operator>==</operator><name>WO_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>!=</operator><name>TK_LE</name> <operator>||</operator> <name>c</name><operator>==</operator><name>WO_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>!=</operator><name>TK_GT</name> <operator>||</operator> <name>c</name><operator>==</operator><name>WO_GT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>!=</operator><name>TK_GE</name> <operator>||</operator> <name>c</name><operator>==</operator><name>WO_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>!=</operator><name>TK_IS</name> <operator>||</operator> <name>c</name><operator>==</operator><name>WO_IS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LIKE_OPTIMIZATION</name></cpp:ifndef>
<comment type="block">/*
** Check to see if the given expression is a LIKE or GLOB operator that
** can be optimized using inequality constraints.  Return TRUE if it is
** so and false if not.
**
** In order for the operator to be optimizible, the RHS must be a string
** literal that does not begin with a wildcard.  The LHS must be a column
** that may only be NULL, a string, or a BLOB, never a number. (This means
** that virtual tables cannot participate in the LIKE optimization.)  The
** collating sequence for the column on the LHS must be appropriate for
** the operator.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isLikeOrGlob</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,    <comment type="block">/* Parsing and code generating context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,      <comment type="block">/* Test this expression */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPrefix</name></decl></parameter>,  <comment type="block">/* Pointer to TK_STRING expression with pattern prefix */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pisComplete</name></decl></parameter>, <comment type="block">/* True if the only wildcard is % in the last character */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnoCase</name></decl></parameter>      <comment type="block">/* True if uppercase is equivalent to lowercase */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* String on RHS of LIKE operator */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>      <comment type="block">/* Right and left size of LIKE operator */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>           <comment type="block">/* List of operands to the LIKE operator */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>c</name></decl>;</decl_stmt>                      <comment type="block">/* One character in z[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>                   <comment type="block">/* Number of non-wildcard prefix characters */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>wc</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>                  <comment type="block">/* Wildcard characters */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                    <comment type="block">/* Opcode of pRight */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                    <comment type="block">/* Result code to return */</comment>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3IsLikeFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pnoCase</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>wc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EBCDIC</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pnoCase</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>pRight</name> <operator>=</operator> <call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_VARIABLE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_EnableQPSG</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pReprepare</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pReprepare</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pRight</name><operator>-&gt;</operator><name>iColumn</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>sqlite3VdbeGetBoundValue</name><argument_list>(<argument><expr><name>pReprepare</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>SQLITE_AFF_BLOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pVal</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetVarmask</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_VARIABLE</name> <operator>||</operator> <name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_REGISTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>op</name><operator>==</operator><name>TK_STRING</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pRight</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block>{<block_content>

    <comment type="block">/* Count the number of prefix characters prior to the first wildcard */</comment>
    <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><name><name>z</name><index>[<expr><name>cnt</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><name><name>wc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><name><name>wc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><name><name>wc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name><name>wc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>cnt</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* The optimization is possible only if (1) the pattern does not begin
    ** with a wildcard and if (2) the non-wildcard prefix does not end with
    ** an (illegal 0xff) character, or (3) the pattern does not consist of
    ** a single escape character. The second condition is necessary so
    ** that we can increment the prefix key to find an upper bound for the
    ** range search. The third is because the caller assumes that the pattern
    ** consists of at least one character after all escapes have been
    ** removed.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">255</literal><operator>!=</operator><operator>(</operator><name>u8</name><operator>)</operator><name><name>z</name><index>[<expr><name>cnt</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>cnt</name><operator>&gt;</operator><literal type="number">1</literal> <operator>||</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><name><name>wc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pPrefix</name></decl>;</decl_stmt>

      <comment type="block">/* A "complete" match if the pattern ends with "*" or "%" */</comment>
      <expr_stmt><expr><operator>*</operator><name>pisComplete</name> <operator>=</operator> <name>c</name><operator>==</operator><name><name>wc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>cnt</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>

      <comment type="block">/* Get the pattern prefix.  Remove all escapes from the prefix. */</comment>
      <expr_stmt><expr><name>pPrefix</name> <operator>=</operator> <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_STRING</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pPrefix</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iFrom</name></decl>, <decl><type ref="prev"/><name>iTo</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pPrefix</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zNew</name> <operator>=</operator> <name><name>pPrefix</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zNew</name><index>[<expr><name>cnt</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>iFrom</name><operator>=</operator><name>iTo</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iFrom</name><operator>&lt;</operator><name>cnt</name></expr>;</condition> <incr><expr><name>iFrom</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>zNew</name><index>[<expr><name>iFrom</name></expr>]</index></name><operator>==</operator><name><name>wc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iFrom</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name><name>zNew</name><index>[<expr><name>iTo</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>zNew</name><index>[<expr><name>iFrom</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>zNew</name><index>[<expr><name>iTo</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTo</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If the LHS is not an ordinary column with TEXT affinity, then the
        ** pattern prefix boundaries (both the start and end boundaries) must
        ** not look like a number.  Otherwise the pattern might be treated as
        ** a number, which will invalidate the LIKE optimization.
        **
        ** Getting this right has been a persistent source of bugs in the
        ** LIKE optimization.  See, for example:
        **    2018-09-10 https://sqlite.org/src/info/c94369cae9b561b1
        **    2019-05-02 https://sqlite.org/src/info/b043a54c3de54b28
        **    2019-06-10 https://sqlite.org/src/info/fd76310a5e843e07
        **    2019-06-14 https://sqlite.org/src/info/ce8717f0885af975
        **    2019-09-03 https://sqlite.org/src/info/0f0428096f17252a
        */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name> 
         <operator>||</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_AFF_TEXT</name> 
         <operator>||</operator> <operator>(</operator><call><name>ALWAYS</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call>
             <operator>&amp;&amp;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name>
             <operator>&amp;&amp;</operator> <call><name>IsVirtual</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>  <comment type="block">/* Might be numeric */</comment>
        )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>isNum</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>double</name></type> <name>rDummy</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>isNum</name> <operator>=</operator> <call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rDummy</name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>isNum</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>iTo</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>zNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>isNum</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name><name>zNew</name><index>[<expr><name>iTo</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
              <expr_stmt><expr><name>isNum</name> <operator>=</operator> <call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rDummy</name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>zNew</name><index>[<expr><name>iTo</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>isNum</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>ppPrefix</name> <operator>=</operator> <name>pPrefix</name></expr>;</expr_stmt>

      <comment type="block">/* If the RHS pattern is a bound parameter, make arrangements to
      ** reprepare the statement when that parameter is rebound */</comment>
      <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_VARIABLE</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeSetVarmask</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pisComplete</name> <operator>&amp;&amp;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
          <comment type="block">/* If the rhs of the LIKE expression is a variable, and the current
          ** value of the variable means there is no need to invoke the LIKE
          ** function, then no OP_Variable will be added to the program.
          ** This causes problems for the sqlite3_bind_parameter_name()
          ** API. To work around them, add a dummy OP_Variable here.
          */</comment> 
          <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeChangeP3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>z</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_LIKE_OPTIMIZATION */</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** Check to see if the pExpr expression is a form that needs to be passed
** to the xBestIndex method of virtual tables.  Forms of interest include:
**
**          Expression                   Virtual Table Operator
**          -----------------------      ---------------------------------
**      1.  column MATCH expr            SQLITE_INDEX_CONSTRAINT_MATCH
**      2.  column GLOB expr             SQLITE_INDEX_CONSTRAINT_GLOB
**      3.  column LIKE expr             SQLITE_INDEX_CONSTRAINT_LIKE
**      4.  column REGEXP expr           SQLITE_INDEX_CONSTRAINT_REGEXP
**      5.  column != expr               SQLITE_INDEX_CONSTRAINT_NE
**      6.  expr != column               SQLITE_INDEX_CONSTRAINT_NE
**      7.  column IS NOT expr           SQLITE_INDEX_CONSTRAINT_ISNOT
**      8.  expr IS NOT column           SQLITE_INDEX_CONSTRAINT_ISNOT
**      9.  column IS NOT NULL           SQLITE_INDEX_CONSTRAINT_ISNOTNULL
**
** In every case, "column" must be a column of a virtual table.  If there
** is a match, set *ppLeft to the "column" expression, set *ppRight to the 
** "expr" expression (even though in forms (6) and (8) the column is on the
** right and the expression is on the left).  Also set *peOp2 to the
** appropriate virtual table operator.  The return value is 1 or 2 if there
** is a match.  The usual return is 1, but if the RHS is also a column
** of virtual table in forms (5) or (7) then return 2.
**
** If the expression matches none of the patterns above, return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isAuxiliaryVtabOperator</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                    <comment type="block">/* Test this expression */</comment>
  <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>peOp2</name></decl></parameter>,           <comment type="block">/* OUT: 0 for MATCH, or else an op2 value */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppLeft</name></decl></parameter>,                  <comment type="block">/* Column expression to left of MATCH/op2 */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRight</name></decl></parameter>                  <comment type="block">/* Expression to left of MATCH/op2 */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name></expr> )</condition><block>{<block_content>
    <struct><specifier>static</specifier> <specifier>const</specifier> struct <name>Op2</name> <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOp</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>eOp2</name></decl>;</decl_stmt>
    }</block> <decl><name><name>aOp</name><index>[]</index></name> <init>= <expr><block>{
      <expr><block>{ <expr><literal type="string">"match"</literal></expr>,  <expr><name>SQLITE_INDEX_CONSTRAINT_MATCH</name></expr> }</block></expr>,
      <expr><block>{ <expr><literal type="string">"glob"</literal></expr>,   <expr><name>SQLITE_INDEX_CONSTRAINT_GLOB</name></expr> }</block></expr>,
      <expr><block>{ <expr><literal type="string">"like"</literal></expr>,   <expr><name>SQLITE_INDEX_CONSTRAINT_LIKE</name></expr> }</block></expr>,
      <expr><block>{ <expr><literal type="string">"regexp"</literal></expr>, <expr><name>SQLITE_INDEX_CONSTRAINT_REGEXP</name></expr> }</block></expr>
    }</block></expr></init></decl>;</struct>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pCol</name></decl>;</decl_stmt>                     <comment type="block">/* Column reference */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Built-in operators MATCH, GLOB, LIKE, and REGEXP attach to a
    ** virtual table on their second argument, which is the same as
    ** the left-hand side operand in their in-fix form.
    **
    **       vtab_column MATCH expression
    **       MATCH(expression,vtab_column)
    */</comment>
    <expr_stmt><expr><name>pCol</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name> <operator>||</operator> <call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pCol</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprIsVtab</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aOp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zOp</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>peOp2</name> <operator>=</operator> <name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eOp2</name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>ppRight</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>ppLeft</name> <operator>=</operator> <name>pCol</name></expr>;</expr_stmt>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We can also match against the first column of overloaded
    ** functions where xFindFunction returns a value of at least
    ** SQLITE_INDEX_CONSTRAINT_FUNCTION.
    **
    **      OVERLOADED(vtab_column,expression)
    **
    ** Historically, xFindFunction expected to see lower-case function
    ** names.  But for this use case, xFindFunction is expected to deal
    ** with function names in an arbitrary case.
    */</comment>
    <expr_stmt><expr><name>pCol</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name> <operator>||</operator> <call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pCol</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprIsVtab</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_module</name> <modifier>*</modifier></type><name>pMod</name></decl>;</decl_stmt>
      <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xNotUsed</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pNotUsed</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pVtab</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVtab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMod</name> <operator>=</operator> <operator>(</operator><name>sqlite3_module</name> <operator>*</operator><operator>)</operator><name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pMod</name><operator>-&gt;</operator><name>xFindFunction</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name><name>pMod</name><operator>-&gt;</operator><name>xFindFunction</name></name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xNotUsed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>SQLITE_INDEX_CONSTRAINT_FUNCTION</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>peOp2</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>ppRight</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>ppLeft</name> <operator>=</operator> <name>pCol</name></expr>;</expr_stmt>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NE</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNOT</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NOTNULL</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name> <operator>||</operator> <call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprIsVtab</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRight</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name> <operator>||</operator> <call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pRight</name> <operator>&amp;&amp;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRight</name> <operator>&amp;&amp;</operator> <call><name>ExprIsVtab</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppLeft</name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppRight</name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>peOp2</name> <operator>=</operator> <name>SQLITE_INDEX_CONSTRAINT_NE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_ISNOT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>peOp2</name> <operator>=</operator> <name>SQLITE_INDEX_CONSTRAINT_ISNOT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NOTNULL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>peOp2</name> <operator>=</operator> <name>SQLITE_INDEX_CONSTRAINT_ISNOTNULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>res</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block">/*
** If the pBase expression originated in the ON or USING clause of
** a join, then transfer the appropriate markings over to derived.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>transferJoinMarkings</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pDerived</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pBase</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pDerived</name> <operator>&amp;&amp;</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pBase</name></expr></argument>, <argument><expr><name>EP_OuterON</name><operator>|</operator><name>EP_InnerON</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pDerived</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name><name>pBase</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>EP_OuterON</name><operator>|</operator><name>EP_InnerON</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDerived</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name> <operator>=</operator> <name><name>pBase</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Mark term iChild as being a child of term iParent
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>markTermAsChild</name><parameter_list>(<parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iChild</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iParent</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iChild</name></expr>]</index></name><operator>.</operator><name>iParent</name> <operator>=</operator> <name>iParent</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iChild</name></expr>]</index></name><operator>.</operator><name>truthProb</name> <operator>=</operator> <name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iParent</name></expr>]</index></name><operator>.</operator><name>truthProb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iParent</name></expr>]</index></name><operator>.</operator><name>nChild</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the N-th AND-connected subterm of pTerm.  Or if pTerm is not
** a conjunction, then return just pTerm when N==0.  If N is exceeds
** the number of available subterms, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>WhereTerm</name> <modifier>*</modifier></type><name>whereNthSubterm</name><parameter_list>(<parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name><operator>!=</operator><name>WO_AND</name></expr> )</condition><block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>N</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>pTerm</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>N</name><operator>&lt;</operator><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pAndInfo</name><operator>-&gt;</operator><name>wc</name><operator>.</operator><name>nTerm</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>&amp;</operator><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pAndInfo</name><operator>-&gt;</operator><name>wc</name><operator>.</operator><name>a</name><index>[<expr><name>N</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Subterms pOne and pTwo are contained within WHERE clause pWC.  The
** two subterms are in disjunction - they are OR-ed together.
**
** If these two terms are both of the form:  "A op B" with the same
** A and B values but different operators and if the operators are
** compatible (if one is = and the other is &lt;, for example) then
** add a new virtual AND term to pWC that is the combination of the
** two.
**
** Some examples:
**
**    x&lt;y OR x=y    --&gt;     x&lt;=y
**    x=y OR x=y    --&gt;     x=y
**    x&lt;=y OR x&lt;y   --&gt;     x&lt;=y
**
** The following is NOT generated:
**
**    x&lt;y OR x&gt;y    --&gt;     x!=y     
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereCombineDisjuncts</name><parameter_list>(
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,         <comment type="block">/* the FROM clause */</comment>
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,      <comment type="block">/* The complete WHERE clause */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pOne</name></decl></parameter>,       <comment type="block">/* First disjunct */</comment>
  <parameter><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTwo</name></decl></parameter>        <comment type="block">/* Second disjunct */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>eOp</name> <init>= <expr><name><name>pOne</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>|</operator> <name><name>pTwo</name><operator>-&gt;</operator><name>eOperator</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>           <comment type="block">/* Database connection (for malloc) */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>            <comment type="block">/* New virtual expression */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                <comment type="block">/* Operator for the combined expression */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idxNew</name></decl>;</decl_stmt>            <comment type="block">/* Index in pWC of the next virtual term */</comment>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOne</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|</operator> <name><name>pTwo</name><operator>-&gt;</operator><name>wtFlags</name></name><operator>)</operator> <operator>&amp;</operator> <name>TERM_VNULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOne</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>|</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTwo</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>|</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>)</operator><operator>)</operator><operator>!=</operator><name>eOp</name>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_EQ</name><operator>|</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>)</operator><operator>)</operator><operator>!=</operator><name>eOp</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOne</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOne</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTwo</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pTwo</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>pOne</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pTwo</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>pOne</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name><name>pTwo</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content><return>return;</return></block_content></block></if></if_stmt>
  <comment type="block">/* If we reach this point, it means the two subterms can be combined */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>eOp</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_LT</name><operator>|</operator><name>WO_LE</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>eOp</name> <operator>=</operator> <name>WO_LE</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOp</name> <operator>&amp;</operator> <operator>(</operator><name>WO_GT</name><operator>|</operator><name>WO_GE</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>eOp</name> <operator>=</operator> <name>WO_GE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOne</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>op</name><operator>=</operator><name>TK_EQ</name></expr>;</init> <condition><expr><name>eOp</name><operator>!=</operator><operator>(</operator><name>WO_EQ</name><operator>&lt;&lt;</operator><operator>(</operator><name>op</name><operator>-</operator><name>TK_EQ</name><operator>)</operator><operator>)</operator></expr>;</condition> <incr><expr><name>op</name><operator>++</operator></expr></incr>)</control><block>{<block_content> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>&lt;</operator><name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> </block_content>}</block></for>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>idxNew</name> <operator>=</operator> <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exprAnalyze</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_OR_OPTIMIZATION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Analyze a term that consists of two or more OR-connected
** subterms.  So in:
**
**     ... WHERE  (a=5) AND (b=7 OR c=9 OR d=13) AND (d=13)
**                          ^^^^^^^^^^^^^^^^^^^^
**
** This routine analyzes terms such as the middle term in the above example.
** A WhereOrTerm object is computed and attached to the term under
** analysis, regardless of the outcome of the analysis.  Hence:
**
**     WhereTerm.wtFlags   |=  TERM_ORINFO
**     WhereTerm.u.pOrInfo  =  a dynamically allocated WhereOrTerm object
**
** The term being analyzed must have two or more of OR-connected subterms.
** A single subterm might be a set of AND-connected sub-subterms.
** Examples of terms under analysis:
**
**     (A)     t1.x=t2.y OR t1.x=t2.z OR t1.y=15 OR t1.z=t3.a+5
**     (B)     x=expr1 OR expr2=x OR x=expr3
**     (C)     t1.x=t2.y OR (t1.x=t2.z AND t1.y=15)
**     (D)     x=expr1 OR (y&gt;11 AND y&lt;22 AND z LIKE '*hello*')
**     (E)     (p.a=1 AND q.b=2 AND r.c=3) OR (p.x=4 AND q.y=5 AND r.z=6)
**     (F)     x&gt;A OR (x=A AND y&gt;=B)
**
** CASE 1:
**
** If all subterms are of the form T.C=expr for some single column of C and
** a single table T (as shown in example B above) then create a new virtual
** term that is an equivalent IN expression.  In other words, if the term
** being analyzed is:
**
**      x = expr1  OR  expr2 = x  OR  x = expr3
**
** then create a new virtual term like this:
**
**      x IN (expr1,expr2,expr3)
**
** CASE 2:
**
** If there are exactly two disjuncts and one side has x&gt;A and the other side
** has x=A (for the same x and A) then add a new virtual conjunct term to the
** WHERE clause of the form "x&gt;=A".  Example:
**
**      x&gt;A OR (x=A AND y&gt;B)    adds:    x&gt;=A
**
** The added conjunct can sometimes be helpful in query planning.
**
** CASE 3:
**
** If all subterms are indexable by a single table T, then set
**
**     WhereTerm.eOperator              =  WO_OR
**     WhereTerm.u.pOrInfo-&gt;indexable  |=  the cursor number for table T
**
** A subterm is "indexable" if it is of the form
** "T.C &lt;op&gt; &lt;expr&gt;" where C is any column of table T and 
** &lt;op&gt; is one of "=", "&lt;", "&lt;=", "&gt;", "&gt;=", "IS NULL", or "IN".
** A subterm is also indexable if it is an AND of two or more
** subsubterms at least one of which is indexable.  Indexable AND 
** subterms have their eOperator set to WO_AND and they have
** u.pAndInfo set to a dynamically allocated WhereAndTerm object.
**
** From another point of view, "indexable" means that the subterm could
** potentially be used with an index if an appropriate index exists.
** This analysis does not consider whether or not the index exists; that
** is decided elsewhere.  This analysis only looks at whether subterms
** appropriate for indexing exist.
**
** All examples A through E above satisfy case 3.  But if a term
** also satisfies case 1 (such as B) we know that the optimizer will
** always prefer case 1, so in that case we pretend that case 3 is not
** satisfied.
**
** It might be the case that multiple tables are indexable.  For example,
** (E) above is indexable on tables P, Q, and R.
**
** Terms that satisfy case 3 are candidates for lookup by using
** separate indices to find rowids for each subterm and composing
** the union of all rowids using a RowSet object.  This is similar
** to "bitmap indices" in other database engines.
**
** OTHERWISE:
**
** If none of cases 1, 2, or 3 apply, then leave the eOperator set to
** zero.  This term is not useful for search.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exprAnalyzeOrTerm</name><parameter_list>(
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,            <comment type="block">/* the FROM clause */</comment>
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,         <comment type="block">/* the complete WHERE clause */</comment>
  <parameter><decl><type><name>int</name></type> <name>idxTerm</name></decl></parameter>               <comment type="block">/* Index of the OR-term to be analyzed */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></init></decl>;</decl_stmt>        <comment type="block">/* WHERE clause processing context */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Parser context */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>               <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name> <init>= <expr><operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* The term to be analyzed */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>             <comment type="block">/* The expression of the term */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                                  <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pOrWc</name></decl>;</decl_stmt>       <comment type="block">/* Breakup of pTerm into subterms */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pOrTerm</name></decl>;</decl_stmt>       <comment type="block">/* A Sub-term within the pOrWc */</comment>
  <decl_stmt><decl><type><name>WhereOrInfo</name> <modifier>*</modifier></type><name>pOrInfo</name></decl>;</decl_stmt>     <comment type="block">/* Additional information associated with pTerm */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>chngToIN</name></decl>;</decl_stmt>         <comment type="block">/* Tables that might satisfy case 1 */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>indexable</name></decl>;</decl_stmt>        <comment type="block">/* Tables that are indexable, satisfying case 2 */</comment>

  <comment type="block">/*
  ** Break the OR clause into its separate subterms.  The subterms are
  ** stored in a WhereClause structure containing within the WhereOrInfo
  ** object that is attached to the original OR clause term.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_DYNAMIC</name><operator>|</operator><name>TERM_ORINFO</name><operator>|</operator><name>TERM_ANDINFO</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_OR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pOrInfo</name></name> <operator>=</operator> <name>pOrInfo</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pOrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_ORINFO</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOrWc</name> <operator>=</operator> <operator>&amp;</operator><name><name>pOrInfo</name><operator>-&gt;</operator><name>wc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pOrWc</name><operator>-&gt;</operator><name>aStatic</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pOrWc</name><operator>-&gt;</operator><name>aStatic</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WhereClauseInit</name><argument_list>(<argument><expr><name>pOrWc</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WhereSplit</name><argument_list>(<argument><expr><name>pOrWc</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>TK_OR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WhereExprAnalyze</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pOrWc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOrWc</name><operator>-&gt;</operator><name>nTerm</name></name><operator>&gt;=</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
  ** Compute the set of tables that might satisfy cases 1 or 3.
  */</comment>
  <expr_stmt><expr><name>indexable</name> <operator>=</operator> <operator>~</operator><operator>(</operator><name>Bitmask</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>chngToIN</name> <operator>=</operator> <operator>~</operator><operator>(</operator><name>Bitmask</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pOrWc</name><operator>-&gt;</operator><name>nTerm</name></name><operator>-</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>pOrTerm</name><operator>=</operator><name><name>pOrWc</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>indexable</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>pOrTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOrTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_SINGLE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>WhereAndInfo</name> <modifier>*</modifier></type><name>pAndInfo</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pOrTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_ANDINFO</name><operator>|</operator><name>TERM_ORINFO</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>chngToIN</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>pAndInfo</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pAndInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pAndInfo</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pAndWC</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pAndTerm</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmask</name></type> <name>b</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pAndInfo</name></name> <operator>=</operator> <name>pAndInfo</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_ANDINFO</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>=</operator> <name>WO_AND</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>leftCursor</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pAndWC</name> <operator>=</operator> <operator>&amp;</operator><name><name>pAndInfo</name><operator>-&gt;</operator><name>wc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pAndWC</name><operator>-&gt;</operator><name>aStatic</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pAndWC</name><operator>-&gt;</operator><name>aStatic</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WhereClauseInit</name><argument_list>(<argument><expr><name>pAndWC</name></expr></argument>, <argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WhereSplit</name><argument_list>(<argument><expr><name>pAndWC</name></expr></argument>, <argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>TK_AND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WhereExprAnalyze</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pAndWC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pAndWC</name><operator>-&gt;</operator><name>pOuter</name></name> <operator>=</operator> <name>pWC</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
          <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pAndTerm</name><operator>=</operator><name><name>pAndWC</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pAndWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>pAndTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pAndTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>allowedOp</name><argument_list>(<argument><expr><name><name>pAndTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call> 
             <operator>||</operator> <name><name>pAndTerm</name><operator>-&gt;</operator><name>eOperator</name></name><operator>==</operator><name>WO_AUX</name></expr>
            )</condition><block>{<block_content>
              <expr_stmt><expr><name>b</name> <operator>|=</operator> <call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>, <argument><expr><name><name>pAndTerm</name><operator>-&gt;</operator><name>leftCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>indexable</name> <operator>&amp;=</operator> <name>b</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_COPIED</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Skip this term for now.  We revisit it when we process the
      ** corresponding TERM_VIRTUAL term */</comment>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>b</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>, <argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>leftCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pOther</name> <init>= <expr><operator>&amp;</operator><name><name>pOrWc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>iParent</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>b</name> <operator>|=</operator> <call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>, <argument><expr><name><name>pOther</name><operator>-&gt;</operator><name>leftCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>indexable</name> <operator>&amp;=</operator> <name>b</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOrTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_EQ</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>chngToIN</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>chngToIN</name> <operator>&amp;=</operator> <name>b</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/*
  ** Record the set of tables that satisfy case 3.  The set might be
  ** empty.
  */</comment>
  <expr_stmt><expr><name><name>pOrInfo</name><operator>-&gt;</operator><name>indexable</name></name> <operator>=</operator> <name>indexable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>=</operator> <name>WO_OR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>indexable</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>hasOr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* For a two-way OR, attempt to implementation case 2.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>indexable</name> <operator>&amp;&amp;</operator> <name><name>pOrWc</name><operator>-&gt;</operator><name>nTerm</name></name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iOne</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pOne</name></decl>;</decl_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>pOne</name> <operator>=</operator> <call><name>whereNthSubterm</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOrWc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name>iOne</name><operator>++</operator></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iTwo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTwo</name></decl>;</decl_stmt>
      <while>while<condition>( <expr><operator>(</operator><name>pTwo</name> <operator>=</operator> <call><name>whereNthSubterm</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOrWc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>iTwo</name><operator>++</operator></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>whereCombineDisjuncts</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pOne</name></expr></argument>, <argument><expr><name>pTwo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
  ** chngToIN holds a set of tables that *might* satisfy case 1.  But
  ** we have to do some additional checking to see if case 1 really
  ** is satisfied.
  **
  ** chngToIN will hold either 0, 1, or 2 bits.  The 0-bit case means
  ** that there is no possibility of transforming the OR clause into an
  ** IN operator because one or more terms in the OR clause contain
  ** something other than == on a column in the single table.  The 1-bit
  ** case means that every term of the OR clause is of the form
  ** "table.column=expr" for some single table.  The one bit that is set
  ** will correspond to the common table.  We still need to check to make
  ** sure the same column is used on all terms.  The 2-bit case is when
  ** the all terms are of the form "table1.column=table2.column".  It
  ** might be possible to form an IN operator with either table1.column
  ** or table2.column as the LHS if either is common to every term of
  ** the OR clause.
  **
  ** Note that terms of the form "table.column1=table.column2" (the
  ** same table on both sizes of the ==) cannot be optimized.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>chngToIN</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>okToChngToIN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* True if the conversion to IN is valid */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iColumn</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Column index on lhs of IN operator */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iCursor</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Table cursor common to all terms */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Loop counter */</comment>

    <comment type="block">/* Search for a table and column that appears on one side or the
    ** other of the == operator in every subterm.  That table and column
    ** will be recorded in iCursor and iColumn.  There might not be any
    ** such table and column.  Set okToChngToIN if an appropriate table
    ** and column is found but leave okToChngToIN false if not found.
    */</comment>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>okToChngToIN</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pOrTerm</name> <operator>=</operator> <name><name>pOrWc</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pOrWc</name><operator>-&gt;</operator><name>nTerm</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>pOrTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TERM_OK</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>==</operator><name>iCursor</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* This is the 2-bit case and we are on the second iteration and
          ** current term is from the first iteration.  So skip this term. */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>chngToIN</name> <operator>&amp;</operator> <call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>,
                                            <argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>leftCursor</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* This term must be of the form t1.a==t2.b where t2 is in the
          ** chngToIN set but t1 is not.  This term will be either preceded
          ** or follwed by an inverted copy (t2.b==t1.a).  Skip this term 
          ** and use its inversion. */</comment>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_COPIED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_COPIED</name><operator>|</operator><name>TERM_VIRTUAL</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pOrTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_OR</name><operator>|</operator><name>WO_AND</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <name><name>pOrTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iCursor</name> <operator>=</operator> <name><name>pOrTerm</name><operator>-&gt;</operator><name>leftCursor</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name><name>pOrTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* No candidate table+column was found.  This can only occur
        ** on the second iteration */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsPowerOfTwo</name><argument_list>(<argument><expr><name>chngToIN</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>chngToIN</name><operator>==</operator><call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr></argument>, <argument><expr><name>iCursor</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>j</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* We have found a candidate table and column.  Check to see if that
      ** table and column is common to every term in the OR clause */</comment>
      <expr_stmt><expr><name>okToChngToIN</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <for>for<control>(<init>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>okToChngToIN</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>pOrTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pOrTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_OR</name><operator>|</operator><name>WO_AND</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>!=</operator><name>iCursor</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TERM_OK</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name><operator>!=</operator><name>iColumn</name> <operator>||</operator> <operator>(</operator><name>iColumn</name><operator>==</operator><name>XN_EXPR</name> 
               <operator>&amp;&amp;</operator> <call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call>
        <operator>)</operator></expr>)</condition><block>{<block_content>
          <expr_stmt><expr><name>okToChngToIN</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>affLeft</name></decl>, <decl><type ref="prev"/><name>affRight</name></decl>;</decl_stmt>
          <comment type="block">/* If the right-hand side is also a column, then the affinities
          ** of both right and left sides must be such that no type
          ** conversions are required on the right.  (Ticket #2249)
          */</comment>
          <expr_stmt><expr><name>affRight</name> <operator>=</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>affLeft</name> <operator>=</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>affRight</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>affRight</name><operator>!=</operator><name>affLeft</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>okToChngToIN</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_OK</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/* At this point, okToChngToIN is true if original pTerm satisfies
    ** case 1.  In that case, construct a new virtual term that is 
    ** pTerm converted into an IN operator.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>okToChngToIN</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pDup</name></decl>;</decl_stmt>            <comment type="block">/* A transient duplicate expression */</comment>
      <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* The RHS of the IN operator */</comment>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* The LHS of the IN operator */</comment>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>            <comment type="block">/* The complete IN operator */</comment>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pOrWc</name><operator>-&gt;</operator><name>nTerm</name></name><operator>-</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>pOrTerm</name><operator>=</operator><name><name>pOrWc</name><operator>-&gt;</operator><name>a</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>pOrTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pOrTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_OK</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <name>WO_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pOrTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_OR</name><operator>|</operator><name>WO_AND</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>==</operator><name>iCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name><operator>==</operator><name>iColumn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pDup</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOrTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name><name>pOrTerm</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeft</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDup</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_IN</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>idxNew</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>transferJoinMarkings</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>idxNew</name> <operator>=</operator> <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>idxNew</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exprAnalyze</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* pTerm = &amp;pWC-&gt;a[idxTerm]; // would be needed if pTerm where reused */</comment>
        <expr_stmt><expr><call><name>markTermAsChild</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew</name></expr></argument>, <argument><expr><name>idxTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_OMIT_OR_OPTIMIZATION &amp;&amp; !SQLITE_OMIT_SUBQUERY */</comment>

<comment type="block">/*
** We already know that pExpr is a binary operator where both operands are
** column references.  This routine checks to see if pExpr is an equivalence
** relation:
**   1.  The SQLITE_Transitive optimization must be enabled
**   2.  Must be either an == or an IS operator
**   3.  Not originating in the ON clause of an OUTER JOIN
**   4.  The affinities of A and B must be compatible
**   5a. Both operands use the same collating sequence OR
**   5b. The overall collating sequence is BINARY
** If this routine returns TRUE, that means that the RHS can be substituted
** for the LHS anyplace else in the WHERE clause where the LHS column occurs.
** This is an optimization.  No harm comes from returning 0.  But if 1 is
** returned when it should not be, then incorrect answers might result.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>termIsEquivalence</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>aff1</name></decl>, <decl><type ref="prev"/><name>aff2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>OptimizationEnabled</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_Transitive</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_EQ</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_IS</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>aff1</name> <operator>=</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aff2</name> <operator>=</operator> <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aff1</name><operator>!=</operator><name>aff2</name>
   <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>sqlite3IsNumericAffinity</name><argument_list>(<argument><expr><name>aff1</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>sqlite3IsNumericAffinity</name><argument_list>(<argument><expr><name>aff2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3ExprCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3IsBinary</name><argument_list>(<argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sqlite3ExprCollSeqMatch</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Recursively walk the expressions of a SELECT statement and generate
** a bitmask indicating which tables are used in that expression
** tree.
*/</comment>
<function><type><specifier>static</specifier> <name>Bitmask</name></type> <name>exprSelectUsage</name><parameter_list>(<parameter><decl><type><name>WhereMaskSet</name> <modifier>*</modifier></type><name>pMaskSet</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>pS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>pS</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name> <init>= <expr><name><name>pS</name><operator>-&gt;</operator><name>pSrc</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3WhereExprListUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pS</name><operator>-&gt;</operator><name>pEList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3WhereExprListUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pS</name><operator>-&gt;</operator><name>pGroupBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3WhereExprListUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pS</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3WhereExprUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pS</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3WhereExprUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pS</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pSrc</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>exprSelectUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>isUsing</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3WhereExprUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u3</name><operator>.</operator><name>pOn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>isTabFunc</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3WhereExprListUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u1</name><operator>.</operator><name>pFuncArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pS</name> <operator>=</operator> <name><name>pS</name><operator>-&gt;</operator><name>pPrior</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>mask</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Expression pExpr is one operand of a comparison operator that might
** be useful for indexing.  This routine checks to see if pExpr appears
** in any index.  Return TRUE (1) if pExpr is an indexed term and return
** FALSE (0) if not.  If TRUE is returned, also set aiCurCol[0] to the cursor
** number of the table that is indexed and aiCurCol[1] to the column number
** of the column that is indexed, or XN_EXPR (-2) if an expression is being
** indexed.
**
** If pExpr is a TK_COLUMN column reference, then this routine always returns
** true even if that particular column is not indexed, because the column
** might be added to an automatic index later.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>exprMightBeIndexed2</name><parameter_list>(
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>,        <comment type="block">/* The FROM clause */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>mPrereq</name></decl></parameter>,       <comment type="block">/* Bitmask of FROM clause terms referenced by pExpr */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aiCurCol</name></decl></parameter>,         <comment type="block">/* Write the referenced table cursor and column here */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>            <comment type="block">/* An operand of a comparison operator */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>mPrereq</name><operator>&gt;</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>mPrereq</name><operator>&gt;&gt;=</operator><literal type="number">1</literal></expr></incr>)</control><block>{<block_content/>}</block></for>
  <expr_stmt><expr><name>iCur</name> <operator>=</operator> <name><name>pFrom</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCursor</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pFrom</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name>XN_EXPR</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCompareSkip</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>aiCurCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>iCur</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aiCurCol</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>XN_EXPR</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exprMightBeIndexed</name><parameter_list>(
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>,        <comment type="block">/* The FROM clause */</comment>
  <parameter><decl><type><name>Bitmask</name></type> <name>mPrereq</name></decl></parameter>,       <comment type="block">/* Bitmask of FROM clause terms referenced by pExpr */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aiCurCol</name></decl></parameter>,         <comment type="block">/* Write the referenced table cursor &amp; column here */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,           <comment type="block">/* An operand of a comparison operator */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>                 <comment type="block">/* The specific comparison operator */</comment>
)</parameter_list><block>{<block_content>
  <comment type="block">/* If this expression is a vector to the left or right of a 
  ** inequality constraint (&gt;, &lt;, &gt;= or &lt;=), perform the processing 
  ** on the first element of the vector.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GT</name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>TK_LE</name> <operator>&amp;&amp;</operator> <name>TK_GT</name><operator>+</operator><literal type="number">2</literal><operator>==</operator><name>TK_LT</name> <operator>&amp;&amp;</operator> <name>TK_GT</name><operator>+</operator><literal type="number">3</literal><operator>==</operator><name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_IS</name><operator>&lt;</operator><name>TK_GE</name> <operator>&amp;&amp;</operator> <name>TK_ISNULL</name><operator>&lt;</operator><name>TK_GE</name> <operator>&amp;&amp;</operator> <name>TK_IN</name><operator>&lt;</operator><name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>&lt;=</operator><name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_VECTOR</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>op</name><operator>&gt;=</operator><name>TK_GT</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>op</name><operator>&lt;=</operator><name>TK_GE</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>

  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>aiCurCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aiCurCol</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>mPrereq</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>                 <comment type="block">/* No table references */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>mPrereq</name><operator>&amp;</operator><operator>(</operator><name>mPrereq</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* Refs more than one table */</comment>
  <return>return <expr><call><name>exprMightBeIndexed2</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>,<argument><expr><name>mPrereq</name></expr></argument>,<argument><expr><name>aiCurCol</name></expr></argument>,<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** The input to this routine is an WhereTerm structure with only the
** "pExpr" field filled in.  The job of this routine is to analyze the
** subexpression and populate all the other fields of the WhereTerm
** structure.
**
** If the expression is of the form "&lt;expr&gt; &lt;op&gt; X" it gets commuted
** to the standard form of "X &lt;op&gt; &lt;expr&gt;".
**
** If the expression is of the form "X &lt;op&gt; Y" where both X and Y are
** columns, then the original expression is unchanged and a new virtual
** term of the form "Y &lt;op&gt; X" is added to the WHERE clause and
** analyzed separately.  The original term is marked with TERM_COPIED
** and the new term is marked with TERM_DYNAMIC (because it's pExpr
** needs to be freed with the WhereClause) and TERM_VIRTUAL (because it
** is a commuted copy of a prior term.)  The original term has nChild=1
** and the copy has idxParent set to the index of the original term.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exprAnalyze</name><parameter_list>(
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,            <comment type="block">/* the FROM clause */</comment>
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,         <comment type="block">/* the WHERE clause */</comment>
  <parameter><decl><type><name>int</name></type> <name>idxTerm</name></decl></parameter>               <comment type="block">/* Index of the term to be analyzed */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* WHERE clause processing context */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>                <comment type="block">/* The term to be analyzed */</comment>
  <decl_stmt><decl><type><name>WhereMaskSet</name> <modifier>*</modifier></type><name>pMaskSet</name></decl>;</decl_stmt>          <comment type="block">/* Set of table index masks */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl>;</decl_stmt>                     <comment type="block">/* The expression to be analyzed */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>prereqLeft</name></decl>;</decl_stmt>              <comment type="block">/* Prerequesites of the pExpr-&gt;pLeft */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>prereqAll</name></decl>;</decl_stmt>               <comment type="block">/* Prerequesites of pExpr */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>extraRight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Extra dependencies on LEFT JOIN */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pStr1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* RHS of LIKE/GLOB operator */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isComplete</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* RHS of LIKE/GLOB ends with wildcard */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>noCase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* uppercase equivalent to lowercase */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                          <comment type="block">/* Top-level operator.  pExpr-&gt;op */</comment>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Parsing context */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>eOp2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* op2 value for LIKE/REGEXP/GLOB */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLeft</name></decl>;</decl_stmt>                       <comment type="block">/* Number of elements on left side vector */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name> <operator>&gt;</operator> <name>idxTerm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMaskSet</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWInfo</name><operator>-&gt;</operator><name>sMaskSet</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Because malloc() has not failed */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_AS</name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLLATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>bVarSelect</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>prereqLeft</name> <operator>=</operator> <call><name>sqlite3WhereExprUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_IN</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprCheckIN</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>=</operator> <call><name>exprSelectUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>=</operator> <call><name>sqlite3WhereExprListUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>prereqAll</name> <operator>=</operator> <name>prereqLeft</name> <operator>|</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>=</operator> <call><name>sqlite3WhereExprUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name><operator>==</operator><literal type="number">0</literal>
     <operator>||</operator> <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name><operator>|</operator><name>EP_IfNullRow</name></expr></argument>)</argument_list></call>
     <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>!=</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>prereqAll</name> <operator>=</operator> <call><name>sqlite3WhereExprUsageNN</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>prereqAll</name> <operator>=</operator> <name>prereqLeft</name> <operator>|</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>bVarSelect</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_VARSELECT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>prereqAll</name><operator>!=</operator><call><name>sqlite3WhereExprUsageNN</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n*** Incorrect prereqAll computed for:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewExpr</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name><operator>|</operator><name>EP_InnerON</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Bitmask</name></type> <name>x</name> <init>= <expr><call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>prereqAll</name> <operator>|=</operator> <name>x</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>extraRight</name> <operator>=</operator> <name>x</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* ON clause terms may not be used with an index
                         ** on left table of a LEFT JOIN.  Ticket #3015 */</comment>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>prereqAll</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator><operator>&gt;=</operator><name>x</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"ON clause references tables to its right"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>prereqAll</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator><operator>&gt;=</operator><name>x</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The ON clause of an INNER JOIN references a table to its right.
      ** Most other SQL database engines raise an error.  But SQLite versions
      ** 3.0 through 3.38 just put the ON clause constraint into the WHERE
      ** clause and carried on.   Beginning with 3.39, raise an error only
      ** if there is a RIGHT or FULL JOIN in the query.  This makes SQLite
      ** more like other systems, and also preserves legacy. */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <name>JT_LTORJ</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"ON clause references tables to its right"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>ExprClearProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_InnerON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>=</operator> <name>prereqAll</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>iParent</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>allowedOp</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name><name>aiCurCol</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><call><name>sqlite3ExprSkipCollate</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u16</name></type> <name>opMask</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>&amp;</operator> <name>prereqLeft</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>WO_ALL</name></expr> </then><else>: <expr><name>WO_EQUIV</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iField</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>TK_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_VECTOR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iField</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>exprMightBeIndexed</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>prereqLeft</name></expr></argument>, <argument><expr><name>aiCurCol</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name> <operator>=</operator> <name><name>aiCurCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_OR</name><operator>|</operator><name>WO_AND</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name> <operator>=</operator> <name><name>aiCurCol</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>=</operator> <call><name>operatorMask</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>opMask</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_IS</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_IS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRight</name> 
     <operator>&amp;&amp;</operator> <call><name>exprMightBeIndexed</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name></expr></argument>, <argument><expr><name>aiCurCol</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>EP_FixedCol</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pDup</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u16</name></type> <name>eExtraOp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Extra bits for pNew-&gt;eOperator */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iField</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>idxNew</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pDup</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>idxNew</name> <operator>=</operator> <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>, <argument><expr><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>idxNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxNew</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>markTermAsChild</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew</name></expr></argument>, <argument><expr><name>idxTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>TK_IS</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_IS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_COPIED</name></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><call><name>termIsEquivalence</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>|=</operator> <name>WO_EQUIV</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>eExtraOp</name> <operator>=</operator> <name>WO_EQUIV</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pDup</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name>pTerm</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <call><name>exprCommute</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>leftCursor</name></name> <operator>=</operator> <name><name>aiCurCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>&amp;</operator> <operator>(</operator><name>WO_OR</name><operator>|</operator><name>WO_AND</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name> <operator>=</operator> <name><name>aiCurCol</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>prereqLeft</name> <operator>|</operator> <name>extraRight</name><operator>)</operator> <operator>!=</operator> <name>prereqLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>=</operator> <name>prereqLeft</name> <operator>|</operator> <name>extraRight</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>=</operator> <name>prereqAll</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>=</operator> <operator>(</operator><call><name>operatorMask</name><argument_list>(<argument><expr><name><name>pDup</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>eExtraOp</name><operator>)</operator> <operator>&amp;</operator> <name>opMask</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else 
    if<condition>( <expr><name>op</name><operator>==</operator><name>TK_ISNULL</name>
     <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>,<argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3ExprCanBeNull</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_TRUEFALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name> <operator>=</operator> <literal type="string">"false"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IsFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_BETWEEN_OPTIMIZATION</name></cpp:ifndef>
  <comment type="block">/* If a term is the BETWEEN operator, create two new virtual terms
  ** that define the range that the BETWEEN implements.  For example:
  **
  **      a BETWEEN b AND c
  **
  ** is converted into:
  **
  **      (a BETWEEN b AND c) AND (a&gt;=b) AND (a&lt;=c)
  **
  ** The two new terms are added onto the end of the WhereClause object.
  ** The new terms are "dynamic" and are children of the original BETWEEN
  ** term.  That means that if the BETWEEN term is coded, the children are
  ** skipped.  Or, if the children are satisfied by an index, the original
  ** BETWEEN term is skipped.
  */</comment>
  <if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_BETWEEN</name> <operator>&amp;&amp;</operator> <name><name>pWC</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>ops</name><index>[]</index></name> <init>= <expr><block>{<expr><name>TK_GE</name></expr>, <expr><name>TK_LE</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNewExpr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>idxNew</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pNewExpr</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>ops</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, 
                             <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>transferJoinMarkings</name><argument_list>(<argument><expr><name>pNewExpr</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>idxNew</name> <operator>=</operator> <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNewExpr</name></expr></argument>, <argument><expr><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>idxNew</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exprAnalyze</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>markTermAsChild</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew</name></expr></argument>, <argument><expr><name>idxTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_BETWEEN_OPTIMIZATION */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_OR_OPTIMIZATION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* Analyze a term that is composed of two or more subterms connected by
  ** an OR operator.
  */</comment>
  <if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_OR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exprAnalyzeOrTerm</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_OR_OPTIMIZATION */</comment>
  <comment type="block">/* The form "x IS NOT NULL" can sometimes be evaluated more efficiently
  ** as "x&gt;NULL" if x is not an INTEGER PRIMARY KEY.  So construct a
  ** virtual term of that form.
  **
  ** The virtual term must be tagged with TERM_VNULL.
  */</comment>
  <if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_NOTNULL</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name>
     <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNewExpr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>idxNew</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pNewTerm</name></decl>;</decl_stmt>
  
      <expr_stmt><expr><name>pNewExpr</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_GT</name></expr></argument>,
                              <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
      <expr_stmt><expr><name>idxNew</name> <operator>=</operator> <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNewExpr</name></expr></argument>,
                                <argument><expr><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_DYNAMIC</name><operator>|</operator><name>TERM_VNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>idxNew</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pNewTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxNew</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewTerm</name><operator>-&gt;</operator><name>leftCursor</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>=</operator> <name>WO_GT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>markTermAsChild</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew</name></expr></argument>, <argument><expr><name>idxTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_COPIED</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LIKE_OPTIMIZATION</name></cpp:ifndef>
  <comment type="block">/* Add constraints to reduce the search space on a LIKE or GLOB
  ** operator.
  **
  ** A like pattern of the form "x LIKE 'aBc%'" is changed into constraints
  **
  **          x&gt;='ABC' AND x&lt;'abd' AND x LIKE 'aBc%'
  **
  ** The last character of the prefix "abc" is incremented to form the
  ** termination condition "abd".  If case is not significant (the default
  ** for LIKE) then the lower-bound is made all uppercase and the upper-
  ** bound is made all lowercase so that the bounds also work when comparing
  ** BLOBs.
  */</comment>
  <if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name>
   <operator>&amp;&amp;</operator> <name><name>pWC</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name>
   <operator>&amp;&amp;</operator> <call><name>isLikeOrGlob</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStr1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isComplete</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>noCase</name></expr></argument>)</argument_list></call></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name></decl>;</decl_stmt>       <comment type="block">/* LHS of LIKE/GLOB operator */</comment>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pStr2</name></decl>;</decl_stmt>       <comment type="block">/* Copy of pStr1 - RHS of LIKE/GLOB operator */</comment>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNewExpr1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNewExpr2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>idxNew1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>idxNew2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCollSeqName</name></decl>;</decl_stmt>     <comment type="block">/* Name of collating sequence */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>u16</name></type> <name>wtFlags</name> <init>= <expr><name>TERM_LIKEOPT</name> <operator>|</operator> <name>TERM_VIRTUAL</name> <operator>|</operator> <name>TERM_DYNAMIC</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseXList</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStr2</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pStr1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pStr1</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pStr1</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pStr2</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pStr2</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
 

    <comment type="block">/* Convert the lower bound to upper-case and the upper bound to
    ** lower-case (upper-case is less than lower-case in ASCII) so that
    ** the range constraints also work for BLOBs
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>noCase</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_LIKE</name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>pStr1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pStr1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3Toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pStr2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3Tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name></type> <name>c</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>       <comment type="block">/* Last character before the first wildcard */</comment>
      <expr_stmt><expr><name>pC</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pStr2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name><index>[<expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pStr2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>pC</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>noCase</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* The point is to increment the last character before the first
        ** wildcard.  But if we increment '@', that will push it into the
        ** alphabetic range where case conversions will mess up the 
        ** inequality.  To avoid this, make sure to also run the full
        ** LIKE on all candidate expressions by clearing the isComplete flag
        */</comment>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'A'</literal><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>isComplete</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>sqlite3UpperToLower</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pC</name> <operator>=</operator> <name>c</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zCollSeqName</name> <operator>=</operator> <ternary><condition><expr><name>noCase</name></expr> ?</condition><then> <expr><literal type="string">"NOCASE"</literal></expr> </then><else>: <expr><name>sqlite3StrBINARY</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewExpr1</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewExpr1</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_GE</name></expr></argument>,
           <argument><expr><call><name>sqlite3ExprAddCollateString</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>pNewExpr1</name></expr></argument>,<argument><expr><name>zCollSeqName</name></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name>pStr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>transferJoinMarkings</name><argument_list>(<argument><expr><name>pNewExpr1</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idxNew1</name> <operator>=</operator> <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNewExpr1</name></expr></argument>, <argument><expr><name>wtFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>idxNew1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exprAnalyze</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewExpr2</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewExpr2</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_LT</name></expr></argument>,
           <argument><expr><call><name>sqlite3ExprAddCollateString</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>pNewExpr2</name></expr></argument>,<argument><expr><name>zCollSeqName</name></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name>pStr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>transferJoinMarkings</name><argument_list>(<argument><expr><name>pNewExpr2</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idxNew2</name> <operator>=</operator> <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNewExpr2</name></expr></argument>, <argument><expr><name>wtFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>idxNew2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exprAnalyze</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>isComplete</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>markTermAsChild</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew1</name></expr></argument>, <argument><expr><name>idxTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>markTermAsChild</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew2</name></expr></argument>, <argument><expr><name>idxTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_LIKE_OPTIMIZATION */</comment>

  <comment type="block">/* If there is a vector == or IS term - e.g. "(a, b) == (?, ?)" - create
  ** new terms for each component comparison - "a = ?" and "b = ?".  The
  ** new terms completely replace the original vector comparison, which is
  ** no longer used.
  **
  ** This is only required if at least one side of the comparison operation
  ** is not a sub-select.
  **
  ** tag-20220128a
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_EQ</name> <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IS</name><operator>)</operator>
   <operator>&amp;&amp;</operator> <operator>(</operator><name>nLeft</name> <operator>=</operator> <call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;</operator><literal type="number">1</literal>
   <operator>&amp;&amp;</operator> <call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>nLeft</name>
   <operator>&amp;&amp;</operator> <operator>(</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_xIsSelect</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
     <operator>||</operator> <operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_xIsSelect</name><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator>
   <operator>&amp;&amp;</operator> <name><name>pWC</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nLeft</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>idxNew</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><call><name>sqlite3ExprForVectorField</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><call><name>sqlite3ExprForVectorField</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>transferJoinMarkings</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>idxNew</name> <operator>=</operator> <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TERM_DYNAMIC</name><operator>|</operator><name>TERM_SLICE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exprAnalyze</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_CODED</name><operator>|</operator><name>TERM_VIRTUAL</name></expr>;</expr_stmt>  <comment type="block">/* Disable the original */</comment>
    <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>=</operator> <name>WO_ROWVAL</name></expr>;</expr_stmt>
  </block_content>}</block></if>

  <comment type="block">/* If there is a vector IN term - e.g. "(a, b) IN (SELECT ...)" - create
  ** a virtual term for each vector component. The expression object
  ** used by each such virtual term is pExpr (the full vector IN(...) 
  ** expression). The WhereTerm.u.x.iField variable identifies the index within
  ** the vector on the LHS that the virtual term represents.
  **
  ** This only works if the RHS is a simple SELECT (not a compound) that does
  ** not use window functions.
  */</comment>
  <if type="elseif">else if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IN</name>
   <operator>&amp;&amp;</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iField</name></name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_VECTOR</name>
   <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>( <argument><expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call>
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pPrior</name></name><operator>==</operator><literal type="number">0</literal>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
   <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name><operator>-&gt;</operator><name>pWin</name></name><operator>==</operator><literal type="number">0</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
   <operator>&amp;&amp;</operator> <name><name>pWC</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>sqlite3ExprVectorSize</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>idxNew</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>idxNew</name> <operator>=</operator> <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_SLICE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxNew</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>iField</name></name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exprAnalyze</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>markTermAsChild</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew</name></expr></argument>, <argument><expr><name>idxTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <comment type="block">/* Add a WO_AUX auxiliary term to the constraint set if the
  ** current expression is of the form "column OP expr" where OP
  ** is an operator that gets passed into virtual tables but which is
  ** not normally optimized for ordinary tables.  In other words, OP
  ** is one of MATCH, LIKE, GLOB, REGEXP, !=, IS, IS NOT, or NOT NULL.
  ** This information is used by the xBestIndex methods of
  ** virtual tables.  The native query optimizer does not attempt
  ** to do anything with MATCH functions.
  */</comment>
  <if type="elseif">else if<condition>( <expr><name><name>pWC</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AND</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pLeft</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>isAuxiliaryVtabOperator</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eOp2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>res</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>idxNew</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pNewTerm</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>prereqColumn</name></decl>, <decl><type ref="prev"/><name>prereqExpr</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>prereqExpr</name> <operator>=</operator> <call><name>sqlite3WhereExprUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>prereqColumn</name> <operator>=</operator> <call><name>sqlite3WhereExprUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>prereqExpr</name> <operator>&amp;</operator> <name>prereqColumn</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNewExpr</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pNewExpr</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_MATCH</name></expr></argument>, 
            <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>pNewExpr</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pNewExpr</name></expr></argument>, <argument><expr><name>EP_OuterON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNewExpr</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>w</name><operator>.</operator><name>iJoin</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>idxNew</name> <operator>=</operator> <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNewExpr</name></expr></argument>, <argument><expr><name>TERM_VIRTUAL</name><operator>|</operator><name>TERM_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>idxNew</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNewTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxNew</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>=</operator> <name>prereqExpr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewTerm</name><operator>-&gt;</operator><name>leftCursor</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>iTable</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewTerm</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><operator>.</operator><name>leftColumn</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>=</operator> <name>WO_AUX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewTerm</name><operator>-&gt;</operator><name>eMatchOp</name></name> <operator>=</operator> <name>eOp2</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>markTermAsChild</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew</name></expr></argument>, <argument><expr><name>idxTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>|=</operator> <name>TERM_COPIED</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNewTerm</name><operator>-&gt;</operator><name>prereqAll</name></name> <operator>=</operator> <name><name>pTerm</name><operator>-&gt;</operator><name>prereqAll</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

  <comment type="block">/* Prevent ON clause terms of a LEFT JOIN from being used to drive
  ** an index for tables to the left of the join.
  */</comment>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pTerm</name><operator>!=</operator><operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>prereqRight</name></name> <operator>|=</operator> <name>extraRight</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***************************************************************************
** Routines with file scope above.  Interface to the rest of the where.c
** subsystem follows.
***************************************************************************/</comment>

<comment type="block">/*
** This routine identifies subexpressions in the WHERE clause where
** each subexpression is separated by the AND operator or some other
** operator specified in the op parameter.  The WhereClause structure
** is filled with pointers to subexpressions.  For example:
**
**    WHERE  a=='hello' AND coalesce(b,11)&lt;10 AND (c+12!=d OR c==22)
**           \________/     \_______________/     \________________/
**            slot[0]            slot[1]               slot[2]
**
** The original WHERE clause in pExpr is unaltered.  All this routine
** does is make slot[] entries point to substructure within pExpr.
**
** In the previous sentence and in the diagram, "slot[]" refers to
** the WhereClause.a[] array.  The slot[] array grows as needed to contain
** all terms of the WHERE clause.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereSplit</name><parameter_list>(<parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>op</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pE2</name> <init>= <expr><call><name>sqlite3ExprSkipCollateAndLikely</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pE2</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pE2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pE2</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>op</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3WhereSplit</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name><name>pE2</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WhereSplit</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name><name>pE2</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add either a LIMIT (if eMatchOp==SQLITE_INDEX_CONSTRAINT_LIMIT) or 
** OFFSET (if eMatchOp==SQLITE_INDEX_CONSTRAINT_OFFSET) term to the 
** where-clause passed as the first argument. The value for the term
** is found in register iReg.
**
** In the common case where the value is a simple integer 
** (example: "LIMIT 5 OFFSET 10") then the expression codes as a
** TK_INTEGER so that it will be available to sqlite3_vtab_rhs_value().
** If not, then it codes as a TK_REGISTER expression.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whereAddLimitExpr</name><parameter_list>(
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,   <comment type="block">/* Add the constraint to this WHERE clause */</comment>
  <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>,           <comment type="block">/* Register that will hold value of the limit/offset */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,        <comment type="block">/* Expression that defines the limit/offset */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCsr</name></decl></parameter>,           <comment type="block">/* Cursor to which the constraint applies */</comment>
  <parameter><decl><type><name>int</name></type> <name>eMatchOp</name></decl></parameter>        <comment type="block">/* SQLITE_INDEX_CONSTRAINT_LIMIT or _OFFSET */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>iVal</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_INTEGER</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pVal</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_MATCH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_REGISTER</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pVal</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name>iReg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_MATCH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TERM_DYNAMIC</name><operator>|</operator><name>TERM_VIRTUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>leftCursor</name></name> <operator>=</operator> <name>iCsr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eOperator</name></name> <operator>=</operator> <name>WO_AUX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>eMatchOp</name></name> <operator>=</operator> <name>eMatchOp</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Possibly add terms corresponding to the LIMIT and OFFSET clauses of the
** SELECT statement passed as the second argument. These terms are only
** added if:
**
**   1. The SELECT statement has a LIMIT clause, and
**   2. The SELECT statement is not an aggregate or DISTINCT query, and
**   3. The SELECT statement has exactly one object in its from clause, and
**      that object is a virtual table, and
**   4. There are no terms in the WHERE clause that will not be passed
**      to the virtual table xBestIndex method.
**   5. The ORDER BY clause, if any, will be made available to the xBestIndex
**      method.
**
** LIMIT and OFFSET terms are ignored by most of the planner code. They
** exist only so that they may be passed to the xBestIndex method of the
** single virtual table in the FROM clause of the SELECT.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereAddLimit</name><parameter_list>(<parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>, <parameter><decl><type><name>Select</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pGroupBy</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <name>SF_Aggregate</name><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pLimit</name></name><operator>)</operator>                                          <comment type="block">/* 1 */</comment>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SF_Distinct</name><operator>|</operator><name>SF_Aggregate</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal>             <comment type="block">/* 2 */</comment>
   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>IsVirtual</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr></argument>)</argument_list></call><operator>)</operator></expr>       <comment type="block">/* 3 */</comment>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCsr</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

    <comment type="block">/* Check condition (4). Return early if it is not met. */</comment>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>wtFlags</name> <operator>&amp;</operator> <name>TERM_CODED</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* This term is a vector operation that has been decomposed into
        ** other, subsequent terms.  It can be ignored. See tag-20220128a */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>wtFlags</name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>eOperator</name><operator>==</operator><name>WO_ROWVAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>leftCursor</name><operator>!=</operator><name>iCsr</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Check condition (5). Return early if it is not met. */</comment>
    <if_stmt><if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pOrderBy</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name> <init>= <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name><operator>!=</operator><name>iCsr</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pOrderBy</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>sortFlags</name></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_BIGNULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* All conditions are met. Add the terms to the where-clause object. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_LIMIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>whereAddLimitExpr</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iLimit</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>,
                      <argument><expr><name>iCsr</name></expr></argument>, <argument><expr><name>SQLITE_INDEX_CONSTRAINT_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>whereAddLimitExpr</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLimit</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>,
                        <argument><expr><name>iCsr</name></expr></argument>, <argument><expr><name>SQLITE_INDEX_CONSTRAINT_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Initialize a preallocated WhereClause structure.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereClauseInit</name><parameter_list>(
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>,        <comment type="block">/* The WhereClause to be initialized */</comment>
  <parameter><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl></parameter>        <comment type="block">/* The WHERE processing context */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name></name> <operator>=</operator> <name>pWInfo</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>hasOr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>pOuter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>nBase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>nSlot</name></name> <operator>=</operator> <call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>aStatic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name><name>pWC</name><operator>-&gt;</operator><name>aStatic</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Deallocate a WhereClause structure.  The WhereClause structure
** itself is not freed.  This routine is the inverse of
** sqlite3WhereClauseInit().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereClauseClear</name><parameter_list>(<parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>pWInfo</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>&gt;=</operator><name><name>pWC</name><operator>-&gt;</operator><name>nBase</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>pWC</name><operator>-&gt;</operator><name>a</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereTerm</name> <modifier>*</modifier></type><name>aLast</name> <init>= <expr><operator>&amp;</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <comment type="block">/* Verify that every term past pWC-&gt;nBase is virtual */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>nBase</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pWC</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>wtFlags</name> <operator>&amp;</operator> <name>TERM_VIRTUAL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>a</name><operator>-&gt;</operator><name>eMatchOp</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>a</name><operator>-&gt;</operator><name>eOperator</name></name><operator>==</operator><name>WO_AUX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>a</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_DYNAMIC</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>a</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TERM_ORINFO</name><operator>|</operator><name>TERM_ANDINFO</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>a</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_ORINFO</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_ANDINFO</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>whereOrInfoDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pOrInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>wtFlags</name></name> <operator>&amp;</operator> <name>TERM_ANDINFO</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>whereAndInfoDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pAndInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>a</name><operator>==</operator><name>aLast</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>a</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** These routines walk (recursively) an expression tree and generate
** a bitmask indicating which tables are used in that expression
** tree.
**
** sqlite3WhereExprUsage(MaskSet, Expr) -&gt;
**
**       Return a Bitmask of all tables referenced by Expr.  Expr can be
**       be NULL, in which case 0 is returned.
**
** sqlite3WhereExprUsageNN(MaskSet, Expr) -&gt;
**
**       Same as sqlite3WhereExprUsage() except that Expr must not be
**       NULL.  The "NN" suffix on the name stands for "Not Null".
**
** sqlite3WhereExprListUsage(MaskSet, ExprList) -&gt;
**
**       Return a Bitmask of all tables referenced by every expression
**       in the expression list ExprList.  ExprList can be NULL, in which
**       case 0 is returned.
**
** sqlite3WhereExprUsageFull(MaskSet, ExprList) -&gt;
**
**       Internal use only.  Called only by sqlite3WhereExprUsageNN() for
**       complex expressions that require pushing register values onto
**       the stack.  Many calls to sqlite3WhereExprUsageNN() do not need
**       the more complex analysis done by this routine.  Hence, the
**       computations done by this routine are broken out into a separate
**       "no-inline" function to avoid the stack push overhead in the
**       common case where it is not needed.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>Bitmask</name></type> <name>sqlite3WhereExprUsageFull</name><parameter_list>(
  <parameter><decl><type><name>WhereMaskSet</name> <modifier>*</modifier></type><name>pMaskSet</name></decl></parameter>,
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>mask</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>mask</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_IF_NULL_ROW</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3WhereExprUsageNN</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3WhereExprUsageNN</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ExprUseXSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_VarSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pMaskSet</name><operator>-&gt;</operator><name>bVarSelect</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>exprSelectUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pSelect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3WhereExprListUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_FUNCTION</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_AGG_FUNCTION</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>ExprUseYWin</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3WhereExprListUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name><operator>-&gt;</operator><name>pPartition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3WhereExprListUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name><operator>-&gt;</operator><name>pOrderBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3WhereExprUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pWin</name><operator>-&gt;</operator><name>pFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>mask</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>Bitmask</name></type> <name>sqlite3WhereExprUsageNN</name><parameter_list>(<parameter><decl><type><name>WhereMaskSet</name> <modifier>*</modifier></type><name>pMaskSet</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>TK_COLUMN</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_FixedCol</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3WhereGetMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_TokenOnly</name><operator>|</operator><name>EP_Leaf</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_IF_NULL_ROW</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>sqlite3WhereExprUsageFull</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>Bitmask</name></type> <name>sqlite3WhereExprUsage</name><parameter_list>(<parameter><decl><type><name>WhereMaskSet</name> <modifier>*</modifier></type><name>pMaskSet</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><call><name>sqlite3WhereExprUsageNN</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>Bitmask</name></type> <name>sqlite3WhereExprListUsage</name><parameter_list>(<parameter><decl><type><name>WhereMaskSet</name> <modifier>*</modifier></type><name>pMaskSet</name></decl></parameter>, <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3WhereExprUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>mask</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Call exprAnalyze on all terms in a WHERE clause.  
**
** Note that exprAnalyze() might add new virtual terms onto the
** end of the WHERE clause.  We do not want to analyze these new
** virtual terms, so start analyzing at the end and work forward
** so that the added virtual terms are never processed.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereExprAnalyze</name><parameter_list>(
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>,       <comment type="block">/* the FROM clause */</comment>
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>         <comment type="block">/* the WHERE clause to be analyzed */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pWC</name><operator>-&gt;</operator><name>nTerm</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>exprAnalyze</name><argument_list>(<argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** For table-valued-functions, transform the function arguments into
** new WHERE clause terms.  
**
** Each function argument translates into an equality constraint against
** a HIDDEN column in the table.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereTabFuncArgs</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                    <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name></decl></parameter>,                   <comment type="block">/* The FROM clause term to process */</comment>
  <parameter><decl><type><name>WhereClause</name> <modifier>*</modifier></type><name>pWC</name></decl></parameter>                  <comment type="block">/* Xfer function arguments to here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pArgs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pColRef</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isTabFunc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pArgs</name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>pFuncArg</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pArgs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pArgs</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRhs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>joinType</name></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>k</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_HIDDEN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content><expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt></block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>k</name><operator>&gt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"too many arguments on %s() - max %d"</literal></expr></argument>,
                      <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pColRef</name> <operator>=</operator> <call><name>sqlite3ExprAlloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>TK_COLUMN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pColRef</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pColRef</name><operator>-&gt;</operator><name>iTable</name></name> <operator>=</operator> <name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pColRef</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>k</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ExprUseYTab</name><argument_list>(<argument><expr><name>pColRef</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pColRef</name><operator>-&gt;</operator><name>y</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>colUsed</name></name> <operator>|=</operator> <call><name>sqlite3ExprColUsed</name><argument_list>(<argument><expr><name>pColRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRhs</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_UPLUS</name></expr></argument>, 
        <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pArgs</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_EQ</name></expr></argument>, <argument><expr><name>pColRef</name></expr></argument>, <argument><expr><name>pRhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>jointype</name></name> <operator>&amp;</operator> <operator>(</operator><name>JT_LEFT</name><operator>|</operator><name>JT_LTORJ</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>joinType</name> <operator>=</operator> <name>EP_OuterON</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>joinType</name> <operator>=</operator> <name>EP_InnerON</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3SetJoinExpr</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>iCursor</name></name></expr></argument>, <argument><expr><name>joinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>TERM_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
</unit>
