<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/delete.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that are called by the parser
** in order to generate code for DELETE FROM statements.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** While a SrcList can in general represent multiple tables and subqueries
** (as in the FROM clause of a SELECT statement) in this case it contains
** the name of a single table, as one might find in an INSERT, DELETE,
** or UPDATE statement.  Look up that table in the symbol table and
** return a pointer.  Set an error message and return NULL if the table 
** name is not found or if any other error occurs.
**
** The following fields are initialized appropriate in pSrc:
**
**    pSrc-&gt;a[0].pTab       Pointer to the Table object
**    pSrc-&gt;a[0].pIndex     Pointer to the INDEXED BY index, if there is one
**
*/</comment>
<function><type><name>Table</name> <modifier>*</modifier></type><name>sqlite3SrcListLookup</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SrcItem</name> <modifier>*</modifier></type><name>pItem</name> <init>= <expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pItem</name> <operator>&amp;&amp;</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3LocateTableItem</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pItem</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nTabRef</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pItem</name><operator>-&gt;</operator><name>fg</name><operator>.</operator><name>isIndexedBy</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3IndexedByLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pItem</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pTab</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate byte-code that will report the number of rows modified 
** by a DELETE, INSERT, or UPDATE statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CodeChangeCount</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>regCounter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FkCheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><name>regCounter</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeSetNumCols</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>, <argument><expr><name>zColName</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return true if table pTab is read-only.
**
** A table is read-only if any of the following are true:
**
**   1) It is a virtual table and no implementation of the xUpdate method
**      has been provided
**
**   2) It is a system table (i.e. sqlite_schema), this call is not
**      part of a nested parse and writable_schema pragma has not 
**      been specified
**
**   3) The table is a shadow table, the database connection is in
**      defensive mode, and the current sqlite3_prepare()
**      is for a top-level SQL statement.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>tabIsReadOnly</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>pMod</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xUpdate</name></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TF_Readonly</name><operator>|</operator><name>TF_Shadow</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Readonly</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3WritableSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Shadow</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ReadOnlyShadowTables</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to make sure the given table is writable.  If it is not
** writable, generate an error message and return 1.  If it is
** writable return 0;
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IsReadOnly</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>viewOk</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>tabIsReadOnly</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"table %s may not be modified"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>viewOk</name> <operator>&amp;&amp;</operator> <call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><literal type="string">"cannot modify %s because it is a view"</literal></expr></argument>,<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Evaluate a view and store its result in an ephemeral table.  The
** pWhere argument is an optional WHERE clause that restricts the
** set of rows in the view that are to be added to the ephemeral table.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3MaterializeView</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pView</name></decl></parameter>,        <comment type="block">/* View definition */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl></parameter>,        <comment type="block">/* Optional WHERE clause to be added */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,  <comment type="block">/* Optional ORDER BY clause */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLimit</name></decl></parameter>,        <comment type="block">/* Optional LIMIT clause */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCur</name></decl></parameter>             <comment type="block">/* Cursor number for ephemeral table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pFrom</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> <init>= <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pView</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pWhere</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFrom</name> <operator>=</operator> <call><name>sqlite3SrcListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFrom</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pView</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFrom</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>zDatabase</name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>isUsing</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFrom</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>u3</name><operator>.</operator><name>pOn</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pSel</name> <operator>=</operator> <call><name>sqlite3SelectNew</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, 
                          <argument><expr><name>SF_IncludeHidden</name></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><name>SRT_EphemTab</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_VIEW) &amp;&amp; !defined(SQLITE_OMIT_TRIGGER) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_UPDATE_DELETE_LIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Generate an expression tree to implement the WHERE, ORDER BY,
** and LIMIT/OFFSET portion of DELETE and UPDATE statements.
**
**     DELETE FROM table_wxyz WHERE a&lt;5 ORDER BY a LIMIT 1;
**                            \__________________________/
**                               pLimitWhere (pInClause)
*/</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>sqlite3LimitWhere</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,               <comment type="block">/* The parser context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,               <comment type="block">/* the FROM clause -- which tables to scan */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl></parameter>,                <comment type="block">/* The WHERE clause.  May be null */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,          <comment type="block">/* The ORDER BY clause.  May be null */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLimit</name></decl></parameter>,                <comment type="block">/* The LIMIT clause.  May be null */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zStmtType</name></decl></parameter>              <comment type="block">/* Either DELETE or UPDATE.  For err msgs. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLhs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>           <comment type="block">/* LHS of IN(SELECT...) operator */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pInClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* WHERE rowid IN ( select ) */</comment>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pEList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Expression list contaning only pSelectRowid */</comment>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSelectSrc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* SELECT rowid FROM x ... (dup of pSrc) */</comment>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Complete SELECT tree */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>

  <comment type="block">/* Check that there isn't an ORDER BY without a LIMIT clause.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name> <operator>&amp;&amp;</operator> <name>pLimit</name><operator>==</operator><literal type="number">0</literal></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY without LIMIT on %s"</literal></expr></argument>, <argument><expr><name>zStmtType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* We only need to generate a select expression if there
  ** is a limit/offset term to enforce.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pLimit</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition> <block>{<block_content>
    <return>return <expr><name>pWhere</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Generate a select expression tree to enforce the limit/offset 
  ** term for the DELETE or UPDATE statement.  For example:
  **   DELETE FROM table_a WHERE col1=1 ORDER BY col2 LIMIT 1 OFFSET 1
  ** becomes:
  **   DELETE FROM table_a WHERE rowid IN ( 
  **     SELECT rowid FROM table_a WHERE col1=1 ORDER BY col2 LIMIT 1 OFFSET 1
  **   );
  */</comment>

  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pLhs</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_ROW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pEList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(
        <argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_ROW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pLhs</name> <operator>=</operator> <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pEList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pEList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>pLhs</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_VECTOR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pLhs</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pLhs</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* duplicate the FROM clause as it is needed by both the DELETE/UPDATE tree
  ** and the SELECT subtree. */</comment>
  <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSelectSrc</name> <operator>=</operator> <call><name>sqlite3SrcListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>isIndexedBy</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>isCte</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>u2</name><operator>.</operator><name>pIBIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>isIndexedBy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>u1</name><operator>.</operator><name>zIndexedBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>isCte</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>u2</name><operator>.</operator><name>pCteUse</name><operator>-&gt;</operator><name>nUse</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* generate the SELECT expression tree. */</comment>
  <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <call><name>sqlite3SelectNew</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><name>pSelectSrc</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> ,<argument><expr><literal type="number">0</literal></expr></argument>, 
      <argument><expr><name>pOrderBy</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>pLimit</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* now generate the new WHERE rowid IN clause for the DELETE/UDPATE */</comment>
  <expr_stmt><expr><name>pInClause</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_IN</name></expr></argument>, <argument><expr><name>pLhs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PExprAddSelect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pInClause</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pInClause</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) */</comment>
       <comment type="block">/*      &amp;&amp; !defined(SQLITE_OMIT_SUBQUERY) */</comment>

<comment type="block">/*
** Generate code for a DELETE FROM statement.
**
**     DELETE FROM table_wxyz WHERE a&lt;5 AND b NOT NULL;
**                 \________/       \________________/
**                  pTabList              pWhere
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DeleteFrom</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* The parser context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>,     <comment type="block">/* The table from which we should delete things */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl></parameter>,          <comment type="block">/* The WHERE clause.  May be null */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,    <comment type="block">/* ORDER BY clause. May be null */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLimit</name></decl></parameter>           <comment type="block">/* LIMIT clause. May be null */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>               <comment type="block">/* The virtual database engine */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>           <comment type="block">/* The table from which records will be deleted */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                 <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name></decl>;</decl_stmt>     <comment type="block">/* Information about the WHERE clause */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>           <comment type="block">/* For looping over indices of the table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTabCur</name></decl>;</decl_stmt>           <comment type="block">/* Cursor number for the table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDataCur</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* VDBE cursor for the canonical data source */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Cursor number of the first index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nIdx</name></decl>;</decl_stmt>              <comment type="block">/* Number of indices */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>           <comment type="block">/* Main database structure */</comment>
  <decl_stmt><decl><type><name>AuthContext</name></type> <name>sContext</name></decl>;</decl_stmt>  <comment type="block">/* Authorization context */</comment>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>       <comment type="block">/* Name context to resolve expressions in */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>               <comment type="block">/* Database number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>memCnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Memory cell used for change counting */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rcauth</name></decl>;</decl_stmt>            <comment type="block">/* Value returned by authorization callback */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eOnePass</name></decl>;</decl_stmt>          <comment type="block">/* ONEPASS_OFF or _SINGLE or _MULTI */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>aiCurOnePass</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* The write cursors opened by WHERE_ONEPASS */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aToOpen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Open cursor iTabCur+j if aToOpen[j] is true */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name></decl>;</decl_stmt>            <comment type="block">/* The PRIMARY KEY index on the table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* First of nPk registers holding PRIMARY KEY value */</comment>
  <decl_stmt><decl><type><name>i16</name></type> <name>nPk</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Number of columns in the PRIMARY KEY */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iKey</name></decl>;</decl_stmt>              <comment type="block">/* Memory cell holding key of row to be deleted */</comment>
  <decl_stmt><decl><type><name>i16</name></type> <name>nKey</name></decl>;</decl_stmt>              <comment type="block">/* Number of memory cells in the row key */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iEphCur</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Ephemeral table holding all primary key values */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iRowSet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Register for rowset of rows to delete */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrBypass</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Address of jump over the delete logic */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrLoop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Top of the delete loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrEphOpen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Instruction to open the Ephemeral table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bComplex</name></decl>;</decl_stmt>          <comment type="block">/* True if there are triggers or FKs or
                         ** subqueries in the WHERE clause */</comment>
 
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>isView</name></decl>;</decl_stmt>                  <comment type="block">/* True if attempting to delete from a view */</comment>
  <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pTrigger</name></decl>;</decl_stmt>           <comment type="block">/* List of table triggers, if required */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sContext</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pParse</name></name><operator>==</operator><name>pParse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>delete_from_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Locate the table which we want to delete.  This table has to be
  ** put in an SrcList structure because some of the subroutines we
  ** will be calling are designed to work with multiple tables and expect
  ** an SrcList* parameter instead of just a Table* parameter.
  */</comment>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3SrcListLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>  <goto>goto <name>delete_from_cleanup</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Figure out if we have any triggers and if the table being
  ** deleted from is a view
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <expr_stmt><expr><name>pTrigger</name> <operator>=</operator> <call><name>sqlite3TriggersExist</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>TK_DELETE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>isView</name> <operator>=</operator> <call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pTrigger</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>isView</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>bComplex</name> <operator>=</operator> <name>pTrigger</name> <operator>||</operator> <call><name>sqlite3FkRequired</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifdef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>isView</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>isView</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x10000</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3TreeViewLine</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"In sqlite3Delete() at %s:%d"</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewDelete</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>,
                          <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_UPDATE_DELETE_LIMIT</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pWhere</name> <operator>=</operator> <call><name>sqlite3LimitWhere</name><argument_list>(
        <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>, <argument><expr><literal type="string">"DELETE"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOrderBy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLimit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If pTab is really a view, make sure it has been initialized.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>delete_from_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3IsReadOnly</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>pTrigger</name></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>delete_from_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rcauth</name> <operator>=</operator> <call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
                            <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rcauth</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rcauth</name><operator>==</operator><name>SQLITE_DENY</name> <operator>||</operator> <name>rcauth</name><operator>==</operator><name>SQLITE_IGNORE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rcauth</name><operator>==</operator><name>SQLITE_DENY</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>delete_from_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>isView</name> <operator>||</operator> <name>pTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Assign cursor numbers to the table and all its indices.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iTabCur</name> <operator>=</operator> <name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>nIdx</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>nIdx</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Start the view context
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isView</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3AuthContextPush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sContext</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Begin generating code.
  */</comment>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>delete_from_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeCountChanges</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>bComplex</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we are trying to delete from a view, realize that view into
  ** an ephemeral table.
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>isView</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3MaterializeView</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, 
        <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>, <argument><expr><name>iTabCur</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iDataCur</name> <operator>=</operator> <name>iIdxCur</name> <operator>=</operator> <name>iTabCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOrderBy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLimit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Resolve the column names in the WHERE clause.
  */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <name>pTabList</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>delete_from_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Initialize the counter of the number of rows deleted, if
  ** we are counting rows.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_CountRows</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>bReturning</name></name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>memCnt</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>memCnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRUNCATE_OPTIMIZATION</name></cpp:ifndef>
  <comment type="block">/* Special case: A DELETE without a WHERE clause deletes everything.
  ** It is easier just to erase the whole table. Prior to version 3.6.5,
  ** this optimization caused the row change count (the value returned by 
  ** API function sqlite3_count_changes) to be set incorrectly.
  **
  ** The "rcauth==SQLITE_OK" terms is the
  ** IMPLEMENTATION-OF: R-17228-37124 If the action code is SQLITE_DELETE and
  ** the callback returns SQLITE_IGNORE then the DELETE operation proceeds but
  ** the truncate optimization is disabled and all rows are deleted
  ** individually.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rcauth</name><operator>==</operator><name>SQLITE_OK</name>
   <operator>&amp;&amp;</operator> <name>pWhere</name><operator>==</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>!</operator><name>bComplex</name>
   <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_PREUPDATE_HOOK</name></cpp:ifdef>
   <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>xPreUpdateCallback</name></name><operator>==</operator><literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>isView</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Clear</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><ternary><condition><expr><name>memCnt</name></expr> ?</condition><then> <expr><name>memCnt</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>,
                        <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pSchema</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Clear</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>tnum</name></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>IsPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>memCnt</name></expr> ?</condition><then> <expr><name>memCnt</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TRUNCATE_OPTIMIZATION */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>u16</name></type> <name>wcf</name> <init>= <expr><name>WHERE_ONEPASS_DESIRED</name><operator>|</operator><name>WHERE_DUPLICATES_OK</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>&amp;</operator> <name>NC_VarSelect</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bComplex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>wcf</name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><name>bComplex</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>WHERE_ONEPASS_MULTIROW</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* For a rowid table, initialize the RowSet to an empty set */</comment>
      <expr_stmt><expr><name>pPk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nPk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>iRowSet</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iRowSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* For a WITHOUT ROWID table, create an ephemeral table used to
      ** hold all primary keys for rows to be deleted. */</comment>
      <expr_stmt><expr><name>pPk</name> <operator>=</operator> <call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPk</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nPk</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iPk</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nPk</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iEphCur</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrEphOpen</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>iEphCur</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeSetP4KeyInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  
    <comment type="block">/* Construct a query to find the rowid or primary key for every row
    ** to be deleted, based on the WHERE clause. Set variable eOnePass
    ** to indicate the strategy used to implement this delete:
    **
    **  ONEPASS_OFF:    Two-pass approach - use a FIFO for rowids/PK values.
    **  ONEPASS_SINGLE: One-pass approach - at most one row deleted.
    **  ONEPASS_MULTI:  One-pass approach - any number of rows may be deleted.
    */</comment>
    <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>wcf</name></expr></argument>,<argument><expr><name>iTabCur</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pWInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>delete_from_cleanup</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>eOnePass</name> <operator>=</operator> <call><name>sqlite3WhereOkOnePass</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>aiCurOnePass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>eOnePass</name><operator>!=</operator><name>ONEPASS_MULTI</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>bComplex</name> <operator>||</operator> <name>eOnePass</name><operator>!=</operator><name>ONEPASS_OFF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>!=</operator><name>ONEPASS_SINGLE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3MultiWrite</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3WhereUsesDeferredSeek</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FinishSeek</name></expr></argument>, <argument><expr><name>iTabCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* Keep track of the number of rows to be deleted */</comment>
    <if_stmt><if>if<condition>( <expr><name>memCnt</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>memCnt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* Extract the rowid or primary key for the current row */</comment>
    <if_stmt><if>if<condition>( <expr><name>pPk</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iTabCur</name></expr></argument>,
                                        <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>iPk</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>iKey</name> <operator>=</operator> <name>iPk</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iKey</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iTabCur</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  
    <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>!=</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* For ONEPASS, no need to store the rowid/primary-key. There is only
      ** one, so just keep it in its register(s) and fall through to the
      ** delete code.  */</comment>
      <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name>nPk</name></expr>;</expr_stmt> <comment type="block">/* OP_Found will use an unpacked key */</comment>
      <expr_stmt><expr><name>aToOpen</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nIdx</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>aToOpen</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>delete_from_cleanup</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aToOpen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nIdx</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aToOpen</name><index>[<expr><name>nIdx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aiCurOnePass</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aToOpen</name><index>[<expr><name><name>aiCurOnePass</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><name>iTabCur</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aiCurOnePass</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aToOpen</name><index>[<expr><name><name>aiCurOnePass</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-</operator><name>iTabCur</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>addrEphOpen</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrEphOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>addrBypass</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pPk</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Add the PK key for this row to the temporary table */</comment>
        <expr_stmt><expr><name>iKey</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nKey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <comment type="block">/* Zero tells OP_Found to use a composite key */</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>iPk</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>,
            <argument><expr><call><name>sqlite3IndexAffinityStr</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iEphCur</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>iPk</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Add the rowid of the row to be deleted to the RowSet */</comment>
        <expr_stmt><expr><name>nKey</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* OP_DeferredSeek always uses a single rowid */</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowSetAdd</name></expr></argument>, <argument><expr><name>iRowSet</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  
    <comment type="block">/* Unless this is a view, open cursors for the table we are 
    ** deleting from and all its indices. If this is a view, then the
    ** only effect this statement has is to fire the INSTEAD OF 
    ** triggers.
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iAddrOnce</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_MULTI</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iAddrOnce</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3OpenTableAndIndices</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>, <argument><expr><name>OPFLAG_FORDELETE</name></expr></argument>,
                                 <argument><expr><name>iTabCur</name></expr></argument>, <argument><expr><name>aToOpen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDataCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iIdxCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPk</name> <operator>||</operator> <call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>iDataCur</name><operator>==</operator><name>iTabCur</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPk</name> <operator>||</operator> <call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>iIdxCur</name><operator>==</operator><name>iDataCur</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_MULTI</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHereOrPopInst</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iAddrOnce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* Set up a loop over the rowids/primary-keys that were found in the
    ** where-clause loop above.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>!=</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nKey</name><operator>==</operator><name>nPk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* OP_Found will use an unpacked key */</comment>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>aToOpen</name><index>[<expr><name>iDataCur</name><operator>-</operator><name>iTabCur</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPk</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotFound</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>addrBypass</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pPk</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>addrLoop</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iEphCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iEphCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowData</name></expr></argument>, <argument><expr><name>iEphCur</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nKey</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* OP_Found will use a composite key */</comment>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>addrLoop</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowSetRead</name></expr></argument>, <argument><expr><name>iRowSet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nKey</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>  
  
    <comment type="block">/* Delete the row */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pVTab</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VtabMakeWritable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_OFF</name> <operator>||</operator> <name>eOnePass</name><operator>==</operator><name>ONEPASS_SINGLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_SINGLE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iTabCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3IsToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>isMultiWrite</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VUpdate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>pVTab</name></expr></argument>, <argument><expr><name>P4_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OE_Abort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>    <comment type="block">/* True to count changes */</comment>
      <expr_stmt><expr><call><name>sqlite3GenerateRowDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>,
          <argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>OE_Default</name></expr></argument>, <argument><expr><name>eOnePass</name></expr></argument>, <argument><expr><name><name>aiCurOnePass</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  
    <comment type="block">/* End of the loop over all rowids/primary-keys. */</comment>
    <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>!=</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrBypass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pPk</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>iEphCur</name></expr></argument>, <argument><expr><name>addrLoop</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeGoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>     
  </block_content>}</block></else></if_stmt> <comment type="block">/* End non-truncate path */</comment>

  <comment type="block">/* Update the sqlite_sequence table by storing the content of the
  ** maximum rowid counter values recorded while inserting into
  ** autoincrement tables.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3AutoincrementEnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Return the number of rows that were deleted. If this routine is 
  ** generating code because of a call to sqlite3NestedParse(), do not
  ** invoke the callback function.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>memCnt</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3CodeChangeCount</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>memCnt</name></expr></argument>, <argument><expr><literal type="string">"rows deleted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>delete_from_cleanup</name>:</label>
  <expr_stmt><expr><call><name>sqlite3AuthContextPop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_UPDATE_DELETE_LIMIT</name></expr></argument>)</argument_list></call></expr></cpp:if> 
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aToOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>
<comment type="block">/* Make sure "isView" and other macros defined above are undefined. Otherwise
** they may interfere with compilation of other functions in this file
** (or in another file, if this file becomes part of the amalgamation).  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>isView</name></cpp:ifdef>
 <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isView</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>pTrigger</name></cpp:ifdef>
 <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>pTrigger</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine generates VDBE code that causes a single row of a
** single table to be deleted.  Both the original table entry and
** all indices are removed.
**
** Preconditions:
**
**   1.  iDataCur is an open cursor on the btree that is the canonical data
**       store for the table.  (This will be either the table itself,
**       in the case of a rowid table, or the PRIMARY KEY index in the case
**       of a WITHOUT ROWID table.)
**
**   2.  Read/write cursors for all indices of pTab must be open as
**       cursor number iIdxCur+i for the i-th index.
**
**   3.  The primary key for the row to be deleted must be stored in a
**       sequence of nPk memory cells starting at iPk.  If nPk==0 that means
**       that a search record formed from OP_MakeRecord is contained in the
**       single memory location iPk.
**
** eMode:
**   Parameter eMode may be passed either ONEPASS_OFF (0), ONEPASS_SINGLE, or
**   ONEPASS_MULTI.  If eMode is not ONEPASS_OFF, then the cursor
**   iDataCur already points to the row to delete. If eMode is ONEPASS_OFF
**   then this function must seek iDataCur to the entry identified by iPk
**   and nPk before reading from it.
**
**   If eMode is ONEPASS_MULTI, then this call is being made as part
**   of a ONEPASS delete that affects multiple rows. In this case, if 
**   iIdxNoSeek is a valid cursor number (&gt;=0) and is not the same as
**   iDataCur, then its position should be preserved following the delete
**   operation. Or, if iIdxNoSeek is not a valid cursor number, the
**   position of iDataCur should be preserved instead.
**
** iIdxNoSeek:
**   If iIdxNoSeek is a valid cursor number (&gt;=0) not equal to iDataCur,
**   then it identifies an index cursor (from within array of cursors
**   starting at iIdxCur) that already points to the index entry to be deleted.
**   Except, this optimization is disabled if there are BEFORE triggers since
**   the trigger body might have moved the cursor.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3GenerateRowDelete</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,       <comment type="block">/* Table containing the row to be deleted */</comment>
  <parameter><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pTrigger</name></decl></parameter>, <comment type="block">/* List of triggers to (potentially) fire */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDataCur</name></decl></parameter>,      <comment type="block">/* Cursor from which column data is extracted */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdxCur</name></decl></parameter>,       <comment type="block">/* First index cursor */</comment>
  <parameter><decl><type><name>int</name></type> <name>iPk</name></decl></parameter>,           <comment type="block">/* First memory cell containing the PRIMARY KEY */</comment>
  <parameter><decl><type><name>i16</name></type> <name>nPk</name></decl></parameter>,           <comment type="block">/* Number of PRIMARY KEY memory cells */</comment>
  <parameter><decl><type><name>u8</name></type> <name>count</name></decl></parameter>,          <comment type="block">/* If non-zero, increment the row change counter */</comment>
  <parameter><decl><type><name>u8</name></type> <name>onconf</name></decl></parameter>,         <comment type="block">/* Default ON CONFLICT policy for triggers */</comment>
  <parameter><decl><type><name>u8</name></type> <name>eMode</name></decl></parameter>,          <comment type="block">/* ONEPASS_OFF, _SINGLE, or _MULTI.  See above */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdxNoSeek</name></decl></parameter>     <comment type="block">/* Cursor number of cursor that does not need seeking */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Vdbe */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iOld</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* First register in OLD.* array */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLabel</name></decl>;</decl_stmt>                     <comment type="block">/* Label resolved to end of generated code */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>opSeek</name></decl>;</decl_stmt>                      <comment type="block">/* Seek opcode */</comment>

  <comment type="block">/* Vdbe is guaranteed to have been allocated by this stage. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"BEGIN: GenRowDel(%d,%d,%d,%d)"</literal><operator>,</operator>
                         <name>iDataCur</name><operator>,</operator> <name>iIdxCur</name><operator>,</operator> <name>iPk</name><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nPk</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Seek cursor iCur to the row to delete. If this row no longer exists 
  ** (this can happen if a trigger program has already deleted it), do
  ** not attempt to delete it or fire any DELETE triggers.  */</comment>
  <expr_stmt><expr><name>iLabel</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>opSeek</name> <operator>=</operator> <ternary><condition><expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>OP_NotExists</name></expr> </then><else>: <expr><name>OP_NotFound</name></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eMode</name><operator>==</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>opSeek</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iLabel</name></expr></argument>, <argument><expr><name>iPk</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>opSeek</name><operator>==</operator><name>OP_NotExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>opSeek</name><operator>==</operator><name>OP_NotFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
 
  <comment type="block">/* If there are any triggers to fire, allocate a range of registers to
  ** use for the old.* references in the triggers.  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3FkRequired</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name>pTrigger</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>mask</name></decl>;</decl_stmt>                     <comment type="block">/* Mask of OLD.* columns in use */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                     <comment type="block">/* Iterator used while populating OLD.* */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>addrStart</name></decl>;</decl_stmt>                <comment type="block">/* Start of BEFORE trigger programs */</comment>

    <comment type="block">/* TODO: Could use temporary registers here. Also could attempt to
    ** avoid copying the contents of the rowid register.  */</comment>
    <expr_stmt><expr><name>mask</name> <operator>=</operator> <call><name>sqlite3TriggerColmask</name><argument_list>(
        <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRIGGER_BEFORE</name><operator>|</operator><name>TRIGGER_AFTER</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>onconf</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> <operator>|=</operator> <call><name>sqlite3FkOldmask</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOld</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Populate the OLD.* pseudo-table register array. These values will be 
    ** used by any BEFORE and AFTER triggers that exist.  */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>iPk</name></expr></argument>, <argument><expr><name>iOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>mask</name><operator>!=</operator><literal type="number">0xffffffff</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>==</operator><literal type="number">31</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>mask</name><operator>!=</operator><literal type="number">0xffffffff</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>==</operator><literal type="number">32</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>mask</name><operator>==</operator><literal type="number">0xffffffff</literal> <operator>||</operator> <operator>(</operator><name>iCol</name><operator>&lt;=</operator><literal type="number">31</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>mask</name> <operator>&amp;</operator> <call><name>MASKBIT32</name><argument_list>(<argument><expr><name>iCol</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>kk</name> <init>= <expr><call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>iOld</name><operator>+</operator><name>kk</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Invoke BEFORE DELETE trigger programs. */</comment>
    <expr_stmt><expr><name>addrStart</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3CodeRowTrigger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, 
        <argument><expr><name>TK_DELETE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRIGGER_BEFORE</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iOld</name></expr></argument>, <argument><expr><name>onconf</name></expr></argument>, <argument><expr><name>iLabel</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If any BEFORE triggers were coded, then seek the cursor to the 
    ** row to be deleted again. It may be that the BEFORE triggers moved
    ** the cursor or already deleted the row that the cursor was
    ** pointing to.
    **
    ** Also disable the iIdxNoSeek optimization since the BEFORE trigger
    ** may have moved that cursor.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>addrStart</name><operator>&lt;</operator><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>opSeek</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iLabel</name></expr></argument>, <argument><expr><name>iPk</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>opSeek</name><operator>==</operator><name>OP_NotExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>opSeek</name><operator>==</operator><name>OP_NotFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iIdxNoSeek</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iIdxNoSeek</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Do FK processing. This call checks that any FK constraints that
    ** refer to this table (i.e. constraints attached to other tables) 
    ** are not violated by deleting this row.  */</comment>
    <expr_stmt><expr><call><name>sqlite3FkCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iOld</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Delete the index and table entries. Skip this step if pTab is really
  ** a view (in which case the only effect of the DELETE statement is to
  ** fire the INSTEAD OF triggers).  
  **
  ** If variable 'count' is non-zero, then this OP_Delete instruction should
  ** invoke the update-hook. The pre-update-hook, on the other hand should
  ** be invoked unless table pTab is a system table. The difference is that
  ** the update-hook is not invoked for rows removed by REPLACE, but the 
  ** pre-update-hook is.
  */</comment> 
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>p5</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3GenerateRowIndexDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>iIdxNoSeek</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Delete</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>count</name></expr>?</condition><then><expr><name>OPFLAG_NCHANGE</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="string">"sqlite_stat1"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pTab</name></expr></argument>, <argument><expr><name>P4_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eMode</name><operator>!=</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_AUXDELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iIdxNoSeek</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iIdxNoSeek</name><operator>!=</operator><name>iDataCur</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Delete</name></expr></argument>, <argument><expr><name>iIdxNoSeek</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eMode</name><operator>==</operator><name>ONEPASS_MULTI</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p5</name> <operator>|=</operator> <name>OPFLAG_SAVEPOSITION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>p5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Do any ON CASCADE, SET NULL or SET DEFAULT operations required to
  ** handle rows (possibly in other tables) that refer via a foreign key
  ** to the row just deleted. */</comment> 
  <expr_stmt><expr><call><name>sqlite3FkActions</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iOld</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Invoke AFTER DELETE trigger programs. */</comment>
  <expr_stmt><expr><call><name>sqlite3CodeRowTrigger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, 
      <argument><expr><name>TK_DELETE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRIGGER_AFTER</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iOld</name></expr></argument>, <argument><expr><name>onconf</name></expr></argument>, <argument><expr><name>iLabel</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Jump here if the row had already been deleted before any BEFORE
  ** trigger programs were invoked. Or if a trigger program throws a 
  ** RAISE(IGNORE) exception.  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"END: GenRowDel()"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine generates VDBE code that causes the deletion of all
** index entries associated with a single row of a single table, pTab
**
** Preconditions:
**
**   1.  A read/write cursor "iDataCur" must be open on the canonical storage
**       btree for the table pTab.  (This will be either the table itself
**       for rowid tables or to the primary key index for WITHOUT ROWID
**       tables.)
**
**   2.  Read/write cursors for all indices of pTab must be open as
**       cursor number iIdxCur+i for the i-th index.  (The pTab-&gt;pIndex
**       index is the 0-th index.)
**
**   3.  The "iDataCur" cursor must be already be positioned on the row
**       that is to be deleted.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3GenerateRowIndexDelete</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Parsing and code generating context */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,       <comment type="block">/* Table containing the row to be deleted */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDataCur</name></decl></parameter>,      <comment type="block">/* Cursor of table holding data. */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdxCur</name></decl></parameter>,       <comment type="block">/* First index cursor */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aRegIdx</name></decl></parameter>,      <comment type="block">/* Only delete if aRegIdx!=0 &amp;&amp; aRegIdx[i]&gt;0 */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdxNoSeek</name></decl></parameter>     <comment type="block">/* Do not delete from this cursor */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>             <comment type="block">/* Index loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Register holding an index key */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPartIdxLabel</name></decl>;</decl_stmt> <comment type="block">/* Jump destination for skipping partial index entries */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>       <comment type="block">/* Current index */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPrior</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Prior index */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>           <comment type="block">/* The prepared statement under construction */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name></decl>;</decl_stmt>        <comment type="block">/* PRIMARY KEY index, or NULL for rowid tables */</comment>

  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPk</name> <operator>=</operator> <ternary><condition><expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIdxCur</name><operator>+</operator><name>i</name><operator>!=</operator><name>iDataCur</name> <operator>||</operator> <name>pPk</name><operator>==</operator><name>pIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aRegIdx</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pIdx</name><operator>==</operator><name>pPk</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iIdxCur</name><operator>+</operator><name>i</name><operator>==</operator><name>iIdxNoSeek</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>VdbeModuleComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"GenRowIdxDel for %s"</literal><operator>,</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>zName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3GenerateIndexKey</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>iPartIdxLabel</name></expr></argument>, <argument><expr><name>pPrior</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxDelete</name></expr></argument>, <argument><expr><name>iIdxCur</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>,
        <argument><expr><ternary><condition><expr><name><name>pIdx</name><operator>-&gt;</operator><name>uniqNotNull</name></name></expr> ?</condition><then> <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr> </then><else>: <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Cause IdxDelete to error if no entry found */</comment>
    <expr_stmt><expr><call><name>sqlite3ResolvePartIdxLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iPartIdxLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPrior</name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that will assemble an index key and stores it in register
** regOut.  The key with be for index pIdx which is an index on pTab.
** iCur is the index of a cursor open on the pTab table and pointing to
** the entry that needs indexing.  If pTab is a WITHOUT ROWID table, then
** iCur must be the cursor of the PRIMARY KEY index.
**
** Return a register number which is the first in a block of
** registers that holds the elements of the index key.  The
** block of registers has already been deallocated by the time
** this routine returns.
**
** If *piPartIdxLabel is not NULL, fill it in with a label and jump
** to that label if pIdx is a partial index that should be skipped.
** The label should be resolved using sqlite3ResolvePartIdxLabel().
** A partial index should be skipped if its WHERE clause evaluates
** to false or null.  If pIdx is not a partial index, *piPartIdxLabel
** will be set to zero which is an empty label that is ignored by
** sqlite3ResolvePartIdxLabel().
**
** The pPrior and regPrior parameters are used to implement a cache to
** avoid unnecessary register loads.  If pPrior is not NULL, then it is
** a pointer to a different index for which an index key has just been
** computed into register regPrior.  If the current pIdx index is generating
** its key into the same sequence of registers and if pPrior and pIdx share
** a column in common, then the register corresponding to that column already
** holds the correct value and the loading of that register is skipped.
** This optimization is helpful when doing a DELETE or an INTEGRITY_CHECK 
** on a table with multiple indices, and especially with the ROWID or
** PRIMARY KEY columns of the index.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3GenerateIndexKey</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,         <comment type="block">/* The index for which to generate a key */</comment>
  <parameter><decl><type><name>int</name></type> <name>iDataCur</name></decl></parameter>,        <comment type="block">/* Cursor number from which to take column data */</comment>
  <parameter><decl><type><name>int</name></type> <name>regOut</name></decl></parameter>,          <comment type="block">/* Put the new key into this register if not 0 */</comment>
  <parameter><decl><type><name>int</name></type> <name>prefixOnly</name></decl></parameter>,      <comment type="block">/* Compute only a unique prefix of the key */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piPartIdxLabel</name></decl></parameter>, <comment type="block">/* OUT: Jump to this label to skip partial index */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPrior</name></decl></parameter>,       <comment type="block">/* Previously generated index key */</comment>
  <parameter><decl><type><name>int</name></type> <name>regPrior</name></decl></parameter>         <comment type="block">/* Register holding previous generated key */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regBase</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>piPartIdxLabel</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piPartIdxLabel</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <name>iDataCur</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalseDup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>, <argument><expr><operator>*</operator><name>piPartIdxLabel</name></expr></argument>, 
                            <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iSelfTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPrior</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Ticket a9efb42811fa41ee 2019-11-02;
                  ** pPartIdxWhere may have corrupted regPrior registers */</comment>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piPartIdxLabel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nCol</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>prefixOnly</name> <operator>&amp;&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>uniqNotNull</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr> </then><else>: <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>regBase</name> <operator>=</operator> <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPrior</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>regBase</name><operator>!=</operator><name>regPrior</name> <operator>||</operator> <name><name>pPrior</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pPrior</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pPrior</name>
     <operator>&amp;&amp;</operator> <name><name>pPrior</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name>
     <operator>&amp;&amp;</operator> <name><name>pPrior</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><name>XN_EXPR</name></expr>
    )</condition><block>{<block_content>
      <comment type="block">/* This column was already computed by the previous index */</comment>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCodeLoadIndexColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>regBase</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* If the column affinity is REAL but the number is an integer, then it
      ** might be stored in the table as an integer (using a compact
      ** representation) then converted to REAL by an OP_RealAffinity opcode.
      ** But we are getting ready to store this value back into an index, where
      ** it should be converted by to INTEGER again.  So omit the
      ** OP_RealAffinity opcode if it is present */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeDeletePriorOpcode</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RealAffinity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>regOut</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>regBase</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If a prior call to sqlite3GenerateIndexKey() generated a jump-over label
** because it was a partial index, then this routine should be called to
** resolve that label.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ResolvePartIdxLabel</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLabel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iLabel</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>iLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
