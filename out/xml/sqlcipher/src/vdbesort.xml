<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/vdbesort.c"><comment type="block">/*
** 2011-07-09
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code for the VdbeSorter object, used in concert with
** a VdbeCursor to sort large numbers of keys for CREATE INDEX statements
** or by SELECT statements with ORDER BY clauses that cannot be satisfied
** using indexes and without LIMIT clauses.
**
** The VdbeSorter object implements a multi-threaded external merge sort
** algorithm that is efficient even if the number of elements being sorted
** exceeds the available memory.
**
** Here is the (internal, non-API) interface between this module and the
** rest of the SQLite system:
**
**    sqlite3VdbeSorterInit()       Create a new VdbeSorter object.
**
**    sqlite3VdbeSorterWrite()      Add a single new row to the VdbeSorter
**                                  object.  The row is a binary blob in the
**                                  OP_MakeRecord format that contains both
**                                  the ORDER BY key columns and result columns
**                                  in the case of a SELECT w/ ORDER BY, or
**                                  the complete record for an index entry
**                                  in the case of a CREATE INDEX.
**
**    sqlite3VdbeSorterRewind()     Sort all content previously added.
**                                  Position the read cursor on the
**                                  first sorted element.
**
**    sqlite3VdbeSorterNext()       Advance the read cursor to the next sorted
**                                  element.
**
**    sqlite3VdbeSorterRowkey()     Return the complete binary blob for the
**                                  row currently under the read cursor.
**
**    sqlite3VdbeSorterCompare()    Compare the binary blob for the row
**                                  currently under the read cursor against
**                                  another binary blob X and report if
**                                  X is strictly less than the read cursor.
**                                  Used to enforce uniqueness in a
**                                  CREATE UNIQUE INDEX statement.
**
**    sqlite3VdbeSorterClose()      Close the VdbeSorter object and reclaim
**                                  all resources.
**
**    sqlite3VdbeSorterReset()      Refurbish the VdbeSorter for reuse.  This
**                                  is like Close() followed by Init() only
**                                  much faster.
**
** The interfaces above must be called in a particular order.  Write() can 
** only occur in between Init()/Reset() and Rewind().  Next(), Rowkey(), and
** Compare() can only occur in between Rewind() and Close()/Reset(). i.e.
**
**   Init()
**   for each record: Write()
**   Rewind()
**     Rowkey()/Compare()
**   Next() 
**   Close()
**
** Algorithm:
**
** Records passed to the sorter via calls to Write() are initially held 
** unsorted in main memory. Assuming the amount of memory used never exceeds
** a threshold, when Rewind() is called the set of records is sorted using
** an in-memory merge sort. In this case, no temporary files are required
** and subsequent calls to Rowkey(), Next() and Compare() read records 
** directly from main memory.
**
** If the amount of space used to store records in main memory exceeds the
** threshold, then the set of records currently in memory are sorted and
** written to a temporary file in "Packed Memory Array" (PMA) format.
** A PMA created at this point is known as a "level-0 PMA". Higher levels
** of PMAs may be created by merging existing PMAs together - for example
** merging two or more level-0 PMAs together creates a level-1 PMA.
**
** The threshold for the amount of main memory to use before flushing 
** records to a PMA is roughly the same as the limit configured for the
** page-cache of the main database. Specifically, the threshold is set to 
** the value returned by "PRAGMA main.page_size" multipled by 
** that returned by "PRAGMA main.cache_size", in bytes.
**
** If the sorter is running in single-threaded mode, then all PMAs generated
** are appended to a single temporary file. Or, if the sorter is running in
** multi-threaded mode then up to (N+1) temporary files may be opened, where
** N is the configured number of worker threads. In this case, instead of
** sorting the records and writing the PMA to a temporary file itself, the
** calling thread usually launches a worker thread to do so. Except, if
** there are already N worker threads running, the main thread does the work
** itself.
**
** The sorter is running in multi-threaded mode if (a) the library was built
** with pre-processor symbol SQLITE_MAX_WORKER_THREADS set to a value greater
** than zero, and (b) worker threads have been enabled at runtime by calling
** "PRAGMA threads=N" with some value of N greater than 0.
**
** When Rewind() is called, any data remaining in memory is flushed to a 
** final PMA. So at this point the data is stored in some number of sorted
** PMAs within temporary files on disk.
**
** If there are fewer than SORTER_MAX_MERGE_COUNT PMAs in total and the
** sorter is running in single-threaded mode, then these PMAs are merged
** incrementally as keys are retreived from the sorter by the VDBE.  The
** MergeEngine object, described in further detail below, performs this
** merge.
**
** Or, if running in multi-threaded mode, then a background thread is
** launched to merge the existing PMAs. Once the background thread has
** merged T bytes of data into a single sorted PMA, the main thread 
** begins reading keys from that PMA while the background thread proceeds
** with merging the next T bytes of data. And so on.
**
** Parameter T is set to half the value of the memory threshold used 
** by Write() above to determine when to create a new PMA.
**
** If there are more than SORTER_MAX_MERGE_COUNT PMAs in total when 
** Rewind() is called, then a hierarchy of incremental-merges is used. 
** First, T bytes of data from the first SORTER_MAX_MERGE_COUNT PMAs on 
** disk are merged together. Then T bytes of data from the second set, and
** so on, such that no operation ever merges more than SORTER_MAX_MERGE_COUNT
** PMAs at a time. This done is to improve locality.
**
** If running in multi-threaded mode and there are more than
** SORTER_MAX_MERGE_COUNT PMAs on disk when Rewind() is called, then more
** than one background thread may be created. Specifically, there may be
** one background thread for each temporary file on disk, and one background
** thread to merge the output of each of the others to a single PMA for
** the main thread to read from.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>

<comment type="block">/* 
** If SQLITE_DEBUG_SORTER_THREADS is defined, this module outputs various
** messages to stderr that may be helpful in understanding the performance
** characteristics of the sorter in multi-threaded mode.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_DEBUG_SORTER_THREADS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Hard-coded maximum amount of data to accumulate in memory before flushing
** to a level 0 PMA. The purpose of this limit is to prevent various integer
** overflows. 512MiB.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_MAX_PMASZ</name></cpp:macro>    <cpp:value>(1&lt;&lt;29)</cpp:value></cpp:define>

<comment type="block">/*
** Private objects used by the sorter
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>MergeEngine</name></name></type> <name>MergeEngine</name>;</typedef>     <comment type="block">/* Merge PMAs together */</comment>
<typedef>typedef <type><name><name>struct</name> <name>PmaReader</name></name></type> <name>PmaReader</name>;</typedef>         <comment type="block">/* Incrementally read one PMA */</comment>
<typedef>typedef <type><name><name>struct</name> <name>PmaWriter</name></name></type> <name>PmaWriter</name>;</typedef>         <comment type="block">/* Incrementally write one PMA */</comment>
<typedef>typedef <type><name><name>struct</name> <name>SorterRecord</name></name></type> <name>SorterRecord</name>;</typedef>   <comment type="block">/* A record being sorted */</comment>
<typedef>typedef <type><name><name>struct</name> <name>SortSubtask</name></name></type> <name>SortSubtask</name>;</typedef>     <comment type="block">/* A sub-task in the sort process */</comment>
<typedef>typedef <type><name><name>struct</name> <name>SorterFile</name></name></type> <name>SorterFile</name>;</typedef>       <comment type="block">/* Temporary file object wrapper */</comment>
<typedef>typedef <type><name><name>struct</name> <name>SorterList</name></name></type> <name>SorterList</name>;</typedef>       <comment type="block">/* In-memory list of records */</comment>
<typedef>typedef <type><name><name>struct</name> <name>IncrMerger</name></name></type> <name>IncrMerger</name>;</typedef>       <comment type="block">/* Read &amp; merge multiple PMAs */</comment>

<comment type="block">/*
** A container for a temp file handle and the current amount of data 
** stored in the file.
*/</comment>
<struct>struct <name>SorterFile</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl>;</decl_stmt>              <comment type="block">/* File handle */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iEof</name></decl>;</decl_stmt>                       <comment type="block">/* Bytes of data stored in pFd */</comment>
}</block>;</struct>

<comment type="block">/*
** An in-memory list of objects to be sorted.
**
** If aMemory==0 then each object is allocated separately and the objects
** are connected using SorterRecord.u.pNext.  If aMemory!=0 then all objects
** are stored in the aMemory[] bulk memory, one right after the other, and
** are connected using SorterRecord.u.iNext.
*/</comment>
<struct>struct <name>SorterList</name> <block>{
  <decl_stmt><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>            <comment type="block">/* Linked list of records */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aMemory</name></decl>;</decl_stmt>                    <comment type="block">/* If non-NULL, bulk memory to hold pList */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szPMA</name></decl>;</decl_stmt>                      <comment type="block">/* Size of pList as PMA in bytes */</comment>
}</block>;</struct>

<comment type="block">/*
** The MergeEngine object is used to combine two or more smaller PMAs into
** one big PMA using a merge operation.  Separate PMAs all need to be
** combined into one big PMA in order to be able to step through the sorted
** records in order.
**
** The aReadr[] array contains a PmaReader object for each of the PMAs being
** merged.  An aReadr[] object either points to a valid key or else is at EOF.
** ("EOF" means "End Of File".  When aReadr[] is at EOF there is no more data.)
** For the purposes of the paragraphs below, we assume that the array is
** actually N elements in size, where N is the smallest power of 2 greater
** to or equal to the number of PMAs being merged. The extra aReadr[] elements
** are treated as if they are empty (always at EOF).
**
** The aTree[] array is also N elements in size. The value of N is stored in
** the MergeEngine.nTree variable.
**
** The final (N/2) elements of aTree[] contain the results of comparing
** pairs of PMA keys together. Element i contains the result of 
** comparing aReadr[2*i-N] and aReadr[2*i-N+1]. Whichever key is smaller, the
** aTree element is set to the index of it. 
**
** For the purposes of this comparison, EOF is considered greater than any
** other key value. If the keys are equal (only possible with two EOF
** values), it doesn't matter which index is stored.
**
** The (N/4) elements of aTree[] that precede the final (N/2) described 
** above contains the index of the smallest of each block of 4 PmaReaders
** And so on. So that aTree[1] contains the index of the PmaReader that 
** currently points to the smallest key value. aTree[0] is unused.
**
** Example:
**
**     aReadr[0] -&gt; Banana
**     aReadr[1] -&gt; Feijoa
**     aReadr[2] -&gt; Elderberry
**     aReadr[3] -&gt; Currant
**     aReadr[4] -&gt; Grapefruit
**     aReadr[5] -&gt; Apple
**     aReadr[6] -&gt; Durian
**     aReadr[7] -&gt; EOF
**
**     aTree[] = { X, 5   0, 5    0, 3, 5, 6 }
**
** The current element is "Apple" (the value of the key indicated by 
** PmaReader 5). When the Next() operation is invoked, PmaReader 5 will
** be advanced to the next key in its segment. Say the next key is
** "Eggplant":
**
**     aReadr[5] -&gt; Eggplant
**
** The contents of aTree[] are updated first by comparing the new PmaReader
** 5 key to the current key of PmaReader 4 (still "Grapefruit"). The PmaReader
** 5 value is still smaller, so aTree[6] is set to 5. And so on up the tree.
** The value of PmaReader 6 - "Durian" - is now smaller than that of PmaReader
** 5, so aTree[3] is set to 6. Key 0 is smaller than key 6 (Banana&lt;Durian),
** so the value written into element 1 of the array is 0. As follows:
**
**     aTree[] = { X, 0   0, 6    0, 3, 5, 6 }
**
** In other words, each time we advance to the next sorter element, log2(N)
** key comparison operations are required, where N is the number of segments
** being merged (rounded up to the next power of 2).
*/</comment>
<struct>struct <name>MergeEngine</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nTree</name></decl>;</decl_stmt>                 <comment type="block">/* Used size of aTree/aReadr (power of 2) */</comment>
  <decl_stmt><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl>;</decl_stmt>        <comment type="block">/* Used by this thread only */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aTree</name></decl>;</decl_stmt>                <comment type="block">/* Current state of incremental merge */</comment>
  <decl_stmt><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>aReadr</name></decl>;</decl_stmt>         <comment type="block">/* Array of PmaReaders to merge data from */</comment>
}</block>;</struct>

<comment type="block">/*
** This object represents a single thread of control in a sort operation.
** Exactly VdbeSorter.nTask instances of this object are allocated
** as part of each VdbeSorter object. Instances are never allocated any
** other way. VdbeSorter.nTask is set to the number of worker threads allowed
** (see SQLITE_CONFIG_WORKER_THREADS) plus one (the main thread).  Thus for
** single-threaded operation, there is exactly one instance of this object
** and for multi-threaded operation there are two or more instances.
**
** Essentially, this structure contains all those fields of the VdbeSorter
** structure for which each thread requires a separate instance. For example,
** each thread requries its own UnpackedRecord object to unpack records in
** as part of comparison operations.
**
** Before a background thread is launched, variable bDone is set to 0. Then, 
** right before it exits, the thread itself sets bDone to 1. This is used for 
** two purposes:
**
**   1. When flushing the contents of memory to a level-0 PMA on disk, to
**      attempt to select a SortSubtask for which there is not already an
**      active background thread (since doing so causes the main thread
**      to block until it finishes).
**
**   2. If SQLITE_DEBUG_SORTER_THREADS is defined, to determine if a call
**      to sqlite3ThreadJoin() is likely to block. Cases that are likely to
**      block provoke debugging output.
**
** In both cases, the effects of the main thread seeing (bDone==0) even
** after the thread has finished are not dire. So we don't worry about
** memory barriers and such here.
*/</comment>
<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>SorterCompare</name>)<parameter_list>(<parameter><decl><type><name>SortSubtask</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<struct>struct <name>SortSubtask</name> <block>{
  <decl_stmt><decl><type><name>SQLiteThread</name> <modifier>*</modifier></type><name>pThread</name></decl>;</decl_stmt>          <comment type="block">/* Background thread, if any */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bDone</name></decl>;</decl_stmt>                      <comment type="block">/* Set if thread is finished but not joined */</comment>
  <decl_stmt><decl><type><name>VdbeSorter</name> <modifier>*</modifier></type><name>pSorter</name></decl>;</decl_stmt>            <comment type="block">/* Sorter that owns this sub-task */</comment>
  <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pUnpacked</name></decl>;</decl_stmt>      <comment type="block">/* Space to unpack a record */</comment>
  <decl_stmt><decl><type><name>SorterList</name></type> <name>list</name></decl>;</decl_stmt>                <comment type="block">/* List for thread to write to a PMA */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPMA</name></decl>;</decl_stmt>                       <comment type="block">/* Number of PMAs currently in file */</comment>
  <decl_stmt><decl><type><name>SorterCompare</name></type> <name>xCompare</name></decl>;</decl_stmt>         <comment type="block">/* Compare function to use */</comment>
  <decl_stmt><decl><type><name>SorterFile</name></type> <name>file</name></decl>;</decl_stmt>                <comment type="block">/* Temp file for level-0 PMAs */</comment>
  <decl_stmt><decl><type><name>SorterFile</name></type> <name>file2</name></decl>;</decl_stmt>               <comment type="block">/* Space for other PMAs */</comment>
}</block>;</struct>


<comment type="block">/*
** Main sorter structure. A single instance of this is allocated for each 
** sorter cursor created by the VDBE.
**
** mxKeysize:
**   As records are added to the sorter by calls to sqlite3VdbeSorterWrite(),
**   this variable is updated so as to be set to the size on disk of the
**   largest record in the sorter.
*/</comment>
<struct>struct <name>VdbeSorter</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>mnPmaSize</name></decl>;</decl_stmt>                  <comment type="block">/* Minimum PMA size, in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mxPmaSize</name></decl>;</decl_stmt>                  <comment type="block">/* Maximum PMA size, in bytes.  0==no limit */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mxKeysize</name></decl>;</decl_stmt>                  <comment type="block">/* Largest serialized key seen so far */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pgsz</name></decl>;</decl_stmt>                       <comment type="block">/* Main database page size */</comment>
  <decl_stmt><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReader</name></decl>;</decl_stmt>             <comment type="block">/* Readr data from here after Rewind() */</comment>
  <decl_stmt><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pMerger</name></decl>;</decl_stmt>           <comment type="block">/* Or here, if bUseThreads==0 */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                    <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>              <comment type="block">/* How to compare records */</comment>
  <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pUnpacked</name></decl>;</decl_stmt>      <comment type="block">/* Used by VdbeSorterCompare() */</comment>
  <decl_stmt><decl><type><name>SorterList</name></type> <name>list</name></decl>;</decl_stmt>                <comment type="block">/* List of in-memory records */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iMemory</name></decl>;</decl_stmt>                    <comment type="block">/* Offset of free space in list.aMemory */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMemory</name></decl>;</decl_stmt>                    <comment type="block">/* Size of list.aMemory allocation in bytes */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bUsePMA</name></decl>;</decl_stmt>                     <comment type="block">/* True if one or more PMAs created */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bUseThreads</name></decl>;</decl_stmt>                 <comment type="block">/* True to use background threads */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>iPrev</name></decl>;</decl_stmt>                       <comment type="block">/* Previous thread used to flush PMA */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nTask</name></decl>;</decl_stmt>                       <comment type="block">/* Size of aTask[] array */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>typeMask</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SortSubtask</name></type> <name><name>aTask</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>           <comment type="block">/* One or more subtasks */</comment>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SORTER_TYPE_INTEGER</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SORTER_TYPE_TEXT</name></cpp:macro>    <cpp:value>0x02</cpp:value></cpp:define>

<comment type="block">/*
** An instance of the following object is used to read records out of a
** PMA, in sorted order.  The next key to be read is cached in nKey/aKey.
** aKey might point into aMap or into aBuffer.  If neither of those locations
** contain a contiguous representation of the key, then aAlloc is allocated
** and the key is copied into aAlloc and aKey is made to poitn to aAlloc.
**
** pFd==0 at EOF.
*/</comment>
<struct>struct <name>PmaReader</name> <block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>iReadOff</name></decl>;</decl_stmt>               <comment type="block">/* Current read offset */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iEof</name></decl>;</decl_stmt>                   <comment type="block">/* 1 byte past EOF for this PmaReader */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>                 <comment type="block">/* Bytes of space at aAlloc */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>                   <comment type="block">/* Number of bytes in key */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl>;</decl_stmt>          <comment type="block">/* File handle we are reading from */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aAlloc</name></decl>;</decl_stmt>                 <comment type="block">/* Space for aKey if aBuffer and pMap wont work */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aKey</name></decl>;</decl_stmt>                   <comment type="block">/* Pointer to current key */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuffer</name></decl>;</decl_stmt>                <comment type="block">/* Current read buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuffer</name></decl>;</decl_stmt>                <comment type="block">/* Size of read buffer in bytes */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aMap</name></decl>;</decl_stmt>                   <comment type="block">/* Pointer to mapping of entire file */</comment>
  <decl_stmt><decl><type><name>IncrMerger</name> <modifier>*</modifier></type><name>pIncr</name></decl>;</decl_stmt>          <comment type="block">/* Incremental merger */</comment>
}</block>;</struct>

<comment type="block">/*
** Normally, a PmaReader object iterates through an existing PMA stored 
** within a temp file. However, if the PmaReader.pIncr variable points to
** an object of the following type, it may be used to iterate/merge through
** multiple PMAs simultaneously.
**
** There are two types of IncrMerger object - single (bUseThread==0) and 
** multi-threaded (bUseThread==1). 
**
** A multi-threaded IncrMerger object uses two temporary files - aFile[0] 
** and aFile[1]. Neither file is allowed to grow to more than mxSz bytes in 
** size. When the IncrMerger is initialized, it reads enough data from 
** pMerger to populate aFile[0]. It then sets variables within the 
** corresponding PmaReader object to read from that file and kicks off 
** a background thread to populate aFile[1] with the next mxSz bytes of 
** sorted record data from pMerger. 
**
** When the PmaReader reaches the end of aFile[0], it blocks until the
** background thread has finished populating aFile[1]. It then exchanges
** the contents of the aFile[0] and aFile[1] variables within this structure,
** sets the PmaReader fields to read from the new aFile[0] and kicks off
** another background thread to populate the new aFile[1]. And so on, until
** the contents of pMerger are exhausted.
**
** A single-threaded IncrMerger does not open any temporary files of its
** own. Instead, it has exclusive access to mxSz bytes of space beginning
** at offset iStartOff of file pTask-&gt;file2. And instead of using a 
** background thread to prepare data for the PmaReader, with a single
** threaded IncrMerger the allocate part of pTask-&gt;file2 is "refilled" with
** keys from pMerger by the calling thread whenever the PmaReader runs out
** of data.
*/</comment>
<struct>struct <name>IncrMerger</name> <block>{
  <decl_stmt><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl>;</decl_stmt>             <comment type="block">/* Task that owns this merger */</comment>
  <decl_stmt><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pMerger</name></decl>;</decl_stmt>           <comment type="block">/* Merge engine thread reads data from */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iStartOff</name></decl>;</decl_stmt>                  <comment type="block">/* Offset to start writing file at */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mxSz</name></decl>;</decl_stmt>                       <comment type="block">/* Maximum bytes of data to store */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bEof</name></decl>;</decl_stmt>                       <comment type="block">/* Set to true when merge is finished */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bUseThread</name></decl>;</decl_stmt>                 <comment type="block">/* True to use a bg thread for this object */</comment>
  <decl_stmt><decl><type><name>SorterFile</name></type> <name><name>aFile</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>            <comment type="block">/* aFile[0] for reading, [1] for writing */</comment>
}</block>;</struct>

<comment type="block">/*
** An instance of this object is used for writing a PMA.
**
** The PMA is written one record at a time.  Each record is of an arbitrary
** size.  But I/O is more efficient if it occurs in page-sized blocks where
** each block is aligned on a page boundary.  This object caches writes to
** the PMA so that aligned, page-size blocks are written.
*/</comment>
<struct>struct <name>PmaWriter</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>eFWErr</name></decl>;</decl_stmt>                     <comment type="block">/* Non-zero if in an error state */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuffer</name></decl>;</decl_stmt>                    <comment type="block">/* Pointer to write buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuffer</name></decl>;</decl_stmt>                    <comment type="block">/* Size of write buffer in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBufStart</name></decl>;</decl_stmt>                  <comment type="block">/* First byte of buffer to write */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBufEnd</name></decl>;</decl_stmt>                    <comment type="block">/* Last byte of buffer to write */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iWriteOff</name></decl>;</decl_stmt>                  <comment type="block">/* Offset of start of buffer in file */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl>;</decl_stmt>              <comment type="block">/* File handle to write to */</comment>
}</block>;</struct>

<comment type="block">/*
** This object is the header on a single record while that record is being
** held in memory and prior to being written out as part of a PMA.
**
** How the linked list is connected depends on how memory is being managed
** by this module. If using a separate allocation for each in-memory record
** (VdbeSorter.list.aMemory==0), then the list is always connected using the
** SorterRecord.u.pNext pointers.
**
** Or, if using the single large allocation method (VdbeSorter.list.aMemory!=0),
** then while records are being accumulated the list is linked using the
** SorterRecord.u.iNext offset. This is because the aMemory[] array may
** be sqlite3Realloc()ed while records are being accumulated. Once the VM
** has finished passing records to the sorter, or when the in-memory buffer
** is full, the list is sorted. As part of the sorting process, it is
** converted to use the SorterRecord.u.pNext pointers. See function
** vdbeSorterSort() for details.
*/</comment>
<struct>struct <name>SorterRecord</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>                       <comment type="block">/* Size of the record in bytes */</comment>
  <union>union <block>{
    <decl_stmt><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>          <comment type="block">/* Pointer to next record in list */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iNext</name></decl>;</decl_stmt>                    <comment type="block">/* Offset within aMemory of next record */</comment>
  }</block> <decl><name>u</name></decl>;</union>
  <comment type="block">/* The data for the record immediately follows this header */</comment>
}</block>;</struct>

<comment type="block">/* Return a pointer to the buffer containing the record data for SorterRecord
** object p. Should be used as if:
**
**   void *SRVAL(SorterRecord *p) { return (void*)&amp;p[1]; }
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SRVAL</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void*)((SorterRecord*)(p) + 1))</cpp:value></cpp:define>


<comment type="block">/* Maximum number of PMAs that a single MergeEngine can merge */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SORTER_MAX_MERGE_COUNT</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>vdbeIncrSwap</name><parameter_list>(<parameter><decl><type><name>IncrMerger</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vdbeIncrFree</name><parameter_list>(<parameter><decl><type><name>IncrMerger</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Free all memory belonging to the PmaReader object passed as the
** argument. All structure fields are set to zero before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbePmaReaderClear</name><parameter_list>(<parameter><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReadr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pReadr</name><operator>-&gt;</operator><name>aAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pReadr</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pReadr</name><operator>-&gt;</operator><name>aMap</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3OsUnfetch</name><argument_list>(<argument><expr><name><name>pReadr</name><operator>-&gt;</operator><name>pFd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pReadr</name><operator>-&gt;</operator><name>aMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>vdbeIncrFree</name><argument_list>(<argument><expr><name><name>pReadr</name><operator>-&gt;</operator><name>pIncr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pReadr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PmaReader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Read the next nByte bytes of data from the PMA p.
** If successful, set *ppOut to point to a buffer containing the data
** and return SQLITE_OK. Otherwise, if an error occurs, return an SQLite
** error code.
**
** The buffer returned in *ppOut is only valid until the
** next call to this function.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbePmaReadBlob</name><parameter_list>(
  <parameter><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* PmaReader from which to take the blob */</comment>
  <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>,                      <comment type="block">/* Bytes of data to read */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>                      <comment type="block">/* OUT: Pointer to buffer containing data */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iBuf</name></decl>;</decl_stmt>                       <comment type="block">/* Offset within buffer to read from */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAvail</name></decl>;</decl_stmt>                     <comment type="block">/* Bytes of data available in buffer */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aMap</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMap</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iReadOff</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iReadOff</name></name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there is no more data to be read from the buffer, read the next 
  ** p-&gt;nBuffer bytes of data from the file into it. Or, if there are less
  ** than p-&gt;nBuffer bytes remaining in the PMA, read all remaining data.  */</comment>
  <expr_stmt><expr><name>iBuf</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iReadOff</name></name> <operator>%</operator> <name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nRead</name></decl>;</decl_stmt>                    <comment type="block">/* Bytes to read from disk */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                       <comment type="block">/* sqlite3OsRead() return code */</comment>

    <comment type="block">/* Determine how many bytes of data to read. */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iEof</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>iReadOff</name></name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nRead</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nRead</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iEof</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>iReadOff</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRead</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Readr data from the file. Return early if an error occurs. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFd</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>, <argument><expr><name>nRead</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iReadOff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_IOERR_SHORT_READ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nAvail</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name> <operator>-</operator> <name>iBuf</name></expr>;</expr_stmt> 

  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&lt;=</operator><name>nAvail</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The requested data is available in the in-memory buffer. In this
    ** case there is no need to make a copy of the data, just return a 
    ** pointer into the buffer to the caller.  */</comment>
    <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name>iBuf</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iReadOff</name></name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* The requested data is not all available in the in-memory buffer.
    ** In this case, allocate space at p-&gt;aAlloc[] to copy the requested
    ** range into. Then return a copy of pointer p-&gt;aAlloc to the caller.  */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nRem</name></decl>;</decl_stmt>                     <comment type="block">/* Bytes remaining to copy */</comment>

    <comment type="block">/* Extend the p-&gt;aAlloc[] allocation if required. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>&lt;</operator><name>nByte</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nNew</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while<condition>( <expr><name>nByte</name><operator>&gt;</operator><name>nNew</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nNew</name> <operator>=</operator> <name>nNew</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>
      <expr_stmt><expr><name>aNew</name> <operator>=</operator> <call><name>sqlite3Realloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aAlloc</name></name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aNew</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aAlloc</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Copy as much data as is available in the buffer into the start of
    ** p-&gt;aAlloc[].  */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aAlloc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name>iBuf</name></expr>]</index></name></expr></argument>, <argument><expr><name>nAvail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iReadOff</name></name> <operator>+=</operator> <name>nAvail</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRem</name> <operator>=</operator> <name>nByte</name> <operator>-</operator> <name>nAvail</name></expr>;</expr_stmt>

    <comment type="block">/* The following loop copies up to p-&gt;nBuffer bytes per iteration into
    ** the p-&gt;aAlloc[] buffer.  */</comment>
    <while>while<condition>( <expr><name>nRem</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                     <comment type="block">/* vdbePmaReadBlob() return code */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name></decl>;</decl_stmt>                  <comment type="block">/* Number of bytes to copy */</comment>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aNext</name></decl>;</decl_stmt>                  <comment type="block">/* Pointer to buffer to copy data from */</comment>

      <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <name>nRem</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nRem</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReadBlob</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aNext</name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>aAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aAlloc</name><index>[<expr><name>nByte</name> <operator>-</operator> <name>nRem</name></expr>]</index></name></expr></argument>, <argument><expr><name>aNext</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <name>nCopy</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aAlloc</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read a varint from the stream of data accessed by p. Set *pnOut to
** the value read.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbePmaReadVarint</name><parameter_list>(<parameter><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u64</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iBuf</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aMap</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iReadOff</name></name> <operator>+=</operator> <call><name>sqlite3GetVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMap</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iReadOff</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>pnOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iBuf</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iReadOff</name></name> <operator>%</operator> <name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iBuf</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name><operator>-</operator><name>iBuf</name><operator>)</operator><operator>&gt;=</operator><literal type="number">9</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iReadOff</name></name> <operator>+=</operator> <call><name>sqlite3GetVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name>iBuf</name></expr>]</index></name></expr></argument>, <argument><expr><name>pnOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>u8</name></type> <name><name>aVarint</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
      <do>do<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReadBlob</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>aVarint</name><index>[<expr><operator>(</operator><name>i</name><operator>++</operator><operator>)</operator><operator>&amp;</operator><literal type="number">0xf</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
      <expr_stmt><expr><call><name>sqlite3GetVarint</name><argument_list>(<argument><expr><name>aVarint</name></expr></argument>, <argument><expr><name>pnOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to memory map file pFile. If successful, set *pp to point to the
** new mapping and return SQLITE_OK. If the mapping is not attempted 
** (because the file is too large or the VFS layer is configured not to use
** mmap), return SQLITE_OK and set *pp to NULL.
**
** Or, if an error occurs, return an SQLite error code. The final value of
** *pp is undefined in this case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterMapFile</name><parameter_list>(<parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>, <parameter><decl><type><name>SorterFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>iEof</name></name><operator>&lt;=</operator><operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nMaxSorterMmap</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>pFd</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsFetch</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>iEof</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attach PmaReader pReadr to file pFile (if it is not already attached to
** that file) and seek it to offset iOff within the file.  Return SQLITE_OK 
** if successful, or an SQLite error code if an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbePmaReaderSeek</name><parameter_list>(
  <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>,             <comment type="block">/* Task context */</comment>
  <parameter><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReadr</name></decl></parameter>,              <comment type="block">/* Reader whose cursor is to be moved */</comment>
  <parameter><decl><type><name>SorterFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,              <comment type="block">/* Sorter file to read from */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>                        <comment type="block">/* Offset in pFile */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReadr</name><operator>-&gt;</operator><name>pIncr</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pReadr</name><operator>-&gt;</operator><name>pIncr</name><operator>-&gt;</operator><name>bEof</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3FaultSim</name><argument_list>(<argument><expr><literal type="number">201</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_IOERR_READ</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pReadr</name><operator>-&gt;</operator><name>aMap</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OsUnfetch</name><argument_list>(<argument><expr><name><name>pReadr</name><operator>-&gt;</operator><name>pFd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pReadr</name><operator>-&gt;</operator><name>aMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReadr</name><operator>-&gt;</operator><name>aMap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pReadr</name><operator>-&gt;</operator><name>iReadOff</name></name> <operator>=</operator> <name>iOff</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReadr</name><operator>-&gt;</operator><name>iEof</name></name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>iEof</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReadr</name><operator>-&gt;</operator><name>pFd</name></name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pFd</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterMapFile</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReadr</name><operator>-&gt;</operator><name>aMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pReadr</name><operator>-&gt;</operator><name>aMap</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>pgsz</name> <init>= <expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>pgsz</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iBuf</name> <init>= <expr><name><name>pReadr</name><operator>-&gt;</operator><name>iReadOff</name></name> <operator>%</operator> <name>pgsz</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pReadr</name><operator>-&gt;</operator><name>aBuffer</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pReadr</name><operator>-&gt;</operator><name>aBuffer</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>pgsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pReadr</name><operator>-&gt;</operator><name>aBuffer</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pReadr</name><operator>-&gt;</operator><name>nBuffer</name></name> <operator>=</operator> <name>pgsz</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iBuf</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nRead</name> <init>= <expr><name>pgsz</name> <operator>-</operator> <name>iBuf</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pReadr</name><operator>-&gt;</operator><name>iReadOff</name></name> <operator>+</operator> <name>nRead</name><operator>)</operator> <operator>&gt;</operator> <name><name>pReadr</name><operator>-&gt;</operator><name>iEof</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nRead</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pReadr</name><operator>-&gt;</operator><name>iEof</name></name> <operator>-</operator> <name><name>pReadr</name><operator>-&gt;</operator><name>iReadOff</name></name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsRead</name><argument_list>(
          <argument><expr><name><name>pReadr</name><operator>-&gt;</operator><name>pFd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReadr</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name>iBuf</name></expr>]</index></name></expr></argument>, <argument><expr><name>nRead</name></expr></argument>, <argument><expr><name><name>pReadr</name><operator>-&gt;</operator><name>iReadOff</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance PmaReader pReadr to the next key in its PMA. Return SQLITE_OK if
** no error occurs, or an SQLite error code if one does.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbePmaReaderNext</name><parameter_list>(<parameter><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReadr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>nRec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Size of record in bytes */</comment>


  <if_stmt><if>if<condition>( <expr><name><name>pReadr</name><operator>-&gt;</operator><name>iReadOff</name></name><operator>&gt;=</operator><name><name>pReadr</name><operator>-&gt;</operator><name>iEof</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>IncrMerger</name> <modifier>*</modifier></type><name>pIncr</name> <init>= <expr><name><name>pReadr</name><operator>-&gt;</operator><name>pIncr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bEof</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pIncr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeIncrSwap</name><argument_list>(<argument><expr><name>pIncr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pIncr</name><operator>-&gt;</operator><name>bEof</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReaderSeek</name><argument_list>(
            <argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>pTask</name></name></expr></argument>, <argument><expr><name>pReadr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>iStartOff</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bEof</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>bEof</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* This is an EOF condition */</comment>
      <expr_stmt><expr><call><name>vdbePmaReaderClear</name><argument_list>(<argument><expr><name>pReadr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReadVarint</name><argument_list>(<argument><expr><name>pReadr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pReadr</name><operator>-&gt;</operator><name>nKey</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nRec</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReadBlob</name><argument_list>(<argument><expr><name>pReadr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nRec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReadr</name><operator>-&gt;</operator><name>aKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize PmaReader pReadr to scan through the PMA stored in file pFile
** starting at offset iStart and ending at offset iEof-1. This function 
** leaves the PmaReader pointing to the first key in the PMA (or EOF if the 
** PMA is empty).
**
** If the pnByte parameter is NULL, then it is assumed that the file 
** contains a single PMA, and that that PMA omits the initial length varint.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbePmaReaderInit</name><parameter_list>(
  <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>,             <comment type="block">/* Task context */</comment>
  <parameter><decl><type><name>SorterFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,              <comment type="block">/* Sorter file to read from */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iStart</name></decl></parameter>,                     <comment type="block">/* Start offset in pFile */</comment>
  <parameter><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReadr</name></decl></parameter>,              <comment type="block">/* PmaReader to populate */</comment>
  <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pnByte</name></decl></parameter>                     <comment type="block">/* IN/OUT: Increment this value by PMA size */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>iEof</name></name><operator>&gt;</operator><name>iStart</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReadr</name><operator>-&gt;</operator><name>aAlloc</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pReadr</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReadr</name><operator>-&gt;</operator><name>aBuffer</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReadr</name><operator>-&gt;</operator><name>aMap</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReaderSeek</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><name>pReadr</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Size of PMA in bytes */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReadVarint</name><argument_list>(<argument><expr><name>pReadr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReadr</name><operator>-&gt;</operator><name>iEof</name></name> <operator>=</operator> <name><name>pReadr</name><operator>-&gt;</operator><name>iReadOff</name></name> <operator>+</operator> <name>nByte</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnByte</name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReaderNext</name><argument_list>(<argument><expr><name>pReadr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A version of vdbeSorterCompare() that assumes that it has already been
** determined that the first field of key1 is equal to the first field of 
** key2.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterCompareTail</name><parameter_list>(
  <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>,             <comment type="block">/* Subtask context (for pKeyInfo) */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbKey2Cached</name></decl></parameter>,              <comment type="block">/* True if pTask-&gt;pUnpacked is pKey2 */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>,   <comment type="block">/* Left side of comparison */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>    <comment type="block">/* Right side of comparison */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>r2</name> <init>= <expr><name><name>pTask</name><operator>-&gt;</operator><name>pUnpacked</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pbKey2Cached</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeRecordUnpack</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pbKey2Cached</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>sqlite3VdbeRecordCompareWithSkip</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare key1 (buffer pKey1, size nKey1 bytes) with key2 (buffer pKey2, 
** size nKey2 bytes). Use (pTask-&gt;pKeyInfo) for the collation sequences
** used by the comparison. Return the result of the comparison.
**
** If IN/OUT parameter *pbKey2Cached is true when this function is called,
** it is assumed that (pTask-&gt;pUnpacked) contains the unpacked version
** of key2. If it is false, (pTask-&gt;pUnpacked) is populated with the unpacked
** version of key2 and *pbKey2Cached set to true before returning.
**
** If an OOM error is encountered, (pTask-&gt;pUnpacked-&gt;error_rc) is set
** to SQLITE_NOMEM.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterCompare</name><parameter_list>(
  <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>,             <comment type="block">/* Subtask context (for pKeyInfo) */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbKey2Cached</name></decl></parameter>,              <comment type="block">/* True if pTask-&gt;pUnpacked is pKey2 */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>,   <comment type="block">/* Left side of comparison */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>    <comment type="block">/* Right side of comparison */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>r2</name> <init>= <expr><name><name>pTask</name><operator>-&gt;</operator><name>pUnpacked</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>*</operator><name>pbKey2Cached</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeRecordUnpack</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pbKey2Cached</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A specially optimized version of vdbeSorterCompare() that assumes that
** the first field of each key is a TEXT value and that the collation
** sequence to compare them with is BINARY.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterCompareText</name><parameter_list>(
  <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>,             <comment type="block">/* Subtask context (for pKeyInfo) */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbKey2Cached</name></decl></parameter>,              <comment type="block">/* True if pTask-&gt;pUnpacked is pKey2 */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>,   <comment type="block">/* Left side of comparison */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>    <comment type="block">/* Right side of comparison */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>p1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>u8</name> <operator>*</operator> <specifier>const</specifier><operator>)</operator><name>pKey1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>p2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>u8</name> <operator>*</operator> <specifier>const</specifier><operator>)</operator><name>pKey2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>v1</name> <init>= <expr><operator>&amp;</operator><name><name>p1</name><index>[ <expr><name><name>p1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ]</index></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Pointer to value 1 */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>v2</name> <init>= <expr><operator>&amp;</operator><name><name>p2</name><index>[ <expr><name><name>p2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ]</index></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Pointer to value 2 */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>n1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>getVarint32NR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>n1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>getVarint32NR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>MIN</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">13</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>n1</name> <operator>-</operator> <name>n2</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nKeyField</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>vdbeSorterCompareTail</name><argument_list>(
          <argument><expr><name>pTask</name></expr></argument>, <argument><expr><name>pbKey2Cached</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><operator>(</operator><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><name>KEYINFO_ORDER_BIGNULL</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name> <operator>*</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A specially optimized version of vdbeSorterCompare() that assumes that
** the first field of each key is an INTEGER value.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterCompareInt</name><parameter_list>(
  <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>,             <comment type="block">/* Subtask context (for pKeyInfo) */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbKey2Cached</name></decl></parameter>,              <comment type="block">/* True if pTask-&gt;pUnpacked is pKey2 */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>,   <comment type="block">/* Left side of comparison */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>    <comment type="block">/* Right side of comparison */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>p1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>u8</name> <operator>*</operator> <specifier>const</specifier><operator>)</operator><name>pKey1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>p2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>u8</name> <operator>*</operator> <specifier>const</specifier><operator>)</operator><name>pKey2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>s1</name> <init>= <expr><name><name>p1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Left hand serial type */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>s2</name> <init>= <expr><name><name>p2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Right hand serial type */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>v1</name> <init>= <expr><operator>&amp;</operator><name><name>p1</name><index>[ <expr><name><name>p1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ]</index></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Pointer to value 1 */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>v2</name> <init>= <expr><operator>&amp;</operator><name><name>p2</name><index>[ <expr><name><name>p2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ]</index></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Pointer to value 2 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>                              <comment type="block">/* Return value */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>s1</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>s1</name><operator>&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>||</operator> <name>s1</name><operator>==</operator><literal type="number">8</literal> <operator>||</operator> <name>s1</name><operator>==</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>s2</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>s2</name><operator>&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>||</operator> <name>s2</name><operator>==</operator><literal type="number">8</literal> <operator>||</operator> <name>s2</name><operator>==</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>s1</name><operator>==</operator><name>s2</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The two values have the same sign. Compare using memcmp(). */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aLen</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name></type> <name>n</name> <init>= <expr><name><name>aLen</name><index>[<expr><name>s1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>res</name> <operator>=</operator> <name><name>v1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>v2</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name><name>v1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^</operator> <name><name>v2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><name><name>v1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>s1</name><operator>&gt;</operator><literal type="number">7</literal> <operator>&amp;&amp;</operator> <name>s2</name><operator>&gt;</operator><literal type="number">7</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>s1</name> <operator>-</operator> <name>s2</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>s2</name><operator>&gt;</operator><literal type="number">7</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>s1</name><operator>&gt;</operator><literal type="number">7</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <name>s1</name> <operator>-</operator> <name>s2</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>v1</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>v2</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nKeyField</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>vdbeSorterCompareTail</name><argument_list>(
          <argument><expr><name>pTask</name></expr></argument>, <argument><expr><name>pbKey2Cached</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><operator>(</operator><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><name>KEYINFO_ORDER_BIGNULL</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name> <operator>*</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize the temporary index cursor just opened as a sorter cursor.
**
** Usually, the sorter module uses the value of (pCsr-&gt;pKeyInfo-&gt;nKeyField)
** to determine the number of fields that should be compared from the
** records being sorted. However, if the value passed as argument nField
** is non-zero and the sorter is able to guarantee a stable sort, nField
** is used instead. This is used when sorting records for a CREATE INDEX
** statement. In this case, keys are always delivered to the sorter in
** order of the primary key, which happens to be make up the final part 
** of the records being sorted. So if the sort is stable, there is never
** any reason to compare PK fields and they can be ignored for a small
** performance boost.
**
** The sorter can guarantee a stable sort when running in single-threaded
** mode, but not in multi-threaded mode.
**
** SQLITE_OK is returned if successful, or an SQLite error code otherwise.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeSorterInit</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database connection (for malloc()) */</comment>
  <parameter><decl><type><name>int</name></type> <name>nField</name></decl></parameter>,                     <comment type="block">/* Number of key fields in each record */</comment>
  <parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>                <comment type="block">/* Cursor that holds the new sorter */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>pgsz</name></decl>;</decl_stmt>                       <comment type="block">/* Page size of main database */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Used to iterate through aTask[] */</comment>
  <decl_stmt><decl><type><name>VdbeSorter</name> <modifier>*</modifier></type><name>pSorter</name></decl>;</decl_stmt>            <comment type="block">/* The new sorter */</comment>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>              <comment type="block">/* Copy of pCsr-&gt;pKeyInfo with db==0 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szKeyInfo</name></decl>;</decl_stmt>                  <comment type="block">/* Size of pCsr-&gt;pKeyInfo in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>                         <comment type="block">/* Size of pSorter in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>==</operator><literal type="number">0</literal></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>nWorker</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>int</name></type> <name>nWorker</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Initialize the upper limit on the number of worker threads */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3TempInMemory</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bCoreMutex</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nWorker</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nWorker</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_WORKER_THREADS</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Do not allow the total number of threads (main thread + all workers)
  ** to exceed the maximum merge count */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;=</operator><name>SORTER_MAX_MERGE_COUNT</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>nWorker</name><operator>&gt;=</operator><name>SORTER_MAX_MERGE_COUNT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nWorker</name> <operator>=</operator> <name>SORTER_MAX_MERGE_COUNT</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pCsr</name><operator>-&gt;</operator><name>isEphemeral</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_SORTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>szKeyInfo</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>KeyInfo</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nKeyField</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>CollSeq</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VdbeSorter</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nWorker</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortSubtask</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

  <expr_stmt><expr><name>pSorter</name> <operator>=</operator> <operator>(</operator><name>VdbeSorter</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sz</name> <operator>+</operator> <name>szKeyInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pSorter</name></name> <operator>=</operator> <name>pSorter</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSorter</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pKeyInfo</name></name> <operator>=</operator> <name>pKeyInfo</name> <operator>=</operator> <operator>(</operator><name>KeyInfo</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>pSorter</name> <operator>+</operator> <name>sz</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument>, <argument><expr><name>szKeyInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nField</name> <operator>&amp;&amp;</operator> <name>nWorker</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nKeyField</name></name> <operator>=</operator> <name>nField</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pgsz</name></name> <operator>=</operator> <name>pgsz</name> <operator>=</operator> <call><name>sqlite3BtreeGetPageSize</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name> <operator>=</operator> <name>nWorker</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>iPrev</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>nWorker</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUseThreads</name></name> <operator>=</operator> <operator>(</operator><name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name><operator>&gt;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name> <init>= <expr><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>aTask</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name></name> <operator>=</operator> <name>pSorter</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3TempInMemory</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>mxCache</name></decl>;</decl_stmt>                <comment type="block">/* Cache size in bytes*/</comment>
      <decl_stmt><decl><type><name>u32</name></type> <name>szPma</name> <init>= <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szPma</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>mnPmaSize</name></name> <operator>=</operator> <name>szPma</name> <operator>*</operator> <name>pgsz</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>mxCache</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pSchema</name><operator>-&gt;</operator><name>cache_size</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>mxCache</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* A negative cache-size value C indicates that the cache is abs(C)
        ** KiB in size.  */</comment>
        <expr_stmt><expr><name>mxCache</name> <operator>=</operator> <name>mxCache</name> <operator>*</operator> <operator>-</operator><literal type="number">1024</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>mxCache</name> <operator>=</operator> <name>mxCache</name> <operator>*</operator> <name>pgsz</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>mxCache</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>mxCache</name></expr></argument>, <argument><expr><name>SQLITE_MAX_PMASZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>mxPmaSize</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>mnPmaSize</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>mxCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Avoid large memory allocations if the application has requested
      ** SQLITE_CONFIG_SMALL_MALLOC. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bSmallMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>iMemory</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>nMemory</name></name> <operator>=</operator> <name>pgsz</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>pgsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nAllField</name></name><operator>&lt;</operator><literal type="number">13</literal> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>pDfltColl</name></name><operator>)</operator>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_BIGNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>typeMask</name></name> <operator>=</operator> <name>SORTER_TYPE_INTEGER</name> <operator>|</operator> <name>SORTER_TYPE_TEXT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>nWorker</name></cpp:undef>   <comment type="block">/* Defined at the top of this function */</comment>

<comment type="block">/*
** Free the list of sorted records starting at pRecord.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeSorterRecordFree</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name>pRecord</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pRecord</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Free all resources owned by the object indicated by argument pTask. All 
** fields of *pTask are zeroed before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeSortSubtaskCleanup</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pUnpacked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <comment type="block">/* pTask-&gt;list.aMemory can only be non-zero if it was handed memory
  ** from the main thread.  That only occurs SQLITE_MAX_WORKER_THREADS&gt;0 */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTask</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vdbeSorterRecordFree</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTask</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>pFd</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OsCloseFree</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>pFd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTask</name><operator>-&gt;</operator><name>file2</name><operator>.</operator><name>pFd</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OsCloseFree</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>file2</name><operator>.</operator><name>pFd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SortSubtask</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG_SORTER_THREADS</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeSorterWorkDebug</name><parameter_list>(<parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEvent</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>t</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iTask</name> <init>= <expr><operator>(</operator><name>pTask</name> <operator>-</operator> <name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>aTask</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3OsCurrentTimeInt64</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%lld:%d %s\n"</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>iTask</name></expr></argument>, <argument><expr><name>zEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeSorterRewindDebug</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEvent</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3OsCurrentTimeInt64</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%lld:X %s\n"</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>zEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeSorterPopulateDebug</name><parameter_list>(
  <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEvent</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>t</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iTask</name> <init>= <expr><operator>(</operator><name>pTask</name> <operator>-</operator> <name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>aTask</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3OsCurrentTimeInt64</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%lld:bg%d %s\n"</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>iTask</name></expr></argument>, <argument><expr><name>zEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeSorterBlockDebug</name><parameter_list>(
  <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bBlocked</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEvent</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>bBlocked</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>t</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3OsCurrentTimeInt64</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%lld:main %s\n"</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>zEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>vdbeSorterWorkDebug</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>vdbeSorterRewindDebug</name><parameter_list>(<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>vdbeSorterPopulateDebug</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>vdbeSorterBlockDebug</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Join thread pTask-&gt;thread.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterJoinThread</name><parameter_list>(<parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTask</name><operator>-&gt;</operator><name>pThread</name></name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG_SORTER_THREADS</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>bDone</name> <init>= <expr><name><name>pTask</name><operator>-&gt;</operator><name>bDone</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><call><name>SQLITE_INT_TO_PTR</name><argument_list>(<argument><expr><name>SQLITE_ERROR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>vdbeSorterBlockDebug</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><operator>!</operator><name>bDone</name></expr></argument>, <argument><expr><literal type="string">"enter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>sqlite3ThreadJoin</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pThread</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vdbeSorterBlockDebug</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><operator>!</operator><name>bDone</name></expr></argument>, <argument><expr><literal type="string">"exit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>bDone</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTask</name><operator>-&gt;</operator><name>bDone</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTask</name><operator>-&gt;</operator><name>pThread</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Launch a background thread to run xTask(pIn).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterCreateThread</name><parameter_list>(
  <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>,             <comment type="block">/* Thread will use this task object */</comment>
  <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>xTask</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,          <comment type="block">/* Routine to run in a separate thread */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>                       <comment type="block">/* Argument passed into xTask() */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pThread</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pTask</name><operator>-&gt;</operator><name>bDone</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ThreadCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTask</name><operator>-&gt;</operator><name>pThread</name></name></expr></argument>, <argument><expr><name>xTask</name></expr></argument>, <argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Join all outstanding threads launched by SorterWrite() to create 
** level-0 PMAs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterJoinAll</name><parameter_list>(<parameter><decl><type><name>VdbeSorter</name> <modifier>*</modifier></type><name>pSorter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rcin</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>rcin</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* This function is always called by the main user thread.
  **
  ** If this function is being called after SorterRewind() has been called, 
  ** it is possible that thread pSorter-&gt;aTask[pSorter-&gt;nTask-1].pThread
  ** is currently attempt to join one of the other threads. To avoid a race
  ** condition where this thread also attempts to join the same object, join 
  ** thread pSorter-&gt;aTask[pSorter-&gt;nTask-1].pThread first. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name> <init>= <expr><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>aTask</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><call><name>vdbeSorterJoinThread</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>vdbeSorterJoinAll</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>rcin</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(rcin)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>vdbeSorterJoinThread</name><parameter_list>(<parameter><type><name>pTask</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SQLITE_OK</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Allocate a new MergeEngine object capable of handling up to
** nReader PmaReader inputs.
**
** nReader is automatically rounded up to the next power of two.
** nReader may not exceed SORTER_MAX_MERGE_COUNT even after rounding up.
*/</comment>
<function><type><specifier>static</specifier> <name>MergeEngine</name> <modifier>*</modifier></type><name>vdbeMergeEngineNew</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>N</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>                      <comment type="block">/* Smallest power of two &gt;= nReader */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                      <comment type="block">/* Total bytes of space to allocate */</comment>
  <decl_stmt><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>              <comment type="block">/* Pointer to allocated object to return */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nReader</name><operator>&lt;=</operator><name>SORTER_MAX_MERGE_COUNT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>N</name><operator>&lt;</operator><name>nReader</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>N</name> <operator>+=</operator> <name>N</name></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MergeEngine</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>N</name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PmaReader</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <ternary><condition><expr><call><name>sqlite3FaultSim</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>MergeEngine</name><operator>*</operator><operator>)</operator><call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nTree</name></name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pTask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aReadr</name></name> <operator>=</operator> <operator>(</operator><name>PmaReader</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aTree</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name>N</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free the MergeEngine object passed as the only argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeMergeEngineFree</name><parameter_list>(<parameter><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pMerger</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pMerger</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pMerger</name><operator>-&gt;</operator><name>nTree</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>vdbePmaReaderClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pMerger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free all resources associated with the IncrMerger object indicated by
** the first argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeIncrFree</name><parameter_list>(<parameter><decl><type><name>IncrMerger</name> <modifier>*</modifier></type><name>pIncr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pIncr</name></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name><name>pIncr</name><operator>-&gt;</operator><name>bUseThread</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>vdbeSorterJoinThread</name><argument_list>(<argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>pTask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pFd</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3OsCloseFree</name><argument_list>(<argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pFd</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3OsCloseFree</name><argument_list>(<argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>vdbeMergeEngineFree</name><argument_list>(<argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>pMerger</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pIncr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Reset a sorting cursor back to its original empty state.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSorterReset</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>VdbeSorter</name> <modifier>*</modifier></type><name>pSorter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>vdbeSorterJoinAll</name><argument_list>(<argument><expr><name>pSorter</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUseThreads</name></name> <operator>||</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>pReader</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>pReader</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vdbePmaReaderClear</name><argument_list>(<argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pReader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pReader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pReader</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>vdbeMergeEngineFree</name><argument_list>(<argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pMerger</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pMerger</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name> <init>= <expr><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>aTask</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>vdbeSortSubtaskCleanup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name></name> <operator>=</operator> <name>pSorter</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vdbeSorterRecordFree</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>szPMA</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUsePMA</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>iMemory</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>mxKeysize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pUnpacked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pUnpacked</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free any cursor components allocated by sqlite3VdbeSorterXXX routines.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSorterClose</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeSorter</name> <modifier>*</modifier></type><name>pSorter</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_SORTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSorter</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pSorter</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSorter</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeSorterReset</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSorter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSorter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pSorter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** The first argument is a file-handle open on a temporary file. The file
** is guaranteed to be nByte bytes or smaller in size. This function
** attempts to extend the file to nByte bytes in size and to ensure that
** the VFS has memory mapped it.
**
** Whether or not the file does end up memory mapped of course depends on
** the specific VFS implementation.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeSorterExtendFile</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&lt;=</operator><operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>nMaxSorterMmap</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>chunksize</name> <init>= <expr><literal type="number">4</literal><operator>*</operator><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3OsFileControlHint</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_CHUNK_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>chunksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3OsFileControlHint</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_SIZE_HINT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3OsFetch</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3OsUnfetch</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>vdbeSorterExtendFile</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Allocate space for a file-handle and open a temporary file. If successful,
** set *ppFd to point to the malloc'd file-handle and return SQLITE_OK.
** Otherwise, set *ppFd to 0 and return an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterOpenTempFile</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle doing sort */</comment>
  <parameter><decl><type><name>i64</name></type> <name>nExtend</name></decl></parameter>,                    <comment type="block">/* Attempt to extend file to this size */</comment>
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppFd</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3FaultSim</name><argument_list>(<argument><expr><literal type="number">202</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_IOERR_ACCESS</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsOpenMalloc</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ppFd</name></expr></argument>,
      <argument><expr><name>SQLITE_OPEN_TEMP_JOURNAL</name> <operator>|</operator>
      <name>SQLITE_OPEN_READWRITE</name>    <operator>|</operator> <name>SQLITE_OPEN_CREATE</name> <operator>|</operator>
      <name>SQLITE_OPEN_EXCLUSIVE</name>    <operator>|</operator> <name>SQLITE_OPEN_DELETEONCLOSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>max</name> <init>= <expr><name>SQLITE_MAX_MMAP_SIZE</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3OsFileControlHint</name><argument_list>(<argument><expr><operator>*</operator><name>ppFd</name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_MMAP_SIZE</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nExtend</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>vdbeSorterExtendFile</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>*</operator><name>ppFd</name></expr></argument>, <argument><expr><name>nExtend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If it has not already been allocated, allocate the UnpackedRecord 
** structure at pTask-&gt;pUnpacked. Return SQLITE_OK if successful (or 
** if no allocation was required), or SQLITE_NOMEM otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSortAllocUnpacked</name><parameter_list>(<parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pTask</name><operator>-&gt;</operator><name>pUnpacked</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTask</name><operator>-&gt;</operator><name>pUnpacked</name></name> <operator>=</operator> <call><name>sqlite3VdbeAllocUnpackedRecord</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTask</name><operator>-&gt;</operator><name>pUnpacked</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pTask</name><operator>-&gt;</operator><name>pUnpacked</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nKeyField</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTask</name><operator>-&gt;</operator><name>pUnpacked</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Merge the two sorted lists p1 and p2 into a single list.
*/</comment>
<function><type><specifier>static</specifier> <name>SorterRecord</name> <modifier>*</modifier></type><name>vdbeSorterMerge</name><parameter_list>(
  <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>,             <comment type="block">/* Calling thread context */</comment>
  <parameter><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>,               <comment type="block">/* First list to merge */</comment>
  <parameter><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>                <comment type="block">/* Second list to merge */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name>pFinal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SorterRecord</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name> <init>= <expr><operator>&amp;</operator><name>pFinal</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bCached</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p2</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>pTask</name><operator>-&gt;</operator><name>xCompare</name></name><argument_list>(
        <argument><expr><name>pTask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bCached</name></expr></argument>, <argument><expr><call><name>SRVAL</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name></expr></argument>, <argument><expr><call><name>SRVAL</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>nVal</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p1</name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNext</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>p1</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p2</name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>bCached</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>p2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>pFinal</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the SorterCompare function to compare values collected by the
** sorter object passed as the only argument.
*/</comment>
<function><type><specifier>static</specifier> <name>SorterCompare</name></type> <name>vdbeSorterGetCompare</name><parameter_list>(<parameter><decl><type><name>VdbeSorter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>typeMask</name></name><operator>==</operator><name>SORTER_TYPE_INTEGER</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>vdbeSorterCompareInt</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>typeMask</name></name><operator>==</operator><name>SORTER_TYPE_TEXT</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>vdbeSorterCompareText</name></expr>;</return> 
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>vdbeSorterCompare</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Sort the linked list of records headed at pTask-&gt;pList. Return 
** SQLITE_OK if successful, or an SQLite error code (i.e. SQLITE_NOMEM) if 
** an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterSort</name><parameter_list>(<parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>, <parameter><decl><type><name>SorterList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name><name>aSlot</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSortAllocUnpacked</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTask</name><operator>-&gt;</operator><name>xCompare</name></name> <operator>=</operator> <call><name>vdbeSorterGetCompare</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aSlot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aSlot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pList</name><operator>-&gt;</operator><name>aMemory</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>p</name><operator>==</operator><name><name>pList</name><operator>-&gt;</operator><name>aMemory</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pNext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iNext</name></name><operator>&lt;</operator><call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>aMemory</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNext</name> <operator>=</operator> <operator>(</operator><name>SorterRecord</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pList</name><operator>-&gt;</operator><name>aMemory</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iNext</name></name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>aSlot</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vdbeSorterMerge</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>aSlot</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aSlot</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>aSlot</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aSlot</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><call><name>vdbeSorterMerge</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>aSlot</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>aSlot</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pUnpacked</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> 
       <operator>||</operator> <name><name>pTask</name><operator>-&gt;</operator><name>pUnpacked</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pTask</name><operator>-&gt;</operator><name>pUnpacked</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize a PMA-writer object.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbePmaWriterInit</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>,              <comment type="block">/* File handle to write to */</comment>
  <parameter><decl><type><name>PmaWriter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Object to populate */</comment>
  <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>,                       <comment type="block">/* Buffer size */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iStart</name></decl></parameter>                      <comment type="block">/* Offset of pFd to begin writing at */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PmaWriter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eFWErr</name></name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iBufEnd</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufStart</name></name> <operator>=</operator> <operator>(</operator><name>iStart</name> <operator>%</operator> <name>nBuf</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iWriteOff</name></name> <operator>=</operator> <name>iStart</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufStart</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name> <operator>=</operator> <name>nBuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFd</name></name> <operator>=</operator> <name>pFd</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Write nData bytes of data to the PMA. Return SQLITE_OK
** if successful, or an SQLite error code if an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbePmaWriteBlob</name><parameter_list>(<parameter><decl><type><name>PmaWriter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nRem</name> <init>= <expr><name>nData</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>nRem</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>eFWErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name> <init>= <expr><name>nRem</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nCopy</name><operator>&gt;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufEnd</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufEnd</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iBufEnd</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pData</name><index>[<expr><name>nData</name><operator>-</operator><name>nRem</name></expr>]</index></name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iBufEnd</name></name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iBufEnd</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eFWErr</name></name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFd</name></name></expr></argument>, 
          <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iBufStart</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iBufEnd</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufStart</name></name></expr></argument>, 
          <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iWriteOff</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufStart</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iBufStart</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iWriteOff</name></name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iBufEnd</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nBuffer</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <name>nCopy</name></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Flush any buffered data to disk and clean up the PMA-writer object.
** The results of using the PMA-writer after this call are undefined.
** Return SQLITE_OK if flushing the buffered data succeeds or is not 
** required. Otherwise, return an SQLite error code.
**
** Before returning, set *piEof to the offset immediately following the
** last byte written to the file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbePmaWriterFinish</name><parameter_list>(<parameter><decl><type><name>PmaWriter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piEof</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eFWErr</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufEnd</name></name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>iBufStart</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eFWErr</name></name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFd</name></name></expr></argument>, 
        <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iBufStart</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iBufEnd</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufStart</name></name></expr></argument>, 
        <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iWriteOff</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufStart</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>piEof</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iWriteOff</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>iBufEnd</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>eFWErr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PmaWriter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write value iVal encoded as a varint to the PMA. Return 
** SQLITE_OK if successful, or an SQLite error code if an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbePmaWriteVarint</name><parameter_list>(<parameter><decl><type><name>PmaWriter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u64</name></type> <name>iVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>u8</name></type> <name><name>aByte</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>sqlite3PutVarint</name><argument_list>(<argument><expr><name>aByte</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>vdbePmaWriteBlob</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>aByte</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Write the current contents of in-memory linked-list pList to a level-0
** PMA in the temp file belonging to sub-task pTask. Return SQLITE_OK if 
** successful, or an SQLite error code otherwise.
**
** The format of a PMA is:
**
**     * A varint. This varint contains the total number of bytes of content
**       in the PMA (not including the varint itself).
**
**     * One or more records packed end-to-end in order of ascending keys. 
**       Each record consists of a varint followed by a blob of data (the 
**       key). The varint is the number of bytes in the blob of data.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterListToPMA</name><parameter_list>(<parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>, <parameter><decl><type><name>SorterList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>PmaWriter</name></type> <name>writer</name></decl>;</decl_stmt>               <comment type="block">/* Object used to write to the file */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* Set iSz to the expected size of file pTask-&gt;file after writing the PMA. 
  ** This is used by an assert() statement at the end of this function.  */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iSz</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>szPMA</name></name> <operator>+</operator> <call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name><name>pList</name><operator>-&gt;</operator><name>szPMA</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>pTask</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>iEof</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>vdbeSorterWorkDebug</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><literal type="string">"enter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PmaWriter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>szPMA</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the first temporary PMA file has not been opened, open it now. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTask</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>pFd</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterOpenTempFile</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTask</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>pFd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>pTask</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>pFd</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>iEof</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>nPMA</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Try to get the file to memory map */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vdbeSorterExtendFile</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>pFd</name></name></expr></argument>, <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>iEof</name></name><operator>+</operator><name><name>pList</name><operator>-&gt;</operator><name>szPMA</name></name><operator>+</operator><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Sort the list */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterSort</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>vdbePmaWriterInit</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>pFd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>pgsz</name></name></expr></argument>,
                      <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>iEof</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTask</name><operator>-&gt;</operator><name>nPMA</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vdbePmaWriteVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>szPMA</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pList</name><operator>-&gt;</operator><name>pList</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>vdbePmaWriteVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>vdbePmaWriteBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><call><name>SRVAL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pList</name><operator>-&gt;</operator><name>aMemory</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaWriterFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTask</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>iEof</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>vdbeSorterWorkDebug</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><literal type="string">"exit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>pList</name><operator>-&gt;</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>pTask</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>iEof</name></name><operator>==</operator><name>iSz</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance the MergeEngine to its next entry.
** Set *pbEof to true there is no next entry because
** the MergeEngine has reached the end of all its inputs.
**
** Return SQLITE_OK if successful or an error code if an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeMergeEngineStep</name><parameter_list>(
  <parameter><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pMerger</name></decl></parameter>,      <comment type="block">/* The merge engine to advance to the next row */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbEof</name></decl></parameter>                 <comment type="block">/* Set TRUE at EOF.  Set false for more content */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPrev</name> <init>= <expr><name><name>pMerger</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt><comment type="block">/* Index of PmaReader to advance */</comment>
  <decl_stmt><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name> <init>= <expr><name><name>pMerger</name><operator>-&gt;</operator><name>pTask</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Advance the current PmaReader */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReaderNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name>iPrev</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Update contents of aTree[] */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                      <comment type="block">/* Index of aTree[] to recalculate */</comment>
    <decl_stmt><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReadr1</name></decl>;</decl_stmt>         <comment type="block">/* First PmaReader to compare */</comment>
    <decl_stmt><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReadr2</name></decl>;</decl_stmt>         <comment type="block">/* Second PmaReader to compare */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bCached</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Find the first two PmaReaders to compare. The one that was just
    ** advanced (iPrev) and the one next to it in the array.  */</comment>
    <expr_stmt><expr><name>pReadr1</name> <operator>=</operator> <operator>&amp;</operator><name><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><operator>(</operator><name>iPrev</name> <operator>&amp;</operator> <literal type="number">0xFFFE</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pReadr2</name> <operator>=</operator> <operator>&amp;</operator><name><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><operator>(</operator><name>iPrev</name> <operator>|</operator> <literal type="number">0x0001</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><operator>(</operator><name><name>pMerger</name><operator>-&gt;</operator><name>nTree</name></name><operator>+</operator><name>iPrev</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>=</operator><name>i</name><operator>/</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
      <comment type="block">/* Compare pReadr1 and pReadr2. Store the result in variable iRes. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iRes</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pReadr1</name><operator>-&gt;</operator><name>pFd</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iRes</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pReadr2</name><operator>-&gt;</operator><name>pFd</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iRes</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iRes</name> <operator>=</operator> <call><name><name>pTask</name><operator>-&gt;</operator><name>xCompare</name></name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bCached</name></expr></argument>,
            <argument><expr><name><name>pReadr1</name><operator>-&gt;</operator><name>aKey</name></name></expr></argument>, <argument><expr><name><name>pReadr1</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><name><name>pReadr2</name><operator>-&gt;</operator><name>aKey</name></name></expr></argument>, <argument><expr><name><name>pReadr2</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* If pReadr1 contained the smaller value, set aTree[i] to its index.
      ** Then set pReadr2 to the next PmaReader to compare to pReadr1. In this
      ** case there is no cache of pReadr2 in pTask-&gt;pUnpacked, so set
      ** pKey2 to point to the record belonging to pReadr2.
      **
      ** Alternatively, if pReadr2 contains the smaller of the two values,
      ** set aTree[i] to its index and update pReadr1. If vdbeSorterCompare()
      ** was actually called above, then pTask-&gt;pUnpacked now contains
      ** a value equivalent to pReadr2. So set pKey2 to NULL to prevent
      ** vdbeSorterCompare() from decoding pReadr2 again.
      **
      ** If the two values were equal, then the value from the oldest
      ** PMA should be considered smaller. The VdbeSorter.aReadr[] array
      ** is sorted from oldest to newest, so pReadr1 contains older values
      ** than pReadr2 iff (pReadr1&lt;pReadr2).  */</comment>
      <if_stmt><if>if<condition>( <expr><name>iRes</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>iRes</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pReadr1</name><operator>&lt;</operator><name>pReadr2</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pMerger</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pReadr1</name> <operator>-</operator> <name><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>pReadr2</name> <operator>=</operator> <operator>&amp;</operator><name><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name><index>[ <expr><name><name>pMerger</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><name>i</name> <operator>^</operator> <literal type="number">0x0001</literal></expr>]</index></name></expr> ]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bCached</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pReadr1</name><operator>-&gt;</operator><name>pFd</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bCached</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pMerger</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pReadr2</name> <operator>-</operator> <name><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>pReadr1</name> <operator>=</operator> <operator>&amp;</operator><name><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name><index>[ <expr><name><name>pMerger</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><name>i</name> <operator>^</operator> <literal type="number">0x0001</literal></expr>]</index></name></expr> ]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>pbEof</name> <operator>=</operator> <operator>(</operator><name><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name><name>pMerger</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>pFd</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> ?</condition><then> <expr><name><name>pTask</name><operator>-&gt;</operator><name>pUnpacked</name><operator>-&gt;</operator><name>errCode</name></name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** The main routine for background threads that write level-0 PMAs.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>vdbeSorterFlushThread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name> <init>= <expr><operator>(</operator><name>SortSubtask</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>bDone</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterListToPMA</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTask</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTask</name><operator>-&gt;</operator><name>bDone</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><call><name>SQLITE_INT_TO_PTR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_MAX_WORKER_THREADS&gt;0 */</comment>

<comment type="block">/*
** Flush the current contents of VdbeSorter.list to a new PMA, possibly
** using a background thread.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterFlushPMA</name><parameter_list>(<parameter><decl><type><name>VdbeSorter</name> <modifier>*</modifier></type><name>pSorter</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>==</operator><literal type="number">0</literal></expr></cpp:if>
  <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUsePMA</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><call><name>vdbeSorterListToPMA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>aTask</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Thread context used to create new PMA */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nWorker</name> <init>= <expr><operator>(</operator><name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Set the flag to indicate that at least one PMA has been written. 
  ** Or will be, anyhow.  */</comment>
  <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUsePMA</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <comment type="block">/* Select a sub-task to sort and flush the current list of in-memory
  ** records to disk. If the sorter is running in multi-threaded mode,
  ** round-robin between the first (pSorter-&gt;nTask-1) tasks. Except, if
  ** the background thread from a sub-tasks previous turn is still running,
  ** skip it. If the first (pSorter-&gt;nTask-1) sub-tasks are all still busy,
  ** fall back to using the final sub-task. The first (pSorter-&gt;nTask-1)
  ** sub-tasks are prefered as they use background threads - the final 
  ** sub-task uses the main thread. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nWorker</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iTest</name> <init>= <expr><operator>(</operator><name><name>pSorter</name><operator>-&gt;</operator><name>iPrev</name></name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>nWorker</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pTask</name> <operator>=</operator> <operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>aTask</name><index>[<expr><name>iTest</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTask</name><operator>-&gt;</operator><name>bDone</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterJoinThread</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>pTask</name><operator>-&gt;</operator><name>pThread</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>nWorker</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Use the foreground thread for this operation */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterListToPMA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>aTask</name><index>[<expr><name>nWorker</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Launch a background thread for this operation */</comment>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aMem</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTask</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pThread</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pTask</name><operator>-&gt;</operator><name>bDone</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>aMem</name> <operator>=</operator> <name><name>pTask</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCtx</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pTask</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>iPrev</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>pTask</name> <operator>-</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>aTask</name></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTask</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>list</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>szPMA</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>aMem</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name> <operator>=</operator> <name>aMem</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>nMemory</name></name> <operator>=</operator> <call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>aMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name> <operator>=</operator> <call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>nMemory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterCreateThread</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><name>vdbeSorterFlushThread</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_MAX_WORKER_THREADS!=0 */</comment>
</block_content>}</block></function>

<comment type="block">/*
** Add a record to the sorter.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeSorterWrite</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>VdbeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,         <comment type="block">/* Sorter cursor */</comment>
  <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>                       <comment type="block">/* Memory cell containing record */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeSorter</name> <modifier>*</modifier></type><name>pSorter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>             <comment type="block">/* New list element */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bFlush</name></decl>;</decl_stmt>                     <comment type="block">/* True to flush contents of memory to PMA */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nReq</name></decl>;</decl_stmt>                       <comment type="block">/* Bytes of memory required */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPMA</name></decl>;</decl_stmt>                       <comment type="block">/* Bytes of PMA space required */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>                          <comment type="block">/* serial type of first record field */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_SORTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSorter</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pSorter</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>getVarint32NR</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pVal</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>t</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>t</name><operator>&lt;</operator><literal type="number">10</literal> <operator>&amp;&amp;</operator> <name>t</name><operator>!=</operator><literal type="number">7</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>typeMask</name></name> <operator>&amp;=</operator> <name>SORTER_TYPE_INTEGER</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>t</name><operator>&gt;</operator><literal type="number">10</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>t</name> <operator>&amp;</operator> <literal type="number">0x01</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>typeMask</name></name> <operator>&amp;=</operator> <name>SORTER_TYPE_TEXT</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>typeMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSorter</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Figure out whether or not the current contents of memory should be
  ** flushed to a PMA before continuing. If so, do so.
  **
  ** If using the single large allocation mode (pSorter-&gt;aMemory!=0), then
  ** flush the contents of memory to a new PMA if (a) at least one value is
  ** already in memory and (b) the new value will not fit in memory.
  ** 
  ** Or, if using separate allocations for each record, flush the contents
  ** of memory to a PMA if either of the following are true:
  **
  **   * The total memory allocated for the in-memory list is greater 
  **     than (page-size * cache-size), or
  **
  **   * The total memory allocated for the in-memory list is greater 
  **     than (page-size * 10) and sqlite3HeapNearlyFull() returns true.
  */</comment>
  <expr_stmt><expr><name>nReq</name> <operator>=</operator> <name><name>pVal</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SorterRecord</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>nPMA</name> <operator>=</operator> <name><name>pVal</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>mxPmaSize</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bFlush</name> <operator>=</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>iMemory</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pSorter</name><operator>-&gt;</operator><name>iMemory</name></name><operator>+</operator><name>nReq</name><operator>)</operator> <operator>&gt;</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>mxPmaSize</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>bFlush</name> <operator>=</operator> <operator>(</operator>
          <operator>(</operator><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>szPMA</name></name> <operator>&gt;</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>mxPmaSize</name></name><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>szPMA</name></name> <operator>&gt;</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>mnPmaSize</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3HeapNearlyFull</name><argument_list>()</argument_list></call><operator>)</operator>
      <operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>bFlush</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterFlushPMA</name><argument_list>(<argument><expr><name>pSorter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>szPMA</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>iMemory</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>szPMA</name></name> <operator>+=</operator> <name>nPMA</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPMA</name><operator>&gt;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>mxKeysize</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>mxKeysize</name></name> <operator>=</operator> <name>nPMA</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nMin</name> <init>= <expr><name><name>pSorter</name><operator>-&gt;</operator><name>iMemory</name></name> <operator>+</operator> <name>nReq</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>nMin</name><operator>&gt;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>nMemory</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nNew</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>pSorter</name><operator>-&gt;</operator><name>nMemory</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iListOff</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iListOff</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name> <operator>-</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <while>while<condition>( <expr><name>nNew</name> <operator>&lt;</operator> <name>nMin</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nNew</name> <operator>=</operator> <name>nNew</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>
      <if_stmt><if>if<condition>( <expr><name>nNew</name> <operator>&gt;</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>mxPmaSize</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nNew</name> <operator>=</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>mxPmaSize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>nNew</name> <operator>&lt;</operator> <name>nMin</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nNew</name> <operator>=</operator> <name>nMin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>aNew</name> <operator>=</operator> <call><name>sqlite3Realloc</name><argument_list>(<argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aNew</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iListOff</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <operator>(</operator><name>SorterRecord</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aNew</name><index>[<expr><name>iListOff</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>nMemory</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>SorterRecord</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name><index>[<expr><name><name>pSorter</name><operator>-&gt;</operator><name>iMemory</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>iMemory</name></name> <operator>+=</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><name>nReq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iNext</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name><operator>)</operator> <operator>-</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>SorterRecord</name> <operator>*</operator><operator>)</operator><call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>nReq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>SRVAL</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nVal</name></name> <operator>=</operator> <name><name>pVal</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read keys from pIncr-&gt;pMerger and populate pIncr-&gt;aFile[1]. The format
** of the data stored in aFile[1] is the same as that used by regular PMAs,
** except that the number-of-bytes varint is omitted from the start.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeIncrPopulate</name><parameter_list>(<parameter><decl><type><name>IncrMerger</name> <modifier>*</modifier></type><name>pIncr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iStart</name> <init>= <expr><name><name>pIncr</name><operator>-&gt;</operator><name>iStartOff</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SorterFile</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><operator>&amp;</operator><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name> <init>= <expr><name><name>pIncr</name><operator>-&gt;</operator><name>pTask</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pMerger</name> <init>= <expr><name><name>pIncr</name><operator>-&gt;</operator><name>pMerger</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PmaWriter</name></type> <name>writer</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>bEof</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>vdbeSorterPopulateDebug</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><literal type="string">"enter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>vdbePmaWriterInit</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>pFd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>pgsz</name></name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReader</name> <init>= <expr><operator>&amp;</operator><name><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name><index>[ <expr><name><name>pMerger</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> ]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><name><name>pReader</name><operator>-&gt;</operator><name>nKey</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>iEof</name> <init>= <expr><name><name>writer</name><operator>.</operator><name>iWriteOff</name></name> <operator>+</operator> <name><name>writer</name><operator>.</operator><name>iBufEnd</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Check if the output file is full or if the input has been exhausted.
    ** In either case exit the loop. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>pFd</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iEof</name> <operator>+</operator> <name>nKey</name> <operator>+</operator> <call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name>nKey</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;</operator><operator>(</operator><name>iStart</name> <operator>+</operator> <name><name>pIncr</name><operator>-&gt;</operator><name>mxSz</name></name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <comment type="block">/* Write the next key to the output. */</comment>
    <expr_stmt><expr><call><name>vdbePmaWriteVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vdbePmaWriteBlob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>aKey</name></name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>pMerger</name><operator>-&gt;</operator><name>pTask</name></name><operator>==</operator><name>pTask</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeMergeEngineStep</name><argument_list>(<argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>pMerger</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>vdbePmaWriterFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pOut</name><operator>-&gt;</operator><name>iEof</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>vdbeSorterPopulateDebug</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><literal type="string">"exit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** The main routine for background threads that populate aFile[1] of
** multi-threaded IncrMerger objects.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>vdbeIncrPopulateThread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IncrMerger</name> <modifier>*</modifier></type><name>pIncr</name> <init>= <expr><operator>(</operator><name>IncrMerger</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><call><name>SQLITE_INT_TO_PTR</name><argument_list>( <argument><expr><call><name>vdbeIncrPopulate</name><argument_list>(<argument><expr><name>pIncr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pIncr</name><operator>-&gt;</operator><name>pTask</name><operator>-&gt;</operator><name>bDone</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Launch a background thread to populate aFile[1] of pIncr.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeIncrBgPopulate</name><parameter_list>(<parameter><decl><type><name>IncrMerger</name> <modifier>*</modifier></type><name>pIncr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pIncr</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>bUseThread</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>vdbeSorterCreateThread</name><argument_list>(<argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>pTask</name></name></expr></argument>, <argument><expr><name>vdbeIncrPopulateThread</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This function is called when the PmaReader corresponding to pIncr has
** finished reading the contents of aFile[0]. Its purpose is to "refill"
** aFile[0] such that the PmaReader should start rereading it from the
** beginning.
**
** For single-threaded objects, this is accomplished by literally reading 
** keys from pIncr-&gt;pMerger and repopulating aFile[0]. 
**
** For multi-threaded objects, all that is required is to wait until the 
** background thread is finished (if it is not already) and then swap 
** aFile[0] and aFile[1] in place. If the contents of pMerger have not
** been exhausted, this function also launches a new background thread
** to populate the new aFile[1].
**
** SQLITE_OK is returned on success, or an SQLite error code otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeIncrSwap</name><parameter_list>(<parameter><decl><type><name>IncrMerger</name> <modifier>*</modifier></type><name>pIncr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pIncr</name><operator>-&gt;</operator><name>bUseThread</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterJoinThread</name><argument_list>(<argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>pTask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>SorterFile</name></type> <name>f0</name> <init>= <expr><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>f0</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iEof</name><operator>==</operator><name><name>pIncr</name><operator>-&gt;</operator><name>iStartOff</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIncr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeIncrBgPopulate</name><argument_list>(<argument><expr><name>pIncr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeIncrPopulate</name><argument_list>(<argument><expr><name>pIncr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iEof</name><operator>==</operator><name><name>pIncr</name><operator>-&gt;</operator><name>iStartOff</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIncr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and return a new IncrMerger object to read data from pMerger.
**
** If an OOM condition is encountered, return NULL. In this case free the
** pMerger argument before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeIncrMergerNew</name><parameter_list>(
  <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>,     <comment type="block">/* The thread that will be using the new IncrMerger */</comment>
  <parameter><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pMerger</name></decl></parameter>,   <comment type="block">/* The MergeEngine that the IncrMerger will control */</comment>
  <parameter><decl><type><name>IncrMerger</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>      <comment type="block">/* Write the new IncrMerger here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IncrMerger</name> <modifier>*</modifier></type><name>pIncr</name> <init>= <expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <operator>(</operator><name>IncrMerger</name><operator>*</operator><operator>)</operator>
       <operator>(</operator><ternary><condition><expr><call><name>sqlite3FaultSim</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pIncr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIncr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIncr</name><operator>-&gt;</operator><name>pMerger</name></name> <operator>=</operator> <name>pMerger</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIncr</name><operator>-&gt;</operator><name>pTask</name></name> <operator>=</operator> <name>pTask</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIncr</name><operator>-&gt;</operator><name>mxSz</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>mxKeysize</name></name><operator>+</operator><literal type="number">9</literal></expr></argument>,<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>mxPmaSize</name></name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTask</name><operator>-&gt;</operator><name>file2</name><operator>.</operator><name>iEof</name></name> <operator>+=</operator> <name><name>pIncr</name><operator>-&gt;</operator><name>mxSz</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>vdbeMergeEngineFree</name><argument_list>(<argument><expr><name>pMerger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>ppOut</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Set the "use-threads" flag on object pIncr.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeIncrMergerSetThreads</name><parameter_list>(<parameter><decl><type><name>IncrMerger</name> <modifier>*</modifier></type><name>pIncr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pIncr</name><operator>-&gt;</operator><name>bUseThread</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIncr</name><operator>-&gt;</operator><name>pTask</name><operator>-&gt;</operator><name>file2</name><operator>.</operator><name>iEof</name></name> <operator>-=</operator> <name><name>pIncr</name><operator>-&gt;</operator><name>mxSz</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_MAX_WORKER_THREADS&gt;0 */</comment>



<comment type="block">/*
** Recompute pMerger-&gt;aTree[iOut] by comparing the next keys on the
** two PmaReaders that feed that entry.  Neither of the PmaReaders
** are advanced.  This routine merely does the comparison.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeMergeEngineCompare</name><parameter_list>(
  <parameter><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pMerger</name></decl></parameter>,  <comment type="block">/* Merge engine containing PmaReaders to compare */</comment>
  <parameter><decl><type><name>int</name></type> <name>iOut</name></decl></parameter>               <comment type="block">/* Store the result in pMerger-&gt;aTree[iOut] */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iRes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>iOut</name><argument_list type="generic">&lt;<argument><expr><name><name>pMerger</name><operator>-&gt;</operator><name>nTree</name></name> <operator>&amp;&amp;</operator> <name>iOut</name></expr></argument>&gt;</argument_list></name><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>iOut</name><operator>&gt;=</operator><operator>(</operator><name><name>pMerger</name><operator>-&gt;</operator><name>nTree</name></name><operator>/</operator><literal type="number">2</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>i1</name> <operator>=</operator> <operator>(</operator><name>iOut</name> <operator>-</operator> <name><name>pMerger</name><operator>-&gt;</operator><name>nTree</name></name><operator>/</operator><literal type="number">2</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>i2</name> <operator>=</operator> <name>i1</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>i1</name> <operator>=</operator> <name><name>pMerger</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><name>iOut</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i2</name> <operator>=</operator> <name><name>pMerger</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><name>iOut</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>p1</name> <operator>=</operator> <operator>&amp;</operator><name><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name>i1</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p2</name> <operator>=</operator> <operator>&amp;</operator><name><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name>i2</name></expr>]</index></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>pFd</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iRes</name> <operator>=</operator> <name>i2</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p2</name><operator>-&gt;</operator><name>pFd</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iRes</name> <operator>=</operator> <name>i1</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name> <init>= <expr><name><name>pMerger</name><operator>-&gt;</operator><name>pTask</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bCached</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pUnpacked</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* from vdbeSortSubtaskMain() */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>pTask</name><operator>-&gt;</operator><name>xCompare</name></name><argument_list>(
        <argument><expr><name>pTask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bCached</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>aKey</name></name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>aKey</name></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>nKey</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iRes</name> <operator>=</operator> <name>i1</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iRes</name> <operator>=</operator> <name>i2</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pMerger</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <name>iRes</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allowed values for the eMode parameter to vdbeMergeEngineInit()
** and vdbePmaReaderIncrMergeInit().
**
** Only INCRINIT_NORMAL is valid in single-threaded builds (when
** SQLITE_MAX_WORKER_THREADS==0).  The other values are only used
** when there exists one or more separate worker threads.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCRINIT_NORMAL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCRINIT_TASK</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCRINIT_ROOT</name></cpp:macro>   <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/* 
** Forward reference required as the vdbeIncrMergeInit() and
** vdbePmaReaderIncrInit() routines are called mutually recursively when
** building a merge tree.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>vdbePmaReaderIncrInit</name><parameter_list>(<parameter><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReadr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Initialize the MergeEngine object passed as the second argument. Once this
** function returns, the first key of merged data may be read from the 
** MergeEngine object in the usual fashion.
**
** If argument eMode is INCRINIT_ROOT, then it is assumed that any IncrMerge
** objects attached to the PmaReader objects that the merger reads from have
** already been populated, but that they have not yet populated aFile[0] and
** set the PmaReader objects up to read from it. In this case all that is
** required is to call vdbePmaReaderNext() on each PmaReader to point it at
** its first key.
**
** Otherwise, if eMode is any value other than INCRINIT_ROOT, then use 
** vdbePmaReaderIncrMergeInit() to initialize each PmaReader that feeds data 
** to pMerger.
**
** SQLITE_OK is returned if successful, or an SQLite error code otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeMergeEngineInit</name><parameter_list>(
  <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>,             <comment type="block">/* Thread that will run pMerger */</comment>
  <parameter><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pMerger</name></decl></parameter>,           <comment type="block">/* MergeEngine to initialize */</comment>
  <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>                       <comment type="block">/* One of the INCRINIT_XXX constants */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* For looping over PmaReader objects */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTree</name></decl>;</decl_stmt>                      <comment type="block">/* Number of subtrees to merge */</comment>

  <comment type="block">/* Failure to allocate the merge would have been detected prior to
  ** invoking this routine */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMerger</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* eMode is always INCRINIT_NORMAL in single-threaded mode */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>eMode</name><operator>==</operator><name>INCRINIT_NORMAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Verify that the MergeEngine is assigned to a single thread */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMerger</name><operator>-&gt;</operator><name>pTask</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMerger</name><operator>-&gt;</operator><name>pTask</name></name> <operator>=</operator> <name>pTask</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>nTree</name> <operator>=</operator> <name><name>pMerger</name><operator>-&gt;</operator><name>nTree</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nTree</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eMode</name><operator>==</operator><name>INCRINIT_ROOT</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* PmaReaders should be normally initialized in order, as if they are
      ** reading from the same temp file this makes for more linear file IO.
      ** However, in the INCRINIT_ROOT case, if PmaReader aReadr[nTask-1] is
      ** in use it will block the vdbePmaReaderNext() call while it uses
      ** the main thread to fill its buffer. So calling PmaReaderNext()
      ** on this PmaReader before any of the multi-threaded PmaReaders takes
      ** better advantage of multi-processor hardware. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReaderNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name>nTree</name><operator>-</operator><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReaderIncrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>INCRINIT_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pMerger</name><operator>-&gt;</operator><name>nTree</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>vdbeMergeEngineCompare</name><argument_list>(<argument><expr><name>pMerger</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name><name>pTask</name><operator>-&gt;</operator><name>pUnpacked</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The PmaReader passed as the first argument is guaranteed to be an
** incremental-reader (pReadr-&gt;pIncr!=0). This function serves to open
** and/or initialize the temp file related fields of the IncrMerge
** object at (pReadr-&gt;pIncr).
**
** If argument eMode is set to INCRINIT_NORMAL, then all PmaReaders
** in the sub-tree headed by pReadr are also initialized. Data is then 
** loaded into the buffers belonging to pReadr and it is set to point to 
** the first key in its range.
**
** If argument eMode is set to INCRINIT_TASK, then pReadr is guaranteed
** to be a multi-threaded PmaReader and this function is being called in a
** background thread. In this case all PmaReaders in the sub-tree are 
** initialized as for INCRINIT_NORMAL and the aFile[1] buffer belonging to
** pReadr is populated. However, pReadr itself is not set up to point
** to its first key. A call to vdbePmaReaderNext() is still required to do
** that. 
**
** The reason this function does not call vdbePmaReaderNext() immediately 
** in the INCRINIT_TASK case is that vdbePmaReaderNext() assumes that it has
** to block on thread (pTask-&gt;thread) before accessing aFile[1]. But, since
** this entire function is being run by thread (pTask-&gt;thread), that will
** lead to the current background thread attempting to join itself.
**
** Finally, if argument eMode is set to INCRINIT_ROOT, it may be assumed
** that pReadr-&gt;pIncr is a multi-threaded IncrMerge objects, and that all
** child-trees have already been initialized using IncrInit(INCRINIT_TASK).
** In this case vdbePmaReaderNext() is called on all child PmaReaders and
** the current PmaReader set to point to the first key in its range.
**
** SQLITE_OK is returned if successful, or an SQLite error code otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbePmaReaderIncrMergeInit</name><parameter_list>(<parameter><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReadr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IncrMerger</name> <modifier>*</modifier></type><name>pIncr</name> <init>= <expr><name><name>pReadr</name><operator>-&gt;</operator><name>pIncr</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name> <init>= <expr><name><name>pIncr</name><operator>-&gt;</operator><name>pTask</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pTask</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* eMode is always INCRINIT_NORMAL in single-threaded mode */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>eMode</name><operator>==</operator><name>INCRINIT_NORMAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeMergeEngineInit</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>pMerger</name></name></expr></argument>, <argument><expr><name>eMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set up the required files for pIncr. A multi-theaded IncrMerge object
  ** requires two temp files to itself, whereas a single-threaded object
  ** only requires a region of pTask-&gt;file2. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>mxSz</name> <init>= <expr><name><name>pIncr</name><operator>-&gt;</operator><name>mxSz</name></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name><name>pIncr</name><operator>-&gt;</operator><name>bUseThread</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterOpenTempFile</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>mxSz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterOpenTempFile</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>mxSz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*if( !pIncr-&gt;bUseThread )*/</comment><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pTask</name><operator>-&gt;</operator><name>file2</name><operator>.</operator><name>pFd</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>file2</name><operator>.</operator><name>iEof</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterOpenTempFile</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>file2</name><operator>.</operator><name>iEof</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTask</name><operator>-&gt;</operator><name>file2</name><operator>.</operator><name>pFd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTask</name><operator>-&gt;</operator><name>file2</name><operator>.</operator><name>iEof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIncr</name><operator>-&gt;</operator><name>aFile</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pFd</name> <operator>=</operator> <name><name>pTask</name><operator>-&gt;</operator><name>file2</name><operator>.</operator><name>pFd</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIncr</name><operator>-&gt;</operator><name>iStartOff</name></name> <operator>=</operator> <name><name>pTask</name><operator>-&gt;</operator><name>file2</name><operator>.</operator><name>iEof</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTask</name><operator>-&gt;</operator><name>file2</name><operator>.</operator><name>iEof</name></name> <operator>+=</operator> <name>mxSz</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pIncr</name><operator>-&gt;</operator><name>bUseThread</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Use the current thread to populate aFile[1], even though this
    ** PmaReader is multi-threaded. If this is an INCRINIT_TASK object,
    ** then this function is already running in background thread 
    ** pIncr-&gt;pTask-&gt;thread. 
    **
    ** If this is the INCRINIT_ROOT object, then it is running in the 
    ** main VDBE thread. But that is Ok, as that thread cannot return
    ** control to the VDBE or proceed with anything useful until the 
    ** first results are ready from this merger object anyway.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMode</name><operator>==</operator><name>INCRINIT_ROOT</name> <operator>||</operator> <name>eMode</name><operator>==</operator><name>INCRINIT_TASK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeIncrPopulate</name><argument_list>(<argument><expr><name>pIncr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>SQLITE_MAX_WORKER_THREADS</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>eMode</name><operator>!=</operator><name>INCRINIT_TASK</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReaderNext</name><argument_list>(<argument><expr><name>pReadr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** The main routine for vdbePmaReaderIncrMergeInit() operations run in 
** background threads.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>vdbePmaReaderBgIncrInit</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReader</name> <init>= <expr><operator>(</operator><name>PmaReader</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><call><name>SQLITE_INT_TO_PTR</name><argument_list>(
                  <argument><expr><call><name>vdbePmaReaderIncrMergeInit</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>,<argument><expr><name>INCRINIT_TASK</name></expr></argument>)</argument_list></call></expr></argument>
               )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pIncr</name><operator>-&gt;</operator><name>pTask</name><operator>-&gt;</operator><name>bDone</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** If the PmaReader passed as the first argument is not an incremental-reader
** (if pReadr-&gt;pIncr==0), then this function is a no-op. Otherwise, it invokes
** the vdbePmaReaderIncrMergeInit() function with the parameters passed to
** this routine to initialize the incremental merge.
** 
** If the IncrMerger object is multi-threaded (IncrMerger.bUseThread==1), 
** then a background thread is launched to call vdbePmaReaderIncrMergeInit().
** Or, if the IncrMerger is single threaded, the same function is called
** using the current thread.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbePmaReaderIncrInit</name><parameter_list>(<parameter><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReadr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IncrMerger</name> <modifier>*</modifier></type><name>pIncr</name> <init>= <expr><name><name>pReadr</name><operator>-&gt;</operator><name>pIncr</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Incremental merger */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Return code */</comment>
  <if_stmt><if>if<condition>( <expr><name>pIncr</name></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>bUseThread</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>eMode</name><operator>==</operator><name>INCRINIT_TASK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIncr</name><operator>-&gt;</operator><name>bUseThread</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pReadr</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterCreateThread</name><argument_list>(<argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>pTask</name></name></expr></argument>, <argument><expr><name>vdbePmaReaderBgIncrInit</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReaderIncrMergeInit</name><argument_list>(<argument><expr><name>pReadr</name></expr></argument>, <argument><expr><name>eMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a new MergeEngine object to merge the contents of nPMA level-0
** PMAs from pTask-&gt;file. If no error occurs, set *ppOut to point to
** the new object and return SQLITE_OK. Or, if an error does occur, set *ppOut
** to NULL and return an SQLite error code.
**
** When this function is called, *piOffset is set to the offset of the
** first PMA to read from pTask-&gt;file. Assuming no error occurs, it is 
** set to the offset immediately following the last byte of the last
** PMA before returning. If an error does occur, then the final value of
** *piOffset is undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeMergeEngineLevel0</name><parameter_list>(
  <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>,             <comment type="block">/* Sorter task to read from */</comment>
  <parameter><decl><type><name>int</name></type> <name>nPMA</name></decl></parameter>,                       <comment type="block">/* Number of PMAs to read */</comment>
  <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piOffset</name></decl></parameter>,                  <comment type="block">/* IN/OUT: Readr offset in pTask-&gt;file */</comment>
  <parameter><decl><type><name>MergeEngine</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>             <comment type="block">/* OUT: New merge-engine */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>              <comment type="block">/* Merge engine to return */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name> <init>= <expr><operator>*</operator><name>piOffset</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pNew</name> <operator>=</operator> <call><name>vdbeMergeEngineNew</name><argument_list>(<argument><expr><name>nPMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPMA</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>nDummy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReadr</name> <init>= <expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReaderInit</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTask</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>pReadr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOff</name> <operator>=</operator> <name><name>pReadr</name><operator>-&gt;</operator><name>iEof</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vdbeMergeEngineFree</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>piOffset</name> <operator>=</operator> <name>iOff</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the depth of a tree comprising nPMA PMAs, assuming a fanout of
** SORTER_MAX_MERGE_COUNT. The returned value does not include leaf nodes.
**
** i.e.
**
**   nPMA&lt;=16    -&gt; TreeDepth() == 0
**   nPMA&lt;=256   -&gt; TreeDepth() == 1
**   nPMA&lt;=65536 -&gt; TreeDepth() == 2
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterTreeDepth</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nPMA</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nDepth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nDiv</name> <init>= <expr><name>SORTER_MAX_MERGE_COUNT</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>nDiv</name> <operator>&lt;</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>nPMA</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nDiv</name> <operator>=</operator> <name>nDiv</name> <operator>*</operator> <name>SORTER_MAX_MERGE_COUNT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nDepth</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>nDepth</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pRoot is the root of an incremental merge-tree with depth nDepth (according
** to vdbeSorterTreeDepth()). pLeaf is the iSeq'th leaf to be added to the
** tree, counting from zero. This function adds pLeaf to the tree.
**
** If successful, SQLITE_OK is returned. If an error occurs, an SQLite error
** code is returned and pLeaf is freed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterAddToTree</name><parameter_list>(
  <parameter><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name></decl></parameter>,             <comment type="block">/* Task context */</comment>
  <parameter><decl><type><name>int</name></type> <name>nDepth</name></decl></parameter>,                     <comment type="block">/* Depth of tree according to TreeDepth() */</comment>
  <parameter><decl><type><name>int</name></type> <name>iSeq</name></decl></parameter>,                       <comment type="block">/* Sequence number of leaf within tree */</comment>
  <parameter><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pRoot</name></decl></parameter>,             <comment type="block">/* Root of tree */</comment>
  <parameter><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pLeaf</name></decl></parameter>              <comment type="block">/* Leaf to add to tree */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDiv</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>pRoot</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IncrMerger</name> <modifier>*</modifier></type><name>pIncr</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeIncrMergerNew</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><name>pLeaf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pIncr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nDepth</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>nDiv</name> <operator>=</operator> <name>nDiv</name> <operator>*</operator> <name>SORTER_MAX_MERGE_COUNT</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nDepth</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iIter</name> <init>= <expr><operator>(</operator><name>iSeq</name> <operator>/</operator> <name>nDiv</name><operator>)</operator> <operator>%</operator> <name>SORTER_MAX_MERGE_COUNT</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReadr</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name>iIter</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pReadr</name><operator>-&gt;</operator><name>pIncr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>vdbeMergeEngineNew</name><argument_list>(<argument><expr><name>SORTER_MAX_MERGE_COUNT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeIncrMergerNew</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReadr</name><operator>-&gt;</operator><name>pIncr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pReadr</name><operator>-&gt;</operator><name>pIncr</name><operator>-&gt;</operator><name>pMerger</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nDiv</name> <operator>=</operator> <name>nDiv</name> <operator>/</operator> <name>SORTER_MAX_MERGE_COUNT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name>iSeq</name> <operator>%</operator> <name>SORTER_MAX_MERGE_COUNT</name></expr>]</index></name><operator>.</operator><name>pIncr</name> <operator>=</operator> <name>pIncr</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>vdbeIncrFree</name><argument_list>(<argument><expr><name>pIncr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called as part of a SorterRewind() operation on a sorter
** that has already written two or more level-0 PMAs to one or more temp
** files. It builds a tree of MergeEngine/IncrMerger/PmaReader objects that 
** can be used to incrementally merge all PMAs on disk.
**
** If successful, SQLITE_OK is returned and *ppOut set to point to the
** MergeEngine object at the root of the tree before returning. Or, if an
** error occurs, an SQLite error code is returned and the final value 
** of *ppOut is undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterMergeTreeBuild</name><parameter_list>(
  <parameter><decl><type><name>VdbeSorter</name> <modifier>*</modifier></type><name>pSorter</name></decl></parameter>,       <comment type="block">/* The VDBE cursor that implements the sort */</comment>
  <parameter><decl><type><name>MergeEngine</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>        <comment type="block">/* Write the MergeEngine here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pMain</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iTask</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <comment type="block">/* If the sorter uses more than one task, then create the top-level 
  ** MergeEngine here. This MergeEngine will read data from exactly 
  ** one PmaReader per sub-task.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUseThreads</name></name> <operator>||</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pMain</name> <operator>=</operator> <call><name>vdbeMergeEngineNew</name><argument_list>(<argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pMain</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <for>for<control>(<init><expr><name>iTask</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iTask</name><operator>&lt;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name></expr>;</condition> <incr><expr><name>iTask</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask</name> <init>= <expr><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>aTask</name><index>[<expr><name>iTask</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>nPMA</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pTask</name><operator>-&gt;</operator><name>nPMA</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pRoot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Root node of tree for this task */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nDepth</name> <init>= <expr><call><name>vdbeSorterTreeDepth</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>nPMA</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>iReadOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>pTask</name><operator>-&gt;</operator><name>nPMA</name></name><operator>&lt;=</operator><name>SORTER_MAX_MERGE_COUNT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeMergeEngineLevel0</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>nPMA</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iReadOff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iSeq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <call><name>vdbeMergeEngineNew</name><argument_list>(<argument><expr><name>SORTER_MAX_MERGE_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pRoot</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTask</name><operator>-&gt;</operator><name>nPMA</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>SORTER_MAX_MERGE_COUNT</name></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pMerger</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* New level-0 PMA merger */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>nReader</name></decl>;</decl_stmt>              <comment type="block">/* Number of level-0 PMAs to merge */</comment>

          <expr_stmt><expr><name>nReader</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>nPMA</name></name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>SORTER_MAX_MERGE_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeMergeEngineLevel0</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><name>nReader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iReadOff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMerger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterAddToTree</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><name>nDepth</name></expr></argument>, <argument><expr><name>iSeq</name><operator>++</operator></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>, <argument><expr><name>pMerger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
        <if_stmt><if>if<condition>( <expr><name>pMain</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeIncrMergerNew</name><argument_list>(<argument><expr><name>pTask</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMain</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name>iTask</name></expr>]</index></name><operator>.</operator><name>pIncr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMain</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pMain</name> <operator>=</operator> <name>pRoot</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>vdbeMergeEngineFree</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vdbeMergeEngineFree</name><argument_list>(<argument><expr><name>pMain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMain</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pMain</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called as part of an sqlite3VdbeSorterRewind() operation
** on a sorter that has written two or more PMAs to temporary files. It sets
** up either VdbeSorter.pMerger (for single threaded sorters) or pReader
** (for multi-threaded sorters) so that it can be used to iterate through
** all records stored in the sorter.
**
** SQLITE_OK is returned if successful, or an SQLite error code otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSorterSetupMerge</name><parameter_list>(<parameter><decl><type><name>VdbeSorter</name> <modifier>*</modifier></type><name>pSorter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pTask0</name> <init>= <expr><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>aTask</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MergeEngine</name> <modifier>*</modifier></type><name>pMain</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name></expr></cpp:if>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pTask0</name><operator>-&gt;</operator><name>pSorter</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SorterCompare</name></type> <name>xCompare</name> <init>= <expr><call><name>vdbeSorterGetCompare</name><argument_list>(<argument><expr><name>pSorter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>aTask</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xCompare</name> <operator>=</operator> <name>xCompare</name></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterMergeTreeBuild</name><argument_list>(<argument><expr><name>pSorter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name></expr></cpp:if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUseThreads</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUseThreads</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iTask</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReadr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>SortSubtask</name> <modifier>*</modifier></type><name>pLast</name> <init>= <expr><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>aTask</name><index>[<expr><name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSortAllocUnpacked</name><argument_list>(<argument><expr><name>pLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pReadr</name> <operator>=</operator> <operator>(</operator><name>PmaReader</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PmaReader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pReader</name></name> <operator>=</operator> <name>pReadr</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pReadr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeIncrMergerNew</name><argument_list>(<argument><expr><name>pLast</name></expr></argument>, <argument><expr><name>pMain</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReadr</name><operator>-&gt;</operator><name>pIncr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>vdbeIncrMergerSetThreads</name><argument_list>(<argument><expr><name><name>pReadr</name><operator>-&gt;</operator><name>pIncr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>iTask</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iTask</name><operator>&lt;</operator><operator>(</operator><name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>iTask</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>IncrMerger</name> <modifier>*</modifier></type><name>pIncr</name></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pIncr</name> <operator>=</operator> <name><name>pMain</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name>iTask</name></expr>]</index></name><operator>.</operator><name>pIncr</name><operator>)</operator></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>vdbeIncrMergerSetThreads</name><argument_list>(<argument><expr><name>pIncr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIncr</name><operator>-&gt;</operator><name>pTask</name></name><operator>!=</operator><name>pLast</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
          <for>for<control>(<init><expr><name>iTask</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iTask</name><operator>&lt;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name></expr>;</condition> <incr><expr><name>iTask</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <comment type="block">/* Check that:
            **   
            **   a) The incremental merge object is configured to use the
            **      right task, and
            **   b) If it is using task (nTask-1), it is configured to run
            **      in single-threaded mode. This is important, as the
            **      root merge (INCRINIT_ROOT) will be using the same task
            **      object.
            */</comment>
            <decl_stmt><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pMain</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name>iTask</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pIncr</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator>
                <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pIncr</name><operator>-&gt;</operator><name>pTask</name></name><operator>==</operator><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>aTask</name><index>[<expr><name>iTask</name></expr>]</index></name><operator>)</operator>             <comment type="block">/* a */</comment>
             <operator>&amp;&amp;</operator> <operator>(</operator><name>iTask</name><operator>!=</operator><name><name>pSorter</name><operator>-&gt;</operator><name>nTask</name></name><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pIncr</name><operator>-&gt;</operator><name>bUseThread</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator>  <comment type="block">/* b */</comment>
            <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReaderIncrInit</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>INCRINIT_TASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>pMain</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReaderIncrMergeInit</name><argument_list>(<argument><expr><name>pReadr</name></expr></argument>, <argument><expr><name>INCRINIT_ROOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeMergeEngineInit</name><argument_list>(<argument><expr><name>pTask0</name></expr></argument>, <argument><expr><name>pMain</name></expr></argument>, <argument><expr><name>INCRINIT_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pMerger</name></name> <operator>=</operator> <name>pMain</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMain</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vdbeMergeEngineFree</name><argument_list>(<argument><expr><name>pMain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Once the sorter has been populated by calls to sqlite3VdbeSorterWrite,
** this function is called to prepare for iterating through the records
** in sorted order.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeSorterRewind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VdbeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbEof</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeSorter</name> <modifier>*</modifier></type><name>pSorter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_SORTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSorter</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pSorter</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSorter</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If no data has been written to disk, then do not do so now. Instead,
  ** sort the VdbeSorter.pRecord list. The vdbe layer will read data directly
  ** from the in-memory list.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUsePMA</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pbEof</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterSort</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>aTask</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pbEof</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Write the current in-memory list to a PMA. When the VdbeSorterWrite() 
  ** function flushes the contents of memory to disk, it immediately always
  ** creates a new list consisting of a single key immediately afterwards.
  ** So the list is never empty at this point.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterFlushPMA</name><argument_list>(<argument><expr><name>pSorter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Join all threads */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterJoinAll</name><argument_list>(<argument><expr><name>pSorter</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>vdbeSorterRewindDebug</name><argument_list>(<argument><expr><literal type="string">"rewind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Assuming no errors have occurred, set up a merger structure to 
  ** incrementally read and merge all remaining PMAs.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pReader</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeSorterSetupMerge</name><argument_list>(<argument><expr><name>pSorter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pbEof</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>vdbeSorterRewindDebug</name><argument_list>(<argument><expr><literal type="string">"rewinddone"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance to the next element in the sorter.  Return value:
**
**    SQLITE_OK     success
**    SQLITE_DONE   end of data
**    otherwise     some kind of error.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeSorterNext</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VdbeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeSorter</name> <modifier>*</modifier></type><name>pSorter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_SORTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSorter</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pSorter</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUsePMA</name></name> <operator>||</operator> <operator>(</operator><name><name>pSorter</name><operator>-&gt;</operator><name>pReader</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>pMerger</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUsePMA</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pReader</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>pMerger</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUseThreads</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>pReader</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUseThreads</name></name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>pMerger</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUseThreads</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbePmaReaderNext</name><argument_list>(<argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pReader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>pReader</name><operator>-&gt;</operator><name>pFd</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*if( !pSorter-&gt;bUseThreads )*/</comment> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pMerger</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pMerger</name><operator>-&gt;</operator><name>pTask</name></name><operator>==</operator><operator>(</operator><operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>aTask</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeMergeEngineStep</name><argument_list>(<argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>pMerger</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>res</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>SorterRecord</name> <modifier>*</modifier></type><name>pFree</name> <init>= <expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name> <operator>=</operator> <name><name>pFree</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFree</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>aMemory</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>vdbeSorterRecordFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>SQLITE_DONE</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to a buffer owned by the sorter that contains the 
** current key.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>vdbeSorterRowkey</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>VdbeSorter</name> <modifier>*</modifier></type><name>pSorter</name></decl></parameter>,      <comment type="block">/* Sorter object */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnKey</name></decl></parameter>                      <comment type="block">/* OUT: Size of current key in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUsePMA</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>PmaReader</name> <modifier>*</modifier></type><name>pReader</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_WORKER_THREADS</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name><name>pSorter</name><operator>-&gt;</operator><name>bUseThreads</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pReader</name> <operator>=</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>pReader</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*if( !pSorter-&gt;bUseThreads )*/</comment><block>{<block_content>
      <expr_stmt><expr><name>pReader</name> <operator>=</operator> <operator>&amp;</operator><name><name>pSorter</name><operator>-&gt;</operator><name>pMerger</name><operator>-&gt;</operator><name>aReadr</name><index>[<expr><name><name>pSorter</name><operator>-&gt;</operator><name>pMerger</name><operator>-&gt;</operator><name>aTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnKey</name> <operator>=</operator> <name><name>pReader</name><operator>-&gt;</operator><name>nKey</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pKey</name> <operator>=</operator> <name><name>pReader</name><operator>-&gt;</operator><name>aKey</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnKey</name> <operator>=</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nVal</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pKey</name> <operator>=</operator> <call><name>SRVAL</name><argument_list>(<argument><expr><name><name>pSorter</name><operator>-&gt;</operator><name>list</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pKey</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Copy the current sorter key into the memory cell pOut.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeSorterRowkey</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VdbeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeSorter</name> <modifier>*</modifier></type><name>pSorter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>           <comment type="block">/* Sorter key to copy into pOut */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_SORTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSorter</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pSorter</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pKey</name> <operator>=</operator> <call><name>vdbeSorterRowkey</name><argument_list>(<argument><expr><name>pSorter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemClearAndResize</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>nKey</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare the key in memory cell pVal with the key that the sorter cursor
** passed as the first argument currently points to. For the purposes of
** the comparison, ignore the rowid field at the end of each record.
**
** If the sorter cursor key contains any NULL values, consider it to be
** less than pVal. Even if pVal also contains NULL values.
**
** If an error occurs, return an SQLite error code (i.e. SQLITE_NOMEM).
** Otherwise, set *pRes to a negative, zero or positive value if the
** key in pVal is smaller than, equal to or larger than the current sorter
** key.
**
** This routine forms the core of the OP_SorterCompare opcode, which in
** turn is used to verify uniqueness when constructing a UNIQUE INDEX.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeSorterCompare</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>VdbeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,         <comment type="block">/* Sorter cursor */</comment>
  <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>,                      <comment type="block">/* Value to compare to current sorter key */</comment>
  <parameter><decl><type><name>int</name></type> <name>nKeyCol</name></decl></parameter>,                    <comment type="block">/* Compare this many columns */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRes</name></decl></parameter>                       <comment type="block">/* OUT: Result of comparison */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeSorter</name> <modifier>*</modifier></type><name>pSorter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>r2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>           <comment type="block">/* Sorter key to compare pVal with */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_SORTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSorter</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pSorter</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>r2</name> <operator>=</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>pUnpacked</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>r2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>r2</name> <operator>=</operator> <name><name>pSorter</name><operator>-&gt;</operator><name>pUnpacked</name></name> <operator>=</operator> <call><name>sqlite3VdbeAllocUnpackedRecord</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>r2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>r2</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>nKeyCol</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>r2</name><operator>-&gt;</operator><name>nField</name></name><operator>==</operator><name>nKeyCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pKey</name> <operator>=</operator> <call><name>vdbeSorterRowkey</name><argument_list>(<argument><expr><name>pSorter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeRecordUnpack</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nKeyCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>r2</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><operator>*</operator><name>pRes</name> <operator>=</operator> <call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
</unit>
