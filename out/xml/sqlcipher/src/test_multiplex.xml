<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/test_multiplex.c"><comment type="block">/*
** 2010 October 28
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains a VFS "shim" - a layer that sits in between the
** pager and the real VFS - that breaks up a very large database file
** into two or more smaller files on disk.  This is useful, for example,
** in order to support large, multi-gigabyte databases on older filesystems
** that limit the maximum file size to 2 GiB.
**
** USAGE:
**
** Compile this source file and link it with your application.  Then
** at start-time, invoke the following procedure:
**
**   int sqlite3_multiplex_initialize(
**      const char *zOrigVfsName,    // The underlying real VFS
**      int makeDefault              // True to make multiplex the default VFS
**   );
**
** The procedure call above will create and register a new VFS shim named
** "multiplex".  The multiplex VFS will use the VFS named by zOrigVfsName to
** do the actual disk I/O.  (The zOrigVfsName parameter may be NULL, in 
** which case the default VFS at the moment sqlite3_multiplex_initialize()
** is called will be used as the underlying real VFS.)  
**
** If the makeDefault parameter is TRUE then multiplex becomes the new
** default VFS.  Otherwise, you can use the multiplex VFS by specifying
** "multiplex" as the 4th parameter to sqlite3_open_v2() or by employing
** URI filenames and adding "vfs=multiplex" as a parameter to the filename
** URI.
**
** The multiplex VFS allows databases up to 32 GiB in size.  But it splits
** the files up into smaller pieces, so that they will work even on 
** filesystems that do not support large files.  The default chunk size
** is 2147418112 bytes (which is 64KiB less than 2GiB) but this can be
** changed at compile-time by defining the SQLITE_MULTIPLEX_CHUNK_SIZE
** macro.  Use the "chunksize=NNNN" query parameter with a URI filename
** in order to select an alternative chunk size for individual connections
** at run-time.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"test_multiplex.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_CORE</name></cpp:ifndef>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_CORE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>  <comment type="block">/* Disable the API redefinition in sqlite3ext.h */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>

<comment type="block">/* 
** These should be defined to be the same as the values in 
** sqliteInt.h.  They are defined separately here so that
** the multiplex VFS shim can be built as a loadable 
** module.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED_PARAMETER</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PAGE_SIZE</name></cpp:macro>       <cpp:value>0x10000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_SECTOR_SIZE</name></cpp:macro> <cpp:value>0x1000</cpp:value></cpp:define>

<comment type="block">/* Maximum chunk number */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MX_CHUNK_NUMBER</name></cpp:macro> <cpp:value>299</cpp:value></cpp:define>

<comment type="block">/* First chunk for rollback journal files */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_MULTIPLEX_JOURNAL_8_3_OFFSET</name></cpp:macro> <cpp:value>400</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_MULTIPLEX_WAL_8_3_OFFSET</name></cpp:macro> <cpp:value>700</cpp:value></cpp:define>


<comment type="block" format="doxygen">/************************ Shim Definitions ******************************/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_MULTIPLEX_VFS_NAME</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_MULTIPLEX_VFS_NAME</name></cpp:macro> <cpp:value>"multiplex"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* This is the limit on the chunk size.  It may be changed by calling
** the xFileControl() interface.  It will be rounded up to a 
** multiple of MAX_PAGE_SIZE.  We default it here to 2GiB less 64KiB.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_MULTIPLEX_CHUNK_SIZE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_MULTIPLEX_CHUNK_SIZE</name></cpp:macro> <cpp:value>2147418112</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* This used to be the default limit on number of chunks, but
** it is no longer enforced. There is currently no limit to the
** number of chunks.
**
** May be changed by calling the xFileControl() interface.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_MULTIPLEX_MAX_CHUNKS</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_MULTIPLEX_MAX_CHUNKS</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/************************ Object Definitions ******************************/</comment>

<comment type="block">/* Forward declaration of all object types */</comment>
<typedef>typedef <type><name><name>struct</name> <name>multiplexGroup</name></name></type> <name>multiplexGroup</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>multiplexConn</name></name></type> <name>multiplexConn</name>;</typedef>

<comment type="block">/*
** A "multiplex group" is a collection of files that collectively
** makeup a single SQLite DB file.  This allows the size of the DB
** to exceed the limits imposed by the file system.
**
** There is an instance of the following object for each defined multiplex
** group.
*/</comment>
<struct>struct <name>multiplexGroup</name> <block>{
  <struct>struct <name>multiplexReal</name> <block>{           <comment type="block">/* For each chunk */</comment>
    <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                  <comment type="block">/* Handle for the chunk */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>                          <comment type="block">/* Name of this chunk */</comment>
  }</block> <decl><modifier>*</modifier><name>aReal</name></decl>;</struct>                        <comment type="block">/* list of all chunks */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nReal</name></decl>;</decl_stmt>                       <comment type="block">/* Number of chunks */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>                     <comment type="block">/* Base filename of this group */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>                       <comment type="block">/* Length of base filename */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>                       <comment type="block">/* Flags used for original opening */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>szChunk</name></decl>;</decl_stmt>            <comment type="block">/* Chunk size used for this group */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>bEnabled</name></decl>;</decl_stmt>          <comment type="block">/* TRUE to use Multiplex VFS for this file */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>bTruncate</name></decl>;</decl_stmt>         <comment type="block">/* TRUE to enable truncation of databases */</comment>
}</block>;</struct>

<comment type="block">/*
** An instance of the following object represents each open connection
** to a file that is multiplex'ed.  This object is a 
** subclass of sqlite3_file.  The sqlite3_file object for the underlying
** VFS is appended to this structure.
*/</comment>
<struct>struct <name>multiplexConn</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_file</name></type> <name>base</name></decl>;</decl_stmt>              <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>multiplexGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl>;</decl_stmt>         <comment type="block">/* The underlying group of files */</comment>
}</block>;</struct>

<comment type="block" format="doxygen">/************************* Global Variables **********************************/</comment>
<comment type="block">/*
** All global variables used by this file are containing within the following
** gMultiplex structure.
*/</comment>
<struct><specifier>static</specifier> struct <block>{
  <comment type="block">/* The pOrigVfs is the real, original underlying VFS implementation.
  ** Most operations pass-through to the real VFS.  This value is read-only
  ** during operation.  It is only modified at start-time and thus does not
  ** require a mutex.
  */</comment>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pOrigVfs</name></decl>;</decl_stmt>

  <comment type="block">/* The sThisVfs is the VFS structure used by this shim.  It is initialized
  ** at start-time and thus does not require a mutex
  */</comment>
  <decl_stmt><decl><type><name>sqlite3_vfs</name></type> <name>sThisVfs</name></decl>;</decl_stmt>

  <comment type="block">/* The sIoMethods defines the methods used by sqlite3_file objects 
  ** associated with this shim.  It is initialized at start-time and does
  ** not require a mutex.
  **
  ** When the underlying VFS is called to open a file, it might return 
  ** either a version 1 or a version 2 sqlite3_file object.  This shim
  ** has to create a wrapper sqlite3_file of the same version.  Hence
  ** there are two I/O method structures, one for version 1 and the other
  ** for version 2.
  */</comment>
  <decl_stmt><decl><type><name>sqlite3_io_methods</name></type> <name>sIoMethodsV1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_io_methods</name></type> <name>sIoMethodsV2</name></decl>;</decl_stmt>

  <comment type="block">/* True when this shim has been initialized.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isInitialized</name></decl>;</decl_stmt>
}</block> <decl><name>gMultiplex</name></decl>;</struct>

<comment type="block" format="doxygen">/************************* Utility Routines *********************************/</comment>
<comment type="block">/*
** Compute a string length that is limited to what can be stored in
** lower 30 bits of a 32-bit signed integer.
**
** The value returned will never be negative.  Nor will it ever be greater
** than the actual length of the string.  For very long strings (greater
** than 1GiB) the value returned might be less than the true string length.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexStrlen30</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z2</name> <init>= <expr><name>z</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>z2</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z2</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><literal type="number">0x3fffffff</literal> <operator>&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>z2</name> <operator>-</operator> <name>z</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate the file-name for chunk iChunk of the group with base name
** zBase. The file-name is written to buffer zOut before returning. Buffer
** zOut must be allocated by the caller so that it is at least (nBase+5)
** bytes in size, where nBase is the length of zBase, not including the
** nul-terminator.
**
** If iChunk is 0 (or 400 - the number for the first journal file chunk),
** the output is a copy of the input string. Otherwise, if 
** SQLITE_ENABLE_8_3_NAMES is not defined or the input buffer does not contain
** a "." character, then the output is a copy of the input string with the 
** three-digit zero-padded decimal representation if iChunk appended to it. 
** For example:
**
**   zBase="test.db", iChunk=4  -&gt;  zOut="test.db004"
**
** Or, if SQLITE_ENABLE_8_3_NAMES is defined and the input buffer contains
** a "." character, then everything after the "." is replaced by the 
** three-digit representation of iChunk.
**
**   zBase="test.db", iChunk=4  -&gt;  zOut="test.004"
**
** The output buffer string is terminated by 2 0x00 bytes. This makes it safe
** to pass to sqlite3_uri_parameter() and similar.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>multiplexFilename</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBase</name></decl></parameter>,              <comment type="block">/* Filename for chunk 0 */</comment>
  <parameter><decl><type><name>int</name></type> <name>nBase</name></decl></parameter>,                      <comment type="block">/* Size of zBase in bytes (without \0) */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,                      <comment type="block">/* Flags used to open file */</comment>
  <parameter><decl><type><name>int</name></type> <name>iChunk</name></decl></parameter>,                     <comment type="block">/* Chunk to generate filename for */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>                      <comment type="block">/* Buffer to write generated name to */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>nBase</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>zBase</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iChunk</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iChunk</name><operator>&lt;=</operator><name>MX_CHUNK_NUMBER</name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_8_3_NAMES</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&gt;=</operator><name>n</name><operator>-</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>zOut</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'.'</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>n</name><operator>-</operator><literal type="number">4</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_MAIN_JOURNAL</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The extensions on overflow files for main databases are 001, 002,
      ** 003 and so forth.  To avoid name collisions, add 400 to the 
      ** extensions of journal files so that they are 401, 402, 403, ....
      */</comment>
      <expr_stmt><expr><name>iChunk</name> <operator>+=</operator> <name>SQLITE_MULTIPLEX_JOURNAL_8_3_OFFSET</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_WAL</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* To avoid name collisions, add 700 to the 
      ** extensions of WAL files so that they are 701, 702, 703, ....
      */</comment>
      <expr_stmt><expr><name>iChunk</name> <operator>+=</operator> <name>SQLITE_MULTIPLEX_WAL_8_3_OFFSET</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"%03d"</literal></expr></argument>,<argument><expr><name>iChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zOut</name><index>[<expr><name>n</name></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Compute the filename for the iChunk-th chunk
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexSubFilename</name><parameter_list>(<parameter><decl><type><name>multiplexGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iChunk</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iChunk</name><operator>&gt;=</operator><name><name>pGroup</name><operator>-&gt;</operator><name>nReal</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>multiplexReal</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name></name></expr></argument>, <argument><expr><operator>(</operator><name>iChunk</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><index>[<expr><name><name>pGroup</name><operator>-&gt;</operator><name>nReal</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>iChunk</name><operator>+</operator><literal type="number">1</literal><operator>-</operator><name><name>pGroup</name><operator>-&gt;</operator><name>nReal</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>nReal</name></name> <operator>=</operator> <name>iChunk</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>zName</name></name> <operator>&amp;&amp;</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>pGroup</name><operator>-&gt;</operator><name>nName</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>multiplexFilename</name><argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>nName</name></name></expr></argument>, <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>iChunk</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>z</name> <operator>=</operator> <call><name>sqlite3_create_filename</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Translate an sqlite3_file* that is really a multiplexGroup* into
** the sqlite3_file* for the underlying original VFS.
**
** For chunk 0, the pGroup-&gt;flags determines whether or not a new file
** is created if it does not already exist.  For chunks 1 and higher, the
** file is created only if createFlag is 1.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_file</name> <modifier>*</modifier></type><name>multiplexSubOpen</name><parameter_list>(
  <parameter><decl><type><name>multiplexGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl></parameter>,    <comment type="block">/* The multiplexor group */</comment>
  <parameter><decl><type><name>int</name></type> <name>iChunk</name></decl></parameter>,                <comment type="block">/* Which chunk to open.  0==original file */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>,                   <comment type="block">/* Result code in and out */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pOutFlags</name></decl></parameter>,            <comment type="block">/* Output flags */</comment>
  <parameter><decl><type><name>int</name></type> <name>createFlag</name></decl></parameter>             <comment type="block">/* True to create if iChunk&gt;0 */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pOrigVfs</name> <init>= <expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Real VFS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_8_3_NAMES</name></cpp:ifdef>
  <comment type="block">/* If JOURNAL_8_3_OFFSET is set to (say) 400, then any overflow files are 
  ** part of a database journal are named db.401, db.402, and so on. A 
  ** database may therefore not grow to larger than 400 chunks. Attempting
  ** to open chunk 401 indicates the database is full. */</comment>
  <if_stmt><if>if<condition>( <expr><name>iChunk</name><operator>&gt;=</operator><name>SQLITE_MULTIPLEX_JOURNAL_8_3_OFFSET</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_FULL</name></expr></argument>, <argument><expr><literal type="string">"multiplexed chunk overflow: %s"</literal></expr></argument>, <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>rc</name> <operator>=</operator> <name>SQLITE_FULL</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><operator>*</operator><name>rc</name> <operator>=</operator> <call><name>multiplexSubFilename</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><name>iChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>rc</name><operator>)</operator><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>pSubOpen</name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>p</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>, <decl><type ref="prev"/><name>bExists</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>createFlag</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>SQLITE_OPEN_CREATE</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iChunk</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Fall through */</comment>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>rc</name> <operator>=</operator> <call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xAccess</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>,
                              <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <if_stmt><if>if<condition>( <expr><operator>*</operator><name>rc</name> <operator>||</operator> <operator>!</operator><name>bExists</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name>rc</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><operator>*</operator><name>rc</name></expr></argument>, <argument><expr><literal type="string">"multiplexor.xAccess failure on %s"</literal></expr></argument>,
                      <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>SQLITE_OPEN_CREATE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>pSubOpen</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name><name>pOrigVfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSubOpen</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_NOMEM</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>p</name> <operator>=</operator> <name>pSubOpen</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>rc</name> <operator>=</operator> <call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name>pSubOpen</name></expr></argument>,
                          <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pOutFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>rc</name><operator>)</operator><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><operator>*</operator><name>rc</name></expr></argument>, <argument><expr><literal type="string">"multiplexor.xOpen failure on %s"</literal></expr></argument>,
                  <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pSubOpen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the size, in bytes, of chunk number iChunk.  If that chunk
** does not exist, then return 0.  This function does not distingish between
** non-existant files and zero-length files.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_int64</name></type> <name>multiplexSubSize</name><parameter_list>(
  <parameter><decl><type><name>multiplexGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl></parameter>,    <comment type="block">/* The multiplexor group */</comment>
  <parameter><decl><type><name>int</name></type> <name>iChunk</name></decl></parameter>,                <comment type="block">/* Which chunk to open.  0==original file */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>                    <comment type="block">/* Result code in and out */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSub</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pSub</name> <operator>=</operator> <call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><name>iChunk</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSub</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>rc</name> <operator>=</operator> <call><name><name>pSub</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>pSub</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>sz</name></expr>;</return>
</block_content>}</block></function>    

<comment type="block">/*
** This is the implementation of the multiplex_control() SQL function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>multiplexControlFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iVal</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>db</name> <operator>||</operator> <name>argc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content> 
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt> 
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* extract params */</comment>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iVal</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* map function op to file_control op */</comment>
    <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">1</literal></expr>:</case> 
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name>MULTIPLEX_CTRL_ENABLE</name></expr>;</expr_stmt> 
        <break>break;</break>
      <case>case <expr><literal type="number">2</literal></expr>:</case> 
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name>MULTIPLEX_CTRL_SET_CHUNK_SIZE</name></expr>;</expr_stmt> 
        <break>break;</break>
      <case>case <expr><literal type="number">3</literal></expr>:</case> 
        <expr_stmt><expr><name>op</name> <operator>=</operator> <name>MULTIPLEX_CTRL_SET_MAX_CHUNKS</name></expr>;</expr_stmt> 
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOTFOUND</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This is the entry point to register the auto-extension for the 
** multiplex_control() function.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexFuncInit</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"multiplex_control"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_ANY</name></expr></argument>, 
      <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>multiplexControlFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close a single sub-file in the connection group.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>multiplexSubClose</name><parameter_list>(
  <parameter><decl><type><name>multiplexGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iChunk</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pOrigVfs</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pOrigVfs</name> <operator>&amp;&amp;</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>z</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free_filename</name><argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Deallocate memory held by a multiplexGroup
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>multiplexFreeComponents</name><parameter_list>(<parameter><decl><type><name>multiplexGroup</name> <modifier>*</modifier></type><name>pGroup</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>nReal</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> <expr_stmt><expr><call><name>multiplexSubClose</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>nReal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/************************* VFS Method Wrappers *****************************/</comment>

<comment type="block">/*
** This is the xOpen method used for the "multiplex" VFS.
**
** Most of the work is done by the underlying original VFS.  This method
** simply links the new file into the appropriate multiplex group if it is a
** file that needs to be tracked.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexOpen</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,         <comment type="block">/* The multiplex VFS */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,         <comment type="block">/* Name of file to be opened */</comment>
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>,       <comment type="block">/* Fill in this file descriptor */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,                 <comment type="block">/* Flags to control the opening */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pOutFlags</name></decl></parameter>             <comment type="block">/* Flags showing results of opening */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Result code */</comment>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>pMultiplexOpen</name></decl>;</decl_stmt>       <comment type="block">/* The new multiplex file descriptor */</comment>
  <decl_stmt><decl><type><name>multiplexGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Corresponding multiplexGroup object */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Real file descriptor */</comment>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pOrigVfs</name> <init>= <expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Real VFS */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zToFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zName</name> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_DELETEONCLOSE</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We need to create a group structure and manage
  ** access to this group of files.
  */</comment>
  <expr_stmt><expr><name>pMultiplexOpen</name> <operator>=</operator> <operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* allocate space for group */</comment>
    <expr_stmt><expr><name>nName</name> <operator>=</operator> <ternary><condition><expr><name>zName</name></expr> ?</condition><then> <expr><call><name>multiplexStrlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>multiplexGroup</name></expr></argument>)</argument_list></sizeof>                             <comment type="block">/* multiplexGroup */</comment>
       <operator>+</operator> <name>nName</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>                                         <comment type="block">/* zName */</comment>
    <expr_stmt><expr><name>pGroup</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>sz</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pGroup</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUri</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_URI</name><operator>)</operator></expr> ?</condition><then> <expr><name>zName</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <comment type="block">/* assign pointers to extra space allocated */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMultiplexOpen</name><operator>-&gt;</operator><name>pGroup</name></name> <operator>=</operator> <name>pGroup</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>bEnabled</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>bTruncate</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><call><name>sqlite3_uri_boolean</name><argument_list>(<argument><expr><name>zUri</name></expr></argument>, <argument><expr><literal type="string">"truncate"</literal></expr></argument>, 
                                   <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_MAIN_DB</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>sqlite3_uri_int64</name><argument_list>(<argument><expr><name>zUri</name></expr></argument>, <argument><expr><literal type="string">"chunksize"</literal></expr></argument>,
                                        <argument><expr><name>SQLITE_MULTIPLEX_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name> <operator>=</operator> <operator>(</operator><name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name><operator>+</operator><literal type="number">0xffff</literal><operator>)</operator><operator>&amp;</operator><operator>~</operator><literal type="number">0xffff</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zName</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pGroup</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>nName</name></name> <operator>=</operator> <name>nName</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>bEnabled</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Make sure that the chunksize is such that the pending byte does not
      ** falls at the end of a chunk.  A region of up to 64K following
      ** the pending byte is never written, so if the pending byte occurs
      ** near the end of a chunk, that chunk will be too small. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WSD</name></cpp:ifndef>
      <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>sqlite3PendingByte</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <decl_stmt><decl><type><name>int</name></type> <name>sqlite3PendingByte</name> <init>= <expr><literal type="number">0x40000000</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <while>while<condition>( <expr><operator>(</operator><name>sqlite3PendingByte</name> <operator>%</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name><operator>)</operator><operator>&gt;=</operator><operator>(</operator><name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name><operator>-</operator><literal type="number">65536</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name> <operator>+=</operator> <literal type="number">65536</literal></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>SQLITE_OPEN_URI</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiplexSubFilename</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pSubOpen</name> <operator>=</operator> <call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pOutFlags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pSubOpen</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>sz64</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>zName</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bExists</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_SUPER_JOURNAL</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>bEnabled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else
        if<condition>( <expr><name>sz64</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_MAIN_JOURNAL</name></expr> )</condition><block>{<block_content>
            <comment type="block">/* If opening a main journal file and the first chunk is zero
            ** bytes in size, delete any subsequent chunks from the 
            ** file-system. */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>iChunk</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <do>do <block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xAccess</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, 
                  <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bExists</name></expr></argument>
              )</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bExists</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>iChunk</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
                  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multiplexSubFilename</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><operator>++</operator><name>iChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bExists</name></expr> )</condition>;</do>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* If the first overflow file exists and if the size of the main file
          ** is different from the chunk size, that means the chunk size is set
          ** set incorrectly.  So fix it.
          **
          ** Or, if the first overflow file does not exist and the main file is
          ** larger than the chunk size, that means the chunk size is too small.
          ** But we have no way of determining the intended chunk size, so 
          ** just disable the multiplexor all togethre.
          */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xAccess</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>,
              <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>bExists</name> <operator>=</operator> <call><name>multiplexSubSize</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bExists</name> <operator>&amp;&amp;</operator> <name>sz64</name><operator>==</operator><operator>(</operator><name>sz64</name><operator>&amp;</operator><literal type="number">0xffff0000</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>sz64</name><operator>&gt;</operator><literal type="number">0</literal>
              <operator>&amp;&amp;</operator> <name>sz64</name><operator>!=</operator><name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>sz64</name></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>bExists</name> <operator>&amp;&amp;</operator> <name>sz64</name><operator>&gt;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>bEnabled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>iVersion</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pConn</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pConn</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV2</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>multiplexFreeComponents</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zToFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the xDelete method used for the "multiplex" VFS.
** It attempts to delete the filename specified.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexDelete</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,         <comment type="block">/* The multiplex VFS */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,         <comment type="block">/* Name of file to delete */</comment>
  <parameter><decl><type><name>int</name></type> <name>syncDir</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pOrigVfs</name> <init>= <expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Real VFS */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>syncDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If the main chunk was deleted successfully, also delete any subsequent
    ** chunks - starting with the last (highest numbered). 
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nName</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iChunk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bExists</name></decl>;</decl_stmt>
      <do>do<block>{<block_content>
        <expr_stmt><expr><call><name>multiplexFilename</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr><name>SQLITE_OPEN_MAIN_JOURNAL</name></expr></argument>, <argument><expr><operator>++</operator><name>iChunk</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xAccess</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bExists</name></expr> )</condition>;</do>
      <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iChunk</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>multiplexFilename</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr><name>SQLITE_OPEN_MAIN_JOURNAL</name></expr></argument>, <argument><expr><operator>--</operator><name>iChunk</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>syncDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iChunk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <do>do<block>{<block_content>
          <expr_stmt><expr><call><name>multiplexFilename</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr><name>SQLITE_OPEN_WAL</name></expr></argument>, <argument><expr><operator>++</operator><name>iChunk</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xAccess</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bExists</name></expr> )</condition>;</do>
        <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iChunk</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>multiplexFilename</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr><name>SQLITE_OPEN_WAL</name></expr></argument>, <argument><expr><operator>--</operator><name>iChunk</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pOrigVfs</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name>pOrigVfs</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>syncDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexAccess</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xAccess</name></name><argument_list>(<argument><expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexFullPathname</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xFullPathname</name></name><argument_list>(<argument><expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>multiplexDlOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xDlOpen</name></name><argument_list>(<argument><expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>multiplexDlError</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xDlError</name></name><argument_list>(<argument><expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><specifier>static</specifier> <macro><name>void</name> <argument_list>(<argument>*multiplexDlSym(sqlite3_vfs *a, void *b, const char *c)</argument>)</argument_list></macro><operator>(</operator><name>void</name><operator>)</operator><block>{
  <return>return <expr><call><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xDlSym</name></name><argument_list>(<argument><expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>multiplexDlClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xDlClose</name></name><argument_list>(<argument><expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexRandomness</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xRandomness</name></name><argument_list>(<argument><expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexSleep</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xSleep</name></name><argument_list>(<argument><expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexCurrentTime</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xCurrentTime</name></name><argument_list>(<argument><expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexGetLastError</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xGetLastError</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xGetLastError</name></name><argument_list>(<argument><expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexCurrentTimeInt64</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name><operator>-&gt;</operator><name>xCurrentTimeInt64</name></name><argument_list>(<argument><expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************ I/O Method Wrappers *******************************/</comment>

<comment type="block">/* xClose requests get passed through to the original VFS.
** We loop over all open chunk handles and close them.
** The group structure for this file is unlinked from 
** our list of groups and freed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>multiplexGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>multiplexFreeComponents</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xRead requests thru to the original VFS after
** determining the correct chunk to operate on.
** Break up reads across chunk boundaries.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexRead</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOfst</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>multiplexGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pGroup</name><operator>-&gt;</operator><name>bEnabled</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSubOpen</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_READ</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>, <argument><expr><name>iOfst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <while>while<condition>( <expr><name>iAmt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>iOfst</name> <operator>/</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pSubOpen</name> <operator>=</operator> <call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>extra</name> <init>= <expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>iOfst</name> <operator>%</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name><operator>)</operator> <operator>+</operator> <name>iAmt</name><operator>)</operator> <operator>-</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>extra</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>extra</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>iAmt</name> <operator>-=</operator> <name>extra</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>,
                                       <argument><expr><name>iOfst</name> <operator>%</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pBuf</name> <operator>+</operator> <name>iAmt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iOfst</name> <operator>+=</operator> <name>iAmt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iAmt</name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_READ</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xWrite requests thru to the original VFS after
** determining the correct chunk to operate on.
** Break up writes across chunk boundaries.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexWrite</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOfst</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>multiplexGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pGroup</name><operator>-&gt;</operator><name>bEnabled</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSubOpen</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_WRITE</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>, <argument><expr><name>iOfst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iAmt</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>iOfst</name> <operator>/</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>extra</name> <init>= <expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>iOfst</name> <operator>%</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name><operator>)</operator> <operator>+</operator> <name>iAmt</name><operator>)</operator> <operator>-</operator>
                    <name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>extra</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>extra</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>iAmt</name> <operator>-=</operator> <name>extra</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>,
                                        <argument><expr><name>iOfst</name> <operator>%</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pBuf</name> <operator>+</operator> <name>iAmt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iOfst</name> <operator>+=</operator> <name>iAmt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iAmt</name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xTruncate requests thru to the original VFS after
** determining the correct chunk to operate on.  Delete any
** chunks above the truncate mark.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>size</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>multiplexGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pGroup</name><operator>-&gt;</operator><name>bEnabled</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSubOpen</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_TRUNCATE</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xTruncate</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iBaseGroup</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>size</name> <operator>/</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pOrigVfs</name> <init>= <expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Real VFS */</comment>
    <comment type="block">/* delete the chunks above the truncate limit */</comment>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>nReal</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><name>iBaseGroup</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>bTruncate</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>multiplexSubClose</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>pOrigVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pSubOpen</name> <operator>=</operator> <call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xTruncate</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pSubOpen</name> <operator>=</operator> <call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><name>iBaseGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xTruncate</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>size</name> <operator>%</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_TRUNCATE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xSync requests through to the original VFS without change
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>multiplexGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>nReal</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xSync</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xFileSize requests through to the original VFS.
** Aggregate the size of all the chunks before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>multiplexGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pGroup</name><operator>-&gt;</operator><name>bEnabled</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pSubOpen</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_FSTAT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>pSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>sz</name> <init>= <expr><call><name>multiplexSubSize</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>sz</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <name>i</name><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name> <operator>+</operator> <name>sz</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xLock requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xLock</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xUnlock requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xUnlock</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_IOERR_UNLOCK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xCheckReservedLock requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xCheckReservedLock</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>pResOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_IOERR_CHECKRESERVEDLOCK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xFileControl requests through to the original VFS unchanged,
** except for any MULTIPLEX_CTRL_* requests here.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>multiplexGroup</name> <modifier>*</modifier></type><name>pGroup</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>gMultiplex</name><operator>.</operator><name>isInitialized</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>MULTIPLEX_CTRL_ENABLE</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name>pArg</name></expr> )</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bEnabled</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>bEnabled</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>bEnabled</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>MULTIPLEX_CTRL_SET_CHUNK_SIZE</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name>pArg</name></expr> )</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>szChunk</name> <init>= <expr><operator>*</operator><operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>szChunk</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* Round up to nearest multiple of MAX_PAGE_SIZE. */</comment>
          <expr_stmt><expr><name>szChunk</name> <operator>=</operator> <operator>(</operator><name>szChunk</name> <operator>+</operator> <operator>(</operator><name>MAX_PAGE_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>szChunk</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MAX_PAGE_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name> <operator>=</operator> <name>szChunk</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>MULTIPLEX_CTRL_SET_MAX_CHUNKS</name></expr>:</case>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>SQLITE_FCNTL_SIZE_HINT</name></expr>:</case>
    <case>case <expr><name>SQLITE_FCNTL_CHUNK_SIZE</name></expr>:</case>
      <comment type="block">/* no-op these */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>SQLITE_FCNTL_PRAGMA</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>aFcntl</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
      <comment type="block">/*
      ** EVIDENCE-OF: R-29875-31678 The argument to the SQLITE_FCNTL_PRAGMA
      ** file control is an array of pointers to strings (char**) in which the
      ** second element of the array is the name of the pragma and the third
      ** element is the argument to the pragma or NULL if the pragma has no
      ** argument.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>aFcntl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>aFcntl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"multiplex_"</literal></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>multiplexFileSize</name><argument_list>(<argument><expr><name>pConn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
        ** PRAGMA multiplex_truncate=BOOLEAN;
        ** PRAGMA multiplex_truncate;
        **
        ** Turn the multiplexor truncate feature on or off.  Return either
        ** "on" or "off" to indicate the new setting.  If the BOOLEAN argument
        ** is omitted, just return the current value for the truncate setting.
        */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>aFcntl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"multiplex_truncate"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>aFcntl</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>aFcntl</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>aFcntl</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
             <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>aFcntl</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>bTruncate</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if><if type="elseif">else
            if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>aFcntl</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
             <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>aFcntl</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name><name>pGroup</name><operator>-&gt;</operator><name>bTruncate</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <comment type="block">/* EVIDENCE-OF: R-27806-26076 The handler for an SQLITE_FCNTL_PRAGMA
          ** file control can optionally make the first element of the char**
          ** argument point to a string obtained from sqlite3_mprintf() or the
          ** equivalent and that string will become the result of the pragma
          ** or the error message if the pragma fails.
          */</comment>
          <expr_stmt><expr><name><name>aFcntl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>pGroup</name><operator>-&gt;</operator><name>bTruncate</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/*
        ** PRAGMA multiplex_enabled;
        **
        ** Return 0 or 1 depending on whether the multiplexor is enabled or
        ** disabled, respectively.
        */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>aFcntl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"multiplex_enabled"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>aFcntl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>bEnabled</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/*
        ** PRAGMA multiplex_chunksize;
        **
        ** Return the chunksize for the multiplexor, or no-op if the 
        ** multiplexor is not active.
        */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>aFcntl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"multiplex_chunksize"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <name><name>pGroup</name><operator>-&gt;</operator><name>bEnabled</name></name></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>aFcntl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>pGroup</name><operator>-&gt;</operator><name>szChunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/*
        ** PRAGMA multiplex_filecount;
        **
        ** Return the number of disk files currently in use by the
        ** multiplexor.  This should be the total database size size
        ** divided by the chunksize and rounded up.
        */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>aFcntl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"multiplex_filecount"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pGroup</name><operator>-&gt;</operator><name>nReal</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pGroup</name><operator>-&gt;</operator><name>aReal</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>p</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><name><name>aFcntl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* If the multiplexor does not handle the pragma, pass it through
      ** into the default case. */</comment>
    </block_content>}</block>
    <default>default:</default>
      <expr_stmt><expr><name>pSubOpen</name> <operator>=</operator> <call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileControl</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_FCNTL_VFSNAME</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
         <expr_stmt><expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"multiplex/%z"</literal></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xSectorSize requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSubOpen</name> <operator>&amp;&amp;</operator> <name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xSectorSize</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xSectorSize</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEFAULT_SECTOR_SIZE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xDeviceCharacteristics requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexDeviceCharacteristics</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xDeviceCharacteristics</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xShmMap requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexShmMap</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>,            <comment type="block">/* Handle open on database file */</comment>
  <parameter><decl><type><name>int</name></type> <name>iRegion</name></decl></parameter>,                    <comment type="block">/* Region to retrieve */</comment>
  <parameter><decl><type><name>int</name></type> <name>szRegion</name></decl></parameter>,                   <comment type="block">/* Size of regions */</comment>
  <parameter><decl><type><name>int</name></type> <name>bExtend</name></decl></parameter>,                    <comment type="block">/* True to extend file if necessary */</comment>
  <parameter><decl><type><name>void</name> <specifier>volatile</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>              <comment type="block">/* OUT: Mapped memory */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmMap</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>iRegion</name></expr></argument>, <argument><expr><name>szRegion</name></expr></argument>, <argument><expr><name>bExtend</name></expr></argument>,<argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xShmLock requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexShmLock</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>,       <comment type="block">/* Database file holding the shared memory */</comment>
  <parameter><decl><type><name>int</name></type> <name>ofst</name></decl></parameter>,                  <comment type="block">/* First lock to acquire or release */</comment>
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,                     <comment type="block">/* Number of locks to acquire or release */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>                  <comment type="block">/* What to do with the lock */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmLock</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>ofst</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pass xShmBarrier requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>multiplexShmBarrier</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmBarrier</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Pass xShmUnmap requests through to the original VFS unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiplexShmUnmap</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pConn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deleteFlag</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>multiplexConn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>multiplexConn</name><operator>*</operator><operator>)</operator><name>pConn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSubOpen</name> <init>= <expr><call><name>multiplexSubOpen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGroup</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSubOpen</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name><name>pSubOpen</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmUnmap</name></name><argument_list>(<argument><expr><name>pSubOpen</name></expr></argument>, <argument><expr><name>deleteFlag</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************** Public Interfaces *****************************/</comment>
<comment type="block">/*
** CAPI: Initialize the multiplex VFS shim - sqlite3_multiplex_initialize()
**
** Use the VFS named zOrigVfsName as the VFS that does the actual work.  
** Use the default if zOrigVfsName==NULL.  
**
** The multiplex VFS shim is named "multiplex".  It will become the default
** VFS if makeDefault is non-zero.
**
** THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once
** during start-up.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_multiplex_initialize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOrigVfsName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>makeDefault</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pOrigVfs</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>gMultiplex</name><operator>.</operator><name>isInitialized</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pOrigVfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><name>zOrigVfsName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrigVfs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrigVfs</name><operator>!=</operator><operator>&amp;</operator><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>isInitialized</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>pOrigVfs</name></name> <operator>=</operator> <name>pOrigVfs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name></name> <operator>=</operator> <operator>*</operator><name>pOrigVfs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>szOsFile</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>multiplexConn</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>zName</name></name> <operator>=</operator> <name>SQLITE_MULTIPLEX_VFS_NAME</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xOpen</name></name> <operator>=</operator> <name>multiplexOpen</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xDelete</name></name> <operator>=</operator> <name>multiplexDelete</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xAccess</name></name> <operator>=</operator> <name>multiplexAccess</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xFullPathname</name></name> <operator>=</operator> <name>multiplexFullPathname</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xDlOpen</name></name> <operator>=</operator> <name>multiplexDlOpen</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xDlError</name></name> <operator>=</operator> <name>multiplexDlError</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xDlSym</name></name> <operator>=</operator> <name>multiplexDlSym</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xDlClose</name></name> <operator>=</operator> <name>multiplexDlClose</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xRandomness</name></name> <operator>=</operator> <name>multiplexRandomness</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xSleep</name></name> <operator>=</operator> <name>multiplexSleep</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xCurrentTime</name></name> <operator>=</operator> <name>multiplexCurrentTime</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xGetLastError</name></name> <operator>=</operator> <name>multiplexGetLastError</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name><operator>.</operator><name>xCurrentTimeInt64</name></name> <operator>=</operator> <name>multiplexCurrentTimeInt64</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>iVersion</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xClose</name></name> <operator>=</operator> <name>multiplexClose</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xRead</name></name> <operator>=</operator> <name>multiplexRead</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xWrite</name></name> <operator>=</operator> <name>multiplexWrite</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xTruncate</name></name> <operator>=</operator> <name>multiplexTruncate</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xSync</name></name> <operator>=</operator> <name>multiplexSync</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xFileSize</name></name> <operator>=</operator> <name>multiplexFileSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xLock</name></name> <operator>=</operator> <name>multiplexLock</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xUnlock</name></name> <operator>=</operator> <name>multiplexUnlock</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xCheckReservedLock</name></name> <operator>=</operator> <name>multiplexCheckReservedLock</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xFileControl</name></name> <operator>=</operator> <name>multiplexFileControl</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xSectorSize</name></name> <operator>=</operator> <name>multiplexSectorSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name><operator>.</operator><name>xDeviceCharacteristics</name></name> <operator>=</operator>
                                            <name>multiplexDeviceCharacteristics</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV2</name></name> <operator>=</operator> <name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV2</name><operator>.</operator><name>iVersion</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV2</name><operator>.</operator><name>xShmMap</name></name> <operator>=</operator> <name>multiplexShmMap</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV2</name><operator>.</operator><name>xShmLock</name></name> <operator>=</operator> <name>multiplexShmLock</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV2</name><operator>.</operator><name>xShmBarrier</name></name> <operator>=</operator> <name>multiplexShmBarrier</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>sIoMethodsV2</name><operator>.</operator><name>xShmUnmap</name></name> <operator>=</operator> <name>multiplexShmUnmap</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_vfs_register</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name></name></expr></argument>, <argument><expr><name>makeDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_auto_extension</name><argument_list>(<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call><operator>)</operator><name>multiplexFuncInit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** CAPI: Shutdown the multiplex system - sqlite3_multiplex_shutdown()
**
** All SQLite database connections must be closed before calling this
** routine.
**
** THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once while
** shutting down in order to free all remaining multiplex groups.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_multiplex_shutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eForce</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>gMultiplex</name><operator>.</operator><name>isInitialized</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>gMultiplex</name><operator>.</operator><name>isInitialized</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_vfs_unregister</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gMultiplex</name><operator>.</operator><name>sThisVfs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gMultiplex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>gMultiplex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***************************** Test Code ***********************************/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_SQLITE_TCL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"sqlite_tcl.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"tcl.h"</cpp:file></cpp:include>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>SQLITE_TCLAPI</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_TCLAPI</name></cpp:macro></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3ErrName</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
** tclcmd: sqlite3_multiplex_initialize NAME MAKEDEFAULT
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_TCLAPI</name></type> <name>test_multiplex_initialize</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>              <comment type="block">/* Name of new multiplex VFS */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>makeDefault</name></decl>;</decl_stmt>                <comment type="block">/* True to make the new VFS the default */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Value returned by multiplex_initialize() */</comment>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>clientData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process arguments */</comment>
  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"NAME MAKEDEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>Tcl_GetBooleanFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>makeDefault</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Call sqlite3_multiplex_initialize() */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_multiplex_initialize</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>makeDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TCL_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tclcmd: sqlite3_multiplex_shutdown
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_TCLAPI</name></type> <name>test_multiplex_shutdown</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>clientData</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Value returned by multiplex_shutdown() */</comment>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>clientData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="string">"-force"</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>objc</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>objc</name><operator>!=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>objc</name><operator>!=</operator><literal type="number">2</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"?-force?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Call sqlite3_multiplex_shutdown() */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_multiplex_shutdown</name><argument_list>(<argument><expr><name>objc</name><operator>==</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TCL_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Tclcmd: test_multiplex_control HANDLE DBNAME SUB-COMMAND ?INT-VALUE?
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_TCLAPI</name></type> <name>test_multiplex_control</name><parameter_list>(
  <parameter><decl><type><name>ClientData</name></type> <name>cd</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>,
  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code from file_control() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>                        <comment type="block">/* Index in aSub[] */</comment>
  <decl_stmt><decl><type><name>Tcl_CmdInfo</name></type> <name>cmdInfo</name></decl>;</decl_stmt>            <comment type="block">/* Command info structure for HANDLE */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                    <comment type="block">/* Underlying db handle for HANDLE */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <struct>struct <name>SubCommand</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>argtype</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aSub</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"enable"</literal></expr>,       <expr><name>MULTIPLEX_CTRL_ENABLE</name></expr>,           <expr><literal type="number">1</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"chunk_size"</literal></expr>,   <expr><name>MULTIPLEX_CTRL_SET_CHUNK_SIZE</name></expr>,   <expr><literal type="number">1</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"max_chunks"</literal></expr>,   <expr><name>MULTIPLEX_CTRL_SET_MAX_CHUNKS</name></expr>,   <expr><literal type="number">1</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
  }</block></expr></init></decl>;</struct>

  <if_stmt><if>if<condition>( <expr><name>objc</name><operator>!=</operator><literal type="number">5</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"HANDLE DBNAME SUB-COMMAND INT-VALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>Tcl_GetCommandInfo</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmdInfo</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"expected database handle, got \""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>db</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>sqlite3</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>cmdInfo</name><operator>.</operator><name>objClientData</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>Tcl_GetIndexFromObjStruct</name><argument_list>(
      <argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>aSub</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>aSub</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"sub-command"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>TCL_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <switch>switch<condition>( <expr><name><name>aSub</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>argtype</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">1</literal></expr>:</case>
      <if_stmt><if>if<condition>( <expr><call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iValue</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><name>TCL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pArg</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iValue</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"SUB-COMMAND"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  </block_content>}</block></switch>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>aSub</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>op</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TCL_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_OK</name><operator>)</operator></expr> ?</condition><then> <expr><name>TCL_OK</name></expr> </then><else>: <expr><name>TCL_ERROR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine registers the custom TCL commands defined in this
** module.  This should be the only procedure visible from outside
** of this module.
*/</comment>
<function><type><name>int</name></type> <name>Sqlitemultiplex_Init</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <struct><specifier>static</specifier> struct <block>{
     <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>Tcl_ObjCmdProc</name> <modifier>*</modifier></type><name>xProc</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aCmd</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"sqlite3_multiplex_initialize"</literal></expr>, <expr><name>test_multiplex_initialize</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_multiplex_shutdown"</literal></expr>, <expr><name>test_multiplex_shutdown</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"sqlite3_multiplex_control"</literal></expr>, <expr><name>test_multiplex_control</name></expr> }</block></expr>,
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aCmd</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>aCmd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>aCmd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xProc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
