<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/update.c"><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that are called by the parser
** to handle UPDATE statements.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>updateVirtualTable</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,       <comment type="block">/* The virtual table to be modified */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,         <comment type="block">/* The virtual table */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pChanges</name></decl></parameter>,  <comment type="block">/* The columns to change in the UPDATE statement */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRowidExpr</name></decl></parameter>,    <comment type="block">/* Expression used to recompute the rowid */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aXRef</name></decl></parameter>,          <comment type="block">/* Mapping from columns of pTab to entries in pChanges */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl></parameter>,        <comment type="block">/* WHERE clause of the UPDATE statement */</comment>
  <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>          <comment type="block">/* ON CONFLICT strategy */</comment>
)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block">/*
** The most recently coded instruction was an OP_Column to retrieve the
** i-th column of table pTab. This routine sets the P4 parameter of the 
** OP_Column to the default value, if any.
**
** The default value of a column is specified by a DEFAULT clause in the 
** column definition. This was either supplied by the user when the table
** was created, or added later to the table definition by an ALTER TABLE
** command. If the latter, then the row-records in the table btree on disk
** may not contain a value for the column and the default value, taken
** from the P4 parameter of the OP_Column instruction, is returned instead.
** If the former, then all row-records are guaranteed to include a value
** for the column and the P4 value is not required.
**
** Column definitions created by an ALTER TABLE command may only have 
** literal default values specified: a number, null or a string. (If a more
** complicated default expression value was provided, it is evaluated 
** when the ALTER TABLE is executed and one of the literal values written
** into the sqlite_schema table.)
**
** Therefore, the P4 parameter is only required if the default value for
** the column is a literal number, string or null. The sqlite3ValueFromExpr()
** function is capable of transforming these types of expressions into
** sqlite3_value objects.
**
** If column as REAL affinity and the table is an ordinary b-tree table
** (not a virtual table) then the value might have been stored as an
** integer.  In that case, add an OP_RealAffinity opcode to make sure
** it has been converted into REAL.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ColumnDefault</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> <init>= <expr><call><name>ENC</name><argument_list>(<argument><expr><call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Column</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr><operator>(</operator><name>v</name><operator>,</operator> <literal type="string">"%s.%s"</literal><operator>,</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name><operator>,</operator> <name><name>pCol</name><operator>-&gt;</operator><name>zCnName</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ValueFromExpr</name><argument_list>(<argument><expr><call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, 
                         <argument><expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>,<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>, 
                         <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>affinity</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pValue</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pValue</name></expr></argument>, <argument><expr><name>P4_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>affinity</name><operator>==</operator><name>SQLITE_AFF_REAL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RealAffinity</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if column iCol of index pIdx references any of the
** columns defined by aXRef and chngRowid.  Return true if it does
** and false if not.  This is an optimization.  False-positives are a
** performance degradation, but false-negatives can result in a corrupt
** index and incorrect answers.
**
** aXRef[j] will be non-negative if column j of the original table is
** being updated.  chngRowid will be true if the rowid of the table is
** being updated.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>indexColumnIsBeingUpdated</name><parameter_list>(
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,      <comment type="block">/* The index to check */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,         <comment type="block">/* Which column of the index to check */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aXRef</name></decl></parameter>,       <comment type="block">/* aXRef[j]&gt;=0 if column j is being updated */</comment>
  <parameter><decl><type><name>int</name></type> <name>chngRowid</name></decl></parameter>     <comment type="block">/* true if the rowid is being updated */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i16</name></type> <name>iIdxCol</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIdxCol</name><operator>!=</operator><name>XN_ROWID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Cannot index rowid */</comment>
  <if_stmt><if>if<condition>( <expr><name>iIdxCol</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>aXRef</name><index>[<expr><name>iIdxCol</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIdxCol</name><operator>==</operator><name>XN_EXPR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>pExpr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ExprReferencesUpdatedColumn</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aColExpr</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>,
                                            <argument><expr><name>aXRef</name></expr></argument>,<argument><expr><name>chngRowid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if index pIdx is a partial index whose conditional
** expression might change values due to an UPDATE.  Return true if
** the index is subject to change and false if the index is guaranteed
** to be unchanged.  This is an optimization.  False-positives are a
** performance degradation, but false-negatives can result in a corrupt
** index and incorrect answers.
**
** aXRef[j] will be non-negative if column j of the original table is
** being updated.  chngRowid will be true if the rowid of the table is
** being updated.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>indexWhereClauseMightChange</name><parameter_list>(
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,      <comment type="block">/* The index to check */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aXRef</name></decl></parameter>,       <comment type="block">/* aXRef[j]&gt;=0 if column j is being updated */</comment>
  <parameter><decl><type><name>int</name></type> <name>chngRowid</name></decl></parameter>     <comment type="block">/* true if the rowid is being updated */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sqlite3ExprReferencesUpdatedColumn</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>pPartIdxWhere</name></name></expr></argument>,
                                            <argument><expr><name>aXRef</name></expr></argument>, <argument><expr><name>chngRowid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and return a pointer to an expression of type TK_ROW with
** Expr.iColumn set to value (iCol+1). The resolver will modify the
** expression to be a TK_COLUMN reading column iCol of the first
** table in the source-list (pSrc-&gt;a[0]).
*/</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>exprRowColumn</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_ROW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>iCol</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Assuming both the pLimit and pOrderBy parameters are NULL, this function
** generates VM code to run the query:
**
**   SELECT &lt;other-columns&gt;, pChanges FROM pTabList WHERE pWhere 
**
** and write the results to the ephemeral table already opened as cursor 
** iEph. None of pChanges, pTabList or pWhere are modified or consumed by 
** this function, they must be deleted by the caller.
**
** Or, if pLimit and pOrderBy are not NULL, and pTab is not a view:
**
**   SELECT &lt;other-columns&gt;, pChanges FROM pTabList 
**   WHERE pWhere
**   GROUP BY &lt;other-columns&gt; 
**   ORDER BY pOrderBy LIMIT pLimit
**
** If pTab is a view, the GROUP BY clause is omitted.
**
** Exactly how results are written to table iEph, and exactly what
** the &lt;other-columns&gt; in the query above are is determined by the type
** of table pTabList-&gt;a[0].pTab.
**
** If the table is a WITHOUT ROWID table, then argument pPk must be its
** PRIMARY KEY. In this case &lt;other-columns&gt; are the primary key columns
** of the table, in order. The results of the query are written to ephemeral
** table iEph as index keys, using OP_IdxInsert.
**
** If the table is actually a view, then &lt;other-columns&gt; are all columns of
** the view. The results are written to the ephemeral table iEph as records
** with automatically assigned integer keys.
**
** If the table is a virtual or ordinary intkey table, then &lt;other-columns&gt; 
** is its rowid. For a virtual table, the results are written to iEph as
** records with automatically assigned integer keys For intkey tables, the
** rowid value in &lt;other-columns&gt; is used as the integer key, and the 
** remaining fields make up the table record. 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>updateFromSelect</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,                  <comment type="block">/* Parse context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iEph</name></decl></parameter>,                       <comment type="block">/* Cursor for open eph. table */</comment>
  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name></decl></parameter>,                     <comment type="block">/* PK if table 0 is WITHOUT ROWID */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pChanges</name></decl></parameter>,             <comment type="block">/* List of expressions to return */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>,              <comment type="block">/* List of tables to select from */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl></parameter>,                   <comment type="block">/* WHERE clause for query */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,             <comment type="block">/* ORDER BY clause */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLimit</name></decl></parameter>                    <comment type="block">/* LIMIT clause */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pGrp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLimit2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eDest</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_UPDATE_DELETE_LIMIT</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>pOrderBy</name> <operator>&amp;&amp;</operator> <name>pLimit</name><operator>==</operator><literal type="number">0</literal></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY without LIMIT on UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pOrderBy2</name> <operator>=</operator> <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLimit2</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>pSrc</name> <operator>=</operator> <call><name>sqlite3SrcListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWhere2</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSrc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fg</name><operator>.</operator><name>notCte</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pTab</name><operator>-&gt;</operator><name>nTabRef</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pTab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPk</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>exprRowColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_UPDATE_DELETE_LIMIT</name></cpp:ifdef>
      <if_stmt><if>if<condition>( <expr><name>pLimit</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pGrp</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pGrp</name></expr></argument>, <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>eDest</name> <operator>=</operator> <ternary><condition><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>SRT_Table</name></expr> </then><else>: <expr><name>SRT_Upfrom</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><call><name>exprRowColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>eDest</name> <operator>=</operator> <name>SRT_Table</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>eDest</name> <operator>=</operator> <ternary><condition><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>SRT_Table</name></expr> </then><else>: <expr><name>SRT_Upfrom</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>TK_ROW</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_UPDATE_DELETE_LIMIT</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name>pLimit</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pGrp</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>TK_ROW</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pChanges</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pChanges</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pChanges</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, 
          <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pChanges</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <call><name>sqlite3SelectNew</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, 
      <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWhere2</name></expr></argument>, <argument><expr><name>pGrp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pOrderBy2</name></expr></argument>, <argument><expr><name>SF_UFSrcCheck</name><operator>|</operator><name>SF_IncludeHidden</name></expr></argument>, <argument><expr><name>pLimit2</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSelect</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pSelect</name><operator>-&gt;</operator><name>selFlags</name></name> <operator>|=</operator> <name>SF_OrderByReqd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><name>eDest</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>iSDParm2</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>pPk</name></expr> ?</condition><then> <expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Process an UPDATE statement.
**
**   UPDATE OR IGNORE tbl SET a=b, c=d FROM tbl2... WHERE e&lt;5 AND f NOT NULL;
**          \_______/ \_/     \______/      \_____/       \________________/
**           onError   |      pChanges         |                pWhere
**                     \_______________________/
**                               pTabList
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Update</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,         <comment type="block">/* The parser context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pTabList</name></decl></parameter>,     <comment type="block">/* The table in which we should change things */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pChanges</name></decl></parameter>,    <comment type="block">/* Things to be changed */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl></parameter>,          <comment type="block">/* The WHERE clause.  May be null */</comment>
  <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>,           <comment type="block">/* How to handle constraint errors */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pOrderBy</name></decl></parameter>,    <comment type="block">/* ORDER BY clause. May be null */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pLimit</name></decl></parameter>,          <comment type="block">/* LIMIT clause. May be null */</comment>
  <parameter><decl><type><name>Upsert</name> <modifier>*</modifier></type><name>pUpsert</name></decl></parameter>        <comment type="block">/* ON CONFLICT clause, or null */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>           <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>           <comment type="block">/* The table to be updated */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrTop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* VDBE instruction address of the start of the loop */</comment>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Information about the WHERE clause */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>               <comment type="block">/* The virtual database engine */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl>;</decl_stmt>           <comment type="block">/* For looping over indices */</comment>
  <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name></decl>;</decl_stmt>            <comment type="block">/* The PRIMARY KEY index for WITHOUT ROWID tables */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nIdx</name></decl>;</decl_stmt>              <comment type="block">/* Number of indices that need updating */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAllIdx</name></decl>;</decl_stmt>           <comment type="block">/* Total number of indexes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBaseCur</name></decl>;</decl_stmt>          <comment type="block">/* Base cursor number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDataCur</name></decl>;</decl_stmt>          <comment type="block">/* Cursor for the canonical data btree */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name></decl>;</decl_stmt>           <comment type="block">/* Cursor for the first index */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>           <comment type="block">/* The database structure */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aRegIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Registers for to each index and the main table */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aXRef</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* aXRef[i] is the index in pChanges-&gt;a[] of the
                         ** an expression for the i-th column of the table.
                         ** aXRef[i]==-1 if the i-th column is not changed. */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aToOpen</name></decl>;</decl_stmt>           <comment type="block">/* 1 for tables and indices to be opened */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>chngPk</name></decl>;</decl_stmt>             <comment type="block">/* PRIMARY KEY changed in a WITHOUT ROWID table */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>chngRowid</name></decl>;</decl_stmt>          <comment type="block">/* Rowid changed in a normal table */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>chngKey</name></decl>;</decl_stmt>            <comment type="block">/* Either chngPk or chngRowid */</comment>
  <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRowidExpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Expression defining the new record number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iRowidExpr</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Index of "rowid=" (or IPK) assignment in pChanges */</comment>
  <decl_stmt><decl><type><name>AuthContext</name></type> <name>sContext</name></decl>;</decl_stmt>  <comment type="block">/* The authorization context */</comment>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>       <comment type="block">/* The name-context to resolve expressions in */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>               <comment type="block">/* Database containing the table being updated */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eOnePass</name></decl>;</decl_stmt>          <comment type="block">/* ONEPASS_XXX value from where.c */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>hasFK</name></decl>;</decl_stmt>             <comment type="block">/* True if foreign key processing is required */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>labelBreak</name></decl>;</decl_stmt>        <comment type="block">/* Jump here to break out of UPDATE loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>labelContinue</name></decl>;</decl_stmt>     <comment type="block">/* Jump here to continue next step of UPDATE loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>             <comment type="block">/* Flags for sqlite3WhereBegin() */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>isView</name></decl>;</decl_stmt>            <comment type="block">/* True when updating a view (INSTEAD OF trigger) */</comment>
  <decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>pTrigger</name></decl>;</decl_stmt>     <comment type="block">/* List of triggers on pTab, if required */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>tmask</name></decl>;</decl_stmt>             <comment type="block">/* Mask of TRIGGER_BEFORE|TRIGGER_AFTER */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>newmask</name></decl>;</decl_stmt>           <comment type="block">/* Mask of NEW.* columns accessed by BEFORE triggers */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iEph</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Ephemeral table holding all primary key values */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Number of elements in regKey for WITHOUT ROWID */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>aiCurOnePass</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* The write cursors opened by WHERE_ONEPASS */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrOpen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Address of OP_OpenEphemeral */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* First of nPk cells holding PRIMARY KEY value */</comment>
  <decl_stmt><decl><type><name>i16</name></type> <name>nPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Number of components of the PRIMARY KEY */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bReplace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* True if REPLACE conflict resolution might happen */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bFinishSeek</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* The OP_FinishSeek opcode is needed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nChangeFrom</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* If there is a FROM, pChanges-&gt;nExpr, else 0 */</comment>

  <comment type="block">/* Register Allocations */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* A count of rows changed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regOldRowid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* The old rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regNewRowid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* The new rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Content of the NEW.* table in triggers */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regOld</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Content of OLD.* table in triggers */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowSet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Rowset of rows to be updated */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* composite PRIMARY KEY value */</comment>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sContext</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pParse</name></name><operator>==</operator><name>pParse</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
    <goto>goto <name>update_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Locate the table which we want to update. 
  */</comment>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3SrcListLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>update_cleanup</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Figure out if we have any triggers and if the table being
  ** updated is a view.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <expr_stmt><expr><name>pTrigger</name> <operator>=</operator> <call><name>sqlite3TriggersExist</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>TK_UPDATE</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>isView</name> <operator>=</operator> <call><name>IsView</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTrigger</name> <operator>||</operator> <name>tmask</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>pTrigger</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>isView</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>tmask</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifdef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>isView</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>isView</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TREETRACE_ENABLED</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>sqlite3TreeTrace</name> <operator>&amp;</operator> <literal type="number">0x10000</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3TreeViewLine</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"In sqlite3Update() at %s:%d"</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3TreeViewUpdate</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pWith</name></name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>,
                          <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>, <argument><expr><name>pUpsert</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If there was a FROM clause, set nChangeFrom to the number of expressions
  ** in the change-list. Otherwise, set it to 0. There cannot be a FROM
  ** clause if this function is being called to generate code for part of
  ** an UPSERT statement.  */</comment>
  <expr_stmt><expr><name>nChangeFrom</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pTabList</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>pChanges</name><operator>-&gt;</operator><name>nExpr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nChangeFrom</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pUpsert</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_UPDATE_DELETE_LIMIT</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name> <operator>&amp;&amp;</operator> <name>nChangeFrom</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pWhere</name> <operator>=</operator> <call><name>sqlite3LimitWhere</name><argument_list>(
        <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>, <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOrderBy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLimit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>update_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3IsReadOnly</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>tmask</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>update_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Allocate a cursors for the main database table and for all indices.
  ** The index cursors might not be used, but if they are used they
  ** need to occur right after the database cursor.  So go ahead and
  ** allocate enough space, just in case.
  */</comment>
  <expr_stmt><expr><name>iBaseCur</name> <operator>=</operator> <name>iDataCur</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>iIdxCur</name> <operator>=</operator> <name>iDataCur</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPk</name> <operator>=</operator> <ternary><condition><expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pPk</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pPk</name><operator>!=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>nIdx</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>nIdx</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pPk</name><operator>==</operator><name>pIdx</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iDataCur</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>pUpsert</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* On an UPSERT, reuse the same cursors already opened by INSERT */</comment>
    <expr_stmt><expr><name>iDataCur</name> <operator>=</operator> <name><name>pUpsert</name><operator>-&gt;</operator><name>iDataCur</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iIdxCur</name> <operator>=</operator> <name><name>pUpsert</name><operator>-&gt;</operator><name>iIdxCur</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name> <operator>=</operator> <name>iBaseCur</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name> <operator>=</operator> <name>iDataCur</name></expr>;</expr_stmt>

  <comment type="block">/* Allocate space for aXRef[], aRegIdx[], and aToOpen[].  
  ** Initialize aXRef[] and aToOpen[] to their default values.
  */</comment>
  <expr_stmt><expr><name>aXRef</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><name>nIdx</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>nIdx</name><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aXRef</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>update_cleanup</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>aRegIdx</name> <operator>=</operator> <name>aXRef</name><operator>+</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aToOpen</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>(</operator><name>aRegIdx</name><operator>+</operator><name>nIdx</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aToOpen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nIdx</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aToOpen</name><index>[<expr><name>nIdx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aXRef</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

  <comment type="block">/* Initialize the name-context */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>pSrcList</name></name> <operator>=</operator> <name>pTabList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>uNC</name><operator>.</operator><name>pUpsert</name></name> <operator>=</operator> <name>pUpsert</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sNC</name><operator>.</operator><name>ncFlags</name></name> <operator>=</operator> <name>NC_UUpsert</name></expr>;</expr_stmt>

  <comment type="block">/* Begin generating code. */</comment>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>update_cleanup</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Resolve the column names in all the expressions of the
  ** of the UPDATE statement.  Also find the column index
  ** for each column to be updated in the pChanges array.  For each
  ** column to be updated, make sure we have authorization to change
  ** that column.
  */</comment>
  <expr_stmt><expr><name>chngRowid</name> <operator>=</operator> <name>chngPk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pChanges</name><operator>-&gt;</operator><name>nExpr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>hCol</name> <init>= <expr><call><name>sqlite3StrIHash</name><argument_list>(<argument><expr><name><name>pChanges</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* If this is an UPDATE with a FROM clause, do not resolve expressions
    ** here. The call to sqlite3Select() below will do that. */</comment>
    <if_stmt><if>if<condition>( <expr><name>nChangeFrom</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name><name>pChanges</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <goto>goto <name>update_cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>hName</name><operator>==</operator><name>hCol</name>
       <operator>&amp;&amp;</operator> <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>, <argument><expr><name><name>pChanges</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>chngRowid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>pRowidExpr</name> <operator>=</operator> <name><name>pChanges</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>iRowidExpr</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pPk</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_PRIMKEY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>chngPk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
        <if type="elseif">else if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_STORED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
             <argument><expr><literal type="string">"cannot UPDATE generated column \"%s\""</literal></expr></argument>,
             <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>update_cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>aXRef</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pPk</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3IsRowid</name><argument_list>(<argument><expr><name><name>pChanges</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>chngRowid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pRowidExpr</name> <operator>=</operator> <name><name>pChanges</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iRowidExpr</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no such column: %s"</literal></expr></argument>, <argument><expr><name><name>pChanges</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zEName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>checkSchema</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>update_cleanup</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_UPDATE</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
                            <argument><expr><ternary><condition><expr><name>j</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"ROWID"</literal></expr> </then><else>: <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zCnName</name></expr></else></ternary></expr></argument>,
                            <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zDbSName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DENY</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>update_cleanup</name>;</goto>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_IGNORE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>aXRef</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>chngRowid</name> <operator>&amp;</operator> <name>chngPk</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>chngRowid</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>chngRowid</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>chngPk</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>chngPk</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>chngKey</name> <operator>=</operator> <name>chngRowid</name> <operator>+</operator> <name>chngPk</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
  <comment type="block">/* Mark generated columns as changing if their generator expressions
  ** reference any changing column.  The actual aXRef[] value for 
  ** generated expressions is not used, other than to check to see that it
  ** is non-negative, so the value of aXRef[] for generated columns can be
  ** set to any non-negative number.  We use 99999 so that the value is
  ** obvious when looking at aXRef[] in a symbolic debugger. 
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasGenerated</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bProgress</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasVirtual</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasStored</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name>bProgress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aXRef</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3ExprReferencesUpdatedColumn</name><argument_list>(
                <argument><expr><call><name>sqlite3ColumnExpr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>aXRef</name></expr></argument>, <argument><expr><name>chngRowid</name></expr></argument>)</argument_list></call></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>aXRef</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">99999</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>bProgress</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block>while<condition>( <expr><name>bProgress</name></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* The SET expressions are not actually used inside the WHERE loop.  
  ** So reset the colUsed mask. Unless this is a virtual table. In that
  ** case, set all bits of the colUsed mask (to ensure that the virtual
  ** table implementation makes all columns available).
  */</comment>
  <expr_stmt><expr><name><name>pTabList</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>colUsed</name> <operator>=</operator> <ternary><condition><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>ALLBITS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

  <expr_stmt><expr><name>hasFK</name> <operator>=</operator> <call><name>sqlite3FkRequired</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>aXRef</name></expr></argument>, <argument><expr><name>chngKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* There is one entry in the aRegIdx[] array for each index on the table
  ** being updated.  Fill in aRegIdx[] with a register number that will hold
  ** the key for accessing each index.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Replace</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bReplace</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>nAllIdx</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pIdx</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pIndex</name></name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>pNext</name></name></expr><operator>,</operator> <expr><name>nAllIdx</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>reg</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>chngKey</name> <operator>||</operator> <name>hasFK</name><operator>&gt;</operator><literal type="number">1</literal> <operator>||</operator> <name>pIdx</name><operator>==</operator><name>pPk</name>
     <operator>||</operator> <call><name>indexWhereClauseMightChange</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>,<argument><expr><name>aXRef</name></expr></argument>,<argument><expr><name>chngRowid</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>reg</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>reg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>indexColumnIsBeingUpdated</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>aXRef</name></expr></argument>, <argument><expr><name>chngRowid</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>reg</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Default</name> <operator>&amp;&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>onError</name></name><operator>==</operator><name>OE_Replace</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>bReplace</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>reg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aToOpen</name><index>[<expr><name>nAllIdx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>aRegIdx</name><index>[<expr><name>nAllIdx</name></expr>]</index></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>aRegIdx</name><index>[<expr><name>nAllIdx</name></expr>]</index></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>  <comment type="block">/* Register storing the table record */</comment>
  <if_stmt><if>if<condition>( <expr><name>bReplace</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If REPLACE conflict resolution might be invoked, open cursors on all 
    ** indexes in case they are needed to delete records.  */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aToOpen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nIdx</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeCountChanges</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTrigger</name> <operator>||</operator> <name>hasFK</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate required registers. */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* For now, regRowSet and aRegIdx[nAllIdx] share the same register.
    ** If regRowSet turns out to be needed, then aRegIdx[nAllIdx] will be
    ** reallocated.  aRegIdx[nAllIdx] is the register in which the main
    ** table record is written.  regRowSet holds the RowSet for the
    ** two-pass update algorithm. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aRegIdx</name><index>[<expr><name>nAllIdx</name></expr>]</index></name><operator>==</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>regRowSet</name> <operator>=</operator> <name><name>aRegIdx</name><index>[<expr><name>nAllIdx</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>regOldRowid</name> <operator>=</operator> <name>regNewRowid</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>chngPk</name> <operator>||</operator> <name>pTrigger</name> <operator>||</operator> <name>hasFK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>regOld</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>chngKey</name> <operator>||</operator> <name>pTrigger</name> <operator>||</operator> <name>hasFK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>regNewRowid</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>regNew</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Start the view context. */</comment>
  <if_stmt><if>if<condition>( <expr><name>isView</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3AuthContextPush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sContext</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we are trying to update a view, realize that view into
  ** an ephemeral table.
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>nChangeFrom</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>isView</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3MaterializeView</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, 
        <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOrderBy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLimit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Resolve the column names in all the expressions in the
  ** WHERE clause.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nChangeFrom</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sNC</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>update_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <comment type="block">/* Virtual tables must be handled separately */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>updateVirtualTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>, <argument><expr><name>pRowidExpr</name></expr></argument>, <argument><expr><name>aXRef</name></expr></argument>,
                       <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>update_cleanup</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Jump to labelBreak to abandon further processing of this UPDATE */</comment>
  <expr_stmt><expr><name>labelContinue</name> <operator>=</operator> <name>labelBreak</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Not an UPSERT.  Normal processing.  Begin by
  ** initialize the count of updated rows */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>SQLITE_CountRows</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name>
   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>bReturning</name></name>
   <operator>&amp;&amp;</operator> <name>pUpsert</name><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>regRowCount</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regRowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nChangeFrom</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regRowSet</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iEph</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrOpen</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regRowSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPk</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nPk</name> <operator>=</operator> <ternary><condition><expr><name>pPk</name></expr> ?</condition><then> <expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>iPk</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nPk</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nChangeFrom</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>regKey</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pUpsert</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nEphCol</name> <init>= <expr><name>nPk</name> <operator>+</operator> <name>nChangeFrom</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>isView</name></expr> ?</condition><then> <expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>iEph</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pPk</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iPk</name></expr></argument>, <argument><expr><name>iPk</name><operator>+</operator><name>nPk</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>addrOpen</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name>nEphCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pPk</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name> <init>= <expr><call><name>sqlite3KeyInfoOfIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>pKeyInfo</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nAllField</name></name> <operator>=</operator> <name>nEphCol</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>nChangeFrom</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>updateFromSelect</name><argument_list>(
            <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
        <if_stmt><if>if<condition>( <expr><name>isView</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iDataCur</name> <operator>=</operator> <name>iEph</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>nChangeFrom</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3MultiWrite</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>eOnePass</name> <operator>=</operator> <name>ONEPASS_OFF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name>nPk</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>regKey</name> <operator>=</operator> <name>iPk</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pUpsert</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If this is an UPSERT, then all cursors have already been opened by
      ** the outer INSERT and the data cursor should be pointing at the row
      ** that is to be updated.  So bypass the code that searches for the
      ** row(s) to be updated.
      */</comment>
      <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>eOnePass</name> <operator>=</operator> <name>ONEPASS_SINGLE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>labelBreak</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bFinishSeek</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Begin the database scan. 
      **
      ** Do not consider a single-pass strategy for a multi-row update if
      ** there are any triggers or foreign keys to process, or rows may
      ** be deleted as a result of REPLACE conflict handling. Any of these
      ** things might disturb a cursor being used to scan through the table
      ** or index, causing a single-pass approach to malfunction.  */</comment>
      <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>WHERE_ONEPASS_DESIRED</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pTrigger</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasFK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>chngKey</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>bReplace</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WHERE_ONEPASS_MULTIROW</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>flags</name></expr></argument>,<argument><expr><name>iIdxCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pWInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>update_cleanup</name>;</goto></block_content></block></if></if_stmt>

      <comment type="block">/* A one-pass strategy that might update more than one row may not
      ** be used if any column of the index used for the scan is being
      ** updated. Otherwise, if there is an index on "b", statements like
      ** the following could create an infinite loop:
      **
      **   UPDATE t1 SET b=b+1 WHERE b&gt;?
      **
      ** Fall back to ONEPASS_OFF if where.c has selected a ONEPASS_MULTI
      ** strategy that uses an index for which one or more columns are being
      ** updated.  */</comment>
      <expr_stmt><expr><name>eOnePass</name> <operator>=</operator> <call><name>sqlite3WhereOkOnePass</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>aiCurOnePass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bFinishSeek</name> <operator>=</operator> <call><name>sqlite3WhereUsesDeferredSeek</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>!=</operator><name>ONEPASS_SINGLE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3MultiWrite</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_MULTI</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iCur</name> <init>= <expr><name><name>aiCurOnePass</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>iCur</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCur</name><operator>!=</operator><name>iDataCur</name> <operator>&amp;&amp;</operator> <name><name>aToOpen</name><index>[<expr><name>iCur</name><operator>-</operator><name>iBaseCur</name></expr>]</index></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>eOnePass</name> <operator>=</operator> <name>ONEPASS_OFF</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCur</name><operator>!=</operator><name>iDataCur</name> <operator>||</operator> <operator>!</operator><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Read the rowid of the current row of the WHERE scan. In ONEPASS_OFF
      ** mode, write the rowid into the FIFO. In either of the one-pass modes,
      ** leave it in register regOldRowid.  */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>aRegIdx</name><index>[<expr><name>nAllIdx</name></expr>]</index></name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name>regRowSet</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>addrOpen</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Read the PK of the current row into an array of registers. In
      ** ONEPASS_OFF mode, serialize the array into a record and store it in
      ** the ephemeral table. Or, in ONEPASS_SINGLE or MULTI mode, change
      ** the OP_OpenEphemeral instruction to a Noop (the ephemeral table 
      ** is not required) and leave the PK fields in the array of registers.  */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>,
                                        <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>iPk</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>eOnePass</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>addrOpen</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name>nPk</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>regKey</name> <operator>=</operator> <name>iPk</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>iPk</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>, <argument><expr><name>regKey</name></expr></argument>,
                          <argument><expr><call><name>sqlite3IndexAffinityStr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name>regKey</name></expr></argument>, <argument><expr><name>iPk</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pUpsert</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nChangeFrom</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eOnePass</name><operator>!=</operator><name>ONEPASS_MULTI</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>addrOnce</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  
      <comment type="block">/* Open every index that needs updating. */</comment>
      <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>!=</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aiCurOnePass</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aToOpen</name><index>[<expr><name><name>aiCurOnePass</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><name>iBaseCur</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>aiCurOnePass</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aToOpen</name><index>[<expr><name><name>aiCurOnePass</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-</operator><name>iBaseCur</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
  
      <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_MULTI</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>nIdx</name><operator>-</operator><operator>(</operator><name><name>aiCurOnePass</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>addrOnce</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3OpenTableAndIndices</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iBaseCur</name></expr></argument>,
                                 <argument><expr><name>aToOpen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>addrOnce</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHereOrPopInst</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrOnce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* Top of the update loop */</comment>
    <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>!=</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aiCurOnePass</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><name>iDataCur</name>
       <operator>&amp;&amp;</operator> <name><name>aiCurOnePass</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><name>iDataCur</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ALLOW_ROWID_IN_VIEW</name></cpp:ifdef>
       <operator>&amp;&amp;</operator> <operator>!</operator><name>isView</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotFound</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>labelBreak</name></expr></argument>, <argument><expr><name>regKey</name></expr></argument>,<argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>!=</operator><name>ONEPASS_SINGLE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>labelContinue</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><ternary><condition><expr><name>pPk</name></expr> ?</condition><then> <expr><name>regKey</name></expr> </then><else>: <expr><name>regOldRowid</name></expr></else></ternary></expr></argument>, <argument><expr><name>labelBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pPk</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverageIf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pPk</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pPk</name> <operator>||</operator> <name>nChangeFrom</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>labelContinue</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name>labelBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrTop</name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nChangeFrom</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>pPk</name></expr> )</condition><block>{<block_content>
            <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iPk</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(
                <argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotFound</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>labelContinue</name></expr></argument>, <argument><expr><name>iPk</name></expr></argument>, <argument><expr><name>nPk</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(
                <argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>labelContinue</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowData</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name>regKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotFound</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>labelContinue</name></expr></argument>, <argument><expr><name>regKey</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name>labelBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>labelContinue</name> <operator>=</operator> <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrTop</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>labelContinue</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the rowid value will change, set register regNewRowid to
  ** contain the new value. If the rowid is not being modified,
  ** then regNewRowid is the same register as regOldRowid, which is
  ** already populated.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>chngKey</name> <operator>||</operator> <name>pTrigger</name> <operator>||</operator> <name>hasFK</name> <operator>||</operator> <name>regOldRowid</name><operator>==</operator><name>regNewRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>chngRowid</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iRowidExpr</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nChangeFrom</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRowidExpr</name></expr></argument>, <argument><expr><name>regNewRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name>iRowidExpr</name></expr></argument>, <argument><expr><name>regNewRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>regNewRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Compute the old pre-UPDATE content of the row being changed, if that
  ** information is needed */</comment>
  <if_stmt><if>if<condition>( <expr><name>chngPk</name> <operator>||</operator> <name>hasFK</name> <operator>||</operator> <name>pTrigger</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>oldmask</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>hasFK</name></expr> ?</condition><then> <expr><call><name>sqlite3FkOldmask</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>oldmask</name> <operator>|=</operator> <call><name>sqlite3TriggerColmask</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr><name>pTrigger</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRIGGER_BEFORE</name><operator>|</operator><name>TRIGGER_AFTER</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>colFlags</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>sqlite3TableColumnToStorage</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>regOld</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>oldmask</name><operator>==</operator><literal type="number">0xffffffff</literal>
       <operator>||</operator> <operator>(</operator><name>i</name><operator>&lt;</operator><literal type="number">32</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>oldmask</name> <operator>&amp;</operator> <call><name>MASKBIT32</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_PRIMKEY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>(  <argument><expr><name>oldmask</name><operator>!=</operator><literal type="number">0xffffffff</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>==</operator><literal type="number">31</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>chngRowid</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pPk</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>, <argument><expr><name>regNewRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Populate the array of registers beginning at regNew with the new
  ** row data. This array is used to check constants, create the new
  ** table and index records, and as the values for any new.* references
  ** made by triggers.
  **
  ** If there are one or more BEFORE triggers, then do not populate the
  ** registers associated with columns that are (a) not modified by
  ** this UPDATE statement and (b) not accessed by new.* references. The
  ** values for registers not modified by the UPDATE must be reloaded from 
  ** the database after the BEFORE triggers are fired anyway (as the trigger 
  ** may have modified them). So not loading those that are not going to
  ** be used eliminates some redundant opcodes.
  */</comment>
  <expr_stmt><expr><name>newmask</name> <operator>=</operator> <call><name>sqlite3TriggerColmask</name><argument_list>(
      <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>TRIGGER_BEFORE</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>k</name><operator>=</operator><name>regNew</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>k</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>aXRef</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>nChangeFrom</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>nOff</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>isView</name></expr> ?</condition><then> <expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> </then><else>: <expr><name>nPk</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_OFF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name>nOff</name><operator>+</operator><name>j</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pChanges</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name>tmask</name><operator>&amp;</operator><name>TRIGGER_BEFORE</name><operator>)</operator> <operator>||</operator> <name>i</name><operator>&gt;</operator><literal type="number">31</literal> <operator>||</operator> <operator>(</operator><name>newmask</name> <operator>&amp;</operator> <call><name>MASKBIT32</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
        <comment type="block">/* This branch loads the value of a column that will not be changed 
        ** into a register. This is done if there are no BEFORE triggers, or
        ** if there are one or more BEFORE triggers that use this value via
        ** a new.* reference in a trigger program.
        */</comment>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">31</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">32</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bFinishSeek</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasGenerated</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasVirtual</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasStored</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ComputeGeneratedColumns</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regNew</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Fire any BEFORE UPDATE triggers. This happens before constraints are
  ** verified. One could argue that this is wrong.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>tmask</name><operator>&amp;</operator><name>TRIGGER_BEFORE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3TableAffinity</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3CodeRowTrigger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, <argument><expr><name>TK_UPDATE</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>, 
        <argument><expr><name>TRIGGER_BEFORE</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>labelContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The row-trigger may have deleted the row being updated. In this
      ** case, jump to the next row. No updates or AFTER triggers are 
      ** required. This behavior - what happens when the row being updated
      ** is deleted or renamed by a BEFORE trigger - is left undefined in the
      ** documentation.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>pPk</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotFound</name></expr></argument>,<argument><expr><name>iDataCur</name></expr></argument>,<argument><expr><name>labelContinue</name></expr></argument>,<argument><expr><name>regKey</name></expr></argument>,<argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>labelContinue</name></expr></argument>,<argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* After-BEFORE-trigger-reload-loop:
      ** If it did not delete it, the BEFORE trigger may still have modified 
      ** some of the columns of the row being updated. Load the values for 
      ** all columns not modified by the update statement into their registers
      ** in case this has happened. Only unmodified columns are reloaded.
      ** The values computed for modified columns use the values before the
      ** BEFORE trigger runs.  See test case trigger1-18.0 (added 2018-04-26)
      ** for an example.
      */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>k</name><operator>=</operator><name>regNew</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_VIRTUAL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>k</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>aXRef</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>!=</operator><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3ExprCodeGetColumnOfTable</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GENERATED_COLUMNS</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasGenerated</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasVirtual</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_HasStored</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ComputeGeneratedColumns</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regNew</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isView</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Do constraint checks. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>regOldRowid</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3GenerateConstraintChecks</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>aRegIdx</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>,
        <argument><expr><name>regNewRowid</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>, <argument><expr><name>chngKey</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>labelContinue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bReplace</name></expr></argument>,
        <argument><expr><name>aXRef</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If REPLACE conflict handling may have been used, or if the PK of the
    ** row is changing, then the GenerateConstraintChecks() above may have
    ** moved cursor iDataCur. Reseek it. */</comment>
    <if_stmt><if>if<condition>( <expr><name>bReplace</name> <operator>||</operator> <name>chngKey</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pPk</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotFound</name></expr></argument>,<argument><expr><name>iDataCur</name></expr></argument>,<argument><expr><name>labelContinue</name></expr></argument>,<argument><expr><name>regKey</name></expr></argument>,<argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>labelContinue</name></expr></argument>,<argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Do FK constraint checks. */</comment>
    <if_stmt><if>if<condition>( <expr><name>hasFK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3FkCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aXRef</name></expr></argument>, <argument><expr><name>chngKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Delete the index entries associated with the current record.  */</comment>
    <expr_stmt><expr><call><name>sqlite3GenerateRowIndexDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>aRegIdx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We must run the OP_FinishSeek opcode to resolve a prior
    ** OP_DeferredSeek if there is any possibility that there have been
    ** no OP_Column opcodes since the OP_DeferredSeek was issued.  But
    ** we want to avoid the OP_FinishSeek if possible, as running it
    ** costs CPU cycles. */</comment>
    <if_stmt><if>if<condition>( <expr><name>bFinishSeek</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_FinishSeek</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If changing the rowid value, or if there are foreign key constraints
    ** to process, delete the old record. Otherwise, add a noop OP_Delete
    ** to invoke the pre-update hook.
    **
    ** That (regNew==regnewRowid+1) is true is also important for the 
    ** pre-update hook. If the caller invokes preupdate_new(), the returned
    ** value is copied from memory cell (regNewRowid+1+iCol), where iCol
    ** is the column index supplied by the user.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>regNew</name><operator>==</operator><name>regNewRowid</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_PREUPDATE_HOOK</name></cpp:ifdef>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Delete</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>,
        <argument><expr><name>OPFLAG_ISUPDATE</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>hasFK</name><operator>&gt;</operator><literal type="number">1</literal> <operator>||</operator> <name>chngKey</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>OPFLAG_ISNOOP</name></expr></else></ternary><operator>)</operator></expr></argument>,
        <argument><expr><name>regNewRowid</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_MULTI</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>hasFK</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>chngKey</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_SAVEPOSITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>P4_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if<condition>( <expr><name>hasFK</name><operator>&gt;</operator><literal type="number">1</literal> <operator>||</operator> <name>chngKey</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Delete</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if<condition>( <expr><name>hasFK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3FkCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regNewRowid</name></expr></argument>, <argument><expr><name>aXRef</name></expr></argument>, <argument><expr><name>chngKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* Insert the new index entries and the new record. */</comment>
    <expr_stmt><expr><call><name>sqlite3CompleteInsertion</name><argument_list>(
        <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iDataCur</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>regNewRowid</name></expr></argument>, <argument><expr><name>aRegIdx</name></expr></argument>, 
        <argument><expr><name>OPFLAG_ISUPDATE</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_MULTI</name></expr> ?</condition><then> <expr><name>OPFLAG_SAVEPOSITION</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>, 
        <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Do any ON CASCADE, SET NULL or SET DEFAULT operations required to
    ** handle rows (possibly in other tables) that refer via a foreign key
    ** to the row just updated. */</comment> 
    <if_stmt><if>if<condition>( <expr><name>hasFK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3FkActions</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>, <argument><expr><name>aXRef</name></expr></argument>, <argument><expr><name>chngKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Increment the row counter 
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>regRowCount</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>regRowCount</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3CodeRowTrigger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>, <argument><expr><name>TK_UPDATE</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>, 
      <argument><expr><name>TRIGGER_AFTER</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>labelContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Repeat the above with the next record to be updated, until
  ** all record selected by the WHERE clause have been updated.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_SINGLE</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Nothing to do at end-of-loop for a single-pass */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_MULTI</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>labelContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>labelContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>iEph</name></expr></argument>, <argument><expr><name>addrTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>labelBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Update the sqlite_sequence table by storing the content of the
  ** maximum rowid counter values recorded while inserting into
  ** autoincrement tables.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nested</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pTriggerTab</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pUpsert</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3AutoincrementEnd</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
  ** Return the number of rows that were changed, if we are tracking
  ** that information.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>regRowCount</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3CodeChangeCount</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>regRowCount</name></expr></argument>, <argument><expr><literal type="string">"rows updated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>update_cleanup</name>:</label>
  <expr_stmt><expr><call><name>sqlite3AuthContextPop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aXRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Also frees aRegIdx[] and aToOpen[] */</comment>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_UPDATE_DELETE_LIMIT</name></expr></argument>)</argument_list></call></expr></cpp:if> 
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return;</return>
</block_content>}</block></function>
<comment type="block">/* Make sure "isView" and other macros defined above are undefined. Otherwise
** they may interfere with compilation of other functions in this file
** (or in another file, if this file becomes part of the amalgamation).  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>isView</name></cpp:ifdef>
 <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isView</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>pTrigger</name></cpp:ifdef>
 <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>pTrigger</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** Generate code for an UPDATE of a virtual table.
**
** There are two possible strategies - the default and the special 
** "onepass" strategy. Onepass is only used if the virtual table 
** implementation indicates that pWhere may match at most one row.
**
** The default strategy is to create an ephemeral table that contains
** for each row to be changed:
**
**   (A)  The original rowid of that row.
**   (B)  The revised rowid for the row.
**   (C)  The content of every column in the row.
**
** Then loop through the contents of this ephemeral table executing a
** VUpdate for each row. When finished, drop the ephemeral table.
**
** The "onepass" strategy does not use an ephemeral table. Instead, it
** stores the same values (A, B and C above) in a register array and
** makes a single invocation of VUpdate.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>updateVirtualTable</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* The parsing context */</comment>
  <parameter><decl><type><name>SrcList</name> <modifier>*</modifier></type><name>pSrc</name></decl></parameter>,       <comment type="block">/* The virtual table to be modified */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,         <comment type="block">/* The virtual table */</comment>
  <parameter><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pChanges</name></decl></parameter>,  <comment type="block">/* The columns to change in the UPDATE statement */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>,        <comment type="block">/* Expression used to recompute the rowid */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aXRef</name></decl></parameter>,          <comment type="block">/* Mapping from columns of pTab to entries in pChanges */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pWhere</name></decl></parameter>,        <comment type="block">/* WHERE clause of the UPDATE statement */</comment>
  <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>          <comment type="block">/* ON CONFLICT strategy */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Virtual machine under construction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ephemTab</name></decl>;</decl_stmt>             <comment type="block">/* Table holding the result of the SELECT */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                    <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pVTab</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereInfo</name> <modifier>*</modifier></type><name>pWInfo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> <init>= <expr><literal type="number">2</literal> <operator>+</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Number of arguments to VUpdate */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regArg</name></decl>;</decl_stmt>                     <comment type="block">/* First register in VUpdate arg array */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRec</name></decl>;</decl_stmt>                     <comment type="block">/* Register in which to assemble record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name></decl>;</decl_stmt>                   <comment type="block">/* Register for ephem table rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCsr</name> <init>= <expr><name><name>pSrc</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iCursor</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Cursor used for virtual table scan */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>aDummy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>                  <comment type="block">/* Unused arg for sqlite3WhereOkOnePass() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eOnePass</name></decl>;</decl_stmt>                   <comment type="block">/* True to use onepass strategy */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>                       <comment type="block">/* Address of OP_OpenEphemeral */</comment>

  <comment type="block">/* Allocate nArg registers in which to gather the arguments for VUpdate. Then
  ** create and open the ephemeral table in which the records created from
  ** these arguments will be temporarily stored. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ephemTab</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr</name><operator>=</operator> <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regArg</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name> <operator>+=</operator> <name>nArg</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pRow</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pRowid</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pRow</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRowid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pRow</name> <operator>=</operator> <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_ROW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>i16</name></type> <name>iPk</name></decl>;</decl_stmt>      <comment type="block">/* PRIMARY KEY column */</comment>
      <expr_stmt><expr><name>pPk</name> <operator>=</operator> <call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPk</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iPk</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aXRef</name><index>[<expr><name>iPk</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pRow</name> <operator>=</operator> <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pChanges</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>aXRef</name><index>[<expr><name>iPk</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pRow</name> <operator>=</operator> <call><name>exprRowColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iPk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aXRef</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>,
          <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pChanges</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>aXRef</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pList</name> <operator>=</operator> <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><call><name>exprRowColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>updateFromSelect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>, <argument><expr><name>pPk</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>eOnePass</name> <operator>=</operator> <name>ONEPASS_OFF</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>regRec</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>regRowid</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>

    <comment type="block">/* Start scanning the virtual table */</comment>
    <expr_stmt><expr><name>pWInfo</name> <operator>=</operator> <call><name>sqlite3WhereBegin</name><argument_list>(
        <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WHERE_ONEPASS_DESIRED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pWInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Populate the argument registers. */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>&amp;</operator> <name>COLFLAG_GENERATED</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aXRef</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pChanges</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>aXRef</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>pExpr</name></expr></argument>, <argument><expr><name>regArg</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VColumn</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>regArg</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_NOCHNG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><comment type="block">/* For sqlite3_vtab_nochange() */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>, <argument><expr><name>regArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pRowid</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRowid</name></expr></argument>, <argument><expr><name>regArg</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>, <argument><expr><name>regArg</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>pPk</name></decl>;</decl_stmt>   <comment type="block">/* PRIMARY KEY index */</comment>
      <decl_stmt><decl><type><name>i16</name></type> <name>iPk</name></decl>;</decl_stmt>      <comment type="block">/* PRIMARY KEY column */</comment>
      <expr_stmt><expr><name>pPk</name> <operator>=</operator> <call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPk</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPk</name><operator>-&gt;</operator><name>nKeyCol</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iPk</name> <operator>=</operator> <name><name>pPk</name><operator>-&gt;</operator><name>aiColumn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VColumn</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>, <argument><expr><name>iPk</name></expr></argument>, <argument><expr><name>regArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>regArg</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>iPk</name></expr></argument>, <argument><expr><name>regArg</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>eOnePass</name> <operator>=</operator> <call><name>sqlite3WhereOkOnePass</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>aDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* There is no ONEPASS_MULTI on virtual tables */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_OFF</name> <operator>||</operator> <name>eOnePass</name><operator>==</operator><name>ONEPASS_SINGLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>eOnePass</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If using the onepass strategy, no-op out the OP_OpenEphemeral coded
      ** above. */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Create a record from the argument register contents and insert it into
      ** the ephemeral table. */</comment>
      <expr_stmt><expr><call><name>sqlite3MultiWrite</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regArg</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_NULL_TRIM</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <comment type="block">/* Signal an assert() within OP_MakeRecord that it is allowed to
      ** accept no-change records with serial_type 10 */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_NOCHNG_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>, <argument><expr><name>regRec</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>


  <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* End the virtual table scan */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pSrc</name><operator>-&gt;</operator><name>nSrc</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Begin scannning through the ephemeral table. */</comment>
    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Extract arguments from the current row of the ephemeral table and 
    ** invoke the VUpdate method.  */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>regArg</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabMakeWritable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VUpdate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>regArg</name></expr></argument>, <argument><expr><name>pVTab</name></expr></argument>, <argument><expr><name>P4_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><ternary><condition><expr><name>onError</name><operator>==</operator><name>OE_Default</name></expr> ?</condition><then> <expr><name>OE_Abort</name></expr> </then><else>: <expr><name>onError</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* End of the ephemeral table scan. Or, if using the onepass strategy,
  ** jump to here if the scan visited zero rows. */</comment>
  <if_stmt><if>if<condition>( <expr><name>eOnePass</name><operator>==</operator><name>ONEPASS_OFF</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>, <argument><expr><name>addr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VdbeCoverage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
</unit>
