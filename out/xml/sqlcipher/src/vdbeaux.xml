<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/vdbeaux.c"><comment type="block">/*
** 2003 September 6
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code used for creating, destroying, and populating
** a VDBE (or an "sqlite3_stmt" as it is known to the outside world.) 
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>

<comment type="block">/* Forward references */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freeEphemeralFunction</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vdbeFreeOpArray</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Op</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Create a new virtual database engine.
*/</comment>
<function><type><name>Vdbe</name> <modifier>*</modifier></type><name>sqlite3VdbeCreate</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Vdbe</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Vdbe</name></expr></argument>)</argument_list></sizeof><operator>-</operator><call><name>offsetof</name><argument_list>(<argument><expr><name>Vdbe</name></expr></argument>,<argument><expr><name>aOp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pVdbe</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_INIT_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name> <operator>=</operator> <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aLabel</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nLabel</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>szOpAlloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_Init</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the Parse object that owns a Vdbe object.
*/</comment>
<function><type><name>Parse</name> <modifier>*</modifier></type><name>sqlite3VdbeParser</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change the error string stored in Vdbe.zErrMsg
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeError</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Remember the SQL string for a prepared statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetSql</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>prepFlags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>prepFlags</name></name> <operator>=</operator> <name>prepFlags</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>prepFlags</name> <operator>&amp;</operator> <name>SQLITE_PREPARE_SAVESQL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expmask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name> <operator>=</operator> <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_NORMALIZE</name></cpp:ifdef>
<comment type="block">/*
** Add a new element to the Vdbe-&gt;pDblStr list.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeAddDblquoteStr</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DblquoteStr</name> <modifier>*</modifier></type><name>pStr</name> <init>= <expr><call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
                            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pStr</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pStr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>pNextStr</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pDblStr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDblStr</name></name> <operator>=</operator> <name>pStr</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_NORMALIZE</name></cpp:ifdef>
<comment type="block">/*
** zId of length nId is a double-quoted identifier.  Check to see if
** that identifier is really used as a string literal.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeUsesDoubleQuotedString</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVdbe</name></decl></parameter>,            <comment type="block">/* The prepared statement */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zId</name></decl></parameter>         <comment type="block">/* The double-quoted identifier, already dequoted */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DblquoteStr</name> <modifier>*</modifier></type><name>pStr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zId</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pVdbe</name><operator>-&gt;</operator><name>pDblStr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>pStr</name><operator>=</operator><name><name>pVdbe</name><operator>-&gt;</operator><name>pDblStr</name></name></expr>;</init> <condition><expr><name>pStr</name></expr>;</condition> <incr><expr><name>pStr</name><operator>=</operator><name><name>pStr</name><operator>-&gt;</operator><name>pNextStr</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zId</name></expr></argument>, <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Swap all content between two VDBE structures.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSwap</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name></type> <name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pTmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTmp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pA</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name><name>pB</name><operator>-&gt;</operator><name>db</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>*</operator><name>pA</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pA</name> <operator>=</operator> <operator>*</operator><name>pB</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pB</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTmp</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pTmp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTmp</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>pTmp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zTmp</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>zSql</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>zSql</name></name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>zSql</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>zSql</name></name> <operator>=</operator> <name>zTmp</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_NORMALIZE</name></cpp:ifdef>
  <expr_stmt><expr><name>zTmp</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>zNormSql</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>zNormSql</name></name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>zNormSql</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>zNormSql</name></name> <operator>=</operator> <name>zTmp</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>expmask</name></name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>expmask</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>prepFlags</name></name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>prepFlags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pB</name><operator>-&gt;</operator><name>aCounter</name></name></expr></argument>, <argument><expr><name><name>pA</name><operator>-&gt;</operator><name>aCounter</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pB</name><operator>-&gt;</operator><name>aCounter</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>aCounter</name><index>[<expr><name>SQLITE_STMTSTATUS_REPREPARE</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Resize the Vdbe.aOp array so that it is at least nOp elements larger 
** than its current size. nOp is guaranteed to be less than or equal
** to 1024/sizeof(Op).
**
** If an out-of-memory error occurs while resizing the array, return
** SQLITE_NOMEM. In this case Vdbe.aOp and Vdbe.nOpAlloc remain 
** unchanged (this is so that any opcodes already allocated can be 
** correctly deallocated along with the rest of the Vdbe).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>growOpArray</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The SQLITE_TEST_REALLOC_STRESS compile-time option is designed to force
  ** more frequent reallocs and hence provide more opportunities for 
  ** simulated OOM faults.  SQLITE_TEST_REALLOC_STRESS is generally used
  ** during testing only.  With SQLITE_TEST_REALLOC_STRESS grow the op array
  ** by the minimum* amount required until the size reaches 512.  Normal
  ** operation (without SQLITE_TEST_REALLOC_STRESS) is to double the current
  ** size of the op array or add 1KB of space, whichever is smaller. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST_REALLOC_STRESS</name></cpp:ifdef>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nNew</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>v</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>&gt;=</operator><literal type="number">512</literal></expr> ?</condition><then> <expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>v</name><operator>-&gt;</operator><name>nOpAlloc</name></name></expr>
                        </then><else>: <expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>v</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>+</operator><name>nOp</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nNew</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>v</name><operator>-&gt;</operator><name>nOpAlloc</name></name></expr> ?</condition><then> <expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>v</name><operator>-&gt;</operator><name>nOpAlloc</name></name></expr>
                        </then><else>: <expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><operator>(</operator><literal type="number">1024</literal><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Ensure that the size of a VDBE does not grow too large */</comment>
  <if_stmt><if>if<condition>( <expr><name>nNew</name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VDBE_OP</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOp</name><operator>&lt;=</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">1024</literal><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nNew</name><operator>&gt;=</operator><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>+</operator><name>nOp</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>aOp</name></name></expr></argument>, <argument><expr><name>nNew</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>szOpAlloc</name></name> <operator>=</operator> <call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nOpAlloc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>szOpAlloc</name></name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>aOp</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>pNew</name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>SQLITE_NOMEM_BKPT</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/* This routine is just a convenient place to set a breakpoint that will
** fire after each opcode is inserted and displayed using
** "PRAGMA vdbe_addoptrace=on".  Parameters "pc" (program counter) and
** pOp are available to make the breakpoint conditional.
**
** Other useful labels for breakpoints include:
**   test_trace_breakpoint(pc,pOp)
**   sqlite3CorruptError(lineno)
**   sqlite3MisuseError(lineno)
**   sqlite3CantopenError(lineno)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_addop_breakpoint</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>, <parameter><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Add a new instruction to the list of instructions current in the
** VDBE.  Return the address of the new instruction.
**
** Parameters:
**
**    p               Pointer to the VDBE
**
**    op              The opcode for this instruction
**
**    p1, p2, p3      Operands
**
** Use the sqlite3VdbeResolveLabel() function to fix an address and
** the sqlite3VdbeChangeP4() function to change the value of the P4
** operand.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>growOp3</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p3</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>growOpArray</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p3</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp3</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p3</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_INIT_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>op</name><operator>&lt;</operator><literal type="number">0xff</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nOpAlloc</name></name><operator>&lt;=</operator><name>i</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>growOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p3</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>op</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <name>p3</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_NOTUSED</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeAddopTrace</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>test_addop_breakpoint</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>cycles</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_VDBE_COVERAGE</name></cpp:ifdef>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>iSrcLine</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp0</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp1</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp2</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate code for an unconditional jump to instruction iDest
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeGoto</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDest</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate code to cause the string zStr to be loaded into
** register iDest
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeLoadString</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_String8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zStr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate code that initializes multiple registers to string or integer
** constants.  The registers begin with iDest and increase consecutively.
** One register is initialized for each characgter in zTypes[].  For each
** "s" character in zTypes[], the register is a string if the argument is
** not NULL, or OP_Null if the value is a null pointer.  For each "i" character
** in zTypes[], the register is initialized to an integer.
**
** If the input string does not end with "X" then an OP_ResultRow instruction
** is generated for the values inserted.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMultiLoad</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTypes</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zTypes</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'s'</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><ternary><condition><expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>OP_Null</name></expr> </then><else>: <expr><name>OP_String8</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iDest</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'i'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iDest</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <goto>goto <name>skip_op_resultrow</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>skip_op_resultrow</name>:</label>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add an opcode that includes the p4 value as a pointer.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp4</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* Add the opcode to this VM */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,             <comment type="block">/* The new opcode */</comment>
  <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>,             <comment type="block">/* The P1 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>,             <comment type="block">/* The P2 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p3</name></decl></parameter>,             <comment type="block">/* The P3 operand */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zP4</name></decl></parameter>,    <comment type="block">/* The P4 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p4type</name></decl></parameter>          <comment type="block">/* P4 operand type */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name> <init>= <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name>p4type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>addr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add an OP_Function or OP_PureFunc opcode.
**
** The eCallCtx argument is information (typically taken from Expr.op2)
** that describes the calling context of the function.  0 means a general
** function call.  NC_IsCheck means called by a check constraint,
** NC_IdxExpr means called as part of an index expression.  NC_PartIdx
** means in the WHERE clause of a partial index.  NC_GenCol means called
** while computing a generated column value.  0 is the usual case.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeAddFunctionCall</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>,               <comment type="block">/* Constant argument mask */</comment>
  <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>,               <comment type="block">/* First argument register */</comment>
  <parameter><decl><type><name>int</name></type> <name>p3</name></decl></parameter>,               <comment type="block">/* Register into which results are written */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,             <comment type="block">/* Number of argument */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>FuncDef</name> <modifier>*</modifier></type><name>pFunc</name></decl></parameter>, <comment type="block">/* The function to be invoked */</comment>
  <parameter><decl><type><name>int</name></type> <name>eCallCtx</name></decl></parameter>          <comment type="block">/* Calling context */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCtx</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCtx</name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCtx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeEphemeralFunction</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FuncDef</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pFunc</name></name> <operator>=</operator> <operator>(</operator><name>FuncDef</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>nArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>iOp</name></name> <operator>=</operator> <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><ternary><condition><expr><name>eCallCtx</name></expr> ?</condition><then> <expr><name>OP_PureFunc</name></expr> </then><else>: <expr><name>OP_Function</name></expr></else></ternary></expr></argument>,
                           <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p3</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></argument>, <argument><expr><name>P4_FUNCCTX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>eCallCtx</name> <operator>&amp;</operator> <name>NC_SelfRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>addr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add an opcode that includes the p4 value with a P4_INT64 or
** P4_REAL type.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp4Dup8</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* Add the opcode to this VM */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,             <comment type="block">/* The new opcode */</comment>
  <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>,             <comment type="block">/* The P1 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>,             <comment type="block">/* The P2 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p3</name></decl></parameter>,             <comment type="block">/* The P3 operand */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>zP4</name></decl></parameter>,      <comment type="block">/* The P4 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p4type</name></decl></parameter>          <comment type="block">/* P4 operand type */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p4copy</name> <init>= <expr><call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p4copy</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p4copy</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p3</name></expr></argument>, <argument><expr><name>p4copy</name></expr></argument>, <argument><expr><name>p4type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
<comment type="block">/*
** Return the address of the current EXPLAIN QUERY PLAN baseline.
** 0 means "none".
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeExplainParent</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>addrExplain</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>addrExplain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set a debugger breakpoint on the following routine in order to
** monitor the EXPLAIN QUERY PLAN code generation.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name>sqlite3ExplainBreakpoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>z1</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>z2</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Add a new OP_Explain opcode.
**
** If the bPush flag is true, then make this opcode the parent for
** subsequent Explains until sqlite3VdbeExplainPop() is called.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeExplain</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>bPush</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifndef>
  <comment type="block">/* Always include the OP_Explain opcodes if SQLITE_DEBUG is defined.
  ** But omit them (for performance) during production builds */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">2</literal></expr> )</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iThis</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iThis</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Explain</name></expr></argument>, <argument><expr><name>iThis</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>addrExplain</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                      <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExplainBreakpoint</name><argument_list>(<argument><expr><ternary><condition><expr><name>bPush</name></expr>?</condition><then><expr><literal type="string">"PUSH"</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bPush</name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>addrExplain</name></name> <operator>=</operator> <name>iThis</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Pop the EXPLAIN QUERY PLAN stack one level.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeExplainPop</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3ExplainBreakpoint</name><argument_list>(<argument><expr><literal type="string">"POP"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>addrExplain</name></name> <operator>=</operator> <call><name>sqlite3VdbeExplainParent</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_EXPLAIN */</comment>

<comment type="block">/*
** Add an OP_ParseSchema opcode.  This routine is broken out from
** sqlite3VdbeAddOp4() since it needs to also needs to mark all btrees
** as having been used.
**
** The zWhere string must have been obtained from sqlite3_malloc().
** This routine will take ownership of the allocated memory.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeAddParseSchemaOp</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zWhere</name></decl></parameter>, <parameter><decl><type><name>u16</name></type> <name>p5</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_ParseSchema</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeUsesBtree</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add an opcode that includes the p4 value as an integer.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp4Int</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* Add the opcode to this VM */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,             <comment type="block">/* The new opcode */</comment>
  <parameter><decl><type><name>int</name></type> <name>p1</name></decl></parameter>,             <comment type="block">/* The P1 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>,             <comment type="block">/* The P2 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p3</name></decl></parameter>,             <comment type="block">/* The P3 operand */</comment>
  <parameter><decl><type><name>int</name></type> <name>p4</name></decl></parameter>              <comment type="block">/* The P4 operand as an integer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name> <init>= <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_INT32</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>p4</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>addr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Insert the end of a co-routine
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeEndCoroutine</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>regYield</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_EndCoroutine</name></expr></argument>, <argument><expr><name>regYield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Clear the temporary register cache, thereby ensuring that each
  ** co-routine has its own independent set of registers, because co-routines
  ** might expect their registers to be preserved across an OP_Yield, and
  ** that could cause problems if two or more co-routines are using the same
  ** temporary register.
  */</comment>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nTempReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nRangeReg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Create a new symbolic label for an instruction that has yet to be
** coded.  The symbolic label is really just a negative number.  The
** label can be used as the P2 value of an operation.  Later, when
** the label is resolved to a specific address, the VDBE will scan
** through its operation list and change all values of P2 which match
** the label into the resolved address.
**
** The VDBE knows that a P2 value is a label because labels are
** always negative and P2 values are suppose to be non-negative.
** Hence, a negative P2 value is a label that has yet to be resolved.
** (Later:) This is only true for opcodes that have the OPFLG_JUMP
** property.
**
** Variable usage notes:
**
**     Parse.aLabel[x]     Stores the address that the x-th label resolves
**                         into.  For testing (SQLITE_DEBUG), unresolved
**                         labels stores -1, but that is not required.
**     Parse.nLabelAlloc   Number of slots allocated to Parse.aLabel[]
**     Parse.nLabel        The *negative* of the number of labels that have
**                         been issued.  The negative is stored because
**                         that gives a performance improvement over storing
**                         the equivalent positive value.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMakeLabel</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>--</operator><name><name>pParse</name><operator>-&gt;</operator><name>nLabel</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Resolve label "x" to be the address of the next instruction to
** be inserted.  The parameter "x" must have been obtained from
** a prior call to sqlite3VdbeMakeLabel().
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>resizeResolveLabel</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nNewSize</name> <init>= <expr><literal type="number">10</literal> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nLabel</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name></name> <operator>=</operator> <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name></name></expr></argument>,
                     <argument><expr><name>nNewSize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLabelAlloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>nLabelAlloc</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nNewSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLabelAlloc</name></name> <operator>=</operator> <name>nNewSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeResolveLabel</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><call><name>ADDR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>v</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_INIT_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>&lt;</operator><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nLabel</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeAddopTrace</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"RESOLVE LABEL %d to %d\n"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nLabelAlloc</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>nLabel</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>resizeResolveLabel</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>v</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Labels may only be resolved once */</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aLabel</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Mark the VDBE as one that can only be run one time.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeRunOnlyOnce</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_Expire</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Mark the VDBE as one that can be run multiple times.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeReusable</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Expire</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name> <operator>=</operator> <name>OP_Noop</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef> <comment type="block">/* sqlite3AssertMayAbort() logic */</comment>

<comment type="block">/*
** The following type and function are used to iterate through all opcodes
** in a Vdbe main program and each of the sub-programs (triggers) it may 
** invoke directly or indirectly. It should be used as follows:
**
**   Op *pOp;
**   VdbeOpIter sIter;
**
**   memset(&amp;sIter, 0, sizeof(sIter));
**   sIter.v = v;                            // v is of type Vdbe* 
**   while( (pOp = opIterNext(&amp;sIter)) ){
**     // Do something with pOp
**   }
**   sqlite3DbFree(v-&gt;db, sIter.apSub);
** 
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>VdbeOpIter</name></name></type> <name>VdbeOpIter</name>;</typedef>
<struct>struct <name>VdbeOpIter</name> <block>{
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>                   <comment type="block">/* Vdbe to iterate through the opcodes of */</comment>
  <decl_stmt><decl><type><name>SubProgram</name> <modifier>*</modifier><modifier>*</modifier></type><name>apSub</name></decl>;</decl_stmt>        <comment type="block">/* Array of subprograms */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSub</name></decl>;</decl_stmt>                  <comment type="block">/* Number of entries in apSub */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iAddr</name></decl>;</decl_stmt>                 <comment type="block">/* Address of next instruction to return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSub</name></decl>;</decl_stmt>                  <comment type="block">/* 0 = main program, 1 = first sub-program etc. */</comment>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>Op</name> <modifier>*</modifier></type><name>opIterNext</name><parameter_list>(<parameter><decl><type><name>VdbeOpIter</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>v</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>aOp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOp</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iSub</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nSub</name></name></expr> )</condition><block>{<block_content>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iSub</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>aOp</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>aOp</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nOp</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>aOp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apSub</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iSub</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>aOp</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nOp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apSub</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iSub</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>nOp</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iAddr</name></name><operator>&lt;</operator><name>nOp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <operator>&amp;</operator><name><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iAddr</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iAddr</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iAddr</name></name><operator>==</operator><name>nOp</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iSub</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iAddr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <if_stmt><if>if<condition>( <expr><name><name>pRet</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_SUBPROGRAM</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nSub</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>SubProgram</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nSub</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>apSub</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name><name>pRet</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pProgram</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nSub</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apSub</name></name> <operator>=</operator> <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apSub</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>apSub</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pRet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apSub</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nSub</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pRet</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pProgram</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check if the program stored in the VM associated with pParse may
** throw an ABORT exception (causing the statement, but not entire transaction
** to be rolled back). This condition is true if the main program or any
** sub-programs contains any of the following:
**
**   *  OP_Halt with P1=SQLITE_CONSTRAINT and P2=OE_Abort.
**   *  OP_HaltIfNull with P1=SQLITE_CONSTRAINT and P2=OE_Abort.
**   *  OP_Destroy
**   *  OP_VUpdate
**   *  OP_VCreate
**   *  OP_VRename
**   *  OP_FkCounter with P2==0 (immediate foreign key constraint)
**   *  OP_CreateBtree/BTREE_INTKEY and OP_InitCoroutine 
**      (for CREATE TABLE AS SELECT ...)
**
** Then check that the value of Parse.mayAbort is true if an
** ABORT may be thrown, or false otherwise. Return true if it does
** match, or false otherwise. This function is intended to be used as
** part of an assert statement in the compiler. Similar to:
**
**   assert( sqlite3VdbeAssertMayAbort(pParse-&gt;pVdbe, pParse-&gt;mayAbort) );
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeAssertMayAbort</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mayAbort</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>hasAbort</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hasFkCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hasCreateTable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hasCreateIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hasInitCoroutine</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeOpIter</name></type> <name>sIter</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sIter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sIter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sIter</name><operator>.</operator><name>v</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>(</operator><name>pOp</name> <operator>=</operator> <call><name>opIterNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sIter</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>opcode</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>opcode</name><operator>==</operator><name>OP_Destroy</name> <operator>||</operator> <name>opcode</name><operator>==</operator><name>OP_VUpdate</name> <operator>||</operator> <name>opcode</name><operator>==</operator><name>OP_VRename</name> 
     <operator>||</operator> <name>opcode</name><operator>==</operator><name>OP_VDestroy</name>
     <operator>||</operator> <name>opcode</name><operator>==</operator><name>OP_VCreate</name>
     <operator>||</operator> <name>opcode</name><operator>==</operator><name>OP_ParseSchema</name>
     <operator>||</operator> <operator>(</operator><operator>(</operator><name>opcode</name><operator>==</operator><name>OP_Halt</name> <operator>||</operator> <name>opcode</name><operator>==</operator><name>OP_HaltIfNull</name><operator>)</operator> 
      <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>)</operator><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><name>OE_Abort</name><operator>)</operator><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>hasAbort</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>opcode</name><operator>==</operator><name>OP_CreateBtree</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><name>BTREE_INTKEY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hasCreateTable</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>mayAbort</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* hasCreateIndex may also be set for some DELETE statements that use
      ** OP_Clear. So this routine may end up returning true in the case 
      ** where a "DELETE FROM tbl" has a statement-journal but does not
      ** require one. This is not so bad - it is an inefficiency, not a bug. */</comment>
      <if_stmt><if>if<condition>( <expr><name>opcode</name><operator>==</operator><name>OP_CreateBtree</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><name>BTREE_BLOBKEY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hasCreateIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>opcode</name><operator>==</operator><name>OP_Clear</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hasCreateIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>opcode</name><operator>==</operator><name>OP_InitCoroutine</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hasInitCoroutine</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>opcode</name><operator>==</operator><name>OP_FkCounter</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>hasFkCounter</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>sIter</name><operator>.</operator><name>apSub</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return true if hasAbort==mayAbort. Or if a malloc failure occurred.
  ** If malloc failed, then the while() loop above may not have iterated
  ** through all opcodes and hasAbort may be set incorrectly. Return
  ** true for this case to prevent the assert() in the callers frame
  ** from failing.  */</comment>
  <return>return <expr><operator>(</operator> <name><name>v</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name> <operator>||</operator> <name>hasAbort</name><operator>==</operator><name>mayAbort</name> <operator>||</operator> <name>hasFkCounter</name>
        <operator>||</operator> <operator>(</operator><name>hasCreateTable</name> <operator>&amp;&amp;</operator> <name>hasInitCoroutine</name><operator>)</operator> <operator>||</operator> <name>hasCreateIndex</name>
  <operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG - the sqlite3AssertMayAbort() function */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Increment the nWrite counter in the VDBE if the cursor is not an
** ephemeral cursor, or if the cursor argument is NULL.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeIncrWriteCounter</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pC</name><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <operator>(</operator><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>!=</operator><name>CURTYPE_SORTER</name>
       <operator>&amp;&amp;</operator> <name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>!=</operator><name>CURTYPE_PSEUDO</name>
       <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pC</name><operator>-&gt;</operator><name>isEphemeral</name></name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nWrite</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Assert if an Abort at this point in time might result in a corrupt
** database.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeAssertAbortable</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nWrite</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>usesStmtJournal</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine is called after all opcodes have been inserted.  It loops
** through all the opcodes and fixes up some details.
**
** (1) For each jump instruction with a negative P2 value (a label)
**     resolve the P2 value to an actual address.
**
** (2) Compute the maximum number of arguments used by any SQL function
**     and store that value in *pMaxFuncArgs.
**
** (3) Update the Vdbe.readOnly and Vdbe.bIsReader flags to accurately
**     indicate what the prepared statement actually does.
**
** (4) (discontinued)
**
** (5) Reclaim the memory allocated for storing labels.
**
** This routine will only function correctly if the mkopcodeh.tcl generator
** script numbers the opcodes correctly.  Changes to this routine must be
** coordinated with changes to mkopcodeh.tcl.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>resolveP2Values</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pMaxFuncArgs</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nMaxArgs</name> <init>= <expr><operator>*</operator><name>pMaxFuncArgs</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aLabel</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>aLabel</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>

    <comment type="block">/* Only JUMP opcodes and the short list of special opcodes in the switch
    ** below need to be considered.  The mkopcodeh.tcl generator script groups
    ** all these opcodes together near the front of the opcode list.  Skip
    ** any opcode that does not need processing by virtual of the fact that
    ** it is larger than SQLITE_MX_JUMP_OPCODE, as a performance optimization.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>&lt;=</operator><name>SQLITE_MX_JUMP_OPCODE</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* NOTE: Be sure to update mkopcodeh.tcl when adding or removing
      ** cases from this switch! */</comment>
      <switch>switch<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr> )</condition><block>{<block_content>
        <case>case <expr><name>OP_Transaction</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
        </block_content>}</block>
        <case>case <expr><name>OP_AutoCommit</name></expr>:</case>
        <case>case <expr><name>OP_Savepoint</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
        <case>case <expr><name>OP_Checkpoint</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>OP_Vacuum</name></expr>:</case>
        <case>case <expr><name>OP_JournalMode</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
        <case>case <expr><name>OP_VUpdate</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><name>nMaxArgs</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nMaxArgs</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>OP_VFilter</name></expr>:</case> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>pOp</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name></name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Integer</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pOp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p1</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><name>nMaxArgs</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nMaxArgs</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <comment type="block">/* Fall through into the default case */</comment>
          <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <default>default:</default> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <comment type="block">/* The mkopcodeh.tcl script has so arranged things that the only
            ** non-jump opcodes less than SQLITE_MX_JUMP_CODE are guaranteed to
            ** have non-negative values for P2. */</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>sqlite3OpcodeProperty</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>]</index></name> <operator>&amp;</operator> <name>OPFLG_JUMP</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ADDR</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call><operator>&lt;</operator><operator>-</operator><name><name>pParse</name><operator>-&gt;</operator><name>nLabel</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name><name>aLabel</name><index>[<expr><call><name>ADDR</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
      </block_content>}</block></switch>
      <comment type="block">/* The mkopcodeh.tcl script has so arranged things that the only
      ** non-jump opcodes less than SQLITE_MX_JUMP_CODE are guaranteed to
      ** have non-negative values for P2. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>sqlite3OpcodeProperty</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>]</index></name><operator>&amp;</operator><name>OPFLG_JUMP</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pOp</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pOp</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>aLabel</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aLabel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aLabel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nLabel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pMaxFuncArgs</name> <operator>=</operator> <name>nMaxArgs</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <call><name>DbMaskAllZero</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Check to see if a subroutine contains a jump to a location outside of
** the subroutine.  If a jump outside the subroutine is detected, add code
** that will cause the program to halt with an error message.
**
** The subroutine consists of opcodes between iFirst and iLast.  Jumps to
** locations within the subroutine are acceptable.  iRetReg is a register
** that contains the return address.  Jumps to outside the range of iFirst
** through iLast are also acceptable as long as the jump destination is
** an OP_Return to iReturnAddr.
**
** A jump to an unresolved label means that the jump destination will be
** beyond the current address.  That is normally a jump to an early
** termination and is consider acceptable.
**
** This routine only runs during debug builds.  The purpose is (of course)
** to detect invalid escapes out of a subroutine.  The OP_Halt opcode
** is generated rather than an assert() or other error, so that ".eqp full"
** will still work to show the original bytecode, to aid in debugging.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeNoJumpsOutsideSubrtn</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,          <comment type="block">/* The byte-code program under construction */</comment>
  <parameter><decl><type><name>int</name></type> <name>iFirst</name></decl></parameter>,       <comment type="block">/* First opcode of the subroutine */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLast</name></decl></parameter>,        <comment type="block">/* Last opcode of the subroutine */</comment>
  <parameter><decl><type><name>int</name></type> <name>iRetReg</name></decl></parameter>       <comment type="block">/* Subroutine return address register */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>pErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>pParse</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLast</name><operator>&gt;=</operator><name>iFirst</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLast</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>iFirst</name></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iFirst</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>iLast</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pOp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>sqlite3OpcodeProperty</name><index>[<expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>]</index></name> <operator>&amp;</operator> <name>OPFLG_JUMP</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iDest</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Jump destination */</comment>
      <if_stmt><if>if<condition>( <expr><name>iDest</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Gosub</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iDest</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><call><name>ADDR</name><argument_list>(<argument><expr><name>iDest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><operator>-</operator><name><name>pParse</name><operator>-&gt;</operator><name>nLabel</name></name> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>aLabel</name><index>[<expr><name>j</name></expr>]</index></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>iDest</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>aLabel</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>iDest</name><argument_list type="generic">&lt;<argument><expr><name>iFirst</name> <operator>||</operator> <name>iDest</name></expr></argument>&gt;</argument_list></name><name>iLast</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>iDest</name></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Return</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>p1</name></name><operator>==</operator><name>iRetReg</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Noop</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pX</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Explain</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>pErr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>pErr</name> <operator>=</operator> <call><name>sqlite3_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_str_appendchar</name><argument_list>(<argument><expr><name>pErr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pErr</name></expr></argument>,
              <argument><expr><literal type="string">"Opcode at %d jumps to %d which is outside the "</literal>
              <literal type="string">"subroutine at %d..%d"</literal></expr></argument>,
              <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iDest</name></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>, <argument><expr><name>iLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>pErr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><call><name>sqlite3_str_finish</name><argument_list>(<argument><expr><name>pErr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Halt</name></expr></argument>, <argument><expr><name>SQLITE_INTERNAL</name></expr></argument>, <argument><expr><name>OE_Abort</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3MayAbort</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>

<comment type="block">/*
** Return the address of the next instruction to be inserted.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeCurrentAddr</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_INIT_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Verify that at least N opcode slots are available in p without
** having to malloc for more space (except when compiled using
** SQLITE_TEST_REALLOC_STRESS).  This interface is used during testing
** to verify that certain calls to sqlite3VdbeAddOpList() can never
** fail due to a OOM fault and hence that the return value from
** sqlite3VdbeAddOpList() will always be non-NULL.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST_REALLOC_STRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name>sqlite3VdbeVerifyNoMallocRequired</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name> <operator>+</operator> <name>N</name> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOpAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Verify that the VM passed as the only argument does not contain
** an OP_ResultRow opcode. Fail an assert() if it does. This is used
** by code in pragma.c to ensure that the implementation of certain
** pragmas comports with the flags specified in the mkpragmatab.tcl
** script.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST_REALLOC_STRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name>sqlite3VdbeVerifyNoResultRow</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name><operator>!=</operator><name>OP_ResultRow</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Generate code (a single OP_Abortable opcode) that will
** verify that the VDBE program can safely call Abort in the current
** context.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name>sqlite3VdbeVerifyAbortable</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>onError</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>onError</name><operator>==</operator><name>OE_Abort</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_Abortable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This function returns a pointer to the array of opcodes associated with
** the Vdbe passed as the first argument. It is the callers responsibility
** to arrange for the returned array to be eventually freed using the 
** vdbeFreeOpArray() function.
**
** Before returning, *pnOp is set to the number of entries in the returned
** array. Also, *pnMaxArg is set to the larger of its current value and 
** the number of entries in the Vdbe.apArg[] array required to execute the 
** returned program.
*/</comment>
<function><type><name>VdbeOp</name> <modifier>*</modifier></type><name>sqlite3VdbeTakeOpArray</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnMaxArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>aOp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aOp</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check that sqlite3VdbeUsesBtree() was not called on this VM */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>DbMaskAllZero</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>resolveP2Values</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pnMaxArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnOp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>aOp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add a whole list of operations to the operation stack.  Return a
** pointer to the first operation inserted.
**
** Non-zero P2 arguments to jump instructions are automatically adjusted
** so that the jump target is relative to the first operation inserted.
*/</comment>
<function><type><name>VdbeOp</name> <modifier>*</modifier></type><name>sqlite3VdbeAddOpList</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                     <comment type="block">/* Add opcodes to the prepared statement */</comment>
  <parameter><decl><type><name>int</name></type> <name>nOp</name></decl></parameter>,                     <comment type="block">/* Number of opcodes to add */</comment>
  <parameter><decl><type><name>VdbeOpList</name> <specifier>const</specifier> <modifier>*</modifier></type><name>aOp</name></decl></parameter>,       <comment type="block">/* The opcodes to be added */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLineno</name></decl></parameter>                  <comment type="block">/* Source-file line number of first opcode */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOut</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pFirst</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOp</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_INIT_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name> <operator>+</operator> <name>nOp</name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>nOpAlloc</name></name> <operator>&amp;&amp;</operator> <call><name>growOpArray</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nOp</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pFirst</name> <operator>=</operator> <name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nOp</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>aOp</name><operator>++</operator></expr><operator>,</operator> <expr><name>pOut</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name><name>aOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>p1</name></name> <operator>=</operator> <name><name>aOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>p2</name></name> <operator>=</operator> <name><name>aOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>sqlite3OpcodeProperty</name><index>[<expr><name><name>aOp</name><operator>-&gt;</operator><name>opcode</name></name></expr>]</index></name> <operator>&amp;</operator> <name>OPFLG_JUMP</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aOp</name><operator>-&gt;</operator><name>p2</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>p2</name></name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>p3</name></name> <operator>=</operator> <name><name>aOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_NOTUSED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>p5</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>zComment</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_VDBE_COVERAGE</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>iSrcLine</name></name> <operator>=</operator> <name>iLineno</name><operator>+</operator><name>i</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>iLineno</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_VdbeAddopTrace</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name> <operator>+=</operator> <name>nOp</name></expr>;</expr_stmt>
  <return>return <expr><name>pFirst</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_STMT_SCANSTATUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Add an entry to the array of counters managed by sqlite3_stmt_scanstatus().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeScanStatus</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                        <comment type="block">/* VM to add scanstatus() to */</comment>
  <parameter><decl><type><name>int</name></type> <name>addrExplain</name></decl></parameter>,                <comment type="block">/* Address of OP_Explain (or 0) */</comment>
  <parameter><decl><type><name>int</name></type> <name>addrLoop</name></decl></parameter>,                   <comment type="block">/* Address of loop counter */</comment> 
  <parameter><decl><type><name>int</name></type> <name>addrVisit</name></decl></parameter>,                  <comment type="block">/* Address of rows visited counter */</comment>
  <parameter><decl><type><name>LogEst</name></type> <name>nEst</name></decl></parameter>,                    <comment type="block">/* Estimated number of output rows */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>               <comment type="block">/* Name of table or index being scanned */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name> <init>= <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nScan</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanStatus</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ScanStatus</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>aNew</name> <operator>=</operator> <operator>(</operator><name>ScanStatus</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aScan</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aNew</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ScanStatus</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><operator>&amp;</operator><name><name>aNew</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nScan</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>addrExplain</name></name> <operator>=</operator> <name>addrExplain</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>addrLoop</name></name> <operator>=</operator> <name>addrLoop</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>addrVisit</name></name> <operator>=</operator> <name>addrVisit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nEst</name></name> <operator>=</operator> <name>nEst</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aScan</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Change the value of the opcode, or P1, P2, P3, or P5 operands
** for a specific instruction.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeOpcode</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>iNewOpcode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>addr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>opcode</name> <operator>=</operator> <name>iNewOpcode</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP1</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>addr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>p1</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP2</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>addr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>p2</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP3</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>addr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>p3</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP5</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u16</name></type> <name>p5</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p5</name> <operator>=</operator> <name>p5</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Change the P2 operand of instruction addr so that it points to
** the address of the next instruction to be coded.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeJumpHere</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Change the P2 operand of the jump instruction at addr so that
** the jump lands on the next opcode.  Or if the jump instruction was
** the previous opcode (and is thus a no-op) then simply back up
** the next instruction counter by one slot so that the jump is
** overwritten by the next inserted opcode.
**
** This routine is an optimization of sqlite3VdbeJumpHere() that
** strives to omit useless byte-code like this:
**
**        7   Once 0 8 0
**        8   ...
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeJumpHereOrPopInst</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>addr</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Once</name>
         <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_If</name>
         <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_FkIfZero</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name><operator>.</operator><name>p4type</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_VDBE_COVERAGE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>iSrcLine</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Erase VdbeCoverage() macros */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** If the input FuncDef structure is ephemeral, then free it.  If
** the FuncDef is not ephermal, then do nothing.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeEphemeralFunction</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_EPHEM</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Delete a P4 value if necessary.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>freeP4Mem</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>freeP4FuncCtx</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>freeEphemeralFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeP4</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p4type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p4</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>p4type</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>P4_FUNCCTX</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>freeP4FuncCtx</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_context</name><operator>*</operator><operator>)</operator><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_REAL</name></expr>:</case>
    <case>case <expr><name>P4_INT64</name></expr>:</case>
    <case>case <expr><name>P4_DYNAMIC</name></expr>:</case>
    <case>case <expr><name>P4_INTARRAY</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_KEYINFO</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3KeyInfoUnref</name><argument_list>(<argument><expr><operator>(</operator><name>KeyInfo</name><operator>*</operator><operator>)</operator><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_CURSOR_HINTS</name></cpp:ifdef>
    <case>case <expr><name>P4_EXPR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>P4_FUNCDEF</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>freeEphemeralFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>FuncDef</name><operator>*</operator><operator>)</operator><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_MEM</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>)</operator><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>freeP4Mem</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_VTAB</name></expr> :</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VtabUnlock</name><argument_list>(<argument><expr><operator>(</operator><name>VTable</name> <operator>*</operator><operator>)</operator><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Free the space allocated for aOp and any p4 values allocated for the
** opcodes contained within. If aOp is not NULL it is assumed to contain 
** nOp entries. 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeFreeOpArray</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Op</name> <modifier>*</modifier></type><name>aOp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOp</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aOp</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><operator>&amp;</operator><name><name>aOp</name><index>[<expr><name>nOp</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>  <comment type="block">/* Exit via break */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>&lt;=</operator> <name>P4_FREE_IF_LE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeP4</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifdef>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>     
      <if_stmt><if>if<condition>( <expr><name>pOp</name><operator>==</operator><name>aOp</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pOp</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Link the SubProgram object passed as the second argument into the linked
** list at Vdbe.pSubProgram. This list is used to delete all sub-program
** objects when the VM is no longer required.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeLinkSubProgram</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVdbe</name></decl></parameter>, <parameter><decl><type><name>SubProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pVdbe</name><operator>-&gt;</operator><name>pProgram</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pVdbe</name><operator>-&gt;</operator><name>pProgram</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the given Vdbe has any SubPrograms.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeHasSubProgram</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVdbe</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pVdbe</name><operator>-&gt;</operator><name>pProgram</name></name><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change the opcode at addr into OP_Noop
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeChangeToNoop</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>addr</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>addr</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>freeP4</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_NOTUSED</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>OP_Noop</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the last opcode is "op" and it is not a jump destination,
** then remove it.  Return true if and only if an opcode was removed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeDeletePriorOpcode</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>op</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>op</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Generate an OP_ReleaseReg opcode to indicate that a range of
** registers, except any identified by mask, are no longer in use.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeReleaseRegisters</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,       <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>int</name></type> <name>iFirst</name></decl></parameter>,          <comment type="block">/* Index of first register to be released */</comment>
  <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>,               <comment type="block">/* Number of registers to release */</comment>
  <parameter><decl><type><name>u32</name></type> <name>mask</name></decl></parameter>,            <comment type="block">/* Mask of registers to NOT release */</comment>
  <parameter><decl><type><name>int</name></type> <name>bUndefine</name></decl></parameter>        <comment type="block">/* If true, mark registers as undefined */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>N</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>OptimizationDisabled</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_ReleaseReg</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iFirst</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iFirst</name><operator>+</operator><name>N</name><operator>-</operator><literal type="number">1</literal><operator>&lt;=</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>N</name><operator>&lt;=</operator><literal type="number">31</literal> <operator>&amp;&amp;</operator> <name>mask</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><name>N</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>mask</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>mask</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>iFirst</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>N</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <while>while<condition>( <expr><name>N</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>N</name><operator>&lt;=</operator><literal type="number">32</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>mask</name> <operator>&amp;</operator> <call><name>MASKBIT32</name><argument_list>(<argument><expr><name>N</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>mask</name> <operator>&amp;=</operator> <operator>~</operator><call><name>MASKBIT32</name><argument_list>(<argument><expr><name>N</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>N</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>N</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><name>OP_ReleaseReg</name></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bUndefine</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>


<comment type="block">/*
** Change the value of the P4 operand for a specific instruction.
** This routine is useful when a large program is loaded from a
** static array using sqlite3VdbeAddOpList but we want to make a
** few minor changes to the program.
**
** If n&gt;=0 then the P4 operand is dynamic, meaning that a copy of
** the string is made into memory obtained from sqlite3_malloc().
** A value of n==0 means copy bytes of zP4 up to and including the
** first null byte.  If n&gt;0 then copy n+1 bytes of zP4.
** 
** Other values of n (P4_STATIC, P4_COLLSEQ etc.) indicate that zP4 points
** to a string or structure that is guaranteed to exist for the lifetime of
** the Vdbe. In these cases we can just copy the pointer.
**
** If addr&lt;0 then change P4 on the most recently inserted instruction.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>SQLITE_NOINLINE</name></type> <name>vdbeChangeP4Full</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zP4</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>freeP4</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pOp</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name></name><operator>)</operator></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name> <operator>=</operator> <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_DYNAMIC</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP4</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zP4</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_INIT_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>!=</operator><name>P4_VTAB</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>freeP4</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>addr</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>addr</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vdbeChangeP4Full</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><name>P4_INT32</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Note: this cast is safe, because the origin data point was an int
    ** that was cast to a (const char *). */</comment>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>P4_INT32</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zP4</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>zP4</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <operator>(</operator><name>signed</name> <name>char</name><operator>)</operator><name>n</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><name>P4_VTAB</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VtabLock</name><argument_list>(<argument><expr><operator>(</operator><name>VTable</name><operator>*</operator><operator>)</operator><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Change the P4 operand of the most recently coded instruction 
** to the value defined by the arguments.  This is a high-speed
** version of sqlite3VdbeChangeP4().
**
** The P4 operand must not have been previously defined.  And the new
** P4 must not be P4_INT32.  Use sqlite3VdbeChangeP4() in either of
** those cases.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeAppendP4</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pP4</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>!=</operator><name>P4_INT32</name> <operator>&amp;&amp;</operator> <name>n</name><operator>!=</operator><name>P4_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>freeP4</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>pP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pP4</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_NOTUSED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>p</name></name> <operator>=</operator> <name>pP4</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the P4 on the most recently added opcode to the KeyInfo for the
** index given.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetP4KeyInfo</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <call><name>sqlite3KeyInfoOfIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pKeyInfo</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeAppendP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifdef>
<comment type="block">/*
** Change the comment on the most recently coded instruction.  Or
** insert a No-op and add the comment to that new instruction.  This
** makes the code easier to read during debugging.  None of this happens
** in a production build.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeVComment</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>zComment</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>zComment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>zComment</name> <operator>=</operator> <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeComment</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vdbeVComment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeNoopComment</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_Noop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vdbeVComment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* NDEBUG */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_VDBE_COVERAGE</name></cpp:ifdef>
<comment type="block">/*
** Set the value if the iSrcLine field for the previously coded instruction.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetLineNumber</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLine</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>iSrcLine</name> <operator>=</operator> <name>iLine</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_VDBE_COVERAGE */</comment>

<comment type="block">/*
** Return the opcode for a given address.  If the address is -1, then
** return the most recently inserted opcode.
**
** If a memory allocation error has occurred prior to the calling of this
** routine, then a pointer to a dummy VdbeOp will be returned.  That opcode
** is readable but not writable, though it is cast to a writable value.
** The return of a dummy opcode allows the call to continue functioning
** after an OOM fault without having to check to see if the return from 
** this routine is a valid pointer.  But because the dummy.opcode is 0,
** dummy will never be written to.  This is verified by code inspection and
** by running with Valgrind.
*/</comment>
<function><type><name>VdbeOp</name> <modifier>*</modifier></type><name>sqlite3VdbeGetOp</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* C89 specifies that the constant "dummy" will be initialized to all
  ** zeros, which is correct.  MSVC generates a warning, nevertheless. */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>VdbeOp</name></type> <name>dummy</name></decl>;</decl_stmt>  <comment type="block">/* Ignore the MSVC warning about no initializer */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_INIT_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>addr</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>addr</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>addr</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>)</operator> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>VdbeOp</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dummy</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Return an integer value for one of the parameters to the opcode pOp
** determined by character c.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>translateP</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'1'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'2'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'3'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'4'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compute a string for the "comment" field of a VDBE opcode listing.
**
** The Synopsis: field in comments in the vdbe.c source file gets converted
** to an extra string that is appended to the sqlite3OpcodeName().  In the
** absence of other comments, this synopsis becomes the comment on the opcode.
** Some translation occurs:
**
**       "PX"      -&gt;  "r[X]"
**       "PX@PY"   -&gt;  "r[X..X+Y-1]"  or "r[x]" if y is 0 or 1
**       "PX@PY+1" -&gt;  "r[X..X+Y]"    or "r[x]" if y is 0
**       "PY..PY"  -&gt;  "r[X..Y]"      or "r[x]" if y&lt;=x
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3VdbeDisplayComment</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,       <comment type="block">/* Optional - Oom error reporting only */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>,     <comment type="block">/* The opcode to be commented */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zP4</name></decl></parameter>    <comment type="block">/* Previously obtained value for P4 */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOpName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSynopsis</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOpName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zAlt</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>x</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zOpName</name> <operator>=</operator> <call><name>sqlite3OpcodeName</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nOpName</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zOpName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zOpName</name><index>[<expr><name>nOpName</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>seenCom</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>zSynopsis</name> <operator>=</operator> <name>zOpName</name> <operator>+</operator> <name>nOpName</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zSynopsis</name></expr></argument>,<argument><expr><literal type="string">"IF "</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zAlt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zAlt</name></expr></argument>, <argument><expr><literal type="string">"if %s goto P2"</literal></expr></argument>, <argument><expr><name>zSynopsis</name><operator>+</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSynopsis</name> <operator>=</operator> <name>zAlt</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zSynopsis</name><index>[<expr><name>ii</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'P'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zSynopsis</name><index>[<expr><operator>++</operator><name>ii</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'4'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_str_appendall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'X'</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>zComment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_str_appendall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>seenCom</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>v1</name> <init>= <expr><call><name>translateP</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>v2</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zSynopsis</name><operator>+</operator><name>ii</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"@P"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>ii</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>v2</name> <operator>=</operator> <call><name>translateP</name><argument_list>(<argument><expr><name><name>zSynopsis</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zSynopsis</name><operator>+</operator><name>ii</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="string">"+1"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>ii</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name>v2</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>v2</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%d..%d"</literal></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v1</name><operator>+</operator><name>v2</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zSynopsis</name><operator>+</operator><name>ii</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"@NP"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pCtx</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>!=</operator><name>P4_FUNCCTX</name> <operator>||</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%d..%d"</literal></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v1</name><operator>+</operator><name><name>pCtx</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>x</name><operator>.</operator><name>accError</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>nChar</name></name><operator>&gt;</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nChar</name></name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name>ii</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>ii</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zSynopsis</name><operator>+</operator><name>ii</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"..P3"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>ii</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_str_appendchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>seenCom</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"; %s"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_str_appendall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>zComment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>x</name><operator>.</operator><name>accError</name></name> <operator>&amp;</operator> <name>SQLITE_NOMEM</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>db</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_EXPLAIN_COMMENTS */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VDBE_DISPLAY_P4</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_CURSOR_HINTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Translate the P4.pExpr value for an OP_CursorHint opcode into text
** that can be displayed in the P4 column of EXPLAIN output.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>displayP4Expr</name><parameter_list>(<parameter><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>TK_STRING</name></expr>:</case>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_IntValue</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%Q"</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TK_INTEGER</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TK_NULL</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TK_REGISTER</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"r[%d]"</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_COLUMN</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"rowid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"c%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pExpr</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_LT</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"LT"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_LE</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"LE"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_GT</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"GT"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_GE</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"GE"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_NE</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"NE"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_EQ</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"EQ"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_IS</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"IS"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_ISNOT</name></expr>:</case>   <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"ISNOT"</literal></expr>;</expr_stmt>   <break>break;</break>
    <case>case <expr><name>TK_AND</name></expr>:</case>     <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>TK_OR</name></expr>:</case>      <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"OR"</literal></expr>;</expr_stmt>      <break>break;</break>
    <case>case <expr><name>TK_PLUS</name></expr>:</case>    <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"ADD"</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>TK_STAR</name></expr>:</case>    <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"MUL"</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>TK_MINUS</name></expr>:</case>   <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"SUB"</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>TK_REM</name></expr>:</case>     <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"REM"</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>TK_BITAND</name></expr>:</case>  <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"BITAND"</literal></expr>;</expr_stmt>  <break>break;</break>
    <case>case <expr><name>TK_BITOR</name></expr>:</case>   <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"BITOR"</literal></expr>;</expr_stmt>   <break>break;</break>
    <case>case <expr><name>TK_SLASH</name></expr>:</case>   <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"DIV"</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>TK_LSHIFT</name></expr>:</case>  <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"LSHIFT"</literal></expr>;</expr_stmt>  <break>break;</break>
    <case>case <expr><name>TK_RSHIFT</name></expr>:</case>  <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"RSHIFT"</literal></expr>;</expr_stmt>  <break>break;</break>
    <case>case <expr><name>TK_CONCAT</name></expr>:</case>  <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"CONCAT"</literal></expr>;</expr_stmt>  <break>break;</break>
    <case>case <expr><name>TK_UMINUS</name></expr>:</case>  <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"MINUS"</literal></expr>;</expr_stmt>   <break>break;</break>
    <case>case <expr><name>TK_UPLUS</name></expr>:</case>   <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"PLUS"</literal></expr>;</expr_stmt>    <break>break;</break>
    <case>case <expr><name>TK_BITNOT</name></expr>:</case>  <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"BITNOT"</literal></expr>;</expr_stmt>  <break>break;</break>
    <case>case <expr><name>TK_NOT</name></expr>:</case>     <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"NOT"</literal></expr>;</expr_stmt>     <break>break;</break>
    <case>case <expr><name>TK_ISNULL</name></expr>:</case>  <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"ISNULL"</literal></expr>;</expr_stmt>  <break>break;</break>
    <case>case <expr><name>TK_NOTNULL</name></expr>:</case> <expr_stmt><expr><name>zOp</name> <operator>=</operator> <literal type="string">"NOTNULL"</literal></expr>;</expr_stmt> <break>break;</break>

    <default>default:</default>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"expr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <if_stmt><if>if<condition>( <expr><name>zOp</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><name>zOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>displayP4Expr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>displayP4Expr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* VDBE_DISPLAY_P4 &amp;&amp; defined(SQLITE_ENABLE_CURSOR_HINTS) */</comment>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VDBE_DISPLAY_P4</name></expr></cpp:if>
<comment type="block">/*
** Compute a string that describes the P4 parameter for an opcode.
** Use zTemp for any required temporary buffer space.
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>sqlite3VdbeDisplayP4</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zP4</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>x</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>P4_KEYINFO</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pKeyInfo</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"k(%d"</literal></expr></argument>, <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nKeyField</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nKeyField</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><ternary><condition><expr><name>pColl</name></expr> ?</condition><then> <expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zColl</name></expr></argument>, <argument><expr><literal type="string">"BINARY"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zColl</name> <operator>=</operator> <literal type="string">"B"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">",%s%s%s"</literal></expr></argument>, 
               <argument><expr><ternary><condition><expr><operator>(</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_DESC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"-"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, 
               <argument><expr><ternary><condition><expr><operator>(</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_BIGNULL</name><operator>)</operator></expr>?</condition><then> <expr><literal type="string">"N."</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, 
               <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_CURSOR_HINTS</name></cpp:ifdef>
    <case>case <expr><name>P4_EXPR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>displayP4Expr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>P4_COLLSEQ</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>encnames</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"?"</literal></expr>, <expr><literal type="string">"8"</literal></expr>, <expr><literal type="string">"16LE"</literal></expr>, <expr><literal type="string">"16BE"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pColl</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>enc</name></name><operator>&lt;</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%.18s-%s"</literal></expr></argument>, <argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
                          <argument><expr><name><name>encnames</name><index>[<expr><name><name>pColl</name><operator>-&gt;</operator><name>enc</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_FUNCDEF</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pFunc</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%s(%d)"</literal></expr></argument>, <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>nArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_FUNCCTX</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pCtx</name><operator>-&gt;</operator><name>pFunc</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%s(%d)"</literal></expr></argument>, <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>nArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_INT64</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pI64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_INT32</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_REAL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%.16g"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pReal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_MEM</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pMem</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zP4</name> <operator>=</operator> <name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%.16g"</literal></expr></argument>, <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zP4</name> <operator>=</operator> <literal type="string">"NULL"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zP4</name> <operator>=</operator> <literal type="string">"(blob)"</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <case>case <expr><name>P4_VTAB</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"vtab:%p"</literal></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>P4_INTARRAY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>ai</name> <init>= <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>ai</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>n</name> <init>= <expr><name><name>ai</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The first element of an INTARRAY is always the
                       ** count of the number of elements to follow */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"%c%u"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>i</name><operator>==</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="char">'['</literal></expr> </then><else>: <expr><literal type="char">','</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name><name>ai</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_SUBPROGRAM</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>zP4</name> <operator>=</operator> <literal type="string">"program"</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>P4_TABLE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>zP4</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><name>zP4</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>
  <if_stmt><if>if<condition>( <expr><name>zP4</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_str_appendall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>x</name><operator>.</operator><name>accError</name></name> <operator>&amp;</operator> <name>SQLITE_NOMEM</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* VDBE_DISPLAY_P4 */</comment>

<comment type="block">/*
** Declare to the Vdbe that the BTree object at db-&gt;aDb[i] is used.
**
** The prepared statements need to know in advance the complete set of
** attached databases that will be use.  A mask of these databases
** is maintained in p-&gt;btreeMask.  The p-&gt;lockMask value is the subset of
** p-&gt;btreeMask of databases that will require a lock.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeUsesBtree</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nDb</name></name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yDbMask</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DbMaskSet</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>btreeMask</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3BtreeSharable</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>DbMaskSet</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>lockMask</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SHARED_CACHE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** If SQLite is compiled to support shared-cache mode and to be threadsafe,
** this routine obtains the mutex associated with each BtShared structure
** that may be accessed by the VM passed as an argument. In doing so it also
** sets the BtShared.db member of each of the BtShared structures, ensuring
** that the correct busy-handler callback is invoked if required.
**
** If SQLite is not threadsafe but does support shared-cache mode, then
** sqlite3BtreeEnter() is invoked to set the BtShared.db variables
** of all of BtShared structures accessible via the database handle 
** associated with the VM.
**
** If SQLite is not threadsafe and does not support shared-cache mode, this
** function is a no-op.
**
** The p-&gt;btreeMask field is a bitmask of all btrees that the prepared 
** statement p will ever use.  Let N be the number of bits in p-&gt;btreeMask
** corresponding to btrees that use shared cache.  Then the runtime of
** this routine is N*N.  But as N is rarely more than 1, this should not
** be a problem.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeEnter</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>aDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDb</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>DbMaskAllZero</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>lockMask</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* The common case */</comment>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nDb</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>lockMask</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SHARED_CACHE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Unlock all of the btrees previously locked by a call to sqlite3VdbeEnter().
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>vdbeLeave</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>aDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDb</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nDb</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nDb</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>DbMaskTest</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>lockMask</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeLeave</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>DbMaskAllZero</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>lockMask</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* The common case */</comment>
  <expr_stmt><expr><call><name>vdbeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VDBE_PROFILE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Print a single opcode.  This routine is used for debugging only.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbePrintOp</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>, <parameter><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zP4</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCom</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name></type> <name>dummyDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat1</name> <init>= <expr><literal type="string">"%4d %-13s %4d %4d %4d %-13s %.2X %s\n"</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pOut</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dummyDb</name><operator>.</operator><name>mallocFailed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>zP4</name> <operator>=</operator> <call><name>sqlite3VdbeDisplayP4</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dummyDb</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifdef>
  <expr_stmt><expr><name>zCom</name> <operator>=</operator> <call><name>sqlite3VdbeDisplayComment</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pOp</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>zCom</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* NB:  The sqlite3OpcodeName() function is implemented by code created
  ** by the mkopcodeh.awk and mkopcodec.awk scripts which extract the
  ** information from the vdbe.c source text */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>zFormat1</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, 
      <argument><expr><call><name>sqlite3OpcodeName</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>, 
      <argument><expr><ternary><condition><expr><name>zP4</name></expr> ?</condition><then> <expr><name>zP4</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>,
      <argument><expr><ternary><condition><expr><name>zCom</name></expr> ?</condition><then> <expr><name>zCom</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Initialize an array of N Mem element.
**
** This is a high-runner, so only those fields that really do need to
** be initialized are set.  The Mem structure is organized so that
** the fields that get initialized are nearby and hopefully on the same
** cache line.
**
**    Mem.flags = flags
**    Mem.db = db
**    Mem.szMalloc = 0
**
** All other fields of Mem can safely remain uninitialized for now.  They
** will be initialized before use.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>initMemArray</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>u16</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>N</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pScopyFrom</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><operator>(</operator><operator>--</operator><name>N</name><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Release auxiliary memory held in an array of N Mem elements.
**
** After this routine returns, all Mem elements in the array will still
** be valid.  Those Mem elements that were not holding auxiliary resources
** will be unchanged.  Mem elements which had something freed will be
** set to MEM_Undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>releaseMemArray</name><parameter_list>(<parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name>N</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><index>[<expr><name>N</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name></expr> )</condition><block>{<block_content>
      <do>do<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block>while<condition>( <expr><operator>(</operator><operator>++</operator><name>p</name><operator>)</operator><operator>&lt;</operator><name>pEnd</name></expr> )</condition>;</do>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>==</operator><name>pEnd</name> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>db</name><operator>==</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeCheckMemInvariants</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* This block is really an inlined version of sqlite3VdbeMemRelease()
      ** that takes advantage of the fact that the memory cell value is 
      ** being set to NULL after releasing any dynamic resources.
      **
      ** The justification for duplicating code is that according to 
      ** callgrind, this causes a certain test case to hit the CPU 4.7 
      ** percent less (x86 linux, gcc version 4.1.2, -O6) than if 
      ** sqlite3MemRelease() were called from here. With -O2, this jumps
      ** to 6.6 percent. The test case is inserting 1000 rows into a table 
      ** with no indexes using a single prepared INSERT statement, bind() 
      ** and reset(). Inserts are grouped into a transaction.
      */</comment>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Agg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_Agg</name><operator>|</operator><name>MEM_Dyn</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Dyn</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>xDel</name></name><operator>==</operator><name>sqlite3VdbeFrameMemDel</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Undefined</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Undefined</name></expr>;</expr_stmt>
      </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
      <else>else<block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Undefined</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block>while<condition>( <expr><operator>(</operator><operator>++</operator><name>p</name><operator>)</operator><operator>&lt;</operator><name>pEnd</name></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Verify that pFrame is a valid VdbeFrame pointer.  Return true if it is
** and false if something is wrong.
**
** This routine is intended for use inside of assert() statements only.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeFrameIsValid</name><parameter_list>(<parameter><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pFrame</name><operator>-&gt;</operator><name>iFrameMagic</name></name><operator>!=</operator><name>SQLITE_FRAME_MAGIC</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** This is a destructor on a Mem object (which is really an sqlite3_value)
** that deletes the Frame object that is attached to it as a blob.
**
** This routine does not delete the Frame right away.  It merely adds the
** frame to a list of frames to be deleted when the Vdbe halts.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeFrameMemDel</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name> <init>= <expr><operator>(</operator><name>VdbeFrame</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeFrameIsValid</name><argument_list>(<argument><expr><name>pFrame</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>pDelFrame</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>pDelFrame</name></name> <operator>=</operator> <name>pFrame</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_BYTECODE_VTAB</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_EXPLAIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Locate the next opcode to be displayed in EXPLAIN or EXPLAIN
** QUERY PLAN output.
**
** Return SQLITE_ROW on success.  Return SQLITE_DONE if there are no
** more opcodes to be displayed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeNextOpcode</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,         <comment type="block">/* The statement being explained */</comment>
  <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pSub</name></decl></parameter>,       <comment type="block">/* Storage for keeping track of subprogram nesting */</comment>
  <parameter><decl><type><name>int</name></type> <name>eMode</name></decl></parameter>,       <comment type="block">/* 0: normal.  1: EQP.  2:  TablesUsed */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piPc</name></decl></parameter>,       <comment type="block">/* IN/OUT: Current rowid.  Overwritten with next rowid */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piAddr</name></decl></parameter>,     <comment type="block">/* OUT: Write index into (*paOp)[] here */</comment>
  <parameter><decl><type><name>Op</name> <modifier>*</modifier><modifier>*</modifier></type><name>paOp</name></decl></parameter>        <comment type="block">/* OUT: Write the opcode array here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nRow</name></decl>;</decl_stmt>                            <comment type="block">/* Stop when row count reaches this */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSub</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                        <comment type="block">/* Number of sub-vdbes seen so far */</comment>
  <decl_stmt><decl><type><name>SubProgram</name> <modifier>*</modifier><modifier>*</modifier></type><name>apSub</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Array of sub-vdbes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                               <comment type="block">/* Next instruction address */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Result code */</comment>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>aOp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                         <comment type="block">/* Opcode array */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPc</name></decl>;</decl_stmt>                             <comment type="block">/* Rowid.  Copy of value in *piPc */</comment>

  <comment type="block">/* When the number of output rows reaches nRow, that means the
  ** listing has finished and sqlite3_step() should return SQLITE_DONE.
  ** nRow is the sum of the number of rows in the main program, plus
  ** the sum of the number of rows in all trigger subprograms encountered
  ** so far.  The nRow value will increase as new trigger subprograms are
  ** encountered, but p-&gt;pc will eventually catch up to nRow.
  */</comment>
  <expr_stmt><expr><name>nRow</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSub</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pSub</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Blob</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* pSub is initiallly NULL.  It is initialized to a BLOB by
      ** the P4_SUBPROGRAM processing logic below */</comment>
      <expr_stmt><expr><name>nSub</name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>n</name></name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Vdbe</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name>apSub</name> <operator>=</operator> <operator>(</operator><name>SubProgram</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>pSub</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nSub</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>nRow</name> <operator>+=</operator> <name><name>apSub</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nOp</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iPc</name> <operator>=</operator> <operator>*</operator><name>piPc</name></expr>;</expr_stmt>
  <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>  <comment type="block">/* Loop exits via break */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>iPc</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>nRow</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The rowid is small enough that we are still in the
      ** main program. */</comment>
      <expr_stmt><expr><name>aOp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* We are currently listing subprograms.  Figure out which one and
      ** pick up the appropriate opcode. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>i</name> <operator>-=</operator> <name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>apSub</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nSub</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><name><name>apSub</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>nOp</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>i</name> <operator>-=</operator> <name><name>apSub</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>nOp</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><name><name>apSub</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>nOp</name> <operator>||</operator> <name>j</name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name>nSub</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>aOp</name> <operator>=</operator> <name><name>apSub</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>aOp</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* When an OP_Program opcode is encounter (the only opcode that has
    ** a P4_SUBPROGRAM argument), expand the size of the array of subprograms
    ** kept in p-&gt;aMem[9].z to hold the new program - assuming this subprogram
    ** has not already been seen.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>pSub</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p4type</name><operator>==</operator><name>P4_SUBPROGRAM</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><operator>(</operator><name>nSub</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>SubProgram</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nSub</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>apSub</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>p4</name><operator>.</operator><name>pProgram</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name>nSub</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pSub</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>nSub</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>apSub</name> <operator>=</operator> <operator>(</operator><name>SubProgram</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>pSub</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>apSub</name><index>[<expr><name>nSub</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>p4</name><operator>.</operator><name>pProgram</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pSub</name></expr></argument>, <argument><expr><name>MEM_Blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSub</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>nSub</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>SubProgram</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name>nRow</name> <operator>+=</operator> <name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>p4</name><operator>.</operator><name>pProgram</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eMode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_BYTECODE_VTAB</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><name>eMode</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><name>aOp</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenRead</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_OpenWrite</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>OPFLAG_P2ISREG</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_ReopenIdx</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>      
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMode</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Explain</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name><operator>==</operator><name>OP_Init</name> <operator>&amp;&amp;</operator> <name>iPc</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>piPc</name> <operator>=</operator> <name>iPc</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piAddr</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>paOp</name> <operator>=</operator> <name>aOp</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_BYTECODE_VTAB || !SQLITE_OMIT_EXPLAIN */</comment>


<comment type="block">/*
** Delete a VdbeFrame object and its contents. VdbeFrame objects are
** allocated by the OP_Program opcode in sqlite3VdbeExec().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeFrameDelete</name><parameter_list>(<parameter><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>aMem</name> <init>= <expr><call><name>VdbeFrameMem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>apCsr</name> <init>= <expr><operator>(</operator><name>VdbeCursor</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aMem</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nChildMem</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3VdbeFrameIsValid</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nChildCsr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeFreeCursorNN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name>aMem</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChildMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeDeleteAuxData</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pAuxData</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
<comment type="block">/*
** Give a listing of the program in the virtual machine.
**
** The interface is the same as sqlite3VdbeExec().  But instead of
** running the code, it invokes the callback once for each instruction.
** This feature is used to implement "EXPLAIN".
**
** When p-&gt;explain==1, each instruction is listed.  When
** p-&gt;explain==2, only OP_Explain instructions are listed and these
** are shown in a different format.  p-&gt;explain==2 is used to implement
** EXPLAIN QUERY PLAN.
** 2018-04-24:  In p-&gt;explain==2 mode, the OP_Init opcodes of triggers
** are also shown, so that the boundaries between the main program and
** each trigger are clear.
**
** When p-&gt;explain==1, first the main program is listed, then each of
** the trigger subprograms are listed one by one.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeList</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>                   <comment type="block">/* The VDBE */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pSub</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                       <comment type="block">/* Memory cell hold array of subprogs */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>                 <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                               <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>             <comment type="block">/* First Mem of result set */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bListSubprogs</name> <init>= <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_TriggerEQP</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>aOp</name></decl>;</decl_stmt>                             <comment type="block">/* Array of opcodes */</comment>
  <decl_stmt><decl><type><name>Op</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>                             <comment type="block">/* Current opcode */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>explain</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_RUN_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_BUSY</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Even though this opcode does not use dynamic strings for
  ** the result, result columns may become dynamic if the user calls
  ** sqlite3_column_text16(), causing a translation to UTF-16 encoding.
  */</comment>
  <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pResultSet</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This happens if a malloc() inside a call to sqlite3_column_text() or
    ** sqlite3_column_text16() failed.  */</comment>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>bListSubprogs</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The first 8 memory cells are used for the result set.  So we will
    ** commandeer the 9th cell to use as storage for an array of pointers
    ** to trigger subprograms.  The VDBE is guaranteed to have at least 9
    ** cells.  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name><operator>&gt;</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSub</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pSub</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Figure out which opcode is next to display */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeNextOpcode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pSub</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pOp</name> <operator>=</operator> <name>aOp</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>AtomicLoad</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_INTERRUPT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zP4</name> <init>= <expr><call><name>sqlite3VdbeDisplayP4</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pMem</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pMem</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pMem</name><operator>+</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>     
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pMem</name><operator>+</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pMem</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3OpcodeName</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pMem</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pMem</name><operator>+</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pMem</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* pMem+5 for p4 is done last */</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pMem</name><operator>+</operator><literal type="number">6</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPLAIN_COMMENTS</name></cpp:ifdef>
        <block>{<block_content>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCom</name> <init>= <expr><call><name>sqlite3VdbeDisplayComment</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pMem</name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><name>zCom</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pMem</name><operator>+</operator><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pMem</name><operator>+</operator><literal type="number">5</literal></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pResultSet</name></name> <operator>=</operator> <name>pMem</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ROW</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_EXPLAIN */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Print the SQL that was used to generate a VDBE program.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbePrintSql</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Init</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>sqlite3Isspace</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SQL: [%s]\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRACE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_IOTRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Print an IOTRACE message showing SQL content.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeIOTraceSql</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nOp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>sqlite3IoTrace</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nOp</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_Init</name> <operator>&amp;&amp;</operator> <name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>z</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>sqlite3Isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3Isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">' '</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3IoTrace</name><argument_list>(<argument><expr><literal type="string">"SQL %s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_OMIT_TRACE &amp;&amp; SQLITE_ENABLE_IOTRACE */</comment>

<comment type="block">/* An instance of this object describes bulk memory available for use
** by subcomponents of a prepared statement.  Space is allocated out
** of a ReusableSpace object by the allocSpace() routine below.
*/</comment>
<struct>struct <name>ReusableSpace</name> <block>{
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pSpace</name></decl>;</decl_stmt>            <comment type="block">/* Available memory */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nFree</name></decl>;</decl_stmt>   <comment type="block">/* Bytes of available memory */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nNeeded</name></decl>;</decl_stmt> <comment type="block">/* Total bytes that could not be allocated */</comment>
}</block>;</struct>

<comment type="block">/* Try to allocate nByte bytes of 8-byte aligned bulk memory for pBuf
** from the ReusableSpace object.  Return a pointer to the allocated
** memory on success.  If insufficient memory is available in the
** ReusableSpace object, increase the ReusableSpace.nNeeded
** value by the amount needed and return NULL.
**
** If pBuf is not initially NULL, that means that the memory has already
** been allocated by a prior call to this routine, so just return a copy
** of pBuf and leave ReusableSpace unchanged.
**
** This allocator is employed to repurpose unused slots at the end of the
** opcode array of prepared state for other memory needs of the prepared
** statement.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>allocSpace</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>ReusableSpace</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,  <comment type="block">/* Bulk memory available for allocation */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,               <comment type="block">/* Pointer to a prior allocation */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl></parameter>       <comment type="block">/* Bytes of memory needed. */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSpace</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>ROUND8P</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nByte</name> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>nFree</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFree</name></name> <operator>-=</operator> <name>nByte</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pSpace</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nFree</name></name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nNeeded</name></name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pBuf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Rewind the VDBE back to the beginning in preparation for
** running it.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeRewind</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>VDBE_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_INIT_STATE</name>
       <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_READY_STATE</name>
       <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_HALT_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* There should be at least one opcode.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name> <operator>=</operator> <name>VDBE_READY_STATE</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>db</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cacheCtr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>minWriteFileFormat</name></name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFkConstraint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cycles</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Prepare a virtual machine for execution for the first time after
** creating the virtual machine.  This involves things such
** as allocating registers and initializing the program counter.
** After the VDBE has be prepped, it can be executed by one or more
** calls to sqlite3VdbeExec().  
**
** This function may be called exactly once on each virtual machine.
** After this routine is called the VM has been "packaged" and is ready
** to run.  After this routine is called, further calls to 
** sqlite3VdbeAddOp() functions are prohibited.  This routine disconnects
** the Vdbe from the Parse object that helped generate it so that the
** the Vdbe becomes an independent entity and the Parse object can be
** destroyed.
**
** Use the sqlite3VdbeRewind() procedure to restore a virtual machine back
** to its initial state after it has been run.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMakeReady</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                       <comment type="block">/* The VDBE */</comment>
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>                  <comment type="block">/* Parsing context */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                   <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nVar</name></decl>;</decl_stmt>                      <comment type="block">/* Number of parameters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMem</name></decl>;</decl_stmt>                      <comment type="block">/* Number of VM memory registers */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCursor</name></decl>;</decl_stmt>                   <comment type="block">/* Number of cursors required */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>                      <comment type="block">/* Number of arguments in subprograms */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                         <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>ReusableSpace</name></name></type> <name>x</name></decl>;</decl_stmt>        <comment type="block">/* Reusable bulk memory */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_INIT_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pParse</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pVList</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pVList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVList</name></name> <operator>=</operator>  <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nVar</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nVar</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nMem</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCursor</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nArg</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nMaxArg</name></name></expr>;</expr_stmt>
  
  <comment type="block">/* Each cursor uses a memory cell.  The first cursor (cursor 0) can
  ** use aMem[0] which is not otherwise used by the VDBE program.  Allocate
  ** space at the end of aMem[] for cursors 1 and greater.
  ** See also: allocateCursor().
  */</comment>
  <expr_stmt><expr><name>nMem</name> <operator>+=</operator> <name>nCursor</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nCursor</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nMem</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nMem</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Space for aMem[0] even if not used */</comment>

  <comment type="block">/* Figure out how much reusable memory is available at the end of the
  ** opcode array.  This extra memory will be reallocated for other elements
  ** of the prepared statement.
  */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ROUND8P</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="block">/* Bytes of opcode memory used */</comment>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pSpace</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name><operator>)</operator><index>[<expr><name>n</name></expr>]</index></expr>;</expr_stmt>               <comment type="block">/* Unused opcode memory */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>pSpace</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nFree</name></name> <operator>=</operator> <call><name>ROUNDDOWN8</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>szOpAlloc</name></name> <operator>-</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Bytes of unused memory */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>nFree</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>x</name><operator>.</operator><name>pSpace</name><index>[<expr><name><name>x</name><operator>.</operator><name>nFree</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>resolveP2Values</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>usesStmtJournal</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>isMultiWrite</name></name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>mayAbort</name></name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>explain</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>azColName</name><index>[]</index></name> <init>= <expr><block>{
       <expr><literal type="string">"addr"</literal></expr>, <expr><literal type="string">"opcode"</literal></expr>, <expr><literal type="string">"p1"</literal></expr>, <expr><literal type="string">"p2"</literal></expr>, <expr><literal type="string">"p3"</literal></expr>, <expr><literal type="string">"p4"</literal></expr>, <expr><literal type="string">"p5"</literal></expr>, <expr><literal type="string">"comment"</literal></expr>,
       <expr><literal type="string">"id"</literal></expr>, <expr><literal type="string">"parent"</literal></expr>, <expr><literal type="string">"notused"</literal></expr>, <expr><literal type="string">"detail"</literal></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iFirst</name></decl>, <decl><type ref="prev"/><name>mx</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nMem</name><operator>&lt;</operator><literal type="number">10</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nMem</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>explain</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>explain</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>explain</name></name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeSetNumCols</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iFirst</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>mx</name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeSetNumCols</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iFirst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>mx</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iFirst</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>mx</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name><operator>-</operator><name>iFirst</name></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>,
                            <argument><expr><name><name>azColName</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Memory for registers, parameters, cursor, etc, is allocated in one or two
  ** passes.  On the first pass, we try to reuse unused memory at the 
  ** end of the opcode array.  If we are unable to satisfy all memory
  ** requirements by reusing the opcode array tail, then the second
  ** pass will fill in the remainder using a fresh memory allocation.  
  **
  ** This two-pass approach that reuses as much memory as possible from
  ** the leftover memory at the end of the opcode array.  This can significantly
  ** reduce the amount of memory held by a prepared statement.
  */</comment>
  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nNeeded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nMem</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aVar</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nVar</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apArg</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nArg</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nCursor</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>VdbeCursor</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>anExec</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>nNeeded</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>pSpace</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFree</name></name> <operator>=</operator> <call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>nNeeded</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nFree</name></name> <operator>=</operator> <name><name>x</name><operator>.</operator><name>nNeeded</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr></argument>, <argument><expr><name>nMem</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aVar</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aVar</name></name></expr></argument>, <argument><expr><name>nVar</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apArg</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apArg</name></name></expr></argument>, <argument><expr><name>nArg</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name></name></expr></argument>, <argument><expr><name>nCursor</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>VdbeCursor</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>anExec</name></name> <operator>=</operator> <call><name>allocSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>anExec</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nVar</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>=</operator> <name>nCursor</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nVar</name></name> <operator>=</operator> <operator>(</operator><name>ynVar</name><operator>)</operator><name>nVar</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initMemArray</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aVar</name></name></expr></argument>, <argument><expr><name>nVar</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name> <operator>=</operator> <name>nMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initMemArray</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr></argument>, <argument><expr><name>nMem</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>MEM_Undefined</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nCursor</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>VdbeCursor</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>anExec</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeRewind</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close a VDBE cursor and release all the resources that cursor 
** happens to hold.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeFreeCursor</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pCx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeFreeCursorNN</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>pCx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeFreeCursorNN</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><name><name>pCx</name><operator>-&gt;</operator><name>eCurType</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>CURTYPE_SORTER</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeSorterClose</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>pCx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>CURTYPE_BTREE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeCloseCursor</name><argument_list>(<argument><expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <case>case <expr><name>CURTYPE_VTAB</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVCur</name> <init>= <expr><name><name>pCx</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pVCur</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name> <init>= <expr><name><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pVCur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pVCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Close all cursors in the current frame.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>closeCursorsInFrame</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pC</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeFreeCursorNN</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Copy the values stored in the VdbeFrame structure to its Vdbe. This
** is used, for example, when a trigger sub-program is halted to restore
** control to the main program.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeFrameRestore</name><parameter_list>(<parameter><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>pFrame</name><operator>-&gt;</operator><name>v</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>closeCursorsInFrame</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>anExec</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>anExec</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>aOp</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>aOp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nOp</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>aMem</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>aMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nMem</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>apCsr</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>apCsr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nCursor</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>nCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>lastRowid</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>lastRowid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>nChange</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>nDbChange</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeDeleteAuxData</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pAuxData</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pAuxData</name></name> <operator>=</operator> <name><name>pFrame</name><operator>-&gt;</operator><name>pAuxData</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFrame</name><operator>-&gt;</operator><name>pAuxData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name><name>pFrame</name><operator>-&gt;</operator><name>pc</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close all cursors.
**
** Also release any dynamic memory held by the VM in the Vdbe.aMem memory 
** cell array. This is necessary as the memory cell array may contain
** pointers to VdbeFrame objects, which may in turn contain pointers to
** open cursors.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>closeAllCursors</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pFrame</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pFrame</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name></expr>;</init> <condition><expr><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</condition> <incr><expr><name>pFrame</name><operator>=</operator><name><name>pFrame</name><operator>-&gt;</operator><name>pParent</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>sqlite3VdbeFrameRestore</name><argument_list>(<argument><expr><name>pFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFrame</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrame</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nFrame</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>closeCursorsInFrame</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pDelFrame</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>VdbeFrame</name> <modifier>*</modifier></type><name>pDel</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pDelFrame</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDelFrame</name></name> <operator>=</operator> <name><name>pDel</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeFrameDelete</name><argument_list>(<argument><expr><name>pDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Delete any auxdata allocations made by the VM */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pAuxData</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeDeleteAuxData</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pAuxData</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pAuxData</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the number of result columns that will be returned by this SQL
** statement. This is now set at compile time, rather than during
** execution of the vdbe program so that sqlite3_column_count() can
** be called on an SQL statement before sqlite3_step().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetNumCols</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nResColumn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name><operator>*</operator><name>COLNAME_N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name>nResColumn</name><operator>*</operator><name>COLNAME_N</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nResColumn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name> <operator>=</operator> <operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>initMemArray</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the name of the idx'th column to be returned by the SQL statement.
** zName must be a pointer to a nul terminated string.
**
** This call must be made after a call to sqlite3VdbeSetNumCols().
**
** The final parameter, xDel, must be one of SQLITE_DYNAMIC, SQLITE_STATIC
** or SQLITE_TRANSIENT. If it is SQLITE_DYNAMIC, then the buffer pointed
** to by zName will be freed by sqlite3DbFree() when the vdbe is destroyed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeSetColName</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                         <comment type="block">/* Vdbe being configured */</comment>
  <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,                         <comment type="block">/* Index of column zName applies to */</comment>
  <parameter><decl><type><name>int</name></type> <name>var</name></decl></parameter>,                         <comment type="block">/* One of the COLNAME_* constants */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,               <comment type="block">/* Pointer to buffer containing name */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>              <comment type="block">/* Memory management strategy for zName */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pColName</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>var</name><operator>&lt;</operator><name>COLNAME_N</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>zName</name> <operator>||</operator> <name>xDel</name><operator>!=</operator><name>SQLITE_DYNAMIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pColName</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>aColName</name><index>[<expr><name>idx</name><operator>+</operator><name>var</name><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pColName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>zName</name> <operator>||</operator> <operator>(</operator><name><name>pColName</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Term</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A read or write transaction may or may not be active on database handle
** db. If a transaction is active, commit it. If there is a
** write-transaction spanning more than one database file, this routine
** takes care of the super-journal trickery.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeCommit</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTrans</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Number of databases with an active write-transaction
                   ** that are candidates for a two-phase commit using a
                   ** super-journal */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>needXcommit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifdef>
  <comment type="block">/* With this option, sqlite3VtabSync() is defined to be simply 
  ** SQLITE_OK so p is not used. 
  */</comment>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Before doing anything else, call the xSync() callback for any
  ** virtual module tables written in this transaction. This has to
  ** be done before determining whether a super-journal file is 
  ** required, as an xSync() callback may add an attached database
  ** to the transaction.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabSync</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This loop determines (a) if the commit hook should be invoked and
  ** (b) how many database files have open write transactions, not 
  ** including the temp database. (b) is important because if more than 
  ** one database file has an open write transaction, a super-journal
  ** file is required for an atomic commit.
  */</comment> 
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> 
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeTxnState</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_TXN_WRITE</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Whether or not a database might need a super-journal depends upon
      ** its journal mode (among other things).  This matrix determines which
      ** journal modes use a super-journal and which do not */</comment>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aMJNeeded</name><index>[]</index></name> <init>= <expr><block>{
        <comment type="block">/* DELETE   */</comment>  <expr><literal type="number">1</literal></expr>,
        <comment type="block">/* PERSIST   */</comment> <expr><literal type="number">1</literal></expr>,
        <comment type="block">/* OFF       */</comment> <expr><literal type="number">0</literal></expr>,
        <comment type="block">/* TRUNCATE  */</comment> <expr><literal type="number">1</literal></expr>,
        <comment type="block">/* MEMORY    */</comment> <expr><literal type="number">0</literal></expr>,
        <comment type="block">/* WAL       */</comment> <expr><literal type="number">0</literal></expr>
      }</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Pager</name> <modifier>*</modifier></type><name>pPager</name></decl>;</decl_stmt>   <comment type="block">/* Pager associated with pBt */</comment>
      <expr_stmt><expr><name>needXcommit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name> <operator>=</operator> <call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>safety_level</name><operator>!=</operator><name>PAGER_SYNCHRONOUS_OFF</name>
       <operator>&amp;&amp;</operator> <name><name>aMJNeeded</name><index>[<expr><call><name>sqlite3PagerGetJournalMode</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>]</index></name>
       <operator>&amp;&amp;</operator> <call><name>sqlite3PagerIsMemdb</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content> 
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>!=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nTrans</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3PagerExclusiveLock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If there are any write-transactions at all, invoke the commit hook */</comment>
  <if_stmt><if>if<condition>( <expr><name>needXcommit</name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>xCommitCallback</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>db</name><operator>-&gt;</operator><name>xCommitCallback</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pCommitArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_CONSTRAINT_COMMITHOOK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The simple case - no more than one database file (not counting the
  ** TEMP database) has a transaction active.   There is no need for the
  ** super-journal.
  **
  ** If the return value of sqlite3BtreeGetFilename() is a zero length
  ** string, it means the main database is :memory: or a temp file.  In 
  ** that case we do not support atomic multi-file commits, so use the 
  ** simple case then too.
  */</comment>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><call><name>sqlite3BtreeGetFilename</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
   <operator>||</operator> <name>nTrans</name><operator>&lt;=</operator><literal type="number">1</literal></expr>
  )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCommitPhaseOne</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Do the commit only if all databases successfully complete phase 1. 
    ** If one of the BtreeCommitPhaseOne() calls fails, this indicates an
    ** IO error while deleting or truncating a journal file. It is unlikely,
    ** but could happen. In this case abandon processing and return the error.
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCommitPhaseTwo</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VtabCommit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>

  <comment type="block">/* The complex case - There is a multi-file write-transaction active.
  ** This requires a super-journal file to ensure the transaction is
  ** committed atomically.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DISKIO</name></cpp:ifndef>
  <else>else<block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSuper</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* File-name for the super-journal */</comment>
    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zMainFile</name> <init>= <expr><call><name>sqlite3BtreeGetFilename</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pSuperJrnl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retryCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nMainFile</name></decl>;</decl_stmt>

    <comment type="block">/* Select a super-journal file name */</comment>
    <expr_stmt><expr><name>nMainFile</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zMainFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSuper</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%.4c%s%.16c"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zMainFile</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zSuper</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zSuper</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iRandom</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>retryCount</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>retryCount</name><operator>&gt;</operator><literal type="number">100</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_FULL</name></expr></argument>, <argument><expr><literal type="string">"MJ delete: %s"</literal></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>retryCount</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_FULL</name></expr></argument>, <argument><expr><literal type="string">"MJ collide: %s"</literal></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>retryCount</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>iRandom</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRandom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">13</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zSuper</name><index>[<expr><name>nMainFile</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-mj%06X9%02X"</literal></expr></argument>,
                               <argument><expr><operator>(</operator><name>iRandom</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xffffff</literal></expr></argument>, <argument><expr><name>iRandom</name><operator>&amp;</operator><literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* The antipenultimate character of the super-journal name must
      ** be "9" to avoid name collisions when using 8+3 filenames. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zSuper</name><index>[<expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zSuper</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="char">'9'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3FileSuffix3</name><argument_list>(<argument><expr><name>zMainFile</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsAccess</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>res</name></expr> )</condition>;</do>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Open the super-journal. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsOpenMalloc</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSuperJrnl</name></expr></argument>, 
          <argument><expr><name>SQLITE_OPEN_READWRITE</name><operator>|</operator><name>SQLITE_OPEN_CREATE</name><operator>|</operator>
          <name>SQLITE_OPEN_EXCLUSIVE</name><operator>|</operator><name>SQLITE_OPEN_SUPER_JOURNAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSuper</name><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
 
    <comment type="block">/* Write the name of each database file in the transaction into the new
    ** super-journal file. If an error occurs at this point close
    ** and delete the super-journal file. All the individual journal files
    ** still have 'null' as the super-journal pointer, so they will roll
    ** back independently if a failure occurs.
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeTxnState</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_TXN_WRITE</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zFile</name> <init>= <expr><call><name>sqlite3BtreeGetJournalname</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>zFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <continue>continue;</continue>  <comment type="block">/* Ignore TEMP and :memory: databases */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pSuperJrnl</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3OsCloseFree</name><argument_list>(<argument><expr><name>pSuperJrnl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSuper</name><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Sync the super-journal file. If the IOCAP_SEQUENTIAL device
    ** flag is set this is not required.
    */</comment>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name>pSuperJrnl</name></expr></argument>)</argument_list></call><operator>&amp;</operator><name>SQLITE_IOCAP_SEQUENTIAL</name><operator>)</operator>
     <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name>pSuperJrnl</name></expr></argument>, <argument><expr><name>SQLITE_SYNC_NORMAL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OsCloseFree</name><argument_list>(<argument><expr><name>pSuperJrnl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSuper</name><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Sync all the db files involved in the transaction. The same call
    ** sets the super-journal pointer in each individual journal. If
    ** an error occurs here, do not delete the super-journal file.
    **
    ** If the error occurs during the first call to
    ** sqlite3BtreeCommitPhaseOne(), then there is a chance that the
    ** super-journal file will be orphaned. But we cannot delete it,
    ** in case the super-journal file name was written into the journal
    ** file before the failure occurred.
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> 
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCommitPhaseOne</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3OsCloseFree</name><argument_list>(<argument><expr><name>pSuperJrnl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_BUSY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSuper</name><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Delete the super-journal file. This commits the transaction. After
    ** doing this the directory is synced again before any individual
    ** transaction files are deleted.
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zSuper</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSuper</name><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSuper</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* All files and directories have already been synced, so the following
    ** calls to sqlite3BtreeCommitPhaseTwo() are only closing files and
    ** deleting or truncating journals. If something goes wrong while
    ** this is happening we don't really care. The integrity of the
    ** transaction is already guaranteed, but some stray 'cold' journals
    ** may be lying around. Returning an error code won't help matters.
    */</comment>
    <expr_stmt><expr><call><name>disable_simulated_io_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> 
      <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3BtreeCommitPhaseTwo</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>enable_simulated_io_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3VtabCommit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** This routine checks that the sqlite3.nVdbeActive count variable
** matches the number of vdbe's in the list sqlite3.pVdbe that are
** currently active. An assertion fails if the two counts do not match.
** This is an internal self-check only - it is not an essential processing
** step.
**
** This is a no-op if NDEBUG is defined.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checkActiveVdbeCnt</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stmt_busy</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_stmt</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nWrite</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nRead</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cnt</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nWrite</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRead</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>checkActiveVdbeCnt</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** If the Vdbe passed as the first argument opened a statement-transaction,
** close it now. Argument eOp must be either SAVEPOINT_ROLLBACK or
** SAVEPOINT_RELEASE. If it is SAVEPOINT_ROLLBACK, then the statement
** transaction is rolled back. If eOp is SAVEPOINT_RELEASE, then the 
** statement transaction is committed.
**
** If an IO error occurs, an SQLITE_IOERR_XXX error code is returned. 
** Otherwise SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>int</name></type> <name>vdbeCloseStatement</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier><specifier>const</specifier></type> <name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>iSavepoint</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOp</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name> <operator>||</operator> <name>eOp</name><operator>==</operator><name>SAVEPOINT_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name><operator>==</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>+</operator><name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> 
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>eOp</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3BtreeSavepoint</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>SAVEPOINT_ROLLBACK</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3BtreeSavepoint</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>SAVEPOINT_RELEASE</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>eOp</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabSavepoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SAVEPOINT_ROLLBACK</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabSavepoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SAVEPOINT_RELEASE</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the statement transaction is being rolled back, also restore the 
  ** database handles deferred constraint counter to the value it had when 
  ** the statement transaction was opened.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>eOp</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nStmtDefCons</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nStmtDefImmCons</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeCloseStatement</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>nStatement</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iStatement</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>vdbeCloseStatement</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>eOp</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is called when a transaction opened by the database 
** handle associated with the VM passed as an argument is about to be 
** committed. If there are outstanding deferred foreign key constraint
** violations, return SQLITE_ERROR. Otherwise, SQLITE_OK.
**
** If there are outstanding FK violations and this function returns 
** SQLITE_ERROR, set the result of the VM to SQLITE_CONSTRAINT_FOREIGNKEY
** and write an error message to it. Then return SQLITE_ERROR.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3VdbeCheckFk</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deferred</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>deferred</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name><operator>+</operator><name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator> 
   <operator>||</operator> <operator>(</operator><operator>!</operator><name>deferred</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nFkConstraint</name></name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr> 
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_CONSTRAINT_FOREIGNKEY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name> <operator>=</operator> <name>OE_Abort</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN KEY constraint failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prepFlags</name></name> <operator>&amp;</operator> <name>SQLITE_PREPARE_SAVESQL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>SQLITE_CONSTRAINT_FOREIGNKEY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine is called the when a VDBE tries to halt.  If the VDBE
** has made changes and is in autocommit mode, then commit those
** changes.  If a rollback is needed, then do the rollback.
**
** This routine is the only way to move the sqlite3eOpenState of a VM from
** SQLITE_STATE_RUN to SQLITE_STATE_HALT.  It is harmless to
** call this on a VM that is in the SQLITE_STATE_HALT state.
**
** Return an error code.  If the commit could not complete because of
** lock contention, return SQLITE_BUSY.  If SQLITE_BUSY is returned, it
** means the close did not happen and needs to be repeated.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeHalt</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Used to store transient return codes */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* This function contains the logic that determines if a statement or
  ** transaction will be committed or rolled back as a result of the
  ** execution of this virtual machine. 
  **
  ** If any of the following errors occur:
  **
  **     SQLITE_NOMEM
  **     SQLITE_IOERR
  **     SQLITE_FULL
  **     SQLITE_INTERRUPT
  **
  ** Then the internal cache might have been left in an inconsistent
  ** state.  We need to rollback the statement transaction, if there is
  ** one, or the complete transaction if there is no statement transaction.
  */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_RUN_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>closeAllCursors</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checkActiveVdbeCnt</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* No commit or rollback needed if the program never started or if the
  ** SQL statement does not read or write a database file.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>mrc</name></decl>;</decl_stmt>   <comment type="block">/* Primary error code from p-&gt;rc */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>eStatementOp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>isSpecialError</name></decl>;</decl_stmt>            <comment type="block">/* Set to true if a 'special' error */</comment>

    <comment type="block">/* Lock all btrees used by the statement */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check for one of the special errors */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>mrc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>isSpecialError</name> <operator>=</operator> <name>mrc</name><operator>==</operator><name>SQLITE_NOMEM</name>
                    <operator>||</operator> <name>mrc</name><operator>==</operator><name>SQLITE_IOERR</name>
                    <operator>||</operator> <name>mrc</name><operator>==</operator><name>SQLITE_INTERRUPT</name>
                    <operator>||</operator> <name>mrc</name><operator>==</operator><name>SQLITE_FULL</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>mrc</name> <operator>=</operator> <name>isSpecialError</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>isSpecialError</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If the query was read-only and the error code is SQLITE_INTERRUPT, 
      ** no rollback is necessary. Otherwise, at least a savepoint 
      ** transaction must be rolled back to restore the database to a 
      ** consistent state.
      **
      ** Even if the statement is read-only, it is important to perform
      ** a statement or transaction rollback operation. If the error 
      ** occurred while writing to the journal, sub-journal or database
      ** file as part of an effort to free up cache space (see function
      ** pagerStress() in pager.c), the rollback is required to restore 
      ** the pager to a consistent state.
      */</comment>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>||</operator> <name>mrc</name><operator>!=</operator><name>SQLITE_INTERRUPT</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>mrc</name><operator>==</operator><name>SQLITE_NOMEM</name> <operator>||</operator> <name>mrc</name><operator>==</operator><name>SQLITE_FULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>usesStmtJournal</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>eStatementOp</name> <operator>=</operator> <name>SAVEPOINT_ROLLBACK</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* We are forced to roll back the active transaction. Before doing
          ** so, abort any other statements this handle currently has active.
          */</comment>
          <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_ABORT_ROLLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3CloseSavepoints</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check for immediate foreign key violations. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name><operator>==</operator><name>OE_Fail</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isSpecialError</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeCheckFk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* If the auto-commit flag is set and this is the only active writer 
    ** VM, then we do either a commit or rollback of the current transaction. 
    **
    ** Note: This block also runs if one of the special errors handled 
    ** above has occurred. 
    */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3VtabInSync</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> 
     <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> 
     <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>==</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> 
    )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name><operator>==</operator><name>OE_Fail</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isSpecialError</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCheckFk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3VdbeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT_FOREIGNKEY</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_CorruptRdOnly</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SQLITE_CorruptRdOnly</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content> 
          <comment type="block">/* The auto-commit flag is true, the vdbe program was successful 
          ** or hit an 'OR FAIL' constraint and there are no deferred foreign
          ** key constraints to hold up the transaction. This means a commit 
          ** is required. */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeCommit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3VdbeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>u64</name><operator>)</operator><name>SQLITE_DeferFKs</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3CommitInternalChanges</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eStatementOp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name><operator>==</operator><name>OE_Fail</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>eStatementOp</name> <operator>=</operator> <name>SAVEPOINT_RELEASE</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errorAction</name></name><operator>==</operator><name>OE_Abort</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>eStatementOp</name> <operator>=</operator> <name>SAVEPOINT_ROLLBACK</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_ABORT_ROLLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3CloseSavepoints</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* If eStatementOp is non-zero, then a statement transaction needs to
    ** be committed or rolled back. Call sqlite3VdbeCloseStatement() to
    ** do so. If this operation returns an error, and the current statement
    ** error code is SQLITE_OK or SQLITE_CONSTRAINT, then promote the
    ** current statement error code.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>eStatementOp</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeCloseStatement</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>eStatementOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_CONSTRAINT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_ABORT_ROLLBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3CloseSavepoints</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  
    <comment type="block">/* If this was an INSERT, UPDATE or DELETE and no statement transaction
    ** has been rolled back, update the database connection change-counter. 
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>changeCntOn</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>eStatementOp</name><operator>!=</operator><name>SAVEPOINT_ROLLBACK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeSetChanges</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeSetChanges</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Release the locks */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* We have successfully halted and closed the VM.  Record this fact. */</comment>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>&gt;=</operator><name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name><operator>&gt;=</operator><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name> <operator>=</operator> <name>VDBE_HALT_STATE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checkActiveVdbeCnt</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the auto-commit flag is set to true, then any locks that were held
  ** by connection db have now been released. Call sqlite3ConnectionUnlocked() 
  ** to invoke any required unlock-notify callbacks.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ConnectionUnlocked</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_BUSY</name></expr> ?</condition><then> <expr><name>SQLITE_BUSY</name></expr> </then><else>: <expr><name>SQLITE_OK</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Each VDBE holds the result of the most recent sqlite3_step() call
** in p-&gt;rc.  This routine sets that result back to SQLITE_OK.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeResetStepResult</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Copy the error code and error message belonging to the VDBE passed
** as the first argument to its database handle (so that they will be 
** returned by calls to sqlite3_errcode() and sqlite3_errmsg()).
**
** This function does not clear the VDBE error code or message, just
** copies them to the database handle.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeTransferError</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>bBenignMalloc</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name> <operator>=</operator> <call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>bBenignMalloc</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ValueSetNull</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errByteOffset</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SQLLOG</name></cpp:ifdef>
<comment type="block">/*
** If an SQLITE_CONFIG_SQLLOG hook is registered and the VM has been run, 
** invoke it.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeInvokeSqllog</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xSqllog</name></name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>-&gt;</operator><name>zSql</name></name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>-&gt;</operator><name>pc</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zExpanded</name> <init>= <expr><call><name>sqlite3VdbeExpandSql</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zExpanded</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xSqllog</name></name><argument_list>(
          <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pSqllogArg</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zExpanded</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zExpanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>vdbeInvokeSqllog</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Clean up a VDBE after execution but do not delete the VDBE just yet.
** Write any error messages into *pzErrMsg.  Return the result code.
**
** After this routine is run, the VDBE should be ready to be executed
** again.
**
** To look at it another way, this routine resets the state of the
** virtual machine from VDBE_RUN_STATE or VDBE_HALT_STATE back to
** VDBE_READY_STATE.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeReset</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>VDBE_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>

  <comment type="block">/* If the VM did not run to completion or if it encountered an
  ** error, then it might not have been halted properly.  So halt
  ** it now.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>==</operator><name>VDBE_RUN_STATE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* If the VDBE has been run even partially, then transfer the error code
  ** and error message from the VDBE into the main database structure.  But
  ** if the VDBE has just been set to run but has not actually executed any
  ** instructions yet, leave the main database error information unchanged.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>vdbeInvokeSqllog</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeTransferError</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Reset register contents and reclaim error message memory.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* Execute assert() statements to ensure that the Vdbe.apCsr[] and 
  ** Vdbe.aMem[] arrays have already been cleaned up.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name></name></expr> )</condition><block type="pseudo"><block_content> <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name><operator>==</operator><name>MEM_Undefined</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pResultSet</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nWrite</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Save profiling information from this VDBE run.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"vdbe_profile.out"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>out</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"---- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>pc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"-- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>zSql</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>pc</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"-- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>pc</name><operator>!=</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>zHdr</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zHdr</name></expr></argument>, <argument><expr><literal type="string">"%6u %12llu %8llu "</literal></expr></argument>,
           <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cnt</name></expr></argument>,
           <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cycles</name></expr></argument>,
           <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cnt</name><operator>&gt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cycles</name><operator>/</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cnt</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>errMask</name></name></expr>;</return>
</block_content>}</block></function>
 
<comment type="block">/*
** Clean up and delete a VDBE after execution.  Return an integer which is
** the result code.  Write any error message text into *pzErrMsg.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeFinalize</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>VDBE_RUN_STATE</name><operator>&gt;</operator><name>VDBE_READY_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>VDBE_HALT_STATE</name><operator>&gt;</operator><name>VDBE_READY_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>VDBE_INIT_STATE</name><operator>&lt;</operator><name>VDBE_READY_STATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>&gt;=</operator><name>VDBE_READY_STATE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name> <operator>&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>errMask</name></name><operator>)</operator><operator>==</operator><name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeDelete</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If parameter iOp is less than zero, then invoke the destructor for
** all auxiliary data pointers currently cached by the VM passed as
** the first argument.
**
** Or, if iOp is greater than or equal to zero, then the destructor is
** only invoked for those auxiliary data pointers created by the user 
** function invoked by the OP_Function opcode at instruction iOp of 
** VM pVdbe, and only then if:
**
**    * the associated function parameter is the 32nd or later (counting
**      from left to right), or
**
**    * the corresponding bit in argument mask is clear (where the first
**      function parameter corresponds to bit 0 etc.).
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeDeleteAuxData</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>AuxData</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iOp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><operator>*</operator><name>pp</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>AuxData</name> <modifier>*</modifier></type><name>pAux</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iOp</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>pAux</name><operator>-&gt;</operator><name>iAuxOp</name></name><operator>==</operator><name>iOp</name>
          <operator>&amp;&amp;</operator> <name><name>pAux</name><operator>-&gt;</operator><name>iAuxArg</name></name><operator>&gt;=</operator><literal type="number">0</literal>
          <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pAux</name><operator>-&gt;</operator><name>iAuxArg</name></name><operator>&gt;</operator><literal type="number">31</literal> <operator>||</operator> <operator>!</operator><operator>(</operator><name>mask</name> <operator>&amp;</operator> <call><name>MASKBIT32</name><argument_list>(<argument><expr><name><name>pAux</name><operator>-&gt;</operator><name>iAuxArg</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pAux</name><operator>-&gt;</operator><name>iAuxArg</name></name><operator>==</operator><literal type="number">31</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pAux</name><operator>-&gt;</operator><name>xDeleteAux</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name><name>pAux</name><operator>-&gt;</operator><name>xDeleteAux</name></name><argument_list>(<argument><expr><name><name>pAux</name><operator>-&gt;</operator><name>pAux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pAux</name><operator>-&gt;</operator><name>pNextAux</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pp</name><operator>=</operator> <operator>&amp;</operator><name><name>pAux</name><operator>-&gt;</operator><name>pNextAux</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Free all memory associated with the Vdbe passed as the second argument,
** except for object itself, which is preserved.
**
** The difference between this function and sqlite3VdbeDelete() is that
** VdbeDelete() also unlinks the Vdbe from the list of VMs associated with
** the database connection and frees the object itself.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3VdbeClearObject</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SubProgram</name> <modifier>*</modifier></type><name>pSub</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nResColumn</name></name><operator>*</operator><name>COLNAME_N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aColName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>pSub</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pProgram</name></name></expr>;</init> <condition><expr><name>pSub</name></expr>;</condition> <incr><expr><name>pSub</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pSub</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vdbeFreeOpArray</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pSub</name><operator>-&gt;</operator><name>aOp</name></name></expr></argument>, <argument><expr><name><name>pSub</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eVdbeState</name></name><operator>!=</operator><name>VDBE_INIT_STATE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aVar</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nVar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pVList</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pFree</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>vdbeFreeOpArray</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_NORMALIZE</name></cpp:ifdef>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zNormSql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <block>{<block_content>
    <decl_stmt><decl><type><name>DblquoteStr</name> <modifier>*</modifier></type><name>pThis</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pThis</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pDblStr</name></name></expr>;</init> <condition><expr><name>pThis</name></expr>;</condition> <incr><expr><name>pThis</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pThis</name><operator>-&gt;</operator><name>pNextStr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pThis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nScan</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aScan</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aScan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Delete an entire VDBE.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeDelete</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeClearObject</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pPrev</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrev</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>==</operator><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The cursor "p" has a pending seek operation that has not yet been
** carried out.  Seek the cursor now.  If an error occurs, return
** the appropriate error code.
*/</comment>
<function><type><name>int</name> <name>SQLITE_NOINLINE</name></type> <name>sqlite3VdbeFinishMoveto</name><parameter_list>(<parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>sqlite3_search_count</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>deferredMoveto</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>isTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeTableMoveto</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>movetoTarget</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <expr_stmt><expr><name>sqlite3_search_count</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>deferredMoveto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Something has moved cursor "p" out of place.  Maybe the row it was
** pointed to was deleted out from under it.  Or maybe the btree was
** rebalanced.  Whatever the cause, try to restore "p" to the place it
** is supposed to be pointing.  If the row was deleted out from under the
** cursor, set the cursor to point to a NULL row.
*/</comment>
<function><type><name>int</name> <name>SQLITE_NOINLINE</name></type> <name>sqlite3VdbeHandleMovedCursor</name><parameter_list>(<parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>isDifferentRow</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorHasMoved</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3BtreeCursorRestore</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isDifferentRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cacheStatus</name></name> <operator>=</operator> <name>CACHE_STALE</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>isDifferentRow</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nullRow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to ensure that the cursor is valid.  Restore the cursor
** if need be.  Return any I/O error from the restore operation.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeCursorRestore</name><parameter_list>(<parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name> <operator>||</operator> <call><name>IsNullCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3BtreeCursorHasMoved</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3VdbeHandleMovedCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following functions:
**
** sqlite3VdbeSerialType()
** sqlite3VdbeSerialTypeLen()
** sqlite3VdbeSerialLen()
** sqlite3VdbeSerialPut()  &lt;--- in-lined into OP_MakeRecord as of 2022-04-02
** sqlite3VdbeSerialGet()
**
** encapsulate the code that serializes values for storage in SQLite
** data and index records. Each serialized value consists of a
** 'serial-type' and a blob of data. The serial type is an 8-byte unsigned
** integer, stored as a varint.
**
** In an SQLite index record, the serial type is stored directly before
** the blob of data that it corresponds to. In a table record, all serial
** types are stored at the start of the record, and the blobs of data at
** the end. Hence these functions allow the caller to handle the
** serial-type and data blob separately.
**
** The following table describes the various storage classes for data:
**
**   serial type        bytes of data      type
**   --------------     ---------------    ---------------
**      0                     0            NULL
**      1                     1            signed integer
**      2                     2            signed integer
**      3                     3            signed integer
**      4                     4            signed integer
**      5                     6            signed integer
**      6                     8            signed integer
**      7                     8            IEEE float
**      8                     0            Integer constant 0
**      9                     0            Integer constant 1
**     10,11                               reserved for expansion
**    N&gt;=12 and even       (N-12)/2        BLOB
**    N&gt;=13 and odd        (N-13)/2        text
**
** The 8 and 9 types were added in 3.3.0, file format 4.  Prior versions
** of SQLite will not understand those serial types.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* Inlined into the OP_MakeRecord opcode */</comment>
<comment type="block">/*
** Return the serial-type for the value stored in pMem.
**
** This routine might convert a large MEM_IntReal value into MEM_Real.
**
** 2019-07-11:  The primary user of this subroutine was the OP_MakeRecord
** opcode in the byte-code engine.  But by moving this routine in-line, we
** can omit some redundant tests and make that opcode a lot faster.  So
** this routine is now only used by the STAT3 logic and STAT3 support has
** ended.  The code is kept here for historical reference only.
*/</comment>
u32 sqlite3VdbeSerialType(Mem *pMem, int file_format, u32 *pLen){
  int flags = pMem-&gt;flags;
  u32 n;

  assert( pLen!=0 );
  if( flags&amp;MEM_Null ){
    *pLen = 0;
    return 0;
  }
  if( flags&amp;(MEM_Int|MEM_IntReal) ){
    <comment type="block">/* Figure out whether to use 1, 2, 4, 6 or 8 bytes. */</comment>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_6BYTE</name></cpp:macro> <cpp:value>((((i64)0x00008000)&lt;&lt;32)-1)</cpp:value></cpp:define>
    i64 i = pMem-&gt;u.i;
    u64 u;
    testcase( flags &amp; MEM_Int );
    testcase( flags &amp; MEM_IntReal );
    if( i&lt;0 ){
      u = ~i;
    }else{
      u = i;
    }
    if( u&lt;=127 ){
      if( (i&amp;1)==i &amp;&amp; file_format&gt;=4 ){
        *pLen = 0;
        return 8+(u32)u;
      }else{
        *pLen = 1;
        return 1;
      }
    }
    if( u&lt;=32767 ){ *pLen = 2; return 2; }
    if( u&lt;=8388607 ){ *pLen = 3; return 3; }
    if( u&lt;=2147483647 ){ *pLen = 4; return 4; }
    if( u&lt;=MAX_6BYTE ){ *pLen = 6; return 5; }
    *pLen = 8;
    if( flags&amp;MEM_IntReal ){
      <comment type="block">/* If the value is IntReal and is going to take up 8 bytes to store
      ** as an integer, then we might as well make it an 8-byte floating
      ** point value */</comment>
      pMem-&gt;u.r = (double)pMem-&gt;u.i;
      pMem-&gt;flags &amp;= ~MEM_IntReal;
      pMem-&gt;flags |= MEM_Real;
      return 7;
    }
    return 6;
  }
  if( flags&amp;MEM_Real ){
    *pLen = 8;
    return 7;
  }
  assert( pMem-&gt;db-&gt;mallocFailed || flags&amp;(MEM_Str|MEM_Blob) );
  assert( pMem-&gt;n&gt;=0 );
  n = (u32)pMem-&gt;n;
  if( flags &amp; MEM_Zero ){
    n += pMem-&gt;u.nZero;
  }
  *pLen = n;
  return ((n*2) + 12 + ((flags&amp;MEM_Str)!=0));
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* inlined into OP_MakeRecord */</comment>

<comment type="block">/*
** The sizes for serial types less than 128
*/</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>u8</name></type> <name><name>sqlite3SmallTypeSizes</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{
        <comment type="block">/*  0   1   2   3   4   5   6   7   8   9 */</comment>   
<comment type="block">/*   0 */</comment>   <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,
<comment type="block">/*  10 */</comment>   <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">3</literal></expr>,
<comment type="block">/*  20 */</comment>   <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">8</literal></expr>,
<comment type="block">/*  30 */</comment>   <expr><literal type="number">9</literal></expr>,  <expr><literal type="number">9</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>,
<comment type="block">/*  40 */</comment>  <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">18</literal></expr>,
<comment type="block">/*  50 */</comment>  <expr><literal type="number">19</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>,
<comment type="block">/*  60 */</comment>  <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">28</literal></expr>,
<comment type="block">/*  70 */</comment>  <expr><literal type="number">29</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">33</literal></expr>, <expr><literal type="number">33</literal></expr>,
<comment type="block">/*  80 */</comment>  <expr><literal type="number">34</literal></expr>, <expr><literal type="number">34</literal></expr>, <expr><literal type="number">35</literal></expr>, <expr><literal type="number">35</literal></expr>, <expr><literal type="number">36</literal></expr>, <expr><literal type="number">36</literal></expr>, <expr><literal type="number">37</literal></expr>, <expr><literal type="number">37</literal></expr>, <expr><literal type="number">38</literal></expr>, <expr><literal type="number">38</literal></expr>,
<comment type="block">/*  90 */</comment>  <expr><literal type="number">39</literal></expr>, <expr><literal type="number">39</literal></expr>, <expr><literal type="number">40</literal></expr>, <expr><literal type="number">40</literal></expr>, <expr><literal type="number">41</literal></expr>, <expr><literal type="number">41</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">43</literal></expr>, <expr><literal type="number">43</literal></expr>,
<comment type="block">/* 100 */</comment>  <expr><literal type="number">44</literal></expr>, <expr><literal type="number">44</literal></expr>, <expr><literal type="number">45</literal></expr>, <expr><literal type="number">45</literal></expr>, <expr><literal type="number">46</literal></expr>, <expr><literal type="number">46</literal></expr>, <expr><literal type="number">47</literal></expr>, <expr><literal type="number">47</literal></expr>, <expr><literal type="number">48</literal></expr>, <expr><literal type="number">48</literal></expr>,
<comment type="block">/* 110 */</comment>  <expr><literal type="number">49</literal></expr>, <expr><literal type="number">49</literal></expr>, <expr><literal type="number">50</literal></expr>, <expr><literal type="number">50</literal></expr>, <expr><literal type="number">51</literal></expr>, <expr><literal type="number">51</literal></expr>, <expr><literal type="number">52</literal></expr>, <expr><literal type="number">52</literal></expr>, <expr><literal type="number">53</literal></expr>, <expr><literal type="number">53</literal></expr>,
<comment type="block">/* 120 */</comment>  <expr><literal type="number">54</literal></expr>, <expr><literal type="number">54</literal></expr>, <expr><literal type="number">55</literal></expr>, <expr><literal type="number">55</literal></expr>, <expr><literal type="number">56</literal></expr>, <expr><literal type="number">56</literal></expr>, <expr><literal type="number">57</literal></expr>, <expr><literal type="number">57</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Return the length of the data corresponding to the supplied serial-type.
*/</comment>
<function><type><name>u32</name></type> <name>sqlite3VdbeSerialTypeLen</name><parameter_list>(<parameter><decl><type><name>u32</name></type> <name>serial_type</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&gt;=</operator><literal type="number">128</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>serial_type</name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>serial_type</name><operator>&lt;</operator><literal type="number">12</literal> 
            <operator>||</operator> <name><name>sqlite3SmallTypeSizes</name><index>[<expr><name>serial_type</name></expr>]</index></name><operator>==</operator><operator>(</operator><name>serial_type</name> <operator>-</operator> <literal type="number">12</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>sqlite3SmallTypeSizes</name><index>[<expr><name>serial_type</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>u8</name></type> <name>sqlite3VdbeOneByteSerialTypeLen</name><parameter_list>(<parameter><decl><type><name>u8</name></type> <name>serial_type</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>serial_type</name><operator>&lt;</operator><literal type="number">128</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>sqlite3SmallTypeSizes</name><index>[<expr><name>serial_type</name></expr>]</index></name></expr>;</return>  
</block_content>}</block></function>

<comment type="block">/*
** If we are on an architecture with mixed-endian floating 
** points (ex: ARM7) then swap the lower 4 bytes with the 
** upper 4 bytes.  Return the result.
**
** For most architectures, this is a no-op.
**
** (later):  It is reported to me that the mixed-endian problem
** on ARM7 is an issue with GCC, not with the ARM7 chip.  It seems
** that early versions of GCC stored the two words of a 64-bit
** float in the wrong order.  And that error has been propagated
** ever since.  The blame is not necessarily with GCC, though.
** GCC might have just copying the problem from a prior compiler.
** I am also told that newer versions of GCC that follow a different
** ABI get the byte order right.
**
** Developers using SQLite on an ARM7 should compile and run their
** application using -DSQLITE_DEBUG=1 at least once.  With DEBUG
** enabled, some asserts below will ensure that the byte order of
** floating point values is correct.
**
** (2007-08-30)  Frank van Vugt has studied this problem closely
** and has send his findings to the SQLite developers.  Frank
** writes that some Linux kernels offer floating point hardware
** emulation that uses only 32-bit mantissas instead of a full 
** 48-bits as required by the IEEE standard.  (This is the
** CONFIG_FPE_FASTFPE option.)  On such systems, floating point
** byte swapping becomes very complicated.  To avoid problems,
** the necessary byte swapping is carried out using a 64-bit integer
** rather than a 64-bit float.  Frank assures us that the code here
** works for him.  We, the developers, have no way to independently
** verify this, but Frank seems to know what he is talking about
** so we trust him.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_MIXED_ENDIAN_64BIT_FLOAT</name></cpp:ifdef>
<function><type><name>u64</name></type> <name>sqlite3FloatSwap</name><parameter_list>(<parameter><decl><type><name>u64</name></type> <name>in</name></decl></parameter>)</parameter_list><block>{<block_content>
  <union>union <block>{
    <decl_stmt><decl><type><name>u64</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name><name>i</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  }</block> <decl><name>u</name></decl>;</union>
  <decl_stmt><decl><type><name>u32</name></type> <name>t</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>u</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>u</name><operator>.</operator><name>i</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>u</name><operator>.</operator><name>i</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>u</name><operator>.</operator><name>i</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>u</name><operator>.</operator><name>i</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
  <return>return <expr><name><name>u</name><operator>.</operator><name>r</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_MIXED_ENDIAN_64BIT_FLOAT */</comment>


<comment type="block">/* Input "x" is a sequence of unsigned characters that represent a
** big-endian integer.  Return the equivalent native integer
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONE_BYTE_INT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>((i8)(x)[0])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TWO_BYTE_INT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(256*(i8)((x)[0])|(x)[1])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THREE_BYTE_INT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(65536*(i8)((x)[0])|((x)[1]&lt;&lt;8)|(x)[2])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOUR_BYTE_UINT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(((u32)(x)[0]&lt;&lt;24)|((x)[1]&lt;&lt;16)|((x)[2]&lt;&lt;8)|(x)[3])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOUR_BYTE_INT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(16777216*(i8)((x)[0])|((x)[1]&lt;&lt;16)|((x)[2]&lt;&lt;8)|(x)[3])</cpp:value></cpp:define>

<comment type="block">/*
** Deserialize the data blob pointed to by buf as serial type serial_type
** and store the result in pMem.
**
** This function is implemented as two separate routines for performance.
** The few cases that require local variables are broken out into a separate
** routine so that in most cases the overhead of moving the stack pointer
** is avoided.
*/</comment> 
<function><type><specifier>static</specifier> <name>void</name></type> <name>serialGet</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,     <comment type="block">/* Buffer to deserialize from */</comment>
  <parameter><decl><type><name>u32</name></type> <name>serial_type</name></decl></parameter>,              <comment type="block">/* Serial type to deserialize */</comment>
  <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>                     <comment type="block">/* Memory cell to write value into */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>x</name> <init>= <expr><call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>y</name> <init>= <expr><call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator> <operator>+</operator> <name>y</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>==</operator><literal type="number">6</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* EVIDENCE-OF: R-29851-52272 Value is a big-endian 64-bit
    ** twos-complement integer. */</comment>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>i64</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>x</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* EVIDENCE-OF: R-57343-49114 Value is a big-endian IEEE 754-2008 64-bit
    ** floating point number. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_FLOATING_POINT</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Verify that integers and floating point values use the same
    ** byte order.  Or, that if SQLITE_MIXED_ENDIAN_64BIT_FLOAT is
    ** defined that 64-bit floating point values really are mixed
    ** endian.
    */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u64</name></type> <name>t1</name> <init>= <expr><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">0x3ff00000</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name>r1</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u64</name></type> <name>t2</name> <init>= <expr><name>t1</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>swapMixedEndianFloat</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></sizeof><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal> <operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>swapMixedEndianFloat</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <ternary><condition><expr><call><name>IsNaN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>MEM_Null</name></expr> </then><else>: <expr><name>MEM_Real</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeSerialGet</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,     <comment type="block">/* Buffer to deserialize from */</comment>
  <parameter><decl><type><name>u32</name></type> <name>serial_type</name></decl></parameter>,              <comment type="block">/* Serial type to deserialize */</comment>
  <parameter><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name></decl></parameter>                     <comment type="block">/* Memory cell to write value into */</comment>
)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><name>serial_type</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">10</literal></expr>:</case> <block>{<block_content> <comment type="block">/* Internal use only: NULL with virtual table
               ** UPDATE no-change flag set */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name><operator>|</operator><name>MEM_Zero</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">11</literal></expr>:</case>   <comment type="block">/* Reserved for future use */</comment>
    <case>case <expr><literal type="number">0</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* Null */</comment>
      <comment type="block">/* EVIDENCE-OF: R-24078-09375 Value is a NULL. */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">1</literal></expr>:</case> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-44885-25196 Value is an 8-bit twos-complement
      ** integer. */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>ONE_BYTE_INT</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">2</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 2-byte signed integer */</comment>
      <comment type="block">/* EVIDENCE-OF: R-49794-35026 Value is a big-endian 16-bit
      ** twos-complement integer. */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>TWO_BYTE_INT</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">3</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 3-byte signed integer */</comment>
      <comment type="block">/* EVIDENCE-OF: R-37839-54301 Value is a big-endian 24-bit
      ** twos-complement integer. */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>THREE_BYTE_INT</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">4</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 4-byte signed integer */</comment>
      <comment type="block">/* EVIDENCE-OF: R-01849-26079 Value is a big-endian 32-bit
      ** twos-complement integer. */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>FOUR_BYTE_INT</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__HP_cc</name></cpp:ifdef> 
      <comment type="block">/* Work around a sign-extension bug in the HP compiler for HP/UX */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>|=</operator> <literal type="number">0xffffffff80000000LL</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">5</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 6-byte signed integer */</comment>
      <comment type="block">/* EVIDENCE-OF: R-50385-09674 Value is a big-endian 48-bit
      ** twos-complement integer. */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator><operator>*</operator><call><name>TWO_BYTE_INT</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">6</literal></expr>:</case>   <comment type="block">/* 8-byte signed integer */</comment>
    <case>case <expr><literal type="number">7</literal></expr>:</case> <block>{<block_content> <comment type="block">/* IEEE floating point */</comment>
      <comment type="block">/* These use local variables, so do them in a separate routine
      ** to avoid having to move the frame pointer in the common case */</comment>
      <expr_stmt><expr><call><name>serialGet</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>serial_type</name></expr></argument>,<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">8</literal></expr>:</case>    <comment type="block">/* Integer 0 */</comment>
    <case>case <expr><literal type="number">9</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* Integer 1 */</comment>
      <comment type="block">/* EVIDENCE-OF: R-12976-22893 Value is the integer 0. */</comment>
      <comment type="block">/* EVIDENCE-OF: R-18143-12121 Value is the integer 1. */</comment>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>serial_type</name><operator>-</operator><literal type="number">8</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Int</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <comment type="block">/* EVIDENCE-OF: R-14606-31564 Value is a BLOB that is (N-12)/2 bytes in
      ** length.
      ** EVIDENCE-OF: R-28401-00140 Value is a string in the text encoding and
      ** (N-13)/2 bytes in length. */</comment>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u16</name></type> <name><name>aFlag</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>MEM_Blob</name><operator>|</operator><name>MEM_Ephem</name></expr>, <expr><name>MEM_Str</name><operator>|</operator><name>MEM_Ephem</name></expr> }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>serial_type</name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>aFlag</name><index>[<expr><name>serial_type</name><operator>&amp;</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return;</return>
</block_content>}</block></function>
<comment type="block">/*
** This routine is used to allocate sufficient space for an UnpackedRecord
** structure large enough to be used with sqlite3VdbeRecordUnpack() if
** the first argument is a pointer to KeyInfo structure pKeyInfo.
**
** The space is either allocated using sqlite3DbMallocRaw() or from within
** the unaligned buffer passed via the second and third arguments (presumably
** stack space). If the former, then *ppFree is set to a pointer that should
** be eventually freed by the caller using sqlite3DbFree(). Or, if the 
** allocation comes from the pSpace/szSpace buffer, *ppFree is set to NULL
** before returning.
**
** If an OOM error occurs, NULL is returned.
*/</comment>
<function><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>sqlite3VdbeAllocUnpackedRecord</name><parameter_list>(
  <parameter><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl></parameter>               <comment type="block">/* Description of the record */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>              <comment type="block">/* Unpacked record to return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                      <comment type="block">/* Number of bytes required for *p */</comment>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>ROUND8P</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UnpackedRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nKeyField</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>UnpackedRecord</name> <operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name> <operator>=</operator> <operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><call><name>ROUND8P</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UnpackedRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pKeyInfo</name></name> <operator>=</operator> <name>pKeyInfo</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>nKeyField</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given the nKey-byte encoding of a record in pKey[], populate the 
** UnpackedRecord structure indicated by the fourth argument with the
** contents of the decoded record.
*/</comment> 
<function><type><name>void</name></type> <name>sqlite3VdbeRecordUnpack</name><parameter_list>(
  <parameter><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl></parameter>,     <comment type="block">/* Information about the record format */</comment>
  <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,              <comment type="block">/* Size of the binary record */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,      <comment type="block">/* The binary record */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>p</name></decl></parameter>      <comment type="block">/* Populate this structure before returning. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aKey</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>d</name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>u32</name></type> <name>idx</name></decl>;</decl_stmt>                        <comment type="block">/* Offset in aKey[] to read from */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>u</name></decl>;</decl_stmt>                          <comment type="block">/* Unsigned loop counter */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>szHdr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>default_rc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>EIGHT_BYTE_ALIGNMENT</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>, <argument><expr><name>szHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>d</name> <operator>=</operator> <name>szHdr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>idx</name><operator>&lt;</operator><name>szHdr</name> <operator>&amp;&amp;</operator> <name>d</name><operator>&lt;=</operator><operator>(</operator><name>u32</name><operator>)</operator><name>nKey</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>serial_type</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>idx</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>enc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
    <comment type="block">/* pMem-&gt;flags = 0; // sqlite3VdbeSerialGet() will set this for us */</comment>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>szMalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>, <argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> <operator>+=</operator> <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>++</operator><name>u</name><operator>)</operator><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nField</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>d</name><operator>&gt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>nKey</name> <operator>&amp;&amp;</operator> <name>u</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* In a corrupt record entry, the last pMem might have been set up using 
    ** uninitialized memory. Overwrite its value with NULL, to prevent
    ** warnings from MSAN. */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pMem</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>u</name><operator>&lt;=</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nKeyField</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nField</name></name> <operator>=</operator> <name>u</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** This function compares two index or table record keys in the same way
** as the sqlite3VdbeRecordCompare() routine. Unlike VdbeRecordCompare(),
** this function deserializes and compares values using the
** sqlite3VdbeSerialGet() and sqlite3MemCompare() functions. It is used
** in assert() statements to ensure that the optimized code in
** sqlite3VdbeRecordCompare() returns results with these two primitives.
**
** Return true if the result of comparison is equivalent to desiredResult.
** Return false if there is a disagreement.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeRecordCompareDebug</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <comment type="block">/* Left key */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>UnpackedRecord</name> <modifier>*</modifier></type><name>pPKey2</name></decl></parameter>, <comment type="block">/* Right key */</comment>
  <parameter><decl><type><name>int</name></type> <name>desiredResult</name></decl></parameter>             <comment type="block">/* Correct answer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>d1</name></decl>;</decl_stmt>            <comment type="block">/* Offset into aKey[] of next data element */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>idx1</name></decl>;</decl_stmt>          <comment type="block">/* Offset into aKey[] of next header element */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>szHdr1</name></decl>;</decl_stmt>        <comment type="block">/* Number of bytes in header */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aKey1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pKey1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name></type> <name>mem1</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pKeyInfo</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>mem1</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>enc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mem1</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <comment type="block">/* mem1.flags = 0;  // Will be initialized by sqlite3VdbeSerialGet() */</comment>
  <macro><name>VVA_ONLY</name><argument_list>( <argument>mem1.szMalloc = <literal type="number">0</literal>;</argument> )</argument_list></macro> <comment type="block">/* Only needed by assert() statements */</comment>

  <comment type="block">/* Compilers may complain that mem1.u.i is potentially uninitialized.
  ** We could initialize it, as shown here, to silence those complaints.
  ** But in fact, mem1.u.i will never actually be used uninitialized, and doing 
  ** the unnecessary initialization has a measurable negative performance
  ** impact, since this routine is a very high runner.  And so, we choose
  ** to ignore the compiler warnings and leave this variable uninitialized.
  */</comment>
  <comment type="block">/*  mem1.u.i = 0;  // not needed, here to silence compiler warning */</comment>
  
  <expr_stmt><expr><name>idx1</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>aKey1</name></expr></argument>, <argument><expr><name>szHdr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>szHdr1</name><operator>&gt;</operator><literal type="number">98307</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CORRUPT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>d1</name> <operator>=</operator> <name>szHdr1</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nAllField</name></name><operator>&gt;=</operator><name><name>pPKey2</name><operator>-&gt;</operator><name>nField</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nKeyField</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx1</name><operator>&lt;=</operator><name>szHdr1</name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>serial_type1</name></decl>;</decl_stmt>

    <comment type="block">/* Read the serial types for the next element in each key. */</comment>
    <expr_stmt><expr><name>idx1</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>( <argument><expr><name>aKey1</name><operator>+</operator><name>idx1</name></expr></argument>, <argument><expr><name>serial_type1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Verify that there is enough key space remaining to avoid
    ** a buffer overread.  The "d1+serial_type1+2" subexpression will
    ** always be greater than or equal to the amount of required key space.
    ** Use that approximation to avoid the more expensive call to
    ** sqlite3VdbeSerialTypeLen() in the common case.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>d1</name><operator>+</operator><operator>(</operator><name>u64</name><operator>)</operator><name>serial_type1</name><operator>+</operator><literal type="number">2</literal><operator>&gt;</operator><operator>(</operator><name>u64</name><operator>)</operator><name>nKey1</name>
     <operator>&amp;&amp;</operator> <name>d1</name><operator>+</operator><operator>(</operator><name>u64</name><operator>)</operator><call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>serial_type1</name></expr></argument>)</argument_list></call><operator>&gt;</operator><operator>(</operator><name>u64</name><operator>)</operator><name>nKey1</name></expr> 
    )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Extract the values to be compared.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d1</name> <operator>+=</operator> <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>serial_type1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Do the comparison
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mem1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPKey2</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                           <argument><expr><ternary><condition><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>nAllField</name></name><operator>&gt;</operator><name>i</name></expr> ?</condition><then> <expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>mem1</name><operator>.</operator><name>szMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* See comment below */</comment>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_BIGNULL</name><operator>)</operator>
       <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>mem1</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>pPKey2</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator><operator>)</operator></expr> 
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><name>rc</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_DESC</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><name>rc</name></expr>;</expr_stmt>  <comment type="block">/* Invert the result for DESC sort order. */</comment>
      </block_content>}</block></if></if_stmt>
      <goto>goto <name>debugCompareEnd</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>idx1</name><operator>&lt;</operator><name>szHdr1</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pPKey2</name><operator>-&gt;</operator><name>nField</name></name></expr> )</condition>;</do>

  <comment type="block">/* No memory allocation is ever used on mem1.  Prove this using
  ** the following assert().  If the assert() fails, it indicates a
  ** memory leak and a need to call sqlite3VdbeMemRelease(&amp;mem1).
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>mem1</name><operator>.</operator><name>szMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* rc==0 here means that one of the keys ran out of fields and
  ** all the fields up to that point were equal. Return the default_rc
  ** value.  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>default_rc</name></name></expr>;</expr_stmt>

<label><name>debugCompareEnd</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>desiredResult</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>desiredResult</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>desiredResult</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>CORRUPT_DB</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Count the number of fields (a.k.a. columns) in the record given by
** pKey,nKey.  The verify that this count is less than or equal to the
** limit given by pKeyInfo-&gt;nAllField.
**
** If this constraint is not satisfied, it means that the high-speed
** vdbeRecordCompareInt() and vdbeRecordCompareString() routines will
** not work correctly.  If this assert() ever fires, it probably means
** that the KeyInfo.nKeyField or KeyInfo.nAllField values were computed
** incorrectly.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeAssertFieldCountWithinLimits</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>,   <comment type="block">/* The record to verify */</comment> 
  <parameter><decl><type><specifier>const</specifier> <name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl></parameter>       <comment type="block">/* Compare size with this KeyInfo */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>szHdr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>idx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>notUsed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aKey</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>pKey</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>CORRUPT_DB</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>, <argument><expr><name>szHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nKey</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>szHdr</name><operator>&lt;=</operator><operator>(</operator><name>u32</name><operator>)</operator><name>nKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>idx</name><operator>&lt;</operator><name>szHdr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>idx</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>aKey</name><operator>+</operator><name>idx</name></expr></argument>, <argument><expr><name>notUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nField</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nField</name> <operator>&lt;=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>nAllField</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>vdbeAssertFieldCountWithinLimits</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>,<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Both *pMem1 and *pMem2 contain string values. Compare the two values
** using the collation sequence pColl. As usual, return a negative , zero
** or positive value if *pMem1 is less than, equal to or greater than 
** *pMem2, respectively. Similar in spirit to "rc = (*pMem1) - (*pMem2);".
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeCompareMemString</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pMem1</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pMem2</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl></parameter>,
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>prcErr</name></decl></parameter>                      <comment type="block">/* If an OOM occurs, set to SQLITE_NOMEM */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pMem1</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name><name>pColl</name><operator>-&gt;</operator><name>enc</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The strings are already in the correct encoding.  Call the
     ** comparison function directly */</comment>
    <return>return <expr><call><name><name>pColl</name><operator>-&gt;</operator><name>xCmp</name></name><argument_list>(<argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>pUser</name></name></expr></argument>,<argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>n</name></name></expr></argument>,<argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>,<argument><expr><name><name>pMem2</name><operator>-&gt;</operator><name>n</name></name></expr></argument>,<argument><expr><name><name>pMem2</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>v2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Mem</name></type> <name>c1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Mem</name></type> <name>c2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>, <argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>, <argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>, <argument><expr><name>pMem1</name></expr></argument>, <argument><expr><name>MEM_Ephem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>, <argument><expr><name>pMem2</name></expr></argument>, <argument><expr><name>MEM_Ephem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>sqlite3ValueText</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c1</name></expr></argument>, <argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v2</name> <operator>=</operator> <call><name>sqlite3ValueText</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c2</name></expr></argument>, <argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>v1</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>v2</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>prcErr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>prcErr</name> <operator>=</operator> <name>SQLITE_NOMEM_BKPT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pColl</name><operator>-&gt;</operator><name>xCmp</name></name><argument_list>(<argument><expr><name><name>pColl</name><operator>-&gt;</operator><name>pUser</name></name></expr></argument>, <argument><expr><name><name>c1</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name><name>c2</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemReleaseMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemReleaseMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The input pBlob is guaranteed to be a Blob that is not marked
** with MEM_Zero.  Return true if it could be a zero-blob.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isAllZero</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare two blobs.  Return negative, zero, or positive if the first
** is less than, equal to, or greater than the second, respectively.
** If one blob is a prefix of the other, then the shorter is the lessor.
*/</comment>
<function><type><name>SQLITE_NOINLINE</name> <name>int</name></type> <name>sqlite3BlobCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pB1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pB2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n1</name> <init>= <expr><name><name>pB1</name><operator>-&gt;</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n2</name> <init>= <expr><name><name>pB2</name><operator>-&gt;</operator><name>n</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* It is possible to have a Blob value that has some non-zero content
  ** followed by zero content.  But that only comes up for Blobs formed
  ** by the OP_MakeRecord opcode, and such Blobs never get passed into
  ** sqlite3MemCompare(). */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pB1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>n1</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pB2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>n2</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pB1</name><operator>-&gt;</operator><name>flags</name></name><operator>|</operator><name><name>pB2</name><operator>-&gt;</operator><name>flags</name></name><operator>)</operator> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pB1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name><name>pB2</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name><name>pB1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name> <operator>-</operator> <name><name>pB2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</return>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pB1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isAllZero</name><argument_list>(<argument><expr><name><name>pB2</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pB2</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <return>return <expr><name><name>pB1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name> <operator>-</operator> <name>n2</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isAllZero</name><argument_list>(<argument><expr><name><name>pB1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pB1</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <return>return <expr><name>n1</name> <operator>-</operator> <name><name>pB2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>pB1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pB2</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>n1</name><operator>&gt;</operator><name>n2</name></expr> ?</condition><then> <expr><name>n2</name></expr> </then><else>: <expr><name>n1</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>c</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>n1</name> <operator>-</operator> <name>n2</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Do a comparison between a 64-bit signed integer and a 64-bit floating-point
** number.  Return negative, zero, or positive if the first (i64) is less than,
** equal to, or greater than the second (double).
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IntFloatCompare</name><parameter_list>(<parameter><decl><type><name>i64</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>r</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><sizeof>sizeof<argument_list>(<argument><expr><name>LONGDOUBLE_TYPE</name></expr></argument>)</argument_list></sizeof><operator>&gt;</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LONGDOUBLE_TYPE</name></type> <name>x</name> <init>= <expr><operator>(</operator><name>LONGDOUBLE_TYPE</name><operator>)</operator><name>i</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>x</name><operator>&lt;</operator><name>r</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>x</name><operator>&gt;</operator><name>r</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>x</name><operator>==</operator><name>r</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><name>r</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;</operator><name>r</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/*NO_TEST*/</comment> <comment type="block">/* work around bugs in gcov */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>             <comment type="block">/*NO_TEST*/</comment> <comment type="block">/* work around bugs in gcov */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>y</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>r</name><operator>&lt;</operator><operator>-</operator><literal type="number">9223372036854775808.0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>r</name><operator>&gt;=</operator><literal type="number">9223372036854775808.0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>y</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>r</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>y</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><name>y</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>i</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>s</name><operator>&lt;</operator><name>r</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>s</name><operator>&gt;</operator><name>r</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compare the values contained by the two memory cells, returning
** negative, zero or positive if pMem1 is less than, equal to, or greater
** than pMem2. Sorting order is NULL's first, followed by numbers (integers
** and reals) sorted numerically, followed by text ordered by the collating
** sequence pColl and finally blob's ordered by memcmp().
**
** Two NULL values are considered equal by this function.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3MemCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pMem1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>pMem2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>f1</name></decl>, <decl><type ref="prev"/><name>f2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>combined_flags</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>f1</name> <operator>=</operator> <name><name>pMem1</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>f2</name> <operator>=</operator> <name><name>pMem2</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>combined_flags</name> <operator>=</operator> <name>f1</name><operator>|</operator><name>f2</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pMem1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3VdbeMemIsRowSet</name><argument_list>(<argument><expr><name>pMem2</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
 
  <comment type="block">/* If one value is NULL, it is less than the other. If both values
  ** are NULL, return 0.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>combined_flags</name><operator>&amp;</operator><name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>f2</name><operator>&amp;</operator><name>MEM_Null</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>f1</name><operator>&amp;</operator><name>MEM_Null</name><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* At least one of the two values is a number
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>combined_flags</name><operator>&amp;</operator><operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>combined_flags</name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>combined_flags</name> <operator>&amp;</operator> <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>combined_flags</name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f1</name> <operator>&amp;</operator> <name>f2</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>f1</name> <operator>&amp;</operator> <name>f2</name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>f1</name> <operator>&amp;</operator> <name>f2</name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pMem1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>&lt;</operator> <name><name>pMem2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pMem1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>&gt;</operator> <name><name>pMem2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f1</name> <operator>&amp;</operator> <name>f2</name> <operator>&amp;</operator> <name>MEM_Real</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pMem1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>&lt;</operator> <name><name>pMem2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pMem1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name> <operator>&gt;</operator> <name><name>pMem2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f1</name><operator>&amp;</operator><operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>f1</name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>f1</name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f2</name><operator>&amp;</operator><name>MEM_Real</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><call><name>sqlite3IntFloatCompare</name><argument_list>(<argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>pMem2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>f2</name><operator>&amp;</operator><operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pMem1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>&lt;</operator> <name><name>pMem2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pMem1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>&gt;</operator> <name><name>pMem2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f1</name><operator>&amp;</operator><name>MEM_Real</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f2</name><operator>&amp;</operator><operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>f2</name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>f2</name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><call><name>sqlite3IntFloatCompare</name><argument_list>(<argument><expr><name><name>pMem2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If one value is a string and the other is a blob, the string is less.
  ** If both are strings, compare using the collating functions.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>combined_flags</name><operator>&amp;</operator><name>MEM_Str</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f1</name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>f2</name> <operator>&amp;</operator> <name>MEM_Str</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name><name>pMem2</name><operator>-&gt;</operator><name>enc</name></name> <operator>||</operator> <name><name>pMem1</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pMem1</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF8</name> <operator>||</operator> 
            <name><name>pMem1</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF16LE</name> <operator>||</operator> <name><name>pMem1</name><operator>-&gt;</operator><name>enc</name></name><operator>==</operator><name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The collation sequence must be defined at this point, even if
    ** the user deletes the collation sequence after the vdbe program is
    ** compiled (this was not always the case).
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>pColl</name> <operator>||</operator> <name><name>pColl</name><operator>-&gt;</operator><name>xCmp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>pColl</name></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>vdbeCompareMemString</name><argument_list>(<argument><expr><name>pMem1</name></expr></argument>, <argument><expr><name>pMem2</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* If a NULL pointer was passed as the collate function, fall through
    ** to the blob case and use memcmp().  */</comment>
  </block_content>}</block></if></if_stmt>
 
  <comment type="block">/* Both values must be blobs.  Compare using memcmp().  */</comment>
  <return>return <expr><call><name>sqlite3BlobCompare</name><argument_list>(<argument><expr><name>pMem1</name></expr></argument>, <argument><expr><name>pMem2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** The first argument passed to this function is a serial-type that
** corresponds to an integer - all values between 1 and 9 inclusive 
** except 7. The second points to a buffer containing an integer value
** serialized according to serial_type. This function deserializes
** and returns the value.
*/</comment>
<function><type><specifier>static</specifier> <name>i64</name></type> <name>vdbeRecordDecodeInt</name><parameter_list>(<parameter><decl><type><name>u32</name></type> <name>serial_type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>y</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> <operator>||</operator> <operator>(</operator><name>serial_type</name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>serial_type</name><operator>&lt;=</operator><literal type="number">9</literal> <operator>&amp;&amp;</operator> <name>serial_type</name><operator>!=</operator><literal type="number">7</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>serial_type</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case>
    <case>case <expr><literal type="number">1</literal></expr>:</case>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>ONE_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">2</literal></expr>:</case>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>TWO_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">3</literal></expr>:</case>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>THREE_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="number">4</literal></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>(</operator><name>i64</name><operator>)</operator><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>y</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">5</literal></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator><operator>*</operator><call><name>TWO_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">6</literal></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>u64</name></type> <name>x</name> <init>= <expr><call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator> <operator>|</operator> <call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>(</operator><name>i64</name><operator>)</operator><operator>*</operator><operator>(</operator><name>i64</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>x</name></expr>;</return>
    </block_content>}</block>
  </block_content>}</block></switch>

  <return>return <expr><operator>(</operator><name>serial_type</name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function compares the two table rows or index records
** specified by {nKey1, pKey1} and pPKey2.  It returns a negative, zero
** or positive integer if key1 is less than, equal to or 
** greater than key2.  The {nKey1, pKey1} key must be a blob
** created by the OP_MakeRecord opcode of the VDBE.  The pPKey2
** key must be a parsed key such as obtained from
** sqlite3VdbeParseRecord.
**
** If argument bSkip is non-zero, it is assumed that the caller has already
** determined that the first fields of the keys are equal.
**
** Key1 and Key2 do not have to contain the same number of fields. If all 
** fields that appear in both keys are equal, then pPKey2-&gt;default_rc is 
** returned.
**
** If database corruption is discovered, set pPKey2-&gt;errCode to 
** SQLITE_CORRUPT and return 0. If an OOM error is encountered, 
** pPKey2-&gt;errCode is set to SQLITE_NOMEM and, if it is not NULL, the
** malloc-failed flag set on database handle (pPKey2-&gt;pKeyInfo-&gt;db).
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeRecordCompareWithSkip</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>,   <comment type="block">/* Left key */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pPKey2</name></decl></parameter>,         <comment type="block">/* Right key */</comment>
  <parameter><decl><type><name>int</name></type> <name>bSkip</name></decl></parameter>                       <comment type="block">/* If true, skip the first field */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>d1</name></decl>;</decl_stmt>                         <comment type="block">/* Offset into aKey[] of next data element */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Index of next field to compare */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>szHdr1</name></decl>;</decl_stmt>                     <comment type="block">/* Size of record header in bytes */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>idx1</name></decl>;</decl_stmt>                       <comment type="block">/* Offset of first type in header */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                     <comment type="block">/* Return value */</comment>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pRhs</name> <init>= <expr><name><name>pPKey2</name><operator>-&gt;</operator><name>aMem</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Next field of pPKey2 to compare */</comment>
  <decl_stmt><decl><type><name>KeyInfo</name> <modifier>*</modifier></type><name>pKeyInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aKey1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pKey1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name></type> <name>mem1</name></decl>;</decl_stmt>

  <comment type="block">/* If bSkip is true, then the caller has already determined that the first
  ** two elements in the keys are equal. Fix the various stack variables so
  ** that this routine begins comparing at the second field. */</comment>
  <if_stmt><if>if<condition>( <expr><name>bSkip</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>s1</name> <init>= <expr><name><name>aKey1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>s1</name><operator>&lt;</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>idx1</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>idx1</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>sqlite3GetVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>szHdr1</name> <operator>=</operator> <name><name>aKey1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>d1</name> <operator>=</operator> <name>szHdr1</name> <operator>+</operator> <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRhs</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>szHdr1</name> <operator>=</operator> <name><name>aKey1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>&lt;</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>idx1</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>idx1</name> <operator>=</operator> <call><name>sqlite3GetVarint32</name><argument_list>(<argument><expr><name>aKey1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>szHdr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>d1</name> <operator>=</operator> <name>szHdr1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>d1</name><operator>&gt;</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr> )</condition><block>{<block_content> 
    <expr_stmt><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Corruption */</comment>
  </block_content>}</block></if></if_stmt>

  <macro><name>VVA_ONLY</name><argument_list>( <argument>mem1.szMalloc = <literal type="number">0</literal>;</argument> )</argument_list></macro> <comment type="block">/* Only needed by assert() statements */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nAllField</name></name><operator>&gt;=</operator><name><name>pPKey2</name><operator>-&gt;</operator><name>nField</name></name> 
       <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nKeyField</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx1</name><operator>&lt;=</operator><name>szHdr1</name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>serial_type</name></decl>;</decl_stmt>

    <comment type="block">/* RHS is an integer */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pRhs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Int</name><operator>|</operator><name>MEM_IntReal</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_IntReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>serial_type</name> <operator>=</operator> <name><name>aKey1</name><index>[<expr><name>idx1</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serial_type</name><operator>==</operator><literal type="number">12</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&gt;=</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>serial_type</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>serial_type</name><operator>==</operator><literal type="number">7</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><call><name>sqlite3IntFloatCompare</name><argument_list>(<argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>mem1</name><operator>.</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>i64</name></type> <name>lhs</name> <init>= <expr><call><name>vdbeRecordDecodeInt</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>i64</name></type> <name>rhs</name> <init>= <expr><name><name>pRhs</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>lhs</name><operator>&lt;</operator><name>rhs</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>lhs</name><operator>&gt;</operator><name>rhs</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>

    <comment type="block">/* RHS is real */</comment>
    <if type="elseif">else if<condition>( <expr><name><name>pRhs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Real</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>serial_type</name> <operator>=</operator> <name><name>aKey1</name><index>[<expr><name>idx1</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&gt;=</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Serial types 12 or greater are strings and blobs (greater than
        ** numbers). Types 10 and 11 are currently "reserved for future 
        ** use", so it doesn't really matter what the results of comparing
        ** them to numberic values are.  */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>serial_type</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>==</operator><literal type="number">7</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>mem1</name><operator>.</operator><name>u</name><operator>.</operator><name>r</name></name><operator>&lt;</operator><name><name>pRhs</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>mem1</name><operator>.</operator><name>u</name><operator>.</operator><name>r</name></name><operator>&gt;</operator><name><name>pRhs</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3IntFloatCompare</name><argument_list>(<argument><expr><name><name>mem1</name><operator>.</operator><name>u</name><operator>.</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>

    <comment type="block">/* RHS is a string */</comment>
    <if type="elseif">else if<condition>( <expr><name><name>pRhs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Str</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>getVarint32NR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>idx1</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serial_type</name><operator>==</operator><literal type="number">12</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&lt;</operator><literal type="number">12</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><operator>(</operator><name>serial_type</name> <operator>&amp;</operator> <literal type="number">0x01</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>mem1</name><operator>.</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>serial_type</name> <operator>-</operator> <literal type="number">12</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>d1</name><operator>+</operator><name><name>mem1</name><operator>.</operator><name>n</name></name><operator>)</operator><operator>==</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>d1</name><operator>+</operator><name><name>mem1</name><operator>.</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>d1</name><operator>+</operator><name><name>mem1</name><operator>.</operator><name>n</name></name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name>
         <operator>||</operator> <operator>(</operator><name>pKeyInfo</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name></name><operator>)</operator><operator>-&gt;</operator><name>nAllField</name><operator>&lt;=</operator><name>i</name></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
          <return>return <expr><literal type="number">0</literal></expr>;</return>                <comment type="block">/* Corruption */</comment>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>mem1</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>enc</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>mem1</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>mem1</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Str</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>mem1</name><operator>.</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vdbeCompareMemString</name><argument_list>(
              <argument><expr><operator>&amp;</operator><name>mem1</name></expr></argument>, <argument><expr><name>pRhs</name></expr></argument>, <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPKey2</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>nCmp</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>mem1</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>nCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>mem1</name><operator>.</operator><name>n</name></name> <operator>-</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt> 
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>

    <comment type="block">/* RHS is a blob */</comment>
    <if type="elseif">else if<condition>( <expr><name><name>pRhs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Blob</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pRhs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>getVarint32NR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>idx1</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>serial_type</name><operator>==</operator><literal type="number">12</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&lt;</operator><literal type="number">12</literal> <operator>||</operator> <operator>(</operator><name>serial_type</name> <operator>&amp;</operator> <literal type="number">0x01</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nStr</name> <init>= <expr><operator>(</operator><name>serial_type</name> <operator>-</operator> <literal type="number">12</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>d1</name><operator>+</operator><name>nStr</name><operator>)</operator><operator>==</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>d1</name><operator>+</operator><name>nStr</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>d1</name><operator>+</operator><name>nStr</name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
          <return>return <expr><literal type="number">0</literal></expr>;</return>                <comment type="block">/* Corruption */</comment>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pRhs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Zero</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isAllZero</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr></argument>,<argument><expr><name>nStr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>nStr</name> <operator>-</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nZero</name></name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>nCmp</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>nStr</name></expr></argument>, <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>nCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>nStr</name> <operator>-</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>

    <comment type="block">/* RHS is null */</comment>
    <else>else<block>{<block_content>
      <expr_stmt><expr><name>serial_type</name> <operator>=</operator> <name><name>aKey1</name><index>[<expr><name>idx1</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>serial_type</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>sortFlags</name> <init>= <expr><name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>sortFlags</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>sortFlags</name> <operator>&amp;</operator> <name>KEYINFO_ORDER_BIGNULL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal>
         <operator>||</operator> <operator>(</operator><operator>(</operator><name>sortFlags</name> <operator>&amp;</operator> <name>KEYINFO_ORDER_DESC</name><operator>)</operator>
           <operator>!=</operator><operator>(</operator><name>serial_type</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pRhs</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Null</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><name>rc</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>vdbeRecordCompareDebug</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>mem1</name><operator>.</operator><name>szMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* See comment below */</comment>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name><name>pPKey2</name><operator>-&gt;</operator><name>nField</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pRhs</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>d1</name> <operator>+=</operator> <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx1</name> <operator>+=</operator> <call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>idx1</name><operator>&lt;</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>szHdr1</name> <operator>&amp;&amp;</operator> <name>d1</name><operator>&lt;=</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>nKey1</name></expr> )</condition>;</do>

  <comment type="block">/* No memory allocation is ever used on mem1.  Prove this using
  ** the following assert().  If the assert() fails, it indicates a
  ** memory leak and a need to call sqlite3VdbeMemRelease(&amp;mem1).  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>mem1</name><operator>.</operator><name>szMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* rc==0 here means that one or both of the keys ran out of fields and
  ** all the fields up to that point were equal. Return the default_rc
  ** value.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name> 
       <operator>||</operator> <call><name>vdbeRecordCompareDebug</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>, <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>default_rc</name></name></expr></argument>)</argument_list></call> 
       <operator>||</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>eqSeen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name><name>pPKey2</name><operator>-&gt;</operator><name>default_rc</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeRecordCompare</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>,   <comment type="block">/* Left key */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pPKey2</name></decl></parameter>          <comment type="block">/* Right key */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeRecordCompareWithSkip</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is an optimized version of sqlite3VdbeRecordCompare() 
** that (a) the first field of pPKey2 is an integer, and (b) the 
** size-of-header varint at the start of (pKey1/nKey1) fits in a single
** byte (i.e. is less than 128).
**
** To avoid concerns about buffer overreads, this routine is only used
** on schemas where the maximum valid header size is 63 bytes or less.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeRecordCompareInt</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <comment type="block">/* Left key */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pPKey2</name></decl></parameter>        <comment type="block">/* Right key */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aKey</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><name>pKey1</name><operator>)</operator><index>[<expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><name>pKey1</name> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>serial_type</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><name>pKey1</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>y</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>lhs</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>vdbeAssertFieldCountWithinLimits</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>pKey1</name><operator>)</operator><operator>&lt;=</operator><literal type="number">0x3F</literal> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>serial_type</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">1</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1-byte signed integer */</comment>
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <call><name>ONE_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>lhs</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">2</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 2-byte signed integer */</comment>
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <call><name>TWO_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>lhs</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">3</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 3-byte signed integer */</comment>
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <call><name>THREE_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>lhs</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">4</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 4-byte signed integer */</comment>
      <expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>y</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>lhs</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">5</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 6-byte signed integer */</comment>
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator><operator>*</operator><call><name>TWO_BYTE_INT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>lhs</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">6</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 8-byte signed integer */</comment>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator> <operator>|</operator> <call><name>FOUR_BYTE_UINT</name><argument_list>(<argument><expr><name>aKey</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>i64</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>x</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>lhs</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">8</literal></expr>:</case> 
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><literal type="number">9</literal></expr>:</case>
      <expr_stmt><expr><name>lhs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>

    <comment type="block">/* This case could be removed without changing the results of running
    ** this code. Including it causes gcc to generate a faster switch 
    ** statement (since the range of switch targets now starts at zero and
    ** is contiguous) but does not cause any duplicate code to be generated
    ** (as gcc is clever enough to combine the two like cases). Other 
    ** compilers might be similar.  */</comment> 
    <case>case <expr><literal type="number">0</literal></expr>:</case> <case>case <expr><literal type="number">7</literal></expr>:</case>
      <return>return <expr><call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>)</argument_list></call></expr>;</return>

    <default>default:</default>
      <return>return <expr><call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>==</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>i</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>&gt;</operator><name>lhs</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r1</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>v</name><operator>&lt;</operator><name>lhs</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r2</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pPKey2</name><operator>-&gt;</operator><name>nField</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The first fields of the two keys are equal. Compare the trailing 
    ** fields.  */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3VdbeRecordCompareWithSkip</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* The first fields of the two keys are equal and there are no trailing
    ** fields. Return pPKey2-&gt;default_rc in this case. */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>default_rc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>eqSeen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>vdbeRecordCompareDebug</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is an optimized version of sqlite3VdbeRecordCompare() 
** that (a) the first field of pPKey2 is a string, that (b) the first field
** uses the collation sequence BINARY and (c) that the size-of-header varint 
** at the start of (pKey1/nKey1) fits in a single byte.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeRecordCompareString</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <comment type="block">/* Left key */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pPKey2</name></decl></parameter>        <comment type="block">/* Right key */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aKey1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><name>pKey1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>serial_type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Str</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>n</name> <operator>==</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>n</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>z</name> <operator>==</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>vdbeAssertFieldCountWithinLimits</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>serial_type</name> <operator>=</operator> <operator>(</operator><name>signed</name> <name>char</name><operator>)</operator><operator>(</operator><name><name>aKey1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<label><name>vrcs_restart</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&lt;</operator><literal type="number">12</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3GetVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>serial_type</name><operator>&gt;=</operator><literal type="number">12</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>vrcs_restart</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r1</name></name></expr>;</expr_stmt>      <comment type="block">/* (pKey1/nKey1) is a number or a null */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><operator>(</operator><name>serial_type</name> <operator>&amp;</operator> <literal type="number">0x01</literal><operator>)</operator></expr> )</condition><block>{<block_content> 
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r2</name></name></expr>;</expr_stmt>      <comment type="block">/* (pKey1/nKey1) is a blob */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nCmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nStr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>szHdr</name> <init>= <expr><name><name>aKey1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>nStr</name> <operator>=</operator> <operator>(</operator><name>serial_type</name><operator>-</operator><literal type="number">12</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>szHdr</name> <operator>+</operator> <name>nStr</name><operator>)</operator> <operator>&gt;</operator> <name>nKey1</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>    <comment type="block">/* Corruption */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nCmp</name> <operator>=</operator> <call><name>MIN</name><argument_list>( <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>nStr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aKey1</name><index>[<expr><name>szHdr</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name>nCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r2</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r1</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <name>nStr</name> <operator>-</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pPKey2</name><operator>-&gt;</operator><name>nField</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3VdbeRecordCompareWithSkip</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>default_rc</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pPKey2</name><operator>-&gt;</operator><name>eqSeen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r2</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>r1</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>vdbeRecordCompareDebug</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pPKey2</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call>
       <operator>||</operator> <name>CORRUPT_DB</name>
       <operator>||</operator> <name><name>pPKey2</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to an sqlite3VdbeRecordCompare() compatible function
** suitable for comparing serialized records to the unpacked record passed
** as the only argument.
*/</comment>
<function><type><name>RecordCompare</name></type> <name>sqlite3VdbeFindCompare</name><parameter_list>(<parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* varintRecordCompareInt() and varintRecordCompareString() both assume
  ** that the size-of-header varint that occurs at the start of each record
  ** fits in a single byte (i.e. is 127 or less). varintRecordCompareInt()
  ** also assumes that it is safe to overread a buffer by at least the 
  ** maximum possible legal header size plus 8 bytes. Because there is
  ** guaranteed to be at least 74 (but not 136) bytes of padding following each
  ** buffer passed to varintRecordCompareInt() this makes it convenient to
  ** limit the size of the header to 64 bytes in cases where the first field
  ** is an integer.
  **
  ** The easiest way to enforce this limit is to consider only records with
  ** 13 fields or less. If the first field is an integer, the maximum legal
  ** header size is (12*5 + 1 + 1) bytes.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>nAllField</name></name><operator>&lt;=</operator><literal type="number">13</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>flags</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>aSortFlags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <name>KEYINFO_ORDER_BIGNULL</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>sqlite3VdbeRecordCompare</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>r1</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>r2</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>r1</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>r2</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MEM_Int</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
      <return>return <expr><name>vdbeRecordCompareInt</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>flags</name> <operator>&amp;</operator> <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>flags</name> <operator>&amp;</operator> <name>MEM_Null</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>flags</name> <operator>&amp;</operator> <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Real</name><operator>|</operator><name>MEM_IntReal</name><operator>|</operator><name>MEM_Null</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pKeyInfo</name><operator>-&gt;</operator><name>aColl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name> <operator>&amp;</operator> <name>MEM_Str</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>z</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>n</name></expr>;</expr_stmt>
      <return>return <expr><name>vdbeRecordCompareString</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>sqlite3VdbeRecordCompare</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pCur points at an index entry created using the OP_MakeRecord opcode.
** Read the rowid (the last field in the record) and store it in *rowid.
** Return SQLITE_OK if everything works, or an error code otherwise.
**
** pCur might be pointing to text obtained from a corrupt database file.
** So the content cannot be trusted.  Do appropriate checks on the content.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeIdxRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>rowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>nCellKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>szHdr</name></decl>;</decl_stmt>        <comment type="block">/* Size of the header */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>typeRowid</name></decl>;</decl_stmt>    <comment type="block">/* Serial type of the rowid */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>lenRowid</name></decl>;</decl_stmt>     <comment type="block">/* Size of the rowid */</comment>
  <decl_stmt><decl><type><name>Mem</name></type> <name>m</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>

  <comment type="block">/* Get the size of the index entry.  Only indices entries of less
  ** than 2GiB are support - anything large must be database corruption.
  ** Any corruption is detected in sqlite3BtreeParseCellPtr(), though, so
  ** this code can safely assume that nCellKey is 32-bits  
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorIsValid</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCellKey</name> <operator>=</operator> <call><name>sqlite3BtreePayloadSize</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>nCellKey</name> <operator>&amp;</operator> <name>SQLITE_MAX_U32</name><operator>)</operator><operator>==</operator><operator>(</operator><name>u64</name><operator>)</operator><name>nCellKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read in the complete content of the index entry */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeMemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemFromBtreeZeroOffset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name>nCellKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The index entry must begin with a header size */</comment>
  <expr_stmt><expr><call><name>getVarint32NR</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>m</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name>szHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>szHdr</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>szHdr</name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>m</name><operator>.</operator><name>n</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>szHdr</name><operator>&gt;</operator><literal type="number">0x7fffffff</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>m</name><operator>.</operator><name>n</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>unlikely</name><argument_list>(<argument><expr><macro><name>szHdr</name></macro><operator>&lt;</operator><literal type="number">3</literal> <operator>||</operator> <name>szHdr</name><operator>&gt;</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>m</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>idx_rowid_corruption</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The last field of the index should be an integer - the ROWID.
  ** Verify that the last entry really is an integer. */</comment>
  <expr_stmt><expr><call><name>getVarint32NR</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>m</name><operator>.</operator><name>z</name><index>[<expr><name>szHdr</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>typeRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">6</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name><operator>==</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>typeRowid</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal> <operator>||</operator> <name>typeRowid</name></expr></argument>&gt;</argument_list></name><literal type="number">9</literal> <operator>||</operator> <name>typeRowid</name><operator>==</operator><literal type="number">7</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>idx_rowid_corruption</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>lenRowid</name> <operator>=</operator> <name><name>sqlite3SmallTypeSizes</name><index>[<expr><name>typeRowid</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>m</name><operator>.</operator><name>n</name></name><operator>==</operator><name>szHdr</name><operator>+</operator><name>lenRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>m</name><operator>.</operator><name>n</name></name><operator>&lt;</operator><name>szHdr</name><operator>+</operator><name>lenRowid</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <goto>goto <name>idx_rowid_corruption</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Fetch the integer off the end of the index record */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>m</name><operator>.</operator><name>z</name><index>[<expr><name><name>m</name><operator>.</operator><name>n</name></name><operator>-</operator><name>lenRowid</name></expr>]</index></name></expr></argument>, <argument><expr><name>typeRowid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>rowid</name> <operator>=</operator> <name><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemReleaseMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

  <comment type="block">/* Jump here if database corruption is detected after m has been
  ** allocated.  Free the m object and return SQLITE_CORRUPT. */</comment>
<label><name>idx_rowid_corruption</name>:</label>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>m</name><operator>.</operator><name>szMalloc</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemReleaseMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare the key of the index entry that cursor pC is pointing to against
** the key string in pUnpacked.  Write into *pRes a number
** that is negative, zero, or positive if pC is less than, equal to,
** or greater than pUnpacked.  Return SQLITE_OK on success.
**
** pUnpacked is either created without a rowid or is truncated so that it
** omits the rowid at the end.  The rowid at the end of the index entry
** is ignored as well.  Hence, this routine only compares the prefixes 
** of the keys prior to the final rowid, not the entire key.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeIdxKeyCompare</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                     <comment type="block">/* Database connection */</comment>
  <parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pC</name></decl></parameter>,                  <comment type="block">/* The cursor to compare against */</comment>
  <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>pUnpacked</name></decl></parameter>,       <comment type="block">/* Unpacked version of key */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res</name></decl></parameter>                         <comment type="block">/* Write the comparison result here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>nCellKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name></type> <name>m</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pC</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <name><name>pC</name><operator>-&gt;</operator><name>uc</name><operator>.</operator><name>pCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeCursorIsValid</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCellKey</name> <operator>=</operator> <call><name>sqlite3BtreePayloadSize</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* nCellKey will always be between 0 and 0xffffffff because of the way
  ** that btreeParseCellPtr() and sqlite3GetVarint32() are implemented */</comment>
  <if_stmt><if>if<condition>( <expr><name>nCellKey</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>nCellKey</name><operator>&gt;</operator><literal type="number">0x7fffffff</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeMemFromBtreeZeroOffset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name>nCellKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <call><name>sqlite3VdbeRecordCompareWithSkip</name><argument_list>(<argument><expr><name><name>m</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name>pUnpacked</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemReleaseMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine sets the value to be returned by subsequent calls to
** sqlite3_changes() on the database handle 'db'. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetChanges</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nChange</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nChange</name></name> <operator>=</operator> <name>nChange</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nTotalChange</name></name> <operator>+=</operator> <name>nChange</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set a flag in the vdbe to update the change counter when it is finalised
** or reset.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeCountChanges</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>changeCntOn</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Mark every prepared statement associated with a database connection
** as expired.
**
** An expired statement means that recompilation of the statement is
** recommend.  Statements expire when things happen that make their
** programs obsolete.  Removing user-defined functions or collating
** sequences, or changing an authorization function are the types of
** things that make prepared statements obsolete.
**
** If iCode is 1, then expiration is advisory.  The statement should
** be reprepared before being restarted, but if it is already running
** it is allowed to run to completion.
**
** Internally, this function just sets the Vdbe.expired flag on all
** prepared statements.  The flag is set to 1 for an immediate expiration
** and set to 2 for an advisory expiration.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExpirePreparedStatements</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iCode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pVdbe</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <name>iCode</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Return the database associated with the Vdbe.
*/</comment>
<function><type><name>sqlite3</name> <modifier>*</modifier></type><name>sqlite3VdbeDb</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the SQLITE_PREPARE flags for a Vdbe.
*/</comment>
<function><type><name>u8</name></type> <name>sqlite3VdbePrepareFlags</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>v</name><operator>-&gt;</operator><name>prepFlags</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to an sqlite3_value structure containing the value bound
** parameter iVar of VM v. Except, if the value is an SQL NULL, return 
** 0 instead. Unless it is NULL, apply affinity aff (one of the SQLITE_AFF_*
** constants) to the value before returning it.
**
** The returned value must be freed by the caller using sqlite3ValueFree().
*/</comment>
<function><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>sqlite3VdbeGetBoundValue</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iVar</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>aff</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iVar</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>aVar</name><index>[<expr><name>iVar</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_EnableQPSG</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3VdbeMemCopy</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name> <operator>*</operator><operator>)</operator><name>pRet</name></expr></argument>, <argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ValueApplyAffinity</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>pRet</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Configure SQL variable iVar so that binding a new value to it signals
** to sqlite3_reoptimize() that re-preparing the statement may result
** in a better query plan.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetVarmask</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iVar</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iVar</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_EnableQPSG</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iVar</name><operator>&gt;=</operator><literal type="number">32</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>expmask</name></name> <operator>|=</operator> <literal type="number">0x80000000</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>expmask</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>iVar</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Cause a function to throw an error if it was call from OP_PureFunc
** rather than OP_Function.
**
** OP_PureFunc means that the function must be deterministic, and should
** throw an error if it is given inputs that would make it non-deterministic.
** This routine is invoked by date/time functions that use non-deterministic
** features such as 'now'.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3NotPureFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT4</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name><operator>-&gt;</operator><name>aOp</name></name> <operator>+</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>iOp</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_PureFunc</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>NC_IsCheck</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zContext</name> <operator>=</operator> <literal type="string">"a CHECK constraint"</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pOp</name><operator>-&gt;</operator><name>p5</name></name> <operator>&amp;</operator> <name>NC_GenCol</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zContext</name> <operator>=</operator> <literal type="string">"a generated column"</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zContext</name> <operator>=</operator> <literal type="string">"an index"</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"non-deterministic use of %s() in %s"</literal></expr></argument>,
                           <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** Transfer error message text from an sqlite3_vtab.zErrMsg (text stored
** in memory obtained from sqlite3_malloc) into a Vdbe.zErrMsg (text stored
** in memory obtained from sqlite3DbMalloc).
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabImportErrmsg</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_PREUPDATE_HOOK</name></cpp:ifdef>

<comment type="block">/*
** If the second argument is not NULL, release any allocations associated 
** with the memory cells in the p-&gt;aMem[] array. Also free the UnpackedRecord
** structure itself, using sqlite3DbFree().
**
** This function is used to free UnpackedRecord structures allocated by
** the vdbeUnpackRecord() function found in vdbeapi.c.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vdbeFreeUnpacked</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nField</name></decl></parameter>, <parameter><decl><type><name>UnpackedRecord</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nField</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>zMalloc</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3VdbeMemReleaseMalloc</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_PREUPDATE_HOOK */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_PREUPDATE_HOOK</name></cpp:ifdef>
<comment type="block">/*
** Invoke the pre-update hook. If this is an UPDATE or DELETE pre-update call,
** then cursor passed as the second argument should point to the row about
** to be update or deleted. If the application calls sqlite3_preupdate_old(),
** the required value will be read from the row the cursor points to.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbePreUpdateHook</name><parameter_list>(
  <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,                        <comment type="block">/* Vdbe pre-update hook is invoked by */</comment>
  <parameter><decl><type><name>VdbeCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* Cursor to grab old.* values from */</comment>
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,                         <comment type="block">/* SQLITE_INSERT, UPDATE or DELETE */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,                <comment type="block">/* Database name */</comment>
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                    <comment type="block">/* Modified table */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iKey1</name></decl></parameter>,                      <comment type="block">/* Initial key value */</comment>
  <parameter><decl><type><name>int</name></type> <name>iReg</name></decl></parameter>,                       <comment type="block">/* Register for new.* record */</comment>
  <parameter><decl><type><name>int</name></type> <name>iBlobWrite</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iKey2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PreUpdate</name></type> <name>preupdate</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTbl</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name>fakeSortOrder</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>pPreUpdate</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preupdate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PreUpdate</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>HasRowid</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iKey1</name> <operator>=</operator> <name>iKey2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>preupdate</name><operator>.</operator><name>pPk</name></name> <operator>=</operator> <call><name>sqlite3PrimaryKeyIndex</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_UPDATE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iKey2</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>aMem</name><index>[<expr><name>iReg</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iKey2</name> <operator>=</operator> <name>iKey1</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCsr</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>eCurType</name></name><operator>==</operator><name>CURTYPE_BTREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nField</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name> 
       <operator>||</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nField</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name><operator>+</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>SQLITE_DELETE</name> <operator>&amp;&amp;</operator> <name>iReg</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>preupdate</name><operator>.</operator><name>v</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>preupdate</name><operator>.</operator><name>pCsr</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>preupdate</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>preupdate</name><operator>.</operator><name>iNewReg</name></name> <operator>=</operator> <name>iReg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>preupdate</name><operator>.</operator><name>keyinfo</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>preupdate</name><operator>.</operator><name>keyinfo</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>preupdate</name><operator>.</operator><name>keyinfo</name><operator>.</operator><name>nKeyField</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>preupdate</name><operator>.</operator><name>keyinfo</name><operator>.</operator><name>aSortFlags</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>fakeSortOrder</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>preupdate</name><operator>.</operator><name>iKey1</name></name> <operator>=</operator> <name>iKey1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>preupdate</name><operator>.</operator><name>iKey2</name></name> <operator>=</operator> <name>iKey2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>preupdate</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>preupdate</name><operator>.</operator><name>iBlobWrite</name></name> <operator>=</operator> <name>iBlobWrite</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pPreUpdate</name></name> <operator>=</operator> <operator>&amp;</operator><name>preupdate</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>xPreUpdateCallback</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pPreUpdateArg</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><name>iKey1</name></expr></argument>, <argument><expr><name>iKey2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pPreUpdate</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>preupdate</name><operator>.</operator><name>aRecord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>vdbeFreeUnpacked</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>preupdate</name><operator>.</operator><name>keyinfo</name><operator>.</operator><name>nKeyField</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>preupdate</name><operator>.</operator><name>pUnpacked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>vdbeFreeUnpacked</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>preupdate</name><operator>.</operator><name>keyinfo</name><operator>.</operator><name>nKeyField</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>preupdate</name><operator>.</operator><name>pNewUnpacked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>preupdate</name><operator>.</operator><name>aNew</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nField</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>preupdate</name><operator>.</operator><name>aNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFreeNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>preupdate</name><operator>.</operator><name>aNew</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_PREUPDATE_HOOK */</comment>
</unit>
