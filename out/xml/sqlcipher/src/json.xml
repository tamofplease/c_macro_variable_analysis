<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/src/json.c"><comment type="block">/*
** 2015-08-12
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This SQLite JSON functions.
**
** This file began as an extension in ext/misc/json1.c in 2015.  That
** extension proved so useful that it has now been moved into the core.
**
** For the time being, all JSON is stored as pure text.  (We might add
** a JSONB type in the future which stores a binary encoding of JSON in
** a BLOB, but there is no support for JSONB in the current implementation.
** This implementation parses JSON text at 250 MB/s, so it is hard to see
** how JSONB might improve on that.)
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_JSON</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Growing our own isspace() routine this way is twice as fast as
** the library isspace() function, resulting in a 7% overall performance
** increase for the parser.  (Ubuntu14.10 gcc 4.8.4 x64 with -Os).
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>jsonIsSpace</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fast_isspace</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(jsonIsSpace[(unsigned char)x])</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_COVERAGE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>VVA</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>VVA</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>X</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Objects */</comment>
<typedef>typedef <type><name><name>struct</name> <name>JsonString</name></name></type> <name>JsonString</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>JsonNode</name></name></type> <name>JsonNode</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>JsonParse</name></name></type> <name>JsonParse</name>;</typedef>

<comment type="block">/* An instance of this object represents a JSON string
** under construction.  Really, this is a generic string accumulator
** that can be and is used to create strings other than JSON.
*/</comment>
<struct>struct <name>JsonString</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>   <comment type="block">/* Function context - put error messages here */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl>;</decl_stmt>              <comment type="block">/* Append JSON content here */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>nAlloc</name></decl>;</decl_stmt>              <comment type="block">/* Bytes of storage available in zBuf[] */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>nUsed</name></decl>;</decl_stmt>               <comment type="block">/* Bytes of zBuf[] currently used */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bStatic</name></decl>;</decl_stmt>              <comment type="block">/* True if zBuf is static space */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bErr</name></decl>;</decl_stmt>                 <comment type="block">/* True if an error has been encountered */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zSpace</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* Initial static space */</comment>
}</block>;</struct>

<comment type="block">/* JSON type values
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_NULL</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TRUE</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_FALSE</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_INT</name></cpp:macro>      <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_REAL</name></cpp:macro>     <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_STRING</name></cpp:macro>   <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_ARRAY</name></cpp:macro>    <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_OBJECT</name></cpp:macro>   <cpp:value>7</cpp:value></cpp:define>

<comment type="block">/* The "subtype" set for JSON values */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_SUBTYPE</name></cpp:macro>  <cpp:value>74</cpp:value></cpp:define>    <comment type="block">/* Ascii for "J" */</comment>

<comment type="block">/*
** Names of the various JSON types:
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>jsonType</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="string">"null"</literal></expr>, <expr><literal type="string">"true"</literal></expr>, <expr><literal type="string">"false"</literal></expr>, <expr><literal type="string">"integer"</literal></expr>, <expr><literal type="string">"real"</literal></expr>, <expr><literal type="string">"text"</literal></expr>, <expr><literal type="string">"array"</literal></expr>, <expr><literal type="string">"object"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Bit values for the JsonNode.jnFlag field
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JNODE_RAW</name></cpp:macro>     <cpp:value>0x01</cpp:value></cpp:define>         <comment type="block">/* Content is raw, not JSON encoded */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JNODE_ESCAPE</name></cpp:macro>  <cpp:value>0x02</cpp:value></cpp:define>         <comment type="block">/* Content is text with \ escapes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JNODE_REMOVE</name></cpp:macro>  <cpp:value>0x04</cpp:value></cpp:define>         <comment type="block">/* Do not output */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JNODE_REPLACE</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define>         <comment type="block">/* Replace with JsonNode.u.iReplace */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JNODE_PATCH</name></cpp:macro>   <cpp:value>0x10</cpp:value></cpp:define>         <comment type="block">/* Patch with JsonNode.u.pPatch */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JNODE_APPEND</name></cpp:macro>  <cpp:value>0x20</cpp:value></cpp:define>         <comment type="block">/* More ARRAY/OBJECT entries at u.iAppend */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JNODE_LABEL</name></cpp:macro>   <cpp:value>0x40</cpp:value></cpp:define>         <comment type="block">/* Is a label of an object */</comment>


<comment type="block">/* A single node of parsed JSON
*/</comment>
<struct>struct <name>JsonNode</name> <block>{
  <decl_stmt><decl><type><name>u8</name></type> <name>eType</name></decl>;</decl_stmt>              <comment type="block">/* One of the JSON_ type values */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>jnFlags</name></decl>;</decl_stmt>            <comment type="block">/* JNODE flags */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>eU</name></decl>;</decl_stmt>                 <comment type="block">/* Which union element to use */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>n</name></decl>;</decl_stmt>                 <comment type="block">/* Bytes of content, or number of sub-nodes */</comment>
  <union>union <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zJContent</name></decl>;</decl_stmt> <comment type="block">/* 1: Content for INT, REAL, and STRING */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>iAppend</name></decl>;</decl_stmt>           <comment type="block">/* 2: More terms for ARRAY and OBJECT */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>iKey</name></decl>;</decl_stmt>              <comment type="block">/* 3: Key for ARRAY objects in json_tree() */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>iReplace</name></decl>;</decl_stmt>          <comment type="block">/* 4: Replacement content for JNODE_REPLACE */</comment>
    <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pPatch</name></decl>;</decl_stmt>      <comment type="block">/* 5: Node chain of patch for JNODE_PATCH */</comment>
  }</block> <decl><name>u</name></decl>;</union>
}</block>;</struct>

<comment type="block">/* A completely parsed JSON string
*/</comment>
<struct>struct <name>JsonParse</name> <block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>nNode</name></decl>;</decl_stmt>         <comment type="block">/* Number of slots of aNode[] used */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nAlloc</name></decl>;</decl_stmt>        <comment type="block">/* Number of slots of aNode[] allocated */</comment>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>aNode</name></decl>;</decl_stmt>   <comment type="block">/* Array of nodes containing the parse */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zJson</name></decl>;</decl_stmt> <comment type="block">/* Original JSON string */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aUp</name></decl>;</decl_stmt>          <comment type="block">/* Index of parent of each node */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>oom</name></decl>;</decl_stmt>            <comment type="block">/* Set to true if out of memory */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nErr</name></decl>;</decl_stmt>           <comment type="block">/* Number of errors seen */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>iDepth</name></decl>;</decl_stmt>        <comment type="block">/* Nesting depth */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nJson</name></decl>;</decl_stmt>         <comment type="block">/* Length of the zJson string in bytes */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iHold</name></decl>;</decl_stmt>         <comment type="block">/* Replace cache line with the lowest iHold value */</comment>
}</block>;</struct>

<comment type="block">/*
** Maximum nesting depth of JSON for this implementation.
**
** This limit is needed to avoid a stack overflow in the recursive
** descent parser.  A depth of 2000 is far deeper than any sane JSON
** should go.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_MAX_DEPTH</name></cpp:macro>  <cpp:value>2000</cpp:value></cpp:define>

<comment type="block" format="doxygen">/**************************************************************************
** Utility routines for dealing with JsonString objects
**************************************************************************/</comment>

<comment type="block">/* Set the JsonString object to an empty string
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonZero</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>zSpace</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSpace</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bStatic</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize the JsonString object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonInit</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pCtx</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bErr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonZero</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Free all allocated memory and reset the JsonString object back to its
** initial state.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonReset</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>bStatic</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>jsonZero</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Report an out-of-memory (OOM) condition 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonOom</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bErr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Enlarge pJson-&gt;zBuf so that it can hold at least N more bytes.
** Return zero on success.  Return non-zero on an OOM error
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonGrow</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>nTotal</name> <init>= <expr><ternary><condition><expr><name>N</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>+</operator><name>N</name><operator>+</operator><literal type="number">10</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bStatic</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zNew</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>jsonOom</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bStatic</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zNew</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><name>nTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>jsonOom</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>nTotal</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append N bytes from zIn onto the end of the JsonString string.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonAppendRaw</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>N</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>N</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>jsonGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>N</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>+=</operator> <name>N</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append formatted text (not to exceed N bytes) to the JsonString.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonPrintf</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>+</operator> <name>N</name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>jsonGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_vsnprintf</name><argument_list>(<argument><expr><name>N</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append a single character
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonAppendChar</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>&amp;&amp;</operator> <call><name>jsonGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append a comma separator to the output buffer, if the previous
** character is not '[' or '{'.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonAppendSeparator</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">'['</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'{'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Append the N-byte string in zIn to the end of the JsonString string
** under construction.  Enclose the string in "..." and escape
** any double-quotes or backslash characters contained within the
** string.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonAppendString</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zIn</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name>N</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>+</operator><literal type="number">2</literal> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>jsonGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>N</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>N</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><operator>(</operator><operator>(</operator><name>unsigned</name> <specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>zIn</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
      <label><name>json_simple_escape</name>:</label>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>+</operator><name>N</name><operator>+</operator><literal type="number">3</literal><operator>-</operator><name>i</name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>jsonGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>N</name><operator>+</operator><literal type="number">3</literal><operator>-</operator><name>i</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&lt;=</operator><literal type="number">0x1f</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>aSpecial</name><index>[]</index></name> <init>= <expr><block>{
         <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'t'</literal></expr>, <expr><literal type="char">'n'</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'f'</literal></expr>, <expr><literal type="char">'r'</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
         <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>
      }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aSpecial</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">32</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aSpecial</name><index>[<expr><literal type="char">'\b'</literal></expr>]</index></name><operator>==</operator><literal type="char">'b'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aSpecial</name><index>[<expr><literal type="char">'\f'</literal></expr>]</index></name><operator>==</operator><literal type="char">'f'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aSpecial</name><index>[<expr><literal type="char">'\n'</literal></expr>]</index></name><operator>==</operator><literal type="char">'n'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aSpecial</name><index>[<expr><literal type="char">'\r'</literal></expr>]</index></name><operator>==</operator><literal type="char">'r'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aSpecial</name><index>[<expr><literal type="char">'\t'</literal></expr>]</index></name><operator>==</operator><literal type="char">'t'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aSpecial</name><index>[<expr><name>c</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>aSpecial</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>
        <goto>goto <name>json_simple_escape</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>+</operator><name>N</name><operator>+</operator><literal type="number">7</literal><operator>+</operator><name>i</name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>jsonGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>N</name><operator>+</operator><literal type="number">7</literal><operator>-</operator><name>i</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'u'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <operator>(</operator><name>c</name><operator>&gt;&gt;</operator><literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="string">"0123456789abcdef"</literal><index>[<expr><name>c</name><operator>&amp;</operator><literal type="number">0xf</literal></expr>]</index></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Append a function parameter value to the JSON string under 
** construction.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonAppendValue</name><parameter_list>(
  <parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                 <comment type="block">/* Append to this JSON string */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>          <comment type="block">/* Value to append */</comment>
)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_NULL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case>
    <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>u32</name><operator>)</operator><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>u32</name><operator>)</operator><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_subtype</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call><operator>==</operator><name>JSON_SUBTYPE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>jsonAppendString</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><literal type="string">"JSON cannot hold BLOB values"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bErr</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jsonReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/* Make the JSON in p the result of the SQL function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonResult</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>, 
                          <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>bStatic</name></name></expr> ?</condition><then> <expr><name>SQLITE_TRANSIENT</name></expr> </then><else>: <expr><name>sqlite3_free</name></expr></else></ternary></expr></argument>,
                          <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonZero</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bStatic</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**************************************************************************
** Utility routines for dealing with JsonNode and JsonParse objects
**************************************************************************/</comment>

<comment type="block">/*
** Return the number of consecutive JsonNode slots need to represent
** the parsed JSON at pNode.  The minimum answer is 1.  For ARRAY and
** OBJECT types, the number might be larger.
**
** Appended elements are not counted.  The value returned is the number
** by which the JsonNode counter should increment in order to go to the
** next peer value.
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>jsonNodeSize</name><parameter_list>(<parameter><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name><operator>&gt;=</operator><name>JSON_ARRAY</name></expr> ?</condition><then> <expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Reclaim all memory allocated by a JsonParse object.  But do not
** delete the JsonParse object itself.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonParseReset</name><parameter_list>(<parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aUp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aUp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free a JsonParse object that was obtained from sqlite3_malloc().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonParseFree</name><parameter_list>(<parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Convert the JsonNode pNode into a pure JSON string and
** append to pOut.  Subsubstructure is also included.  Return
** the number of JsonNode objects that are encoded.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonRenderNode</name><parameter_list>(
  <parameter><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,               <comment type="block">/* The node to render */</comment>
  <parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>,              <comment type="block">/* Write JSON here */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>aReplace</name></decl></parameter>       <comment type="block">/* Replacement values */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNode</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <operator>(</operator><name>JNODE_REPLACE</name><operator>|</operator><name>JNODE_PATCH</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_REPLACE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>aReplace</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonAppendValue</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>aReplace</name><index>[<expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iReplace</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pPatch</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <switch>switch<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_TRUE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_FALSE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_STRING</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_RAW</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jsonAppendString</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
    </block_content>}</block>
    <case>case <expr><name>JSON_REAL</name></expr>:</case>
    <case>case <expr><name>JSON_INT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_ARRAY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
        <while>while<condition>( <expr><name>j</name><operator>&lt;=</operator><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNode</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REMOVE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>jsonAppendSeparator</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonRenderNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>aReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>j</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_APPEND</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNode</name><index>[<expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iAppend</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_OBJECT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
        <while>while<condition>( <expr><name>j</name><operator>&lt;=</operator><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNode</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REMOVE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>jsonAppendSeparator</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonRenderNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>aReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonRenderNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>aReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>j</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_APPEND</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNode</name><index>[<expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iAppend</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Return a JsonNode and all its descendents as a JSON string.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonReturnJson</name><parameter_list>(
  <parameter><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,            <comment type="block">/* Node to return */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,      <comment type="block">/* Return value for this function */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>aReplace</name></decl></parameter>    <comment type="block">/* Array of replacement values */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonString</name></type> <name>s</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonRenderNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>aReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Translate a single byte of Hex into an integer.
** This routine only works if h really is a valid hexadecimal
** character:  0..9a..fA..F
*/</comment>
<function><type><specifier>static</specifier> <name>u8</name></type> <name>jsonHexToInt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>h</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>h</name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator> <operator>||</operator>  <operator>(</operator><name>h</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>h</name><operator>&lt;=</operator><literal type="char">'f'</literal><operator>)</operator> <operator>||</operator>  <operator>(</operator><name>h</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>h</name><operator>&lt;=</operator><literal type="char">'F'</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EBCDIC</name></cpp:ifdef>
  <expr_stmt><expr><name>h</name> <operator>+=</operator> <literal type="number">9</literal><operator>*</operator><operator>(</operator><literal type="number">1</literal><operator>&amp;</operator><operator>~</operator><operator>(</operator><name>h</name><operator>&gt;&gt;</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>h</name> <operator>+=</operator> <literal type="number">9</literal><operator>*</operator><operator>(</operator><literal type="number">1</literal><operator>&amp;</operator><operator>(</operator><name>h</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>h</name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert a 4-byte hex string into an integer
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>jsonHexToInt4</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>v</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><call><name>jsonHexToInt</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>&lt;&lt;</operator><literal type="number">12</literal><operator>)</operator>
    <operator>+</operator> <operator>(</operator><call><name>jsonHexToInt</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator>
    <operator>+</operator> <operator>(</operator><call><name>jsonHexToInt</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator>
    <operator>+</operator> <call><name>jsonHexToInt</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Make the JsonNode the return value of the function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonReturn</name><parameter_list>(
  <parameter><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,            <comment type="block">/* Node to return */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,      <comment type="block">/* Return value for this function */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>aReplace</name></decl></parameter>    <comment type="block">/* Array of replacement values */</comment>
)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_TRUE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_FALSE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_INT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <while>while<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>v</name> <init>= <expr><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator> <operator>-</operator> <literal type="char">'0'</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>LARGEST_INT64</name><operator>/</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><name>LARGEST_INT64</name><operator>/</operator><literal type="number">10</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>int_as_real</name>;</goto></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>int_as_real</name>;</goto></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">9</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>int_as_real</name>;</goto></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>SMALLEST_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <goto>goto <name>int_done</name>;</goto>
            </block_content>}</block></if><else>else<block>{<block_content>
              <goto>goto <name>int_as_real</name>;</goto>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>i</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>v</name></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><name>i</name></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <label><name>int_done</name>:</label>
      <break>break;</break>
      <label><name>int_as_real</name>:</label> <empty_stmt>;</empty_stmt> <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
    </block_content>}</block>
    <case>case <expr><name>JSON_REAL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifdef>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_STRING</name></expr>:</case> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* Never happens because JNODE_RAW is only set by json_set(),
      ** json_insert() and json_replace() and those routines do not
      ** call jsonReturn() */</comment>
      if( pNode-&gt;jnFlags &amp; JNODE_RAW ){
        assert( pNode-&gt;eU==1 );
        sqlite3_result_text(pCtx, pNode-&gt;u.zJContent, pNode-&gt;n,
                            SQLITE_TRANSIENT);
      }else 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_RAW</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_ESCAPE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* JSON formatted without any backslash-escapes */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>,
                            <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Translate JSON formatted string into raw text */</comment>
        <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u32</name></type> <name>n</name> <init>= <expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u32</name></type> <name>j</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'u'</literal></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>u32</name></type> <name>v</name> <init>= <expr><call><name>jsonHexToInt4</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
              <if_stmt><if>if<condition>( <expr><name>v</name><operator>&lt;=</operator><literal type="number">0x7f</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>v</name><operator>&lt;=</operator><literal type="number">0x7ff</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><literal type="number">0xc0</literal> <operator>|</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>v</name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
              </block_content>}</block></if><else>else<block>{<block_content>
                <decl_stmt><decl><type><name>u32</name></type> <name>vlo</name></decl>;</decl_stmt>
                <if_stmt><if>if<condition>( <expr><operator>(</operator><name>v</name><operator>&amp;</operator><literal type="number">0xfc00</literal><operator>)</operator><operator>==</operator><literal type="number">0xd800</literal>
                  <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>n</name><operator>-</operator><literal type="number">6</literal>
                  <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\\'</literal>
                  <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'u'</literal>
                  <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>vlo</name> <operator>=</operator> <call><name>jsonHexToInt4</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><name>i</name><operator>+</operator><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>&amp;</operator><literal type="number">0xfc00</literal><operator>)</operator><operator>==</operator><literal type="number">0xdc00</literal></expr>
                )</condition><block>{<block_content>
                  <comment type="block">/* We have a surrogate pair */</comment>
                  <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>v</name><operator>&amp;</operator><literal type="number">0x3ff</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">10</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>vlo</name><operator>&amp;</operator><literal type="number">0x3ff</literal><operator>)</operator> <operator>+</operator> <literal type="number">0x10000</literal></expr>;</expr_stmt>
                  <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0xf0</literal> <operator>|</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">18</literal><operator>)</operator></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>v</name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
                </block_content>}</block></if><else>else<block>{<block_content>
                  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0xe0</literal> <operator>|</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>v</name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'b'</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'f'</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'n'</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'r'</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'t'</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_ARRAY</name></expr>:</case>
    <case>case <expr><name>JSON_OBJECT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>jsonReturnJson</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>aReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Forward reference */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>jsonParseAddNode</name><parameter_list>(<parameter><decl><type><name>JsonParse</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>u32</name></type></decl></parameter>,<parameter><decl><type><name>u32</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** A macro to hint to the compiler that a function should not be
** inlined.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_NOINLINE</name></cpp:macro>  <cpp:value>__attribute__((noinline))</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name><operator>&gt;=</operator><literal type="number">1310</literal></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_NOINLINE</name></cpp:macro>  <cpp:value>__declspec(noinline)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_NOINLINE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>JSON_NOINLINE</name> <name>int</name></type> <name>jsonParseAddNodeExpand</name><parameter_list>(
  <parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Append the node to this object */</comment>
  <parameter><decl><type><name>u32</name></type> <name>eType</name></decl></parameter>,                <comment type="block">/* Node type */</comment>
  <parameter><decl><type><name>u32</name></type> <name>n</name></decl></parameter>,                    <comment type="block">/* Content size or sub-node count */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zContent</name></decl></parameter>      <comment type="block">/* Content */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>nNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>&gt;=</operator><name><name>pParse</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nNew</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonNode</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>&lt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>zContent</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new JsonNode instance based on the arguments and append that
** instance to the JsonParse.  Return the index in pParse-&gt;aNode[] of the
** new node, or -1 if a memory allocation fails.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonParseAddNode</name><parameter_list>(
  <parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Append the node to this object */</comment>
  <parameter><decl><type><name>u32</name></type> <name>eType</name></decl></parameter>,                <comment type="block">/* Node type */</comment>
  <parameter><decl><type><name>u32</name></type> <name>n</name></decl></parameter>,                    <comment type="block">/* Content size or sub-node count */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zContent</name></decl></parameter>      <comment type="block">/* Content */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>&gt;=</operator><name><name>pParse</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>jsonParseAddNodeExpand</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>zContent</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>eType</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VVA</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eU</name></name> <operator>=</operator> <ternary><condition><expr><name>zContent</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name> <operator>=</operator> <name>zContent</name></expr>;</expr_stmt>
  <return>return <expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if z[] begins with 4 (or more) hexadecimal digits
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonIs4Hex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3Isxdigit</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Parse a single JSON value which begins at pParse-&gt;zJson[i].  Return the
** index of the first character past the end of the value parsed.
**
** Return negative for a syntax error.  Special cases:  return -2 if the
** first non-whitespace character is '}' and return -3 if the first
** non-whitespace character is ']'.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonParseValue</name><parameter_list>(<parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iThis</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name></name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><call><name>fast_isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>==</operator><literal type="char">'{'</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Parse object */</comment>
    <expr_stmt><expr><name>iThis</name> <operator>=</operator> <call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_OBJECT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iThis</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</init><condition>;</condition><incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <while>while<condition>( <expr><call><name>fast_isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>iDepth</name></name> <operator>&gt;</operator> <name>JSON_MAX_DEPTH</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jsonParseValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iDepth</name></name><operator>--</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name>iThis</name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>JSON_STRING</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>|=</operator> <name>JNODE_LABEL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>fast_isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><literal type="char">':'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jsonParseValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iDepth</name></name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>fast_isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">','</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">'}'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iThis</name></expr>]</index></name><operator>.</operator><name>n</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name> <operator>-</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>iThis</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Parse array */</comment>
    <expr_stmt><expr><name>iThis</name> <operator>=</operator> <call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_ARRAY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iThis</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iThis</name></expr>]</index></name><operator>.</operator><name>u</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iThis</name></expr>]</index></name><operator>.</operator><name>u</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</init><condition>;</condition><incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <while>while<condition>( <expr><call><name>fast_isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>iDepth</name></name> <operator>&gt;</operator> <name>JSON_MAX_DEPTH</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jsonParseValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>iDepth</name></name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name>iThis</name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>fast_isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">','</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">']'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iThis</name></expr>]</index></name><operator>.</operator><name>n</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name> <operator>-</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>iThis</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Parse string */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name>jnFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x1f</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Control characters are not allowed in strings */</comment>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><operator>++</operator><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\\'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'/'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'b'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'f'</literal>
           <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'n'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'r'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'t'</literal>
           <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="char">'u'</literal> <operator>&amp;&amp;</operator> <call><name>jsonIs4Hex</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>jnFlags</name> <operator>=</operator> <name>JNODE_ESCAPE</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_STRING</name></expr></argument>, <argument><expr><name>j</name><operator>+</operator><literal type="number">1</literal><operator>-</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>=</operator> <name>jnFlags</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'n'</literal>
         <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><name>i</name></expr></argument>,<argument><expr><literal type="string">"null"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3Isalnum</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>i</name><operator>+</operator><literal type="number">4</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'t'</literal>
         <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><name>i</name></expr></argument>,<argument><expr><literal type="string">"true"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3Isalnum</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_TRUE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>i</name><operator>+</operator><literal type="number">4</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'f'</literal>
         <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><name>i</name></expr></argument>,<argument><expr><literal type="string">"false"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3Isalnum</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>i</name><operator>+</operator><literal type="number">5</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'-'</literal> <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <comment type="block">/* Parse number */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name>seenDP</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>seenE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="char">'-'</literal> <operator>&lt;</operator> <literal type="char">'0'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;=</operator><literal type="char">'0'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <ternary><condition><expr><name>c</name><operator>==</operator><literal type="char">'-'</literal></expr> ?</condition><then> <expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init>;</init><condition>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>seenDP</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>seenDP</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'e'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'E'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>&lt;</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>seenE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>seenDP</name> <operator>=</operator> <name>seenE</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'+'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>c</name><argument_list type="generic">&lt;<argument><expr><literal type="char">'0'</literal> <operator>||</operator> <name>c</name></expr></argument>&gt;</argument_list></name><literal type="char">'9'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>&lt;</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><ternary><condition><expr><name>seenDP</name></expr> ?</condition><then> <expr><name>JSON_REAL</name></expr> </then><else>: <expr><name>JSON_INT</name></expr></else></ternary></expr></argument>,
                        <argument><expr><name>j</name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>j</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'}'</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>  <comment type="block">/* End of {...} */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">']'</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">3</literal></expr>;</return>  <comment type="block">/* End of [...] */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* End of file */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Syntax error */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Parse a complete JSON string.  Return 0 on success or non-zero if there
** are any errors.  If an error occurs, free all memory associated with
** pParse.
**
** pParse is uninitialized when this routine is called.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonParse</name><parameter_list>(
  <parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,           <comment type="block">/* Initialize and fill this JsonParse object */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,       <comment type="block">/* Report errors here */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zJson</name></decl></parameter>            <comment type="block">/* Input JSON text to be parsed */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pParse</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zJson</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name></name> <operator>=</operator> <name>zJson</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>jsonParseValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>iDepth</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><call><name>fast_isspace</name><argument_list>(<argument><expr><name><name>zJson</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if<condition>( <expr><name><name>zJson</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pCtx</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"malformed JSON"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Mark node i of pParse as being a child of iParent.  Call recursively
** to fill in all the descendants of node i.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonParseFillInParentage</name><parameter_list>(<parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iParent</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aUp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>iParent</name></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>JSON_ARRAY</name></expr>:</case> <block>{<block_content>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;=</operator><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>j</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><name>pNode</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>jsonParseFillInParentage</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_OBJECT</name></expr>:</case> <block>{<block_content>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;=</operator><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>j</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><name>pNode</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aUp</name><index>[<expr><name>i</name><operator>+</operator><name>j</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jsonParseFillInParentage</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Compute the parentage of all nodes in a completed parse.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonParseFindParents</name><parameter_list>(<parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aUp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aUp</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aUp</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>aUp</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aUp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>jsonParseFillInParentage</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Magic number used for the JSON parse cache in sqlite3_get_auxdata()
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_CACHE_ID</name></cpp:macro>  <cpp:value>(-429938)</cpp:value></cpp:define>  <comment type="block">/* First cache entry */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_CACHE_SZ</name></cpp:macro>  <cpp:value>4</cpp:value></cpp:define>          <comment type="block">/* Max number of cache entries */</comment>

<comment type="block">/*
** Obtain a complete parse of the JSON found in the first argument
** of the argv array.  Use the sqlite3_get_auxdata() cache for this
** parse if it is available.  If the cache is not available or if it
** is no longer valid, parse the JSON again and return the new parse,
** and also register the new parse so that it will be available for
** future sqlite3_get_auxdata() calls.
*/</comment>
<function><type><specifier>static</specifier> <name>JsonParse</name> <modifier>*</modifier></type><name>jsonParseCached</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pErrCtx</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zJson</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nJson</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pMatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iMinKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iMinHold</name> <init>= <expr><literal type="number">0xffffffff</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iMaxHold</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zJson</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>iKey</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iKey</name><operator>&lt;</operator><name>JSON_CACHE_SZ</name></expr>;</condition> <incr><expr><name>iKey</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>JsonParse</name><operator>*</operator><operator>)</operator><call><name>sqlite3_get_auxdata</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>JSON_CACHE_ID</name><operator>+</operator><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iMinKey</name> <operator>=</operator> <name>iKey</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pMatch</name><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nJson</name></name><operator>==</operator><name>nJson</name>
     <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name></expr></argument>,<argument><expr><name>zJson</name></expr></argument>,<argument><expr><name>nJson</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nErr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMatch</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iHold</name></name><operator>&lt;</operator><name>iMinHold</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iMinHold</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iHold</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iMinKey</name> <operator>=</operator> <name>iKey</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iHold</name></name><operator>&gt;</operator><name>iMaxHold</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iMaxHold</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iHold</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>pMatch</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pMatch</name><operator>-&gt;</operator><name>nErr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMatch</name><operator>-&gt;</operator><name>iHold</name></name> <operator>=</operator> <name>iMaxHold</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>pMatch</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nJson</name> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name></expr></argument>, <argument><expr><name>zJson</name></expr></argument>, <argument><expr><name>nJson</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pErrCtx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nJson</name></name> <operator>=</operator> <name>nJson</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iHold</name></name> <operator>=</operator> <name>iMaxHold</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_set_auxdata</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>JSON_CACHE_ID</name><operator>+</operator><name>iMinKey</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,
                      <argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>jsonParseFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>JsonParse</name><operator>*</operator><operator>)</operator><call><name>sqlite3_get_auxdata</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>JSON_CACHE_ID</name><operator>+</operator><name>iMinKey</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare the OBJECT label at pNode against zKey,nKey.  Return true on
** a match.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonLabelCompare</name><parameter_list>(<parameter><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>nKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_RAW</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name><operator>!=</operator><name>nKey</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name><operator>!=</operator><name>nKey</name><operator>+</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>JsonNode</name> <modifier>*</modifier></type><name>jsonLookupAppend</name><parameter_list>(<parameter><decl><type><name>JsonParse</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Search along zPath to find the node specified.  Return a pointer
** to that node, or NULL if zPath is malformed or if there is no such
** node.
**
** If pApnd!=0, then try to append new nodes to complete zPath if it is
** possible to do so and if no existing node corresponds to zPath.  If
** new nodes are appended *pApnd is set to 1.
*/</comment>
<function><type><specifier>static</specifier> <name>JsonNode</name> <modifier>*</modifier></type><name>jsonLookupStep</name><parameter_list>(
  <parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* The JSON to search */</comment>
  <parameter><decl><type><name>u32</name></type> <name>iRoot</name></decl></parameter>,              <comment type="block">/* Begin the search at this node */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,      <comment type="block">/* The path to search */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pApnd</name></decl></parameter>,             <comment type="block">/* Append nodes to complete path if not NULL */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>      <comment type="block">/* Make *pzErr point to any syntax error in zPath */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>nKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pRoot</name> <init>= <expr><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>pRoot</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pRoot</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_REPLACE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pRoot</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>JSON_OBJECT</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zPath</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zKey</name> <operator>=</operator> <name>zPath</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>zPath</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zPath</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'"'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name>i</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <name>zPath</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nKey</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zKey</name> <operator>=</operator> <name>zPath</name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zPath</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zPath</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>zPath</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'['</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nKey</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <name>zPath</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
      <while>while<condition>( <expr><name>j</name><operator>&lt;=</operator><name><name>pRoot</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>jsonLabelCompare</name><argument_list>(<argument><expr><name>pRoot</name><operator>+</operator><name>j</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <return>return <expr><call><name>jsonLookupStep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iRoot</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zPath</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pApnd</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pRoot</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRoot</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_APPEND</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iRoot</name> <operator>+=</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iAppend</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>pApnd</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iStart</name></decl>, <decl><type ref="prev"/><name>iLabel</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>iStart</name> <operator>=</operator> <call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_OBJECT</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iLabel</name> <operator>=</operator> <call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_STRING</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zPath</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookupAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pApnd</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iAppend</name></name> <operator>=</operator> <name>iStart</name> <operator>-</operator> <name>iRoot</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>|=</operator> <name>JNODE_APPEND</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VVA</name><argument_list>( <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>eU</name></name> <operator>=</operator> <literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iLabel</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>|=</operator> <name>JNODE_RAW</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>pNode</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><name><name>zPath</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name> <operator>=</operator> <name>i</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name><name>zPath</name><index>[<expr><name>j</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><literal type="number">2</literal> <operator>||</operator> <name><name>zPath</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><literal type="char">']'</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'#'</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pBase</name> <init>= <expr><name>pRoot</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iBase</name> <init>= <expr><name>iRoot</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pRoot</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>JSON_ARRAY</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
          <while>while<condition>( <expr><name>j</name><operator>&lt;=</operator><name><name>pBase</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pBase</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REMOVE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>j</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBase</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></while>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pBase</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_APPEND</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBase</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iBase</name> <operator>+=</operator> <name><name>pBase</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iAppend</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pBase</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iBase</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><name><name>zPath</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          <do>do<block>{<block_content>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <name>x</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name><name>zPath</name><index>[<expr><name>j</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block>while<condition>( <expr><call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><name><name>zPath</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition>;</do>
          <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;</operator><name>i</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>i</name> <operator>-=</operator> <name>x</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><literal type="char">']'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <name>zPath</name></expr>;</expr_stmt>
          <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <name>zPath</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pRoot</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>JSON_ARRAY</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zPath</name> <operator>+=</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
      <while>while<condition>( <expr><name>j</name><operator>&lt;=</operator><name><name>pRoot</name><operator>-&gt;</operator><name>n</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pRoot</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REMOVE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRoot</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REMOVE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>j</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pRoot</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRoot</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_APPEND</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iRoot</name> <operator>+=</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iAppend</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;=</operator><name><name>pRoot</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>jsonLookupStep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iRoot</name><operator>+</operator><name>j</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pApnd</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pApnd</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iStart</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>iStart</name> <operator>=</operator> <call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_ARRAY</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookupAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pApnd</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iAppend</name></name> <operator>=</operator> <name>iStart</name> <operator>-</operator> <name>iRoot</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>|=</operator> <name>JNODE_APPEND</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VVA</name><argument_list>( <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>eU</name></name> <operator>=</operator> <literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>pNode</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <name>zPath</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append content to pParse that will complete zPath.  Return a pointer
** to the inserted node, or return NULL if the append fails.
*/</comment>
<function><type><specifier>static</specifier> <name>JsonNode</name> <modifier>*</modifier></type><name>jsonLookupAppend</name><parameter_list>(
  <parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Append content to the JSON parse */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,     <comment type="block">/* Description of content to append */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pApnd</name></decl></parameter>,            <comment type="block">/* Set this flag to 1 */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>     <comment type="block">/* Make this point to any syntax error */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pApnd</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_OBJECT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>,<argument><expr><literal type="string">"[0]"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_ARRAY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>jsonLookupStep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pApnd</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the text of a syntax error message on a JSON path.  Space is
** obtained from sqlite3_malloc().
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>jsonPathSyntaxError</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"JSON path error near '%q'"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Do a node lookup using zPath.  Return a pointer to the node on success.
** Return NULL if not found or if there is an error.
**
** On an error, write an error message into pCtx and increment the
** pParse-&gt;nErr counter.
**
** If pApnd!=NULL then try to append missing nodes and set *pApnd = 1 if
** nodes are appended.
*/</comment>
<function><type><specifier>static</specifier> <name>JsonNode</name> <modifier>*</modifier></type><name>jsonLookup</name><parameter_list>(
  <parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* The JSON to search */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,      <comment type="block">/* The path to search */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pApnd</name></decl></parameter>,             <comment type="block">/* Append nodes to complete path if not NULL */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>   <comment type="block">/* Report errors here, if not NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zPath</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'$'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zErr</name> <operator>=</operator> <name>zPath</name></expr>;</expr_stmt>
    <goto>goto <name>lookup_err</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zPath</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookupStep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pApnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zErr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>pNode</name></expr>;</return></block_content></block></if></if_stmt>

<label><name>lookup_err</name>:</label>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zErr</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pCtx</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>jsonPathSyntaxError</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zMsg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Report the wrong number of arguments for json_insert(), json_replace()
** or json_set().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonWrongNumArgs</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFuncName</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"json_%s() needs an odd number of arguments"</literal></expr></argument>,
                               <argument><expr><name>zFuncName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>     
</block_content>}</block></function>

<comment type="block">/*
** Mark all NULL entries in the Object passed in as JNODE_REMOVE.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonRemoveAllNulls</name><parameter_list>(<parameter><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_OBJECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></incr>)</control><block>{<block_content>
    <switch>switch<condition>( <expr><name><name>pNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eType</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>JSON_NULL</name></expr>:</case>
        <expr_stmt><expr><name><name>pNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>|=</operator> <name>JNODE_REMOVE</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>JSON_OBJECT</name></expr>:</case>
        <expr_stmt><expr><call><name>jsonRemoveAllNulls</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************************
** SQL functions used for testing and debugging
****************************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** The json_parse(JSON) function returns a string which describes
** a parse of the JSON provided.  Or it returns NULL if JSON is not
** well-formed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonParseFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonString</name></type> <name>s</name></decl>;</decl_stmt>       <comment type="block">/* Output string - not real JSON */</comment>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>x</name></decl>;</decl_stmt>        <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>jsonParseFindParents</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>x</name><operator>.</operator><name>nNode</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_LABEL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eType</name><operator>==</operator><name>JSON_STRING</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"label"</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <name><name>jsonType</name><index>[<expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eType</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>jsonPrintf</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>,<argument><expr><literal type="string">"node %3u: %7s n=%-4d up=%-4d"</literal></expr></argument>,
               <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>aUp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>zJContent</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>zJContent</name></name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The json_test1(JSON) function return true (1) if the input is JSON
** text generated by another json function.  It returns (0) if the input
** is not known to be JSON.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonTest1Func</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>sqlite3_value_subtype</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>

<comment type="block" format="doxygen">/****************************************************************************
** Scalar SQL function implementations
****************************************************************************/</comment>

<comment type="block">/*
** Implementation of the json_QUOTE(VALUE) function.  Return a JSON value
** corresponding to the SQL value input.  Mostly this means putting 
** double-quotes around strings and returning the unquoted string "null"
** when given a NULL input.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonQuoteFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonString</name></type> <name>jx</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonAppendValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the json_array(VALUE,...) function.  Return a JSON
** array that contains all values given in arguments.  Or if any argument
** is a BLOB, throw an error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonArrayFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonString</name></type> <name>jx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>jsonAppendSeparator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** json_array_length(JSON)
** json_array_length(JSON, PATH)
**
** Return the number of elements in the top-level JSON array.  
** Return 0 if the input is not a well-formed JSON array.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonArrayLengthFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>          <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>jsonParseCached</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aNode</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_ARRAY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_APPEND</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>i</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Bit values for the flags passed into jsonExtractFunc() or
** jsonSetFunc() via the user-data value.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_JSON</name></cpp:macro>      <cpp:value>0x01</cpp:value></cpp:define>        <comment type="block">/* Result is always JSON */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_SQL</name></cpp:macro>       <cpp:value>0x02</cpp:value></cpp:define>        <comment type="block">/* Result is always SQL */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_ABPATH</name></cpp:macro>    <cpp:value>0x03</cpp:value></cpp:define>        <comment type="block">/* Allow abbreviated JSON path specs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_ISSET</name></cpp:macro>     <cpp:value>0x04</cpp:value></cpp:define>        <comment type="block">/* json_set(), not json_insert() */</comment>

<comment type="block">/*
** json_extract(JSON, PATH, ...)
** "-&gt;"(JSON,PATH)
** "-&gt;&gt;"(JSON,PATH)
**
** Return the element described by PATH.  Return NULL if that PATH element
** is not found.
**
** If JSON_JSON is set or if more that one PATH argument is supplied then
** always return a JSON representation of the result.  If JSON_SQL is set,
** then always return an SQL representation of the result.  If neither flag
** is present and argc==2, then return JSON for objects and arrays and SQL
** for all other values.
**
** When multiple PATH arguments are supplied, the result is a JSON array
** containing the result of each PATH.
**
** Abbreviated JSON path expressions are allows if JSON_ABPATH, for
** compatibility with PG.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonExtractFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>          <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonString</name></type> <name>jx</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>jsonParseCached</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* With a single PATH argument */</comment>
    <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zPath</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>JSON_ABPATH</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'$'</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* The -&gt; and -&gt;&gt; operators accept abbreviated PATH arguments.  This
        ** is mostly for compatibility with PostgreSQL, but also for
        ** convenience.
        **
        **     NUMBER   ==&gt;  $[NUMBER]     // PG compatible
        **     LABEL    ==&gt;  $.LABEL       // PG compatible
        **     [NUMBER] ==&gt;  $[NUMBER]     // Not PG.  Purely for convenience
        */</comment>
        <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3Isdigit</name><argument_list>(<argument><expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="string">"$["</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="string">"$."</literal></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'['</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>pNode</name> <operator>=</operator> <ternary><condition><expr><name><name>jx</name><operator>.</operator><name>bErr</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>jsonLookup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>jx</name><operator>.</operator><name>zBuf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jsonReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>JSON_JSON</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>jsonReturnJson</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>jsonReturn</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pNode</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>jsonReturn</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Two or more PATH arguments results in a JSON array with each
    ** element of the array being the value selected by one of the PATHs */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>jsonAppendSeparator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>jsonRenderNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>argc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>jsonReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This is the RFC 7396 MergePatch algorithm.
*/</comment>
<function><type><specifier>static</specifier> <name>JsonNode</name> <modifier>*</modifier></type><name>jsonMergePatch</name><parameter_list>(
  <parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,   <comment type="block">/* The JSON parser that contains the TARGET */</comment>
  <parameter><decl><type><name>u32</name></type> <name>iTarget</name></decl></parameter>,         <comment type="block">/* Node of the TARGET in pParse */</comment>
  <parameter><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pPatch</name></decl></parameter>     <comment type="block">/* The PATCH */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iRoot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pTarget</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPatch</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>JSON_OBJECT</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>pPatch</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTarget</name><operator>&lt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTarget</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iTarget</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPatch</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_APPEND</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTarget</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>JSON_OBJECT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonRemoveAllNulls</name><argument_list>(<argument><expr><name>pPatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>pPatch</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iRoot</name> <operator>=</operator> <name>iTarget</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pPatch</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPatch</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>nKey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eType</name><operator>==</operator><name>JSON_STRING</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_LABEL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name><name>pPatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zKey</name> <operator>=</operator> <name><name>pPatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>zJContent</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_RAW</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pTarget</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>j</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTarget</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></incr> )</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTarget</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>eType</name><operator>==</operator><name>JSON_STRING</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTarget</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_LABEL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_RAW</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pTarget</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>n</name><operator>==</operator><name>nKey</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>pTarget</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>zJContent</name></name></expr></argument>,<argument><expr><name>zKey</name></expr></argument>,<argument><expr><name>nKey</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pTarget</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <operator>(</operator><name>JNODE_REMOVE</name><operator>|</operator><name>JNODE_PATCH</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pPatch</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>eType</name><operator>==</operator><name>JSON_NULL</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pTarget</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>|=</operator> <name>JNODE_REMOVE</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>jsonMergePatch</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iTarget</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPatch</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>pTarget</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iTarget</name></expr>]</index></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>!=</operator><operator>&amp;</operator><name><name>pTarget</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTarget</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">0</literal>
                 <operator>||</operator> <name><name>pTarget</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">1</literal>
                 <operator>||</operator> <name><name>pTarget</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTarget</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pTarget</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>VVA</name><argument_list>( <argument><expr><name><name>pTarget</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>eU</name> <operator>=</operator> <literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pTarget</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>pPatch</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pTarget</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>|=</operator> <name>JNODE_PATCH</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><name><name>pTarget</name><operator>-&gt;</operator><name>n</name></name> <operator>&amp;&amp;</operator> <name><name>pPatch</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>eType</name><operator>!=</operator><name>JSON_NULL</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iStart</name></decl>, <decl><type ref="prev"/><name>iPatch</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>iStart</name> <operator>=</operator> <call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_OBJECT</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_STRING</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iPatch</name> <operator>=</operator> <call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_TRUE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>jsonRemoveAllNulls</name><argument_list>(<argument><expr><name>pPatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTarget</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iTarget</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>|=</operator> <name>JNODE_APPEND</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VVA</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name><operator>.</operator><name>eU</name> <operator>=</operator> <literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>iAppend</name></name> <operator>=</operator> <name>iStart</name> <operator>-</operator> <name>iRoot</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iRoot</name> <operator>=</operator> <name>iStart</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iPatch</name></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VVA</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iPatch</name></expr>]</index></name><operator>.</operator><name>eU</name> <operator>=</operator> <literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iPatch</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>|=</operator> <name>JNODE_PATCH</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iPatch</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>pPatch</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pPatch</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>pTarget</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the json_mergepatch(JSON1,JSON2) function.  Return a JSON
** object that is the result of running the RFC 7396 MergePatch() algorithm
** on the two arguments.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonPatchFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>x</name></decl>;</decl_stmt>     <comment type="block">/* The JSON that is being patched */</comment>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>y</name></decl>;</decl_stmt>     <comment type="block">/* The patch */</comment>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pResult</name></decl>;</decl_stmt>   <comment type="block">/* The result of the merge */</comment>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pResult</name> <operator>=</operator> <call><name>jsonMergePatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>y</name><operator>.</operator><name>aNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pResult</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>x</name><operator>.</operator><name>oom</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pResult</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonReturnJson</name><argument_list>(<argument><expr><name>pResult</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Implementation of the json_object(NAME,VALUE,...) function.  Return a JSON
** object that contains all name/value given in arguments.  Or if any name
** is not a string or if any value is a BLOB, throw an error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonObjectFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonString</name></type> <name>jx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>n</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&amp;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"json_object() requires an even number "</literal>
                                  <literal type="string">"of arguments"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"json_object() labels must be TEXT"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>jsonAppendSeparator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** json_remove(JSON, PATH, ...)
**
** Remove the named elements from JSON and return the result.  malformed
** JSON or PATH arguments result in an error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonRemoveFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>x</name></decl>;</decl_stmt>          <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>nNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zPath</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>remove_done</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>remove_done</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>|=</operator> <name>JNODE_REMOVE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REMOVE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonReturnJson</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>aNode</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<label><name>remove_done</name>:</label>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** json_replace(JSON, PATH, VALUE, ...)
**
** Replace the value at PATH with VALUE.  If PATH does not already exist,
** this routine is a no-op.  If JSON or PATH is malformed, throw an error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonReplaceFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>x</name></decl>;</decl_stmt>          <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>argc</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>jsonWrongNumArgs</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"replace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>nNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>replace_err</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>!=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>|=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>JNODE_REPLACE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VVA</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name> <operator>=</operator>  <literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iReplace</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REPLACE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>iReplace</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>jsonReturnJson</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>aNode</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<label><name>replace_err</name>:</label>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** json_set(JSON, PATH, VALUE, ...)
**
** Set the value at PATH to VALUE.  Create the PATH if it does not already
** exist.  Overwrite existing values that do exist.
** If JSON or PATH is malformed, throw an error.
**
** json_insert(JSON, PATH, VALUE, ...)
**
** Create PATH and initialize it to VALUE.  If PATH already exists, this
** routine is a no-op.  If JSON or PATH is malformed, throw an error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonSetFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>x</name></decl>;</decl_stmt>          <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bApnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bIsSet</name> <init>= <expr><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>argc</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>jsonWrongNumArgs</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><ternary><condition><expr><name>bIsSet</name></expr> ?</condition><then> <expr><literal type="string">"set"</literal></expr> </then><else>: <expr><literal type="string">"insert"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>nNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bApnd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bApnd</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>oom</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>jsonSetDone</name>;</goto>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>x</name><operator>.</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
      <goto>goto <name>jsonSetDone</name>;</goto>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pNode</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>bApnd</name> <operator>||</operator> <name>bIsSet</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>!=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>!=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>!=</operator><literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VVA</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name> <operator>=</operator> <literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>|=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>JNODE_REPLACE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iReplace</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REPLACE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>iReplace</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>jsonReturnJson</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>aNode</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<label><name>jsonSetDone</name>:</label>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** json_type(JSON)
** json_type(JSON, PATH)
**
** Return the top-level "type" of a JSON string.  json_type() raises an
** error if either the JSON or PATH inputs are not well-formed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonTypeFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>          <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>jsonParseCached</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aNode</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>jsonType</name><index>[<expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** json_valid(JSON)
**
** Return 1 if JSON is a well-formed JSON string according to RFC-7159.
** Return 0 otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonValidFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>          <comment type="block">/* The parse */</comment>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>jsonParseCached</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************************
** Aggregate SQL function implementations
****************************************************************************/</comment>
<comment type="block">/*
** json_group_array(VALUE)
**
** Return a JSON array composed of all values in the aggregate.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonArrayStep</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>pStr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pStr</name> <operator>=</operator> <operator>(</operator><name>JsonString</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pStr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStr</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>zBuf</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>pCtx</name></name> <operator>=</operator> <name>ctx</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendValue</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonArrayCompute</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isFinal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>pStr</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pStr</name> <operator>=</operator> <operator>(</operator><name>JsonString</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>pCtx</name></name> <operator>=</operator> <name>ctx</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>bErr</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>bErr</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>bStatic</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>isFinal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>,
                          <argument><expr><ternary><condition><expr><name><name>pStr</name><operator>-&gt;</operator><name>bStatic</name></name></expr> ?</condition><then> <expr><name>SQLITE_TRANSIENT</name></expr> </then><else>: <expr><name>sqlite3_free</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>bStatic</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonArrayValue</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>jsonArrayCompute</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonArrayFinal</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>jsonArrayCompute</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WINDOWFUNC</name></cpp:ifndef>
<comment type="block">/*
** This method works for both json_group_array() and json_group_object().
** It works by removing the first element of the group by searching forward
** to the first comma (",") that is not within a string and deleting all
** text through that comma.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonGroupInverse</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>inStr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nNest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>pStr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pStr</name> <operator>=</operator> <operator>(</operator><name>JsonString</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEVER</name></cpp:ifdef>
  <comment type="block">/* pStr is always non-NULL since jsonArrayStep() or jsonObjectStep() will
  ** always have been called to initalize it */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><operator>!</operator><name>pStr</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>pStr</name><operator>-&gt;</operator><name>zBuf</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="char">','</literal> <operator>||</operator> <name>inStr</name> <operator>||</operator> <name>nNest</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>inStr</name> <operator>=</operator> <operator>!</operator><name>inStr</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><name>inStr</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'{'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nNest</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'}'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">']'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nNest</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>jsonGroupInverse</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** json_group_obj(NAME,VALUE)
**
** Return a JSON object composed of all names and values in the aggregate.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonObjectStep</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>pStr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pStr</name> <operator>=</operator> <operator>(</operator><name>JsonString</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pStr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStr</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>zBuf</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>pCtx</name></name> <operator>=</operator> <name>ctx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendString</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendValue</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonObjectCompute</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isFinal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>pStr</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pStr</name> <operator>=</operator> <operator>(</operator><name>JsonString</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>bErr</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>bErr</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>bStatic</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>isFinal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>,
                          <argument><expr><ternary><condition><expr><name><name>pStr</name><operator>-&gt;</operator><name>bStatic</name></name></expr> ?</condition><then> <expr><name>SQLITE_TRANSIENT</name></expr> </then><else>: <expr><name>sqlite3_free</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>bStatic</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"{}"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonObjectValue</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>jsonObjectCompute</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonObjectFinal</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>jsonObjectCompute</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block" format="doxygen">/****************************************************************************
** The json_each virtual table
****************************************************************************/</comment>
<typedef>typedef <type><name><name>struct</name> <name>JsonEachCursor</name></name></type> <name>JsonEachCursor</name>;</typedef>
<struct>struct <name>JsonEachCursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iRowid</name></decl>;</decl_stmt>                <comment type="block">/* The rowid */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iBegin</name></decl>;</decl_stmt>                <comment type="block">/* The first node of the scan */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>                     <comment type="block">/* Index in sParse.aNode[] of current row */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iEnd</name></decl>;</decl_stmt>                  <comment type="block">/* EOF when i equals or exceeds this value */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>eType</name></decl>;</decl_stmt>                  <comment type="block">/* Type of top-level element */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bRecursive</name></decl>;</decl_stmt>             <comment type="block">/* True for json_tree().  False for json_each() */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zJson</name></decl>;</decl_stmt>               <comment type="block">/* Input JSON */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRoot</name></decl>;</decl_stmt>               <comment type="block">/* Path by which to filter zJson */</comment>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>sParse</name></decl>;</decl_stmt>          <comment type="block">/* Parse of the input JSON */</comment>
}</block>;</struct>

<comment type="block">/* Constructor for the json_each virtual table */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<comment type="block">/* Column numbers */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_KEY</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_VALUE</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_TYPE</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_ATOM</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_ID</name></cpp:macro>      <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_PARENT</name></cpp:macro>  <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_FULLKEY</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_PATH</name></cpp:macro>    <cpp:value>7</cpp:value></cpp:define>
<comment type="block">/* The xBestIndex method assumes that the JSON and ROOT columns are
** the last two columns in the table.  Should this ever changes, be
** sure to update the xBestIndex method. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_JSON</name></cpp:macro>    <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_ROOT</name></cpp:macro>    <cpp:value>9</cpp:value></cpp:define>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, 
     <argument><expr><literal type="string">"CREATE TABLE x(key,value,type,atom,id,parent,fullkey,path,"</literal>
                    <literal type="string">"json HIDDEN,root HIDDEN)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>*</operator><name>ppVtab</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_VTAB_INNOCUOUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* destructor for json_each virtual table */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* constructor for a JsonEachCursor object for json_each(). */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachOpenEach</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* constructor for a JsonEachCursor object for json_tree(). */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachOpenTree</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>jsonEachOpenEach</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ppCursor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>JsonEachCursor</name><operator>*</operator><operator>)</operator><operator>*</operator><name>ppCursor</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>bRecursive</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reset a JsonEachCursor back to its original state.  Free any memory
** held. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonEachCursorReset</name><parameter_list>(<parameter><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Destructor for a jsonEachCursor object */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>JsonEachCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>jsonEachCursorReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return TRUE if the jsonEachCursor object has been advanced off the end
** of the JSON object */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>JsonEachCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>iEnd</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Advance the cursor to the next element for json_tree() */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>JsonEachCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRecursive</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_LABEL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>iEnd</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iUp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aUp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pUp</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name>iUp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name><name>pUp</name><operator>-&gt;</operator><name>eType</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pUp</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_ARRAY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pUp</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pUp</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pUp</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VVA</name><argument_list>( <argument><expr><name><name>pUp</name><operator>-&gt;</operator><name>eU</name></name> <operator>=</operator> <literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iUp</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pUp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pUp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iKey</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>JSON_ARRAY</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>JSON_OBJECT</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iEnd</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append an object label to the JSON Path being constructed
** in pStr.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonAppendObjectPathElement</name><parameter_list>(
  <parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>,
  <parameter><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>jj</name></decl>, <decl><type ref="prev"/><name>nn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_STRING</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_LABEL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nn</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nn</name><operator>&gt;=</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'"'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>z</name><index>[<expr><name>nn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'"'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nn</name><operator>&gt;</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3Isalpha</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name>nn</name><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3Isalnum</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>jj</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>jj</name><operator>==</operator><name>nn</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>nn</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>jsonPrintf</name><argument_list>(<argument><expr><name>nn</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">".%.*s"</literal></expr></argument>, <argument><expr><name>nn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append the name of the path for element i to pStr
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonEachComputePath</name><parameter_list>(
  <parameter><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,       <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>,        <comment type="block">/* Write the path here */</comment>
  <parameter><decl><type><name>u32</name></type> <name>i</name></decl></parameter>                    <comment type="block">/* Path to this element */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pUp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iUp</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iUp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aUp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonEachComputePath</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>iUp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pUp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name>iUp</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pUp</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_ARRAY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pUp</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">3</literal> <operator>||</operator> <operator>(</operator><name><name>pUp</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pUp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iKey</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>pUp</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonPrintf</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>, <argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"[%d]"</literal></expr></argument>, <argument><expr><name><name>pUp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pUp</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_OBJECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_LABEL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pNode</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>jsonAppendObjectPathElement</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the value of a column */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,   <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,       <comment type="block">/* First argument to sqlite3_result_...() */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>                       <comment type="block">/* Which column to return */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>JsonEachCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pThis</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>JEACH_KEY</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_OBJECT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>jsonReturn</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_ARRAY</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u32</name></type> <name>iKey</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRecursive</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aUp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>eU</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iKey</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aUp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>iKey</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>iKey</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_VALUE</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pThis</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_LABEL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pThis</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>jsonReturn</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_TYPE</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pThis</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_LABEL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pThis</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>jsonType</name><index>[<expr><name><name>pThis</name><operator>-&gt;</operator><name>eType</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_ATOM</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pThis</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_LABEL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pThis</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pThis</name><operator>-&gt;</operator><name>eType</name></name><operator>&gt;=</operator><name>JSON_ARRAY</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>jsonReturn</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_ID</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, 
         <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>pThis</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_LABEL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_PARENT</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>iBegin</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bRecursive</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aUp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_FULLKEY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>JsonString</name></type> <name>x</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRecursive</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>jsonEachComputePath</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_ARRAY</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>jsonPrintf</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"[%d]"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_OBJECT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>jsonAppendObjectPathElement</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>pThis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_PATH</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRecursive</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>JsonString</name></type> <name>x</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jsonEachComputePath</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aUp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* For json_each() path and root are the same so fall through
      ** into the root case */</comment>
      <comment type="block">/* no break */</comment> <expr_stmt><expr><name>deliberate_fall_through</name></expr></expr_stmt>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRoot</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zRoot</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zRoot</name> <operator>=</operator> <literal type="string">"$"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>zRoot</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_JSON</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name>JEACH_JSON</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>zJson</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the current rowid value */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>JsonEachCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The query strategy is to look for an equality constraint on the json
** column.  Without such a constraint, the table cannot operate.  idxNum is
** 1 if the constraint is found, 3 if the constraint and zRoot are found,
** and 0 otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachBestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                     <comment type="block">/* Loop counter or computed array index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>aIdx</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>               <comment type="block">/* Index of constraints for JSON and ROOT */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>unusableMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Mask of unusable JSON and ROOT constraints */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idxMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Mask of usable == constraints JSON and ROOT */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>

  <comment type="block">/* This implementation assumes that JSON and ROOT are the last two
  ** columns in the table */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>JEACH_ROOT</name> <operator>==</operator> <name>JEACH_JSON</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aIdx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>aIdx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pConstraint</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iMask</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>&lt;</operator> <name>JEACH_JSON</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>-</operator> <name>JEACH_JSON</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iCol</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>iCol</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iMask</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>iCol</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>unusableMask</name> <operator>|=</operator> <name>iMask</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>aIdx</name><index>[<expr><name>iCol</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>idxMask</name> <operator>|=</operator> <name>iMask</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>unusableMask</name> <operator>&amp;</operator> <operator>~</operator><name>idxMask</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there are any unusable constraints on JSON or ROOT, then reject
    ** this entire plan */</comment>
    <return>return <expr><name>SQLITE_CONSTRAINT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>aIdx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* No JSON input.  Leave estimatedCost at the huge value that it was
    ** initialized to to discourage the query planner from selecting this
    ** plan. */</comment>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>aIdx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>aIdx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Only JSON supplied.  Plan 1 */</comment>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>aIdx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>  <comment type="block">/* Both JSON and ROOT are supplied.  Plan 3 */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Start a search on a new JSON string */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>JsonEachCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRoot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>n</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>idxStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonEachCursorReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_NOMEM</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>oom</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"malformed JSON"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>jsonEachCursorReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRecursive</name></name> <operator>&amp;&amp;</operator> <call><name>jsonParseFindParents</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonEachCursorReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>zRoot</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zRoot</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name></expr></argument>, <argument><expr><name>zRoot</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>zRoot</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'$'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zErr</name> <operator>=</operator> <name>zRoot</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookupStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>jsonPathSyntaxError</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jsonEachCursorReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><ternary><condition><expr><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> ?</condition><then> <expr><name>SQLITE_ERROR</name></expr> </then><else>: <expr><name>SQLITE_NOMEM</name></expr></else></ternary></expr>;</return>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pNode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iBegin</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pNode</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>&gt;=</operator><name>JSON_ARRAY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VVA</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eU</name></name> <operator>=</operator> <literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iEnd</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>+</operator> <name><name>pNode</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRecursive</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aUp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>eType</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_LABEL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iEnd</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The methods of the json_each virtual table */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>jsonEachModule</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* iVersion */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCreate */</comment>
  <expr><name>jsonEachConnect</name></expr>,           <comment type="block">/* xConnect */</comment>
  <expr><name>jsonEachBestIndex</name></expr>,         <comment type="block">/* xBestIndex */</comment>
  <expr><name>jsonEachDisconnect</name></expr>,        <comment type="block">/* xDisconnect */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xDestroy */</comment>
  <expr><name>jsonEachOpenEach</name></expr>,          <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>jsonEachClose</name></expr>,             <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>jsonEachFilter</name></expr>,            <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>jsonEachNext</name></expr>,              <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>jsonEachEof</name></expr>,               <comment type="block">/* xEof - check for end of scan */</comment>
  <expr><name>jsonEachColumn</name></expr>,            <comment type="block">/* xColumn - read data */</comment>
  <expr><name>jsonEachRowid</name></expr>,             <comment type="block">/* xRowid - read data */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xUpdate */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xBegin */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSync */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCommit */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollback */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xFindMethod */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRename */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSavepoint */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRelease */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollbackTo */</comment>
  <expr><literal type="number">0</literal></expr>                          <comment type="block">/* xShadowName */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* The methods of the json_tree virtual table. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>jsonTreeModule</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* iVersion */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCreate */</comment>
  <expr><name>jsonEachConnect</name></expr>,           <comment type="block">/* xConnect */</comment>
  <expr><name>jsonEachBestIndex</name></expr>,         <comment type="block">/* xBestIndex */</comment>
  <expr><name>jsonEachDisconnect</name></expr>,        <comment type="block">/* xDisconnect */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xDestroy */</comment>
  <expr><name>jsonEachOpenTree</name></expr>,          <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>jsonEachClose</name></expr>,             <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>jsonEachFilter</name></expr>,            <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>jsonEachNext</name></expr>,              <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>jsonEachEof</name></expr>,               <comment type="block">/* xEof - check for end of scan */</comment>
  <expr><name>jsonEachColumn</name></expr>,            <comment type="block">/* xColumn - read data */</comment>
  <expr><name>jsonEachRowid</name></expr>,             <comment type="block">/* xRowid - read data */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xUpdate */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xBegin */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSync */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCommit */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollback */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xFindMethod */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRename */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSavepoint */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRelease */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollbackTo */</comment>
  <expr><literal type="number">0</literal></expr>                          <comment type="block">/* xShadowName */</comment>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_JSON) */</comment>

<comment type="block">/*
** Register JSON functions.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RegisterJsonFunctions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_JSON</name></cpp:ifndef>
  <decl_stmt><decl><type><specifier>static</specifier> <name>FuncDef</name></type> <name><name>aJsonFunc</name><index>[]</index></name> <init>= <expr><block>{
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json</name></expr></argument>,               <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonRemoveFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_array</name></expr></argument>,        <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonArrayFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_array_length</name></expr></argument>,  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonArrayLengthFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_array_length</name></expr></argument>,  <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonArrayLengthFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_extract</name></expr></argument>,      <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonExtractFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><operator>-&gt;</operator></expr></argument>,                 <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>JSON_JSON</name></expr></argument>, <argument><expr><name>jsonExtractFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><operator>-&gt;</operator><operator>&gt;</operator></expr></argument>,                <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>JSON_SQL</name></expr></argument>, <argument><expr><name>jsonExtractFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_insert</name></expr></argument>,       <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonSetFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_object</name></expr></argument>,       <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonObjectFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_patch</name></expr></argument>,         <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonPatchFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_quote</name></expr></argument>,         <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonQuoteFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_remove</name></expr></argument>,       <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonRemoveFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_replace</name></expr></argument>,      <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonReplaceFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_set</name></expr></argument>,          <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>JSON_ISSET</name></expr></argument>,  <argument><expr><name>jsonSetFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_type</name></expr></argument>,          <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonTypeFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_type</name></expr></argument>,          <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonTypeFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_valid</name></expr></argument>,         <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonValidFunc</name></expr></argument>)</argument_list></call></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEBUG</name></expr></cpp:if>
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_parse</name></expr></argument>,         <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonParseFunc</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JFUNCTION</name><argument_list>(<argument><expr><name>json_test1</name></expr></argument>,         <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,  <argument><expr><name>jsonTest1Func</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><call><name>WAGGREGATE</name><argument_list>(<argument><expr><name>json_group_array</name></expr></argument>,  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
       <argument><expr><name>jsonArrayStep</name></expr></argument>, <argument><expr><name>jsonArrayFinal</name></expr></argument>, <argument><expr><name>jsonArrayValue</name></expr></argument>, <argument><expr><name>jsonGroupInverse</name></expr></argument>,
       <argument><expr><name>SQLITE_SUBTYPE</name><operator>|</operator><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name><operator>|</operator><name>SQLITE_INNOCUOUS</name></expr></argument>)</argument_list></call></expr>,
    <macro><name>WAGGREGATE</name><argument_list>(<argument>json_group_object</argument>, <argument><literal type="number">2</literal></argument>, <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument>, 
       <argument>jsonObjectStep</argument>, <argument>jsonObjectFinal</argument>, <argument>jsonObjectValue</argument>, <argument>jsonGroupInverse</argument>,
       <argument>SQLITE_SUBTYPE|SQLITE_UTF8|SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS</argument>)</argument_list></macro>
  }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3InsertBuiltinFuncs</name><argument_list>(<argument><expr><name>aJsonFunc</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>aJsonFunc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive>  <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_JSON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Register the JSON table-valued functions
*/</comment>
<function><type><name>int</name></type> <name>sqlite3JsonTableFunctions</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aMod</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"json_each"</literal></expr>,            <expr><operator>&amp;</operator><name>jsonEachModule</name></expr>               }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_tree"</literal></expr>,            <expr><operator>&amp;</operator><name>jsonTreeModule</name></expr>               }</block></expr>,
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aMod</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aMod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aMod</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>aMod</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; !defined(SQLITE_OMIT_JSON) */</comment>
</unit>
