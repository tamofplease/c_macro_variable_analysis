<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_dispatch.c"><comment type="block">/*
** Instruction dispatch handling.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_dispatch_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_buf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_str.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_meta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_frame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_bc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strfmt.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_jit.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ccallback.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_dispatch.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASPROFILE</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_profile.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_vm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"luajit.h"</cpp:file></cpp:include>

<comment type="block">/* Bump GG_NUM_ASMFF in lj_dispatch.h as needed. Ugly. */</comment>
<expr_stmt><expr><call><name>LJ_STATIC_ASSERT</name><argument_list>(<argument><expr><name>GG_NUM_ASMFF</name> <operator>==</operator> <name>FF_NUM_ASMFUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* -- Dispatch table management ------------------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_MIPS</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<function_decl><type><name>LJ_FUNCA_NORET</name> <name>void</name> <name>LJ_FASTCALL</name></type> <name>lj_ffh_coroutine_wrap_err</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>,
							  <parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>co</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_HASJIT</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_dispatch_stitch</name></cpp:macro>	<cpp:value>lj_dispatch_ins</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_HASPROFILE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_dispatch_profile</name></cpp:macro>	<cpp:value>lj_dispatch_ins</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GOTFUNC</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(ASMFunction)name,</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ASMFunction</name></type> <name><name>dispatch_got</name><index>[]</index></name> <init>= <expr><block>{
  <macro><name>GOTDEF</name><argument_list>(<argument>GOTFUNC</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GOTFUNC</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Initialize instruction dispatch table and hot counters. */</comment>
<function><type><name>void</name></type> <name>lj_dispatch_init</name><parameter_list>(<parameter><decl><type><name>GG_State</name> <modifier>*</modifier></type><name>GG</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ASMFunction</name> <modifier>*</modifier></type><name>disp</name> <init>= <expr><name><name>GG</name><operator>-&gt;</operator><name>dispatch</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>GG_LEN_SDISP</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>disp</name><index>[<expr><name>GG_LEN_DDISP</name><operator>+</operator><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>disp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>makeasmfunc</name><argument_list>(<argument><expr><name><name>lj_bc_ofs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>GG_LEN_SDISP</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>GG_LEN_DDISP</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>disp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>makeasmfunc</name><argument_list>(<argument><expr><name><name>lj_bc_ofs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <comment type="block">/* The JIT engine is off by default. luaopen_jit() turns it on. */</comment>
  <expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_FORL</name></expr>]</index></name> <operator>=</operator> <name><name>disp</name><index>[<expr><name>BC_IFORL</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_ITERL</name></expr>]</index></name> <operator>=</operator> <name><name>disp</name><index>[<expr><name>BC_IITERL</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_LOOP</name></expr>]</index></name> <operator>=</operator> <name><name>disp</name><index>[<expr><name>BC_ILOOP</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_FUNCF</name></expr>]</index></name> <operator>=</operator> <name><name>disp</name><index>[<expr><name>BC_IFUNCF</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_FUNCV</name></expr>]</index></name> <operator>=</operator> <name><name>disp</name><index>[<expr><name>BC_IFUNCV</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>GG</name><operator>-&gt;</operator><name>g</name><operator>.</operator><name>bc_cfunc_ext</name></name> <operator>=</operator> <name><name>GG</name><operator>-&gt;</operator><name>g</name><operator>.</operator><name>bc_cfunc_int</name></name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_FUNCC</name></expr></argument>, <argument><expr><name>LUA_MINSTACK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>GG_NUM_ASMFF</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>GG</name><operator>-&gt;</operator><name>bcff</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC__MAX</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_MIPS</name></expr></cpp:if>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>GG</name><operator>-&gt;</operator><name>got</name></name></expr></argument>, <argument><expr><name>dispatch_got</name></expr></argument>, <argument><expr><name>LJ_GOT__MAX</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ASMFunction</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
<comment type="block">/* Initialize hotcount table. */</comment>
<function><type><name>void</name></type> <name>lj_dispatch_init_hotcount</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>hotloop</name> <init>= <expr><call><name>G2J</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>param</name><index>[<expr><name>JIT_P_hotloop</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HotCount</name></type> <name>start</name> <init>= <expr><operator>(</operator><name>HotCount</name><operator>)</operator><operator>(</operator><name>hotloop</name><operator>*</operator><name>HOTCOUNT_LOOP</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HotCount</name> <modifier>*</modifier></type><name>hotcount</name> <init>= <expr><call><name>G2GG</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>hotcount</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HOTCOUNT_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>hotcount</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Internal dispatch mode bits. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPMODE_CALL</name></cpp:macro>	<cpp:value>0x01</cpp:value></cpp:define>	<comment type="block">/* Override call dispatch. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPMODE_RET</name></cpp:macro>	<cpp:value>0x02</cpp:value></cpp:define>	<comment type="block">/* Override return dispatch. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPMODE_INS</name></cpp:macro>	<cpp:value>0x04</cpp:value></cpp:define>	<comment type="block">/* Override instruction dispatch. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPMODE_JIT</name></cpp:macro>	<cpp:value>0x10</cpp:value></cpp:define>	<comment type="block">/* JIT compiler on. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPMODE_REC</name></cpp:macro>	<cpp:value>0x20</cpp:value></cpp:define>	<comment type="block">/* Recording active. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPMODE_PROF</name></cpp:macro>	<cpp:value>0x40</cpp:value></cpp:define>	<comment type="block">/* Profiling active. */</comment>

<comment type="block">/* Update dispatch table depending on various flags. */</comment>
<function><type><name>void</name></type> <name>lj_dispatch_update</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>oldmode</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>dispatchmode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
  <expr_stmt><expr><name>mode</name> <operator>|=</operator> <ternary><condition><expr><operator>(</operator><call><name>G2J</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>JIT_F_ON</name><operator>)</operator></expr> ?</condition><then> <expr><name>DISPMODE_JIT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>mode</name> <operator>|=</operator> <ternary><condition><expr><call><name>G2J</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name> <operator>!=</operator> <name>LJ_TRACE_IDLE</name></expr> ?</condition><then>
	    <expr><operator>(</operator><name>DISPMODE_REC</name><operator>|</operator><name>DISPMODE_INS</name><operator>|</operator><name>DISPMODE_CALL</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASPROFILE</name></expr></cpp:if>
  <expr_stmt><expr><name>mode</name> <operator>|=</operator> <ternary><condition><expr><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>HOOK_PROFILE</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>DISPMODE_PROF</name><operator>|</operator><name>DISPMODE_INS</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>mode</name> <operator>|=</operator> <ternary><condition><expr><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <operator>(</operator><name>LUA_MASKLINE</name><operator>|</operator><name>LUA_MASKCOUNT</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>DISPMODE_INS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>mode</name> <operator>|=</operator> <ternary><condition><expr><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>LUA_MASKCALL</name><operator>)</operator></expr> ?</condition><then> <expr><name>DISPMODE_CALL</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>mode</name> <operator>|=</operator> <ternary><condition><expr><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>LUA_MASKRET</name><operator>)</operator></expr> ?</condition><then> <expr><name>DISPMODE_RET</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>oldmode</name> <operator>!=</operator> <name>mode</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Mode changed? */</comment>
    <decl_stmt><decl><type><name>ASMFunction</name> <modifier>*</modifier></type><name>disp</name> <init>= <expr><call><name>G2GG</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>dispatch</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ASMFunction</name></type> <name>f_forl</name></decl>, <decl><type ref="prev"/><name>f_iterl</name></decl>, <decl><type ref="prev"/><name>f_loop</name></decl>, <decl><type ref="prev"/><name>f_funcf</name></decl>, <decl><type ref="prev"/><name>f_funcv</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>dispatchmode</name></name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>

    <comment type="block">/* Hotcount if JIT is on, but not while recording. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&amp;</operator> <operator>(</operator><name>DISPMODE_JIT</name><operator>|</operator><name>DISPMODE_REC</name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>DISPMODE_JIT</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>f_forl</name> <operator>=</operator> <call><name>makeasmfunc</name><argument_list>(<argument><expr><name><name>lj_bc_ofs</name><index>[<expr><name>BC_FORL</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>f_iterl</name> <operator>=</operator> <call><name>makeasmfunc</name><argument_list>(<argument><expr><name><name>lj_bc_ofs</name><index>[<expr><name>BC_ITERL</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>f_loop</name> <operator>=</operator> <call><name>makeasmfunc</name><argument_list>(<argument><expr><name><name>lj_bc_ofs</name><index>[<expr><name>BC_LOOP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>f_funcf</name> <operator>=</operator> <call><name>makeasmfunc</name><argument_list>(<argument><expr><name><name>lj_bc_ofs</name><index>[<expr><name>BC_FUNCF</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>f_funcv</name> <operator>=</operator> <call><name>makeasmfunc</name><argument_list>(<argument><expr><name><name>lj_bc_ofs</name><index>[<expr><name>BC_FUNCV</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Otherwise use the non-hotcounting instructions. */</comment>
      <expr_stmt><expr><name>f_forl</name> <operator>=</operator> <name><name>disp</name><index>[<expr><name>GG_LEN_DDISP</name><operator>+</operator><name>BC_IFORL</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>f_iterl</name> <operator>=</operator> <name><name>disp</name><index>[<expr><name>GG_LEN_DDISP</name><operator>+</operator><name>BC_IITERL</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>f_loop</name> <operator>=</operator> <name><name>disp</name><index>[<expr><name>GG_LEN_DDISP</name><operator>+</operator><name>BC_ILOOP</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>f_funcf</name> <operator>=</operator> <call><name>makeasmfunc</name><argument_list>(<argument><expr><name><name>lj_bc_ofs</name><index>[<expr><name>BC_IFUNCF</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>f_funcv</name> <operator>=</operator> <call><name>makeasmfunc</name><argument_list>(<argument><expr><name><name>lj_bc_ofs</name><index>[<expr><name>BC_IFUNCV</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* Init static counting instruction dispatch first (may be copied below). */</comment>
    <expr_stmt><expr><name><name>disp</name><index>[<expr><name>GG_LEN_DDISP</name><operator>+</operator><name>BC_FORL</name></expr>]</index></name> <operator>=</operator> <name>f_forl</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>disp</name><index>[<expr><name>GG_LEN_DDISP</name><operator>+</operator><name>BC_ITERL</name></expr>]</index></name> <operator>=</operator> <name>f_iterl</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>disp</name><index>[<expr><name>GG_LEN_DDISP</name><operator>+</operator><name>BC_LOOP</name></expr>]</index></name> <operator>=</operator> <name>f_loop</name></expr>;</expr_stmt>

    <comment type="block">/* Set dynamic instruction dispatch. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>oldmode</name> <operator>^</operator> <name>mode</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>DISPMODE_PROF</name><operator>|</operator><name>DISPMODE_REC</name><operator>|</operator><name>DISPMODE_INS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Need to update the whole table. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>DISPMODE_INS</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* No ins dispatch? */</comment>
	<comment type="block">/* Copy static dispatch table to dynamic dispatch table. */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>disp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>disp</name><index>[<expr><name>GG_LEN_DDISP</name></expr>]</index></name></expr></argument>, <argument><expr><name>GG_LEN_SDISP</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ASMFunction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Overwrite with dynamic return dispatch. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>DISPMODE_RET</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_RETM</name></expr>]</index></name> <operator>=</operator> <name>lj_vm_rethook</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_RET</name></expr>]</index></name> <operator>=</operator> <name>lj_vm_rethook</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_RET0</name></expr>]</index></name> <operator>=</operator> <name>lj_vm_rethook</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_RET1</name></expr>]</index></name> <operator>=</operator> <name>lj_vm_rethook</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<comment type="block">/* The recording dispatch also checks for hooks. */</comment>
	<decl_stmt><decl><type><name>ASMFunction</name></type> <name>f</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>DISPMODE_PROF</name><operator>)</operator></expr> ?</condition><then> <expr><name>lj_vm_profhook</name></expr> </then><else>:
			<expr><ternary><condition><expr><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>DISPMODE_REC</name><operator>)</operator></expr> ?</condition><then> <expr><name>lj_vm_record</name></expr> </then><else>: <expr><name>lj_vm_inshook</name></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>GG_LEN_SDISP</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>disp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt></block_content></block></for>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>DISPMODE_INS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Otherwise set dynamic counting ins. */</comment>
      <expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_FORL</name></expr>]</index></name> <operator>=</operator> <name>f_forl</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_ITERL</name></expr>]</index></name> <operator>=</operator> <name>f_iterl</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_LOOP</name></expr>]</index></name> <operator>=</operator> <name>f_loop</name></expr>;</expr_stmt>
      <comment type="block">/* Set dynamic return dispatch. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>DISPMODE_RET</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_RETM</name></expr>]</index></name> <operator>=</operator> <name>lj_vm_rethook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_RET</name></expr>]</index></name> <operator>=</operator> <name>lj_vm_rethook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_RET0</name></expr>]</index></name> <operator>=</operator> <name>lj_vm_rethook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_RET1</name></expr>]</index></name> <operator>=</operator> <name>lj_vm_rethook</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_RETM</name></expr>]</index></name> <operator>=</operator> <name><name>disp</name><index>[<expr><name>GG_LEN_DDISP</name><operator>+</operator><name>BC_RETM</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_RET</name></expr>]</index></name> <operator>=</operator> <name><name>disp</name><index>[<expr><name>GG_LEN_DDISP</name><operator>+</operator><name>BC_RET</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_RET0</name></expr>]</index></name> <operator>=</operator> <name><name>disp</name><index>[<expr><name>GG_LEN_DDISP</name><operator>+</operator><name>BC_RET0</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_RET1</name></expr>]</index></name> <operator>=</operator> <name><name>disp</name><index>[<expr><name>GG_LEN_DDISP</name><operator>+</operator><name>BC_RET1</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Set dynamic call dispatch. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>oldmode</name> <operator>^</operator> <name>mode</name><operator>)</operator> <operator>&amp;</operator> <name>DISPMODE_CALL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Update the whole table? */</comment>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>DISPMODE_CALL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* No call hooks? */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>GG_LEN_SDISP</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>GG_LEN_DDISP</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>disp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>makeasmfunc</name><argument_list>(<argument><expr><name><name>lj_bc_ofs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>GG_LEN_SDISP</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>GG_LEN_DDISP</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>disp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>lj_vm_callhook</name></expr>;</expr_stmt></block_content></block></for>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>DISPMODE_CALL</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Overwrite dynamic counting ins. */</comment>
      <expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_FUNCF</name></expr>]</index></name> <operator>=</operator> <name>f_funcf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>disp</name><index>[<expr><name>BC_FUNCV</name></expr>]</index></name> <operator>=</operator> <name>f_funcv</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
    <comment type="block">/* Reset hotcounts for JIT off to on transition. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>DISPMODE_JIT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>oldmode</name> <operator>&amp;</operator> <name>DISPMODE_JIT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_dispatch_init_hotcount</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- JIT mode setting ---------------------------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
<comment type="block">/* Set JIT mode for a single prototype. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setptmode</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>LUAJIT_MODE_ON</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* (Re-)enable JIT compilation. */</comment>
    <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PROTO_NOJIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_trace_reenableproto</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Unpatch all ILOOP etc. bytecodes. */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Flush and/or disable JIT compilation. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>LUAJIT_MODE_FLUSH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PROTO_NOJIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_trace_flushproto</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Flush all traces of prototype. */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Recursively set the JIT mode for all children of a prototype. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setptmode_all</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTO_CHILD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name><name>pt</name><operator>-&gt;</operator><name>sizekgc</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>proto_kgc</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>gct</name></name> <operator>==</operator> <operator>~</operator><name>LJ_TPROTO</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setptmode</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gco2pt</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setptmode_all</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gco2pt</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Public API function: control the JIT engine. */</comment>
<function><type><name>int</name></type> <name>luaJIT_setmode</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mm</name> <init>= <expr><name>mode</name> <operator>&amp;</operator> <name>LUAJIT_MODE_MASK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_trace_abort</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Abort recording on any state change. */</comment>
  <comment type="block">/* Avoid pulling the rug from under our own feet. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>HOOK_GC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_NOGCMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <switch>switch <condition>(<expr><name>mm</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
  <case>case <expr><name>LUAJIT_MODE_ENGINE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>LUAJIT_MODE_FLUSH</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lj_trace_flushall</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>LUAJIT_MODE_ON</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>G2J</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>JIT_F_ON</name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>G2J</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>JIT_F_ON</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <expr_stmt><expr><call><name>lj_dispatch_update</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <break>break;</break>
  <case>case <expr><name>LUAJIT_MODE_FUNC</name></expr>:</case>
  <case>case <expr><name>LUAJIT_MODE_ALLFUNC</name></expr>:</case>
  <case>case <expr><name>LUAJIT_MODE_ALLSUBFUNC</name></expr>:</case> <block>{<block_content>
    <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><ternary><condition><expr><name>idx</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>frame_prev</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-</operator><name>LJ_FR2</name></expr> </then><else>:
		  <expr><ternary><condition><expr><name>idx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <operator>(</operator><name>idx</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>+</operator> <name>idx</name></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>idx</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>tvisfunc</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>isluafunc</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>gcval</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>pt</name> <operator>=</operator> <call><name>funcproto</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>gcval</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* Cannot use funcV() for frame slot. */</comment>
    <if type="elseif">else if <condition>(<expr><call><name>tvisproto</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>pt</name> <operator>=</operator> <call><name>protoV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* Failed. */</comment>
    <if_stmt><if>if <condition>(<expr><name>mm</name> <operator>!=</operator> <name>LUAJIT_MODE_ALLSUBFUNC</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>setptmode</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>mm</name> <operator>!=</operator> <name>LUAJIT_MODE_FUNC</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>setptmode_all</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>
    </block_content>}</block>
  <case>case <expr><name>LUAJIT_MODE_TRACE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>LUAJIT_MODE_FLUSH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Failed. */</comment>
    <expr_stmt><expr><call><name>lj_trace_flush</name><argument_list>(<argument><expr><call><name>G2J</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <case>case <expr><name>LUAJIT_MODE_ENGINE</name></expr>:</case>
  <case>case <expr><name>LUAJIT_MODE_FUNC</name></expr>:</case>
  <case>case <expr><name>LUAJIT_MODE_ALLFUNC</name></expr>:</case>
  <case>case <expr><name>LUAJIT_MODE_ALLSUBFUNC</name></expr>:</case>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>LUAJIT_MODE_ON</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Failed. */</comment>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <case>case <expr><name>LUAJIT_MODE_WRAPCFUNC</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>LUAJIT_MODE_ON</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><ternary><condition><expr><name>idx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <operator>(</operator><name>idx</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>+</operator> <name>idx</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tvislightud</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>wrapf</name></name> <operator>=</operator> <operator>(</operator><name>lua_CFunction</name><operator>)</operator><call><name>lightudV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* Failed. */</comment>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Failed. */</comment>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>bc_cfunc_ext</name></name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_FUNCCW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>bc_cfunc_ext</name></name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_FUNCC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <break>break;</break>
  <default>default:</default>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Failed. */</comment>
  </block_content>}</block></switch>
  <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* OK. */</comment>
</block_content>}</block></function>

<comment type="block">/* Enforce (dynamic) linker error for version mismatches. See luajit.c. */</comment>
<function><type><name>LUA_API</name> <name>void</name></type> <name>LUAJIT_VERSION_SYM</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<comment type="block">/* -- Hooks --------------------------------------------------------------- */</comment>

<comment type="block">/* This function can be called asynchronously (e.g. during a signal). */</comment>
<function><type><name>LUA_API</name> <name>int</name></type> <name>lua_sethook</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>lua_Hook</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>mask</name> <operator>&amp;=</operator> <name>HOOK_EVENTMASK</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>mask</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>mask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>func</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>  <comment type="block">/* Consistency. */</comment>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>hookf</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>hookcount</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>hookcstart</name></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name>count</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <operator>~</operator><name>HOOK_EVENTMASK</name><operator>)</operator> <operator>|</operator> <name>mask</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_trace_abort</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Abort recording on any hook change. */</comment>
  <expr_stmt><expr><call><name>lj_dispatch_update</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>LUA_API</name> <name>lua_Hook</name></type> <name>lua_gethook</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>hookf</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>LUA_API</name> <name>int</name></type> <name>lua_gethookmask</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>hookmask</name> <operator>&amp;</operator> <name>HOOK_EVENTMASK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>LUA_API</name> <name>int</name></type> <name>lua_gethookcount</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>hookcstart</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Call a hook. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>callhook</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>BCLine</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Hook</name></type> <name>hookf</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>hookf</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>hookf</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>hook_active</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Debug</name></type> <name>ar</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lj_trace_abort</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Abort recording on any hook call. */</comment>
    <expr_stmt><expr><name><name>ar</name><operator>.</operator><name>event</name></name> <operator>=</operator> <name>event</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ar</name><operator>.</operator><name>currentline</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
    <comment type="block">/* Top frame, nextframe = NULL. */</comment>
    <expr_stmt><expr><name><name>ar</name><operator>.</operator><name>i_ci</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <call><name>tvref</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_state_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>LUA_MINSTACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASPROFILE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_PROFILE_SIGPROF</name></expr></cpp:if>
    <expr_stmt><expr><call><name>lj_profile_hook_enter</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>hook_enter</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>hookf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>hook_active</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>cur_L</name></name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASPROFILE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_PROFILE_SIGPROF</name></expr></cpp:if>
    <expr_stmt><expr><call><name>lj_profile_hook_leave</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>hook_leave</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Dispatch callbacks -------------------------------------------------- */</comment>

<comment type="block">/* Calculate number of used stack slots in the current frame. */</comment>
<function><type><specifier>static</specifier> <name>BCReg</name></type> <name>cur_topslot</name><parameter_list>(<parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>nres</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCIns</name></type> <name>ins</name> <init>= <expr><name><name>pc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_UCLO</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>ins</name> <operator>=</operator> <name><name>pc</name><index>[<expr><call><name>bc_j</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <switch>switch <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>BC_CALLM</name></expr>:</case> <case>case <expr><name>BC_CALLMT</name></expr>:</case> <return>return <expr><call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>bc_c</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nres</name><operator>-</operator><literal type="number">1</literal><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr>;</return>
  <case>case <expr><name>BC_RETM</name></expr>:</case> <return>return <expr><call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>bc_d</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nres</name><operator>-</operator><literal type="number">1</literal></expr>;</return>
  <case>case <expr><name>BC_TSETM</name></expr>:</case> <return>return <expr><call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nres</name><operator>-</operator><literal type="number">1</literal></expr>;</return>
  <default>default:</default> <return>return <expr><name><name>pt</name><operator>-&gt;</operator><name>framesize</name></name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Instruction dispatch. Used by instr/line/return hooks or when recording. */</comment>
<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>lj_dispatch_ins</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ERRNO_SAVE</name>
  <name>GCfunc</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>funcproto</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cf</name> <init>= <expr><call><name>cframe_raw</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>oldpc</name> <init>= <expr><call><name>cframe_pc</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>slots</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setcframe_pc</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>slots</name> <operator>=</operator> <call><name>cur_topslot</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><call><name>cframe_multres_n</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>slots</name></expr>;</expr_stmt>  <comment type="block">/* Fix top. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
  <block>{<block_content>
    <decl_stmt><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name> <init>= <expr><call><name>G2J</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>LJ_TRACE_IDLE</name></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUA_USE_ASSERT</name></cpp:ifdef>
      <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>delta</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name> <operator>=</operator> <name>L</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lj_trace_ins</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pc</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* The interpreter bytecode PC is offset by 1. */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>==</operator> <name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>LUA_MASKCOUNT</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>hookcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>hookcount</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>hookcstart</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>callhook</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_HOOKCOUNT</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>slots</name></expr>;</expr_stmt>  <comment type="block">/* Fix top again. */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>LUA_MASKLINE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCPos</name></type> <name>npc</name> <init>= <expr><call><name>proto_bcpos</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCPos</name></type> <name>opc</name> <init>= <expr><call><name>proto_bcpos</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>oldpc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCLine</name></type> <name>line</name> <init>= <expr><call><name>lj_debug_line</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>npc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>pc</name> <operator>&lt;=</operator> <name>oldpc</name> <operator>||</operator> <name>opc</name> <operator>&gt;=</operator> <name><name>pt</name><operator>-&gt;</operator><name>sizebc</name></name> <operator>||</operator> <name>line</name> <operator>!=</operator> <call><name>lj_debug_line</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>opc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>callhook</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_HOOKLINE</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>slots</name></expr>;</expr_stmt>  <comment type="block">/* Fix top again. */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>LUA_MASKRET</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>bc_isret</name><argument_list>(<argument><expr><call><name>bc_op</name><argument_list>(<argument><expr><name><name>pc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>callhook</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_HOOKRET</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>ERRNO_RESTORE</name></expr></expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize call. Ensure stack space and return # of missing parameters. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>call_init</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>isluafunc</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>funcproto</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numparams</name> <init>= <expr><name><name>pt</name><operator>-&gt;</operator><name>numparams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>gotparams</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>need</name> <init>= <expr><name><name>pt</name><operator>-&gt;</operator><name>framesize</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTO_VARARG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>need</name> <operator>+=</operator> <literal type="number">1</literal><operator>+</operator><name>gotparams</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_state_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>(</operator><name>MSize</name><operator>)</operator><name>need</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>numparams</name> <operator>-=</operator> <name>gotparams</name></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name>numparams</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>numparams</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lj_state_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_MINSTACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Call dispatch. Used by call hooks, hot calls or when recording. */</comment>
<function><type><name>ASMFunction</name> <name>LJ_FASTCALL</name></type> <name>lj_dispatch_call</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ERRNO_SAVE</name>
  <name>GCfunc</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCOp</name></type> <name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
  <decl_stmt><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name> <init>= <expr><call><name>G2J</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>missing</name> <init>= <expr><call><name>call_init</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name> <operator>=</operator> <name>L</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>pc</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Marker for hot call. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUA_USE_ASSERT</name></cpp:ifdef>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>delta</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>pc</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BCIns</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>pc</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_trace_hot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>==</operator> <name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>out</name>;</goto>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>LJ_TRACE_IDLE</name> <operator>&amp;&amp;</operator>
	     <operator>!</operator><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <operator>(</operator><name>HOOK_GC</name><operator>|</operator><name>HOOK_VMEVENT</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUA_USE_ASSERT</name></cpp:ifdef>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>delta</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Record the FUNC* bytecodes, too. */</comment>
    <expr_stmt><expr><call><name>lj_trace_ins</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pc</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* The interpreter bytecode PC is offset by 1. */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>==</operator> <name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>LUA_MASKCALL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>missing</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* Add missing parameters. */</comment>
      <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>callhook</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_HOOKCALL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Preserve modifications of missing parameters by lua_setlocal(). */</comment>
    <while>while <condition>(<expr><name>missing</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>tvisnil</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
<label><name>out</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>bc_op</name><argument_list>(<argument><expr><name><name>pc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Get FUNC* op. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
  <comment type="block">/* Use the non-hotcounting variants if JIT is off or while recording. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_ON</name><operator>)</operator> <operator>||</operator> <name><name>J</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>LJ_TRACE_IDLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
      <operator>(</operator><name>op</name> <operator>==</operator> <name>BC_FUNCF</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>BC_FUNCV</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><name>BCOp</name><operator>)</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>op</name><operator>+</operator><operator>(</operator><name>int</name><operator>)</operator><name>BC_IFUNCF</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>BC_FUNCF</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <macro><name>ERRNO_RESTORE</name></macro>
  <return>return <expr><call><name>makeasmfunc</name><argument_list>(<argument><expr><name><name>lj_bc_ofs</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* Return static dispatch target. */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
<comment type="block">/* Stitch a new trace. */</comment>
<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>lj_dispatch_stitch</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ERRNO_SAVE</name>
  <name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cf</name> <init>= <expr><call><name>cframe_raw</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>oldpc</name> <init>= <expr><call><name>cframe_pc</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setcframe_pc</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Before dispatch, have to bias PC by 1. */</comment>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <call><name>cur_topslot</name><argument_list>(<argument><expr><call><name>curr_proto</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pc</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>cframe_multres_n</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_trace_stitch</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pc</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Point to the CALL instruction. */</comment>
  <expr_stmt><expr><call><name>setcframe_pc</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>oldpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ERRNO_RESTORE</name></expr></expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASPROFILE</name></expr></cpp:if>
<comment type="block">/* Profile dispatch. */</comment>
<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>lj_dispatch_profile</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ERRNO_SAVE</name>
  <name>GCfunc</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>funcproto</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cf</name> <init>= <expr><call><name>cframe_raw</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>oldpc</name> <init>= <expr><call><name>cframe_pc</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setcframe_pc</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <call><name>cur_topslot</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><call><name>cframe_multres_n</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_profile_interpreter</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setcframe_pc</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>oldpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>g</name> <operator>=</operator> <call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>cur_L</name></name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setvmstate</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>INTERP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ERRNO_RESTORE</name></expr></expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
