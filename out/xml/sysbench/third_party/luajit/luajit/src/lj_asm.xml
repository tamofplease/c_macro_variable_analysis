<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_asm.c"><comment type="block">/*
** IR assembler (SSA IR -&gt; machine code).
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_asm_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_str.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_frame.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ircall.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_iropt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_mcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_snap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_asm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_vm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_target.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUA_USE_ASSERT</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- Assembler state and common macros ----------------------------------- */</comment>

<comment type="block">/* Assembler state. */</comment>
<typedef>typedef <type><struct>struct <name>ASMState</name> <block>{
  <decl_stmt><decl><type><name>RegCost</name></type> <name><name>cost</name><index>[<expr><name>RID_MAX</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Reference and blended allocation cost for regs. */</comment>

  <decl_stmt><decl><type><name>MCode</name> <modifier>*</modifier></type><name>mcp</name></decl>;</decl_stmt>		<comment type="block">/* Current MCode pointer (grows down). */</comment>
  <decl_stmt><decl><type><name>MCode</name> <modifier>*</modifier></type><name>mclim</name></decl>;</decl_stmt>		<comment type="block">/* Lower limit for MCode memory + red zone. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUA_USE_ASSERT</name></cpp:ifdef>
  <decl_stmt><decl><type><name>MCode</name> <modifier>*</modifier></type><name>mcp_prev</name></decl>;</decl_stmt>	<comment type="block">/* Red zone overflow check. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl>;</decl_stmt>		<comment type="block">/* Copy of pointer to IR instructions/constants. */</comment>
  <decl_stmt><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl>;</decl_stmt>		<comment type="block">/* JIT compiler state. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
  <decl_stmt><decl><type><name>x86ModRM</name></type> <name>mrm</name></decl>;</decl_stmt>		<comment type="block">/* Fused x86 address operand. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>RegSet</name></type> <name>freeset</name></decl>;</decl_stmt>	<comment type="block">/* Set of free registers. */</comment>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>modset</name></decl>;</decl_stmt>	<comment type="block">/* Set of registers modified inside the loop. */</comment>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>weakset</name></decl>;</decl_stmt>	<comment type="block">/* Set of weakly referenced registers. */</comment>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>phiset</name></decl>;</decl_stmt>	<comment type="block">/* Set of PHI registers. */</comment>

  <decl_stmt><decl><type><name>uint32_t</name></type> <name>flags</name></decl>;</decl_stmt>	<comment type="block">/* Copy of JIT compiler flags. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>loopinv</name></decl>;</decl_stmt>		<comment type="block">/* Loop branch inversion (0:no, 1:yes, 2:yes+CC_P). */</comment>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>evenspill</name></decl>;</decl_stmt>	<comment type="block">/* Next even spill slot. */</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>oddspill</name></decl>;</decl_stmt>	<comment type="block">/* Next odd spill slot (or 0). */</comment>

  <decl_stmt><decl><type><name>IRRef</name></type> <name>curins</name></decl>;</decl_stmt>		<comment type="block">/* Reference of current instruction. */</comment>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>stopins</name></decl>;</decl_stmt>	<comment type="block">/* Stop assembly before hitting this instruction. */</comment>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>orignins</name></decl>;</decl_stmt>	<comment type="block">/* Original T-&gt;nins. */</comment>

  <decl_stmt><decl><type><name>IRRef</name></type> <name>snapref</name></decl>;</decl_stmt>	<comment type="block">/* Current snapshot is active after this reference. */</comment>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>snaprename</name></decl>;</decl_stmt>	<comment type="block">/* Rename highwater mark for snapshot check. */</comment>
  <decl_stmt><decl><type><name>SnapNo</name></type> <name>snapno</name></decl>;</decl_stmt>	<comment type="block">/* Current snapshot number. */</comment>
  <decl_stmt><decl><type><name>SnapNo</name></type> <name>loopsnapno</name></decl>;</decl_stmt>	<comment type="block">/* Loop snapshot number. */</comment>

  <decl_stmt><decl><type><name>IRRef</name></type> <name>fuseref</name></decl>;</decl_stmt>	<comment type="block">/* Fusion limit (loopref, 0 or FUSE_DISABLED). */</comment>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>sectref</name></decl>;</decl_stmt>	<comment type="block">/* Section base reference (loopref or 0). */</comment>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>loopref</name></decl>;</decl_stmt>	<comment type="block">/* Reference of LOOP instruction (or 0). */</comment>

  <decl_stmt><decl><type><name>BCReg</name></type> <name>topslot</name></decl>;</decl_stmt>	<comment type="block">/* Number of slots for stack check (unless 0). */</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>gcsteps</name></decl>;</decl_stmt>	<comment type="block">/* Accumulated number of GC steps (per section). */</comment>

  <decl_stmt><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl>;</decl_stmt>		<comment type="block">/* Trace to assemble. */</comment>
  <decl_stmt><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>	<comment type="block">/* Parent trace (or NULL). */</comment>

  <decl_stmt><decl><type><name>MCode</name> <modifier>*</modifier></type><name>mcbot</name></decl>;</decl_stmt>		<comment type="block">/* Bottom of reserved MCode. */</comment>
  <decl_stmt><decl><type><name>MCode</name> <modifier>*</modifier></type><name>mctop</name></decl>;</decl_stmt>		<comment type="block">/* Top of generated MCode. */</comment>
  <decl_stmt><decl><type><name>MCode</name> <modifier>*</modifier></type><name>mcloop</name></decl>;</decl_stmt>	<comment type="block">/* Pointer to loop MCode (or NULL). */</comment>
  <decl_stmt><decl><type><name>MCode</name> <modifier>*</modifier></type><name>invmcp</name></decl>;</decl_stmt>	<comment type="block">/* Points to invertible loop branch (or NULL). */</comment>
  <decl_stmt><decl><type><name>MCode</name> <modifier>*</modifier></type><name>flagmcp</name></decl>;</decl_stmt>	<comment type="block">/* Pending opportunity to merge flag setting ins. */</comment>
  <decl_stmt><decl><type><name>MCode</name> <modifier>*</modifier></type><name>realign</name></decl>;</decl_stmt>	<comment type="block">/* Realign loop if not NULL. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RID_NUM_KREF</name></cpp:ifdef>
  <decl_stmt><decl><type><name>intptr_t</name></type> <name><name>krefk</name><index>[<expr><name>RID_NUM_KREF</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>IRRef1</name></type> <name><name>phireg</name><index>[<expr><name>RID_MAX</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* PHI register references. */</comment>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name><name>parentmap</name><index>[<expr><name>LJ_MAX_JSLOTS</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Parent instruction to RegSP map. */</comment>
}</block></struct></type> <name>ASMState</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IR</name><parameter_list>(<parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>			<cpp:value>(&amp;as-&gt;ir[(ref)])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASMREF_TMP1</name></cpp:macro>		<cpp:value>REF_TRUE</cpp:value></cpp:define>	<comment type="block">/* Temp. register. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASMREF_TMP2</name></cpp:macro>		<cpp:value>REF_FALSE</cpp:value></cpp:define>	<comment type="block">/* Temp. register. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASMREF_L</name></cpp:macro>		<cpp:value>REF_NIL</cpp:value></cpp:define>		<comment type="block">/* Stores register for L. */</comment>

<comment type="block">/* Check for variant to invariant references. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>iscrossref</name><parameter_list>(<parameter><type><name>as</name></type></parameter>, <parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((ref) &lt; as-&gt;sectref)</cpp:value></cpp:define>

<comment type="block">/* Inhibit memory op fusion from variant to invariant references. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUSE_DISABLED</name></cpp:macro>		<cpp:value>(~(IRRef)0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mayfuse</name><parameter_list>(<parameter><type><name>as</name></type></parameter>, <parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((ref) &gt; as-&gt;fuseref)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>neverfuse</name><parameter_list>(<parameter><type><name>as</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(as-&gt;fuseref == FUSE_DISABLED)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>canfuse</name><parameter_list>(<parameter><type><name>as</name></type></parameter>, <parameter><type><name>ir</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(!neverfuse(as) &amp;&amp; !irt_isphi((ir)-&gt;t))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>opisfusableload</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>((o) == IR_ALOAD || (o) == IR_HLOAD || (o) == IR_ULOAD || \
   (o) == IR_FLOAD || (o) == IR_XLOAD || (o) == IR_SLOAD || (o) == IR_VLOAD)</cpp:value></cpp:define>

<comment type="block">/* Sparse limit checks using a red zone before the actual limit. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MCLIM_REDZONE</name></cpp:macro>	<cpp:value>64</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>LJ_NORET</name> <name>LJ_NOINLINE</name> <name>void</name></type> <name>asm_mclimit</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_mcode_limiterr</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>mctop</name></name> <operator>-</operator> <name><name>as</name><operator>-&gt;</operator><name>mcp</name></name> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>MCLIM_REDZONE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>void</name></type> <name>checkmclim</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUA_USE_ASSERT</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>mcp</name></name> <operator>+</operator> <name>MCLIM_REDZONE</name> <operator>&lt;</operator> <name><name>as</name><operator>-&gt;</operator><name>mcp_prev</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"RED ZONE OVERFLOW: %p IR %04d  %02d %04d %04d\n"</literal></expr></argument>, <argument><expr><name><name>as</name><operator>-&gt;</operator><name>mcp</name></name></expr></argument>,
	    <argument><expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name><operator>+</operator><literal type="number">1</literal><operator>-</operator><name>REF_BIAS</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name><operator>-</operator><name>REF_BIAS</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name><operator>-</operator><name>REF_BIAS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>mcp</name></name> <operator>&lt;</operator> <name><name>as</name><operator>-&gt;</operator><name>mclim</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>asm_mclimit</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUA_USE_ASSERT</name></cpp:ifdef>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>mcp_prev</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>mcp</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RID_NUM_KREF</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ra_iskref</name><parameter_list>(<parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((ref) &lt; RID_NUM_KREF)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ra_krefreg</name><parameter_list>(<parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((Reg)(RID_MIN_KREF + (Reg)(ref)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ra_krefk</name><parameter_list>(<parameter><type><name>as</name></type></parameter>, <parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(as-&gt;krefk[(ref)])</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>void</name></type> <name>ra_setkref</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>Reg</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>intptr_t</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><operator>(</operator><name>IRRef</name><operator>)</operator><operator>(</operator><name>r</name> <operator>-</operator> <name>RID_MIN_KREF</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>krefk</name><index>[<expr><name>ref</name></expr>]</index></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name> <operator>=</operator> <call><name>REGCOST</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ra_iskref</name><parameter_list>(<parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ra_krefreg</name><parameter_list>(<parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>RID_MIN_GPR</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ra_krefk</name><parameter_list>(<parameter><type><name>as</name></type></parameter>, <parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Arch-specific field offsets. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>field_ofs</name><index>[<expr><name>IRFL__MAX</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOFS</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>ofs</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(uint8_t)(ofs),</cpp:value></cpp:define>
<expr><call><name>IRFLDEF</name><argument_list>(<argument><expr><name>FLOFS</name></expr></argument>)</argument_list></call>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FLOFS</name></cpp:undef>
  <literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* -- Target-specific instruction emitter --------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_emit_x86.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM</name></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_emit_arm.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM64</name></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_emit_arm64.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_PPC</name></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_emit_ppc.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_MIPS</name></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_emit_mips.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Missing instruction emitter for target CPU"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Generic load/store of register from/to stack slot. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>emit_spload</name><parameter_list>(<parameter><type><name>as</name></type></parameter>, <parameter><type><name>ir</name></type></parameter>, <parameter><type><name>r</name></type></parameter>, <parameter><type><name>ofs</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>emit_loadofs(as, ir, (r), RID_SP, (ofs))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>emit_spstore</name><parameter_list>(<parameter><type><name>as</name></type></parameter>, <parameter><type><name>ir</name></type></parameter>, <parameter><type><name>r</name></type></parameter>, <parameter><type><name>ofs</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>emit_storeofs(as, ir, (r), RID_SP, (ofs))</cpp:value></cpp:define>

<comment type="block">/* -- Register allocator debugging ---------------------------------------- */</comment>

<comment type="block">/* #define LUAJIT_DEBUG_RA */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUAJIT_DEBUG_RA</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RIDNAME</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>#name,</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>ra_regname</name><index>[]</index></name> <init>= <expr><block>{
  <macro><name>GPRDEF</name><argument_list>(<argument>RIDNAME</argument>)</argument_list></macro>
  <macro><name>FPRDEF</name><argument_list>(<argument>RIDNAME</argument>)</argument_list></macro>
  <macro><name>VRIDDEF</name><argument_list>(<argument>RIDNAME</argument>)</argument_list></macro>
  <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RIDNAME</name></cpp:undef>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>ra_dbg_buf</name><index>[<expr><literal type="number">65536</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ra_dbg_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ra_dbg_merge</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MCode</name> <modifier>*</modifier></type><name>ra_dbg_mcp</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ra_dstart</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>ra_dbg_p</name> <operator>=</operator> <name>ra_dbg_buf</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ra_dbg_merge</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ra_dbg_mcp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ra_dflush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>ra_dbg_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>ra_dbg_p</name><operator>-</operator><name>ra_dbg_buf</name><operator>)</operator></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ra_dstart</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ra_dprintf</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>argp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><name>ra_dbg_mcp</name> <operator>==</operator> <name><name>as</name><operator>-&gt;</operator><name>mcp</name></name></expr> ?</condition><then> <expr><name>ra_dbg_merge</name></expr> </then><else>: <expr><name>ra_dbg_p</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>ra_dbg_mcp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%08x  \e[36m%04d "</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>as</name><operator>-&gt;</operator><name>mcp</name></name></expr></argument>, <argument><expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name><operator>-</operator><name>REF_BIAS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>e</name><operator>-</operator><name>fmt</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>e</name><operator>-</operator><name>fmt</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>Reg</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>RID_MASK</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;=</operator> <name>RID_MAX</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>q</name> <operator>=</operator> <name><name>ra_regname</name><index>[<expr><name>r</name></expr>]</index></name></expr>;</init> <condition><expr><operator>*</operator><name>q</name></expr>;</condition> <incr><expr><name>q</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>*</operator><name>q</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>q</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr> ?</condition><then> <expr><operator>*</operator><name>q</name> <operator>+</operator> <literal type="number">0x20</literal></expr> </then><else>: <expr><operator>*</operator><name>q</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></for>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal> <operator>||</operator> <name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>IRRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>IRIns</name> <operator>*</operator></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>as</name><operator>-&gt;</operator><name>ir</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&gt;=</operator> <name>REF_BIAS</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%04d"</literal></expr></argument>, <argument><expr><name>ref</name> <operator>-</operator> <name>REF_BIAS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"K%03d"</literal></expr></argument>, <argument><expr><name>REF_BIAS</name> <operator>-</operator> <name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>slot</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"[sp+0x%x]"</literal></expr></argument>, <argument><expr><call><name>sps_scale</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%08x"</literal></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>e</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><operator>*</operator><name>fmt</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>fmt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\e'</literal></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'['</literal></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'m'</literal></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>ra_dbg_buf</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ra_dbg_buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">256</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>ra_dbg_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>p</name><operator>-</operator><name>ra_dbg_buf</name><operator>)</operator></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>ra_dbg_buf</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>ra_dbg_p</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RA_DBG_START</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>ra_dstart()</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RA_DBG_FLUSH</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>ra_dflush()</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RA_DBG_REF</name><parameter_list>()</parameter_list></cpp:macro> \
  <cpp:value>do { char *_p = ra_dbg_p; ra_dprintf(as, ""); \
       ra_dbg_merge = _p; ra_dbg_mcp = as-&gt;mcp; } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RA_DBGX</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>ra_dprintf x</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RA_DBG_START</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RA_DBG_FLUSH</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RA_DBG_REF</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RA_DBGX</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- Register allocator -------------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ra_free</name><parameter_list>(<parameter><type><name>as</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>rset_set(as-&gt;freeset, (r))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ra_modified</name><parameter_list>(<parameter><type><name>as</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>rset_set(as-&gt;modset, (r))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ra_weak</name><parameter_list>(<parameter><type><name>as</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>rset_set(as-&gt;weakset, (r))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ra_noweak</name><parameter_list>(<parameter><type><name>as</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>rset_clear(as-&gt;weakset, (r))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ra_used</name><parameter_list>(<parameter><type><name>ir</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(ra_hasreg((ir)-&gt;r) || ra_hasspill((ir)-&gt;s))</cpp:value></cpp:define>

<comment type="block">/* Setup register allocator. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ra_setup</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Reg</name></type> <name>r</name></decl>;</decl_stmt>
  <comment type="block">/* Initially all regs (except the stack pointer) are free for use. */</comment>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>=</operator> <name>RSET_INIT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>modset</name></name> <operator>=</operator> <name>RSET_EMPTY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>weakset</name></name> <operator>=</operator> <name>RSET_EMPTY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>phiset</name></name> <operator>=</operator> <name>RSET_EMPTY</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>phireg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>phireg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>r</name> <operator>=</operator> <name>RID_MIN_GPR</name></expr>;</init> <condition><expr><name>r</name> <operator>&lt;</operator> <name>RID_MAX</name></expr>;</condition> <incr><expr><name>r</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name> <operator>=</operator> <call><name>REGCOST</name><argument_list>(<argument><expr><operator>~</operator><literal type="number">0u</literal></expr></argument>, <argument><expr><literal type="number">0u</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/* Rematerialize constants. */</comment>
<function><type><specifier>static</specifier> <name>Reg</name></type> <name>ra_rematk</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Reg</name></type> <name>r</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ra_iskref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ra_krefreg</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>rset_test</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ra_free</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ra_modified</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
    <expr_stmt><expr><call><name>emit_loadu64</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>ra_krefk</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>emit_loadi</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>ra_krefk</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>r</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>r</name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ra_hasreg</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ra_free</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ra_modified</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>=</operator> <name>RID_INIT</name></expr>;</expr_stmt>  <comment type="block">/* Do not keep any hint. */</comment>
  <expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"remat     $i $r"</literal><operator>,</operator> <name>ir</name><operator>,</operator> <name>r</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_SOFTFP32</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KNUM</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>emit_loadk64</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  if <condition>(<expr><call><name>emit_canremat</name><argument_list>(<argument><expr><name>REF_BASE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BASE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>ra_sethint</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><name>RID_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Restore BASE register hint. */</comment>
    <expr_stmt><expr><call><name>emit_getgl</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>jit_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>emit_canremat</name><argument_list>(<argument><expr><name>ASMREF_L</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KPRI</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>irt_isnil</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* REF_NIL stores ASMREF_L register. */</comment>
    <expr_stmt><expr><call><name>emit_getgl</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>cur_L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT64</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>emit_loadu64</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>ir_kint64</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KGC</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>emit_loadu64</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>ir_kgc</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KPTR</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KKPTR</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>emit_loadu64</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>ir_kptr</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KGC</name> <operator>||</operator>
	       <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KPTR</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KKPTR</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emit_loadi</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Force a spill. Allocate a new spill slot if needed. */</comment>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>ra_spill</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>slot</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>ir</name> <operator>&gt;=</operator> <name><name>as</name><operator>-&gt;</operator><name>ir</name></name> <operator>+</operator> <name>REF_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ra_hasspill</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>oddspill</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>oddspill</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>oddspill</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>oddspill</name></name> <operator>=</operator> <name>slot</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name> <operator>&gt;</operator> <literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>, <argument><expr><name>LJ_TRERR_SPILLOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>slot</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>sps_scale</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Release the temporarily allocated register in ASMREF_TMP1/ASMREF_TMP2. */</comment>
<function><type><specifier>static</specifier> <name>Reg</name></type> <name>ra_releasetmp</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ra_hasreg</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ra_free</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ra_modified</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>=</operator> <name>RID_INIT</name></expr>;</expr_stmt>
  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Restore a register (marked as free). Rematerialize or force a spill. */</comment>
<function><type><specifier>static</specifier> <name>Reg</name></type> <name>ra_restore</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>emit_canremat</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>ra_rematk</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>ofs</name> <init>= <expr><call><name>ra_spill</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* Force a spill slot. */</comment>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ra_hasreg</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ra_sethint</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Keep hint. */</comment>
    <expr_stmt><expr><call><name>ra_free</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rset_test</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>weakset</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Only restore non-weak references. */</comment>
      <expr_stmt><expr><call><name>ra_modified</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"restore   $i $r"</literal><operator>,</operator> <name>ir</name><operator>,</operator> <name>r</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>emit_spload</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>ofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>r</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Save a register to a spill slot. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ra_save</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>, <parameter><decl><type><name>Reg</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"save      $i $r"</literal><operator>,</operator> <name>ir</name><operator>,</operator> <name>r</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>emit_spstore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>sps_scale</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINCOST</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (rset_test(RSET_ALL, RID_##name) &amp;&amp; \
      LJ_LIKELY(allow&amp;RID2RSET(RID_##name)) &amp;&amp; as-&gt;cost[RID_##name] &lt; cost) \
    cost = as-&gt;cost[RID_##name];</cpp:value></cpp:define>

<comment type="block">/* Evict the register with the lowest cost, forcing a restore. */</comment>
<function><type><specifier>static</specifier> <name>Reg</name></type> <name>ra_evict</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>RegSet</name></type> <name>allow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RegCost</name></type> <name>cost</name> <init>= <expr><operator>~</operator><operator>(</operator><name>RegCost</name><operator>)</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>allow</name> <operator>!=</operator> <name>RSET_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>RID_NUM_FPR</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>allow</name> <operator>&lt;</operator> <call><name>RID2RSET</name><argument_list>(<argument><expr><name>RID_MAX_GPR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <macro><name>GPRDEF</name><argument_list>(<argument>MINCOST</argument>)</argument_list></macro>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <macro><name>FPRDEF</name><argument_list>(<argument>MINCOST</argument>)</argument_list></macro>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>regcost_ref</name><argument_list>(<argument><expr><name>cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ra_iskref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>ref</name> <operator>&gt;=</operator> <name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>nk</name></name> <operator>&amp;&amp;</operator> <name>ref</name> <operator>&lt;</operator> <name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>nins</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Preferably pick any weak ref instead of a non-weak, non-const ref. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irref_isk</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>weakset</name></name> <operator>&amp;</operator> <name>allow</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rset_test</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>weakset</name></name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><call><name>rset_pickbot</name><argument_list>(<argument><expr><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>weakset</name></name> <operator>&amp;</operator> <name>allow</name><operator>)</operator></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>ra_restore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pick any register (marked as free). Evict on-demand. */</comment>
<function><type><specifier>static</specifier> <name>Reg</name></type> <name>ra_pick</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>RegSet</name></type> <name>allow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>pick</name> <init>= <expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>allow</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pick</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>ra_evict</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>allow</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><call><name>rset_picktop</name><argument_list>(<argument><expr><name>pick</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Get a scratch register (marked as free). */</comment>
<function><type><specifier>static</specifier> <name>Reg</name></type> <name>ra_scratch</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>RegSet</name></type> <name>allow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>ra_pick</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>allow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>ra_modified</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"scratch        $r"</literal><operator>,</operator> <name>r</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Evict all registers from a set (if not free). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ra_evictset</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>RegSet</name></type> <name>drop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>work</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>modset</name></name> <operator>|=</operator> <name>drop</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_SOFTFP</name></expr></cpp:if>
  <expr_stmt><expr><name>work</name> <operator>=</operator> <operator>(</operator><name>drop</name> <operator>&amp;</operator> <operator>~</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name><operator>)</operator> <operator>&amp;</operator> <name>RSET_FPR</name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>work</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>rset_pickbot</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ra_restore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>work</name> <operator>=</operator> <operator>(</operator><name>drop</name> <operator>&amp;</operator> <operator>~</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name><operator>)</operator></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>work</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>rset_pickbot</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ra_restore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Evict (rematerialize) all registers allocated to constants. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ra_evictk</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>work</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_SOFTFP</name></expr></cpp:if>
  <expr_stmt><expr><name>work</name> <operator>=</operator> <operator>~</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>RSET_FPR</name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>work</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>rset_pickbot</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>emit_canremat</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ra_rematk</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>work</name> <operator>=</operator> <operator>~</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>RSET_GPR</name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>work</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>rset_pickbot</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>emit_canremat</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ra_rematk</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RID_NUM_KREF</name></cpp:ifdef>
<comment type="block">/* Allocate a register for a constant. */</comment>
<function><type><specifier>static</specifier> <name>Reg</name></type> <name>ra_allock</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>intptr_t</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>RegSet</name></type> <name>allow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* First try to find a register which already holds the same constant. */</comment>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>pick</name></decl>, <decl><type ref="prev"/><name>work</name> <init>= <expr><operator>~</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>RSET_GPR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Reg</name></type> <name>r</name></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>work</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rset_pickbot</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&lt;</operator> <name>ASMREF_L</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ra_iskref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <call><name>ra_krefk</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT64</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>==</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>ir_kint64</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name><operator>)</operator> <operator>||</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
	    <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>==</operator> <name><name>ir</name><operator>-&gt;</operator><name>i</name></name><operator>)</operator> <operator>||</operator>
	    <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KGC</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>==</operator> <operator>(</operator><name>intptr_t</name><operator>)</operator><call><name>ir_kgc</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
	    <operator>(</operator><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KPTR</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KKPTR</name><operator>)</operator> <operator>&amp;&amp;</operator>
	     <name>k</name> <operator>==</operator> <operator>(</operator><name>intptr_t</name><operator>)</operator><call><name>ir_kptr</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call><operator>)</operator>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	    <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>!=</operator> <name>IR_KINT64</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>==</operator> <name><name>ir</name><operator>-&gt;</operator><name>i</name></name><operator>)</operator></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	   )</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&lt;</operator> <name>ASMREF_L</name> <operator>&amp;&amp;</operator>
	<name>k</name> <operator>==</operator> <operator>(</operator><ternary><condition><expr><call><name>ra_iskref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>ra_krefk</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>pick</name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>allow</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>pick</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Constants should preferably get unmodified registers. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pick</name> <operator>&amp;</operator> <operator>~</operator><name><name>as</name><operator>-&gt;</operator><name>modset</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>pick</name> <operator>&amp;=</operator> <operator>~</operator><name><name>as</name><operator>-&gt;</operator><name>modset</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rset_pickbot</name><argument_list>(<argument><expr><name>pick</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Reduce conflicts with inverse allocation. */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ra_evict</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>allow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"allock    $x $r"</literal><operator>,</operator> <name>k</name><operator>,</operator> <name>r</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ra_setkref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ra_noweak</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Allocate a specific register for a constant. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ra_allockreg</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>intptr_t</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>Reg</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Reg</name></type> <name>kr</name> <init>= <expr><call><name>ra_allock</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><call><name>RID2RSET</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>kr</name> <operator>!=</operator> <name>r</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name></type> <name>irdummy</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>irdummy</name><operator>.</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>=</operator> <name>IRT_INT</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ra_scratch</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>RID2RSET</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>irdummy</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>kr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ra_allockreg</name><parameter_list>(<parameter><type><name>as</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>emit_loadi(as, (r), (k))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Allocate a register for ref from the allowed set of registers.
** Note: this function assumes the ref does NOT have a register yet!
** Picks an optimal register, sets the cost and marks the register as non-free.
*/</comment>
<function><type><specifier>static</specifier> <name>Reg</name></type> <name>ra_allocref</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>RegSet</name></type> <name>allow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>pick</name> <init>= <expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>allow</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Reg</name></type> <name>r</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ra_noreg</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>pick</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* First check register hint from propagation or PHI. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ra_hashint</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ra_gethint</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>rset_test</name><argument_list>(<argument><expr><name>pick</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Use hint register if possible. */</comment>
	<goto>goto <name>found</name>;</goto></block_content></block></if></if_stmt>
      <comment type="block">/* Rematerialization is cheaper than missing a hint. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>rset_test</name><argument_list>(<argument><expr><name>allow</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>emit_canremat</name><argument_list>(<argument><expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>ra_rematk</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<goto>goto <name>found</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"hintmiss  $f $r"</literal><operator>,</operator> <name>ref</name><operator>,</operator> <name>r</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Invariants should preferably get unmodified registers. */</comment>
    <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&lt;</operator> <name><name>as</name><operator>-&gt;</operator><name>loopref</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>irt_isphi</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pick</name> <operator>&amp;</operator> <operator>~</operator><name><name>as</name><operator>-&gt;</operator><name>modset</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>pick</name> <operator>&amp;=</operator> <operator>~</operator><name><name>as</name><operator>-&gt;</operator><name>modset</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rset_pickbot</name><argument_list>(<argument><expr><name>pick</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Reduce conflicts with inverse allocation. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="block">/* We've got plenty of regs, so get callee-save regs if possible. */</comment>
      <if_stmt><if>if <condition>(<expr><name>RID_NUM_GPR</name> <operator>&gt;</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>pick</name> <operator>&amp;</operator> <operator>~</operator><name>RSET_SCRATCH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>pick</name> <operator>&amp;=</operator> <operator>~</operator><name>RSET_SCRATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rset_picktop</name><argument_list>(<argument><expr><name>pick</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ra_evict</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>allow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<label><name>found</name>:</label>
  <expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"alloc     $f $r"</literal><operator>,</operator> <name>ref</name><operator>,</operator> <name>r</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>r</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ra_noweak</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name> <operator>=</operator> <call><name>REGCOST_REF_T</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><call><name>irt_t</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Allocate a register on-demand. */</comment>
<function><type><specifier>static</specifier> <name>Reg</name></type> <name>ra_alloc1</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>RegSet</name></type> <name>allow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>r</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Note: allow is ignored if the register is already allocated. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ra_noreg</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ra_allocref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>allow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>ra_noweak</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a register rename to the IR. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ra_addrename</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>Reg</name></type> <name>down</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>SnapNo</name></type> <name>snapno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>ren</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_ir_set</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_RENAME</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ren</name> <operator>=</operator> <call><name>tref_ref</name><argument_list>(<argument><expr><call><name>lj_ir_emit</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>ir</name><index>[<expr><name>ren</name></expr>]</index></name><operator>.</operator><name>r</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>down</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>ir</name><index>[<expr><name>ren</name></expr>]</index></name><operator>.</operator><name>s</name> <operator>=</operator> <name>SPS_NONE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Rename register allocation and emit move. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ra_rename</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>Reg</name></type> <name>down</name></decl></parameter>, <parameter><decl><type><name>Reg</name></type> <name>up</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>up</name></expr>]</index></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>down</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>up</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>down</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name>down</name> <operator>&lt;</operator> <name>RID_MAX_GPR</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>up</name> <operator>&lt;</operator> <name>RID_MAX_GPR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>rset_test</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name></expr></argument>, <argument><expr><name>down</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>rset_test</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name></expr></argument>, <argument><expr><name>up</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ra_free</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 'down' is free ... */</comment>
  <expr_stmt><expr><call><name>ra_modified</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name></expr></argument>, <argument><expr><name>up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ... and 'up' is now allocated. */</comment>
  <expr_stmt><expr><call><name>ra_noweak</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"rename    $f $r $r"</literal><operator>,</operator> <call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>up</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>,</operator> <name>down</name><operator>,</operator> <name>up</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>down</name></expr></argument>, <argument><expr><name>up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Backwards codegen needs inverse move. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ra_hasspill</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Add the rename to the IR. */</comment>
    <expr_stmt><expr><call><name>ra_addrename</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>down</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name><name>as</name><operator>-&gt;</operator><name>snapno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Pick a destination register (marked as free).
** Caveat: allow is ignored if there's already a destination register.
** Use ra_destreg() to get a specific register.
*/</comment>
<function><type><specifier>static</specifier> <name>Reg</name></type> <name>ra_dest</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>, <parameter><decl><type><name>RegSet</name></type> <name>allow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Reg</name></type> <name>dest</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ra_hasreg</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>ra_free</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ra_modified</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>ra_hashint</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>rset_test</name><argument_list>(<argument><expr><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name><operator>&amp;</operator><name>allow</name><operator>)</operator></expr></argument>, <argument><expr><call><name>ra_gethint</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>ra_gethint</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ra_modified</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"dest           $r"</literal><operator>,</operator> <name>dest</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>ra_scratch</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>allow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ra_save</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>dest</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Force a specific destination register (marked as free). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ra_destreg</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>, <parameter><decl><type><name>Reg</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Reg</name></type> <name>dest</name> <init>= <expr><call><name>ra_dest</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><call><name>RID2RSET</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>dest</name> <operator>!=</operator> <name>r</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>rset_test</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ra_modified</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
<comment type="block">/* Propagate dest register to left reference. Emit moves as needed.
** This is a required fixup step for all 2-operand machine instructions.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ra_left</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>Reg</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>lref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>lref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Reg</name></type> <name>left</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ra_noreg</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name>lref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KNUM</name></expr>)</condition> <block>{<block_content>
	<comment type="block">/* FP remat needs a load except for +0. Still better than eviction. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>tvispzero</name><argument_list>(<argument><expr><call><name>ir_knum</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>RSET_FPR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>emit_loadk64</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <return>return;</return>
	</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT64</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>emit_loadk64</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KGC</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KPTR</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KKPTR</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>emit_loadk64</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>!=</operator> <name>IR_KPRI</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KGC</name> <operator>||</operator>
		   <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KPTR</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KKPTR</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emit_loadi</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ra_hashint</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>iscrossref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>lref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>ra_sethint</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Propagate register hint. */</comment>
    <expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>ra_allocref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>lref</name></expr></argument>, <argument><expr><ternary><condition><expr><name>dest</name> <operator>&lt;</operator> <name>RID_MAX_GPR</name></expr> ?</condition><then> <expr><name>RSET_GPR</name></expr> </then><else>: <expr><name>RSET_FPR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>ra_noweak</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Move needed for true 3-operand instruction: y=a+b ==&gt; y=a; y+=b. */</comment>
  <if_stmt><if>if <condition>(<expr><name>dest</name> <operator>!=</operator> <name>left</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Use register renaming if dest is the PHI reg. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>irt_isphi</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>as</name><operator>-&gt;</operator><name>phireg</name><index>[<expr><name>dest</name></expr>]</index></name> <operator>==</operator> <name>lref</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ra_modified</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ra_rename</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* Similar to ra_left, except we override any hints. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ra_leftov</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>Reg</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>lref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>lref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Reg</name></type> <name>left</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ra_noreg</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>ra_sethint</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Propagate register hint. */</comment>
    <expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>ra_allocref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>lref</name></expr></argument>,
		       <argument><expr><ternary><condition><expr><operator>(</operator><name>LJ_SOFTFP</name> <operator>||</operator> <name>dest</name> <operator>&lt;</operator> <name>RID_MAX_GPR</name><operator>)</operator></expr> ?</condition><then> <expr><name>RSET_GPR</name></expr> </then><else>: <expr><name>RSET_FPR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>ra_noweak</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>dest</name> <operator>!=</operator> <name>left</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Use register renaming if dest is the PHI reg. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>irt_isphi</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>as</name><operator>-&gt;</operator><name>phireg</name><index>[<expr><name>dest</name></expr>]</index></name> <operator>==</operator> <name>lref</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ra_modified</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ra_rename</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_64</name></expr></cpp:if>
<comment type="block">/* Force a RID_RETLO/RID_RETHI destination register pair (marked as free). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ra_destpair</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Reg</name></type> <name>destlo</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></init></decl>, <decl><type ref="prev"/><name>desthi</name> <init>= <expr><operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>r</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* First spill unrelated refs blocking the destination registers. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rset_test</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name></expr></argument>, <argument><expr><name>RID_RETLO</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <name>destlo</name> <operator>!=</operator> <name>RID_RETLO</name> <operator>&amp;&amp;</operator> <name>desthi</name> <operator>!=</operator> <name>RID_RETLO</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ra_restore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>RID_RETLO</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rset_test</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name></expr></argument>, <argument><expr><name>RID_RETHI</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <name>destlo</name> <operator>!=</operator> <name>RID_RETHI</name> <operator>&amp;&amp;</operator> <name>desthi</name> <operator>!=</operator> <name>RID_RETHI</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ra_restore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>RID_RETHI</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <comment type="block">/* Next free the destination registers (if any). */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ra_hasreg</name><argument_list>(<argument><expr><name>destlo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>ra_free</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>destlo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ra_modified</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>destlo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>destlo</name> <operator>=</operator> <name>RID_RETLO</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ra_hasreg</name><argument_list>(<argument><expr><name>desthi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>ra_free</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>desthi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ra_modified</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>desthi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>desthi</name> <operator>=</operator> <name>RID_RETHI</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Check for conflicts and shuffle the registers as needed. */</comment>
  <if_stmt><if>if <condition>(<expr><name>destlo</name> <operator>==</operator> <name>RID_RETHI</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>desthi</name> <operator>==</operator> <name>RID_RETLO</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
      <expr_stmt><expr><operator>*</operator><operator>--</operator><name><name>as</name><operator>-&gt;</operator><name>mcp</name></name> <operator>=</operator> <name>XI_XCHGa</name> <operator>+</operator> <name>RID_RETHI</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>RID_RETHI</name></expr></argument>, <argument><expr><name>RID_TMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>RID_RETLO</name></expr></argument>, <argument><expr><name>RID_RETHI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>RID_TMP</name></expr></argument>, <argument><expr><name>RID_RETLO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>RID_RETHI</name></expr></argument>, <argument><expr><name>RID_RETLO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>desthi</name> <operator>!=</operator> <name>RID_RETHI</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>desthi</name></expr></argument>, <argument><expr><name>RID_RETHI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>desthi</name> <operator>==</operator> <name>RID_RETLO</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>RID_RETLO</name></expr></argument>, <argument><expr><name>RID_RETHI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>destlo</name> <operator>!=</operator> <name>RID_RETLO</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>destlo</name></expr></argument>, <argument><expr><name>RID_RETLO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>desthi</name> <operator>!=</operator> <name>RID_RETHI</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>desthi</name></expr></argument>, <argument><expr><name>RID_RETHI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>destlo</name> <operator>!=</operator> <name>RID_RETLO</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>destlo</name></expr></argument>, <argument><expr><name>RID_RETLO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Restore spill slots (if any). */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ra_save</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>RID_RETHI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ra_save</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>RID_RETLO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- Snapshot handling --------- ----------------------------------------- */</comment>

<comment type="block">/* Can we rematerialize a KNUM instead of forcing a spill? */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asm_snap_canremat</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Reg</name></type> <name>r</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>r</name> <operator>=</operator> <name>RID_MIN_FPR</name></expr>;</init> <condition><expr><name>r</name> <operator>&lt;</operator> <name>RID_MAX_FPR</name></expr>;</condition> <incr><expr><name>r</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check whether a sunk store corresponds to an allocation. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asm_sunk_store</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ira</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>irs</name><operator>-&gt;</operator><name>s</name></name> <operator>==</operator> <literal type="number">255</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_ASTORE</name> <operator>||</operator> <name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_HSTORE</name> <operator>||</operator>
	<name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_FSTORE</name> <operator>||</operator> <name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_XSTORE</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irk</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_AREF</name> <operator>||</operator> <name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_HREFK</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>irk</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>irk</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><operator>(</operator><call><name>IR</name><argument_list>(<argument><expr><name><name>irk</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ira</name><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><operator>(</operator><name>ira</name> <operator>+</operator> <name><name>irs</name><operator>-&gt;</operator><name>s</name></name> <operator>==</operator> <name>irs</name><operator>)</operator></expr>;</return>  <comment type="block">/* Quick check. */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Allocate register or spill slot for a ref that escapes to a snapshot. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_snap_alloc1</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irref_isk</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>(</operator><call><name>ra_used</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>RID_SUNK</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>RID_SINK</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>=</operator> <name>RID_SUNK</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEWI</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Allocate CNEWI value. */</comment>
	<expr_stmt><expr><call><name>asm_snap_alloc1</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>LJ_32</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_HIOP</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>asm_snap_alloc1</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{<block_content>  <comment type="block">/* Allocate stored values for TNEW, TDUP and CNEW. */</comment>
	<decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irs</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TNEW</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TDUP</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>irs</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>snapref</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>irs</name> <operator>&gt;</operator> <name>ir</name></expr>;</condition> <incr><expr><name>irs</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
	  <if_stmt><if>if <condition>(<expr><name><name>irs</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>RID_SINK</name> <operator>&amp;&amp;</operator> <call><name>asm_sunk_store</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>irs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_ASTORE</name> <operator>||</operator> <name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_HSTORE</name> <operator>||</operator>
		       <name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_FSTORE</name> <operator>||</operator> <name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_XSTORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>asm_snap_alloc1</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name><name>irs</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name>LJ_32</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>irs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_HIOP</name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><call><name>asm_snap_alloc1</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><operator>(</operator><name>irs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  </block_content>}</block></if></if_stmt></block_content></block></for>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>RegSet</name></type> <name>allow</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CONV</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRCONV_NUM_INT</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irc</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>irc</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>irc</name> <operator>&gt;</operator> <name>ir</name></expr>;</condition> <incr><expr><name>irc</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
	  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>irc</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name>ref</name> <operator>||</operator> <name><name>irc</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>ref</name><operator>)</operator> <operator>&amp;&amp;</operator>
	      <operator>!</operator><operator>(</operator><name><name>irc</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>RID_SINK</name> <operator>||</operator> <name><name>irc</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>RID_SUNK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	    <goto>goto <name>nosink</name>;</goto></block_content></block></if></if_stmt></block_content></block></for>  <comment type="block">/* Don't sink conversion if result is used. */</comment>
	<expr_stmt><expr><call><name>asm_snap_alloc1</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
      </block_content>}</block></if></if_stmt>
    <label><name>nosink</name>:</label>
      <expr_stmt><expr><name>allow</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>!</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <call><name>irt_isfp</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>RSET_FPR</name></expr> </then><else>: <expr><name>RSET_GPR</name></expr></else></ternary></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>allow</name><operator>)</operator> <operator>||</operator>
	       <operator>(</operator><name>allow</name> <operator>==</operator> <name>RSET_FPR</name> <operator>&amp;&amp;</operator> <call><name>asm_snap_canremat</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Get a weak register if we have a free one or can rematerialize. */</comment>
	<decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>ra_allocref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>allow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* Allocate a register. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irt_isphi</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>ra_weak</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* But mark it as weakly referenced. */</comment>
	<expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"snapreg   $f $r"</literal><operator>,</operator> <name>ref</name><operator>,</operator> <name><name>ir</name><operator>-&gt;</operator><name>r</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>ra_spill</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Otherwise force a spill slot. */</comment>
	<expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"snapspill $f $s"</literal><operator>,</operator> <name>ref</name><operator>,</operator> <name><name>ir</name><operator>-&gt;</operator><name>s</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Allocate refs escaping to a snapshot. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_snap_alloc</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SnapShot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>snap</name><index>[<expr><name><name>as</name><operator>-&gt;</operator><name>snapno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>snapmap</name><index>[<expr><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>nent</name> <init>= <expr><name><name>snap</name><operator>-&gt;</operator><name>nent</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nent</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SnapEntry</name></type> <name>sn</name> <init>= <expr><name><name>map</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><call><name>snap_ref</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irref_isk</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>asm_snap_alloc1</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sn</name> <operator>&amp;</operator> <name>SNAP_SOFTFPNUM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>irt_type</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>IRT_SOFTFP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>asm_snap_alloc1</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ref</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* All guards for a snapshot use the same exitno. This is currently the
** same as the snapshot number. Since the exact origin of the exit cannot
** be determined, all guards for the same snapshot must exit with the same
** RegSP mapping.
** A renamed ref which has been used in a prior guard for the same snapshot
** would cause an inconsistency. The easy way out is to force a spill slot.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>asm_snap_checkrename</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ren</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SnapShot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>snap</name><index>[<expr><name><name>as</name><operator>-&gt;</operator><name>snapno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>snapmap</name><index>[<expr><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>nent</name> <init>= <expr><name><name>snap</name><operator>-&gt;</operator><name>nent</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nent</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SnapEntry</name></type> <name>sn</name> <init>= <expr><name><name>map</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><call><name>snap_ref</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>==</operator> <name>ren</name> <operator>||</operator> <operator>(</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sn</name> <operator>&amp;</operator> <name>SNAP_SOFTFPNUM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>++</operator><name>ref</name> <operator>==</operator> <name>ren</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>ra_spill</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Register renamed, so force a spill slot. */</comment>
      <expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"snaprensp $f $s"</literal><operator>,</operator> <name>ref</name><operator>,</operator> <name><name>ir</name><operator>-&gt;</operator><name>s</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Found. */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Not found. */</comment>
</block_content>}</block></function>

<comment type="block">/* Prepare snapshot for next guard instruction. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_snap_prep</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name> <operator>&lt;</operator> <name><name>as</name><operator>-&gt;</operator><name>snapref</name></name></expr>)</condition> <block>{<block_content>
    <do>do <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>snapno</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* Called by sunk stores before snap #0. */</comment>
      <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>snapno</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>snapref</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>snap</name><index>[<expr><name><name>as</name><operator>-&gt;</operator><name>snapno</name></name></expr>]</index></name><operator>.</operator><name>ref</name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name> <operator>&lt;</operator> <name><name>as</name><operator>-&gt;</operator><name>snapref</name></name></expr>)</condition>;</do>
    <expr_stmt><expr><call><name>asm_snap_alloc</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>snaprename</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>nins</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* Process any renames above the highwater mark. */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name><name>as</name><operator>-&gt;</operator><name>snaprename</name></name> <operator>&lt;</operator> <name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>nins</name></name></expr>;</condition> <incr><expr><name><name>as</name><operator>-&gt;</operator><name>snaprename</name></name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>as</name><operator>-&gt;</operator><name>snaprename</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>asm_snap_checkrename</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>REF_BIAS</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Kill rename. */</comment>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Miscellaneous helpers ----------------------------------------------- */</comment>

<comment type="block">/* Calculate stack adjustment. */</comment>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>asm_stack_adjust</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name> <operator>&lt;=</operator> <name>SPS_FIXED</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>sps_scale</name><argument_list>(<argument><expr><call><name>sps_align</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Must match with hash*() in lj_tab.c. */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>ir_khash</name><parameter_list>(<parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>lo</name></decl>, <decl><type ref="prev"/><name>hi</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>irt_isstr</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>ir_kstr</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>hash</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>lo</name> <operator>=</operator> <call><name>ir_knum</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u32</name><operator>.</operator><name>lo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>ir_knum</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u32</name><operator>.</operator><name>hi</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>irt_ispri</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>irt_isnil</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>irt_type</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call><operator>-</operator><name>IRT_FALSE</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>irt_isgcv</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lo</name> <operator>=</operator> <call><name>u32ptr</name><argument_list>(<argument><expr><call><name>ir_kgc</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
    <expr_stmt><expr><name>hi</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><call><name>u64ptr</name><argument_list>(<argument><expr><call><name>ir_kgc</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><call><name>irt_toitype</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">15</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>hi</name> <operator>=</operator> <name>lo</name> <operator>+</operator> <name>HASH_BIAS</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><call><name>hashrot</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Allocations --------------------------------------------------------- */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>asm_gencall</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name></decl></parameter>, <parameter><decl><type><name>IRRef</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>asm_setupresult</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_snew</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>IRCALL_lj_str_new</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ASMREF_L</name></expr>;</expr_stmt>  <comment type="block">/* lua_State *L    */</comment>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>   <comment type="block">/* const char *str */</comment>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>   <comment type="block">/* size_t len      */</comment>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>gcsteps</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>asm_setupresult</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* GCstr * */</comment>
  <expr_stmt><expr><call><name>asm_gencall</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_tnew</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>IRCALL_lj_tab_new1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ASMREF_L</name></expr>;</expr_stmt>     <comment type="block">/* lua_State *L    */</comment>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>ASMREF_TMP1</name></expr>;</expr_stmt>  <comment type="block">/* uint32_t ahsize */</comment>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>gcsteps</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>asm_setupresult</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* GCtab * */</comment>
  <expr_stmt><expr><call><name>asm_gencall</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ra_allockreg</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>|</operator> <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr></argument>, <argument><expr><call><name>ra_releasetmp</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ASMREF_TMP1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_tdup</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>IRCALL_lj_tab_dup</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ASMREF_L</name></expr>;</expr_stmt>  <comment type="block">/* lua_State *L    */</comment>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>   <comment type="block">/* const GCtab *kt */</comment>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>gcsteps</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>asm_setupresult</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* GCtab * */</comment>
  <expr_stmt><expr><call><name>asm_gencall</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>asm_gc_check</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Explicit GC step. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_gcstep</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ira</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>ira</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>stopins</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ira</name> <operator>&lt;</operator> <name>ir</name></expr>;</condition> <incr><expr><name>ira</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TNEW</name> <operator>||</operator> <name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TDUP</name> <operator>||</operator>
	 <operator>(</operator><name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEW</name> <operator>||</operator> <name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEWI</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
	<call><name>ra_used</name><argument_list>(<argument><expr><name>ira</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>gcsteps</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
  <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>gcsteps</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>asm_gc_check</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>gcsteps</name></name> <operator>=</operator> <literal type="number">0x80000000</literal></expr>;</expr_stmt>  <comment type="block">/* Prevent implicit GC check further up. */</comment>
</block_content>}</block></function>

<comment type="block">/* -- Buffer operations --------------------------------------------------- */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>asm_tvptr</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>Reg</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_bufhdr</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Reg</name></type> <name>sb</name> <init>= <expr><call><name>ra_dest</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>RSET_GPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRBUFHDR_APPEND</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Rematerialize const buffer pointer instead of likely spill. */</comment>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irp</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>ra_hasreg</name><argument_list>(<argument><expr><name><name>irp</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>irp</name> <operator>==</operator> <name>ir</name><operator>-</operator><literal type="number">1</literal> <operator>||</operator>
	  <operator>(</operator><name>irp</name> <operator>==</operator> <name>ir</name><operator>-</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ra_used</name><argument_list>(<argument><expr><name>ir</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
      <while>while <condition>(<expr><operator>!</operator><operator>(</operator><name><name>irp</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BUFHDR</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>irp</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRBUFHDR_APPEND</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>irp</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>irp</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
      <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>irp</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>ra_weak</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>ra_allocref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>, <argument><expr><name>RSET_GPR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ir</name> <operator>=</operator> <name>irp</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>Reg</name></type> <name>tmp</name> <init>= <expr><call><name>ra_scratch</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>rset_exclude</name><argument_list>(<argument><expr><name>RSET_GPR</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Passing ir isn't strictly correct, but it's an IRT_PGC, too. */</comment>
    <expr_stmt><expr><call><name>emit_storeofs</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>SBuf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emit_loadofs</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>SBuf</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
  <expr_stmt><expr><call><name>ra_left</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>ra_leftov</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_bufput</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>IRCALL_lj_buf_putstr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>kchar</name> <init>= <expr><operator>-</operator><literal type="number">129</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>  <comment type="block">/* SBuf * */</comment>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>  <comment type="block">/* GCstr * */</comment>
  <expr_stmt><expr><name>irs</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>irt_isstr</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KGC</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>ir_kstr</name><argument_list>(<argument><expr><name>irs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Optimize put of single-char string constant. */</comment>
      <expr_stmt><expr><name>kchar</name> <operator>=</operator> <operator>(</operator><name>int8_t</name><operator>)</operator><call><name>strdata</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>  <comment type="block">/* Signed! */</comment>
      <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>ASMREF_TMP1</name></expr>;</expr_stmt>  <comment type="block">/* int, truncated to char */</comment>
      <expr_stmt><expr><name>ci</name> <operator>=</operator> <operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>IRCALL_lj_buf_putchar</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>mayfuse</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ra_noreg</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TOSTR</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Fuse number to string conversions. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>irs</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRTOSTR_NUM</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>ASMREF_TMP1</name></expr>;</expr_stmt>  <comment type="block">/* TValue * */</comment>
	<expr_stmt><expr><name>ci</name> <operator>=</operator> <operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>IRCALL_lj_strfmt_putnum</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>irt_isinteger</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>irs</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>  <comment type="block">/* int */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>irs</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRTOSTR_INT</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>ci</name> <operator>=</operator> <operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>IRCALL_lj_strfmt_putint</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><name>ci</name> <operator>=</operator> <operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>IRCALL_lj_buf_putchar</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_SNEW</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Fuse string allocation. */</comment>
      <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>irs</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>  <comment type="block">/* const void * */</comment>
      <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>irs</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>  <comment type="block">/* MSize */</comment>
      <expr_stmt><expr><name>ci</name> <operator>=</operator> <operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>IRCALL_lj_buf_putmem</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>asm_setupresult</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* SBuf * */</comment>
  <expr_stmt><expr><call><name>asm_gencall</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>ASMREF_TMP1</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Reg</name></type> <name>tmp</name> <init>= <expr><call><name>ra_releasetmp</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ASMREF_TMP1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>kchar</name> <operator>==</operator> <operator>-</operator><literal type="number">129</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>asm_tvptr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>irs</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>ra_allockreg</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>kchar</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_bufstr</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>IRCALL_lj_buf_tostr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>  <comment type="block">/* SBuf *sb */</comment>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>gcsteps</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>asm_setupresult</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* GCstr * */</comment>
  <expr_stmt><expr><call><name>asm_gencall</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Type conversions ---------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_tostr</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ASMREF_L</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>gcsteps</name></name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRTOSTR_NUM</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>ASMREF_TMP1</name></expr>;</expr_stmt>  <comment type="block">/* cTValue * */</comment>
    <expr_stmt><expr><name>ci</name> <operator>=</operator> <operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>IRCALL_lj_strfmt_num</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>  <comment type="block">/* int32_t k */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRTOSTR_INT</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ci</name> <operator>=</operator> <operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>IRCALL_lj_strfmt_int</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>ci</name> <operator>=</operator> <operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>IRCALL_lj_strfmt_char</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>asm_setupresult</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* GCstr * */</comment>
  <expr_stmt><expr><call><name>asm_gencall</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRTOSTR_NUM</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>asm_tvptr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>ra_releasetmp</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ASMREF_TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_TARGET_X86</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_conv64</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRType</name></type> <name>st</name> <init>= <expr><operator>(</operator><name>IRType</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ir</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op2</name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRType</name></type> <name>dt</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>ir</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op2</name> <operator>&amp;</operator> <name>IRCONV_DSTMASK</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>IRCONV_DSH</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRCallID</name></type> <name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name>ir</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_CONV</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_HIOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>LJ_BE</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>ir</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>LJ_LE</name></expr>]</index></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>st</name> <operator>==</operator> <name>IRT_NUM</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_FLOAT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>id</name> <operator>=</operator> <name>IRCALL_fp64_d2l</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>st</name> <operator>==</operator> <name>IRT_FLOAT</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator> <operator>(</operator><name>dt</name> <operator>-</operator> <name>IRT_I64</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>ir</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>id</name> <operator>=</operator> <name>IRCALL_fp64_l2d</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>dt</name> <operator>==</operator> <name>IRT_FLOAT</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator> <operator>(</operator><name>st</name> <operator>-</operator> <name>IRT_I64</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_ARM</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_ABI_SOFTFP</name></expr></cpp:if>
    <decl_stmt><decl><type><name>CCallInfo</name></type> <name>cim</name> <init>= <expr><name><name>lj_ir_callinfo</name><index>[<expr><name>id</name></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name>cim</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>cim</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>CCI_VARARG</name></expr>;</expr_stmt>  <comment type="block">/* These calls don't use the hard-float ABI! */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>asm_setupresult</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>asm_gencall</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- Memory references --------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_newref</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>IRCALL_lj_tab_newkey</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>RID_SINK</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ASMREF_L</name></expr>;</expr_stmt>     <comment type="block">/* lua_State *L */</comment>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>      <comment type="block">/* GCtab *t     */</comment>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>ASMREF_TMP1</name></expr>;</expr_stmt>  <comment type="block">/* cTValue *key */</comment>
  <expr_stmt><expr><call><name>asm_setupresult</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* TValue * */</comment>
  <expr_stmt><expr><call><name>asm_gencall</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>asm_tvptr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>ra_releasetmp</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ASMREF_TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_lref</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>ra_dest</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>RSET_GPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
  <expr_stmt><expr><call><name>ra_left</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>ASMREF_L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>ra_leftov</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>ASMREF_L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* -- Calls --------------------------------------------------------------- */</comment>

<comment type="block">/* Collect arguments from CALL* and CARG instructions. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_collectargs</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>,
			    <parameter><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name></decl></parameter>, <parameter><decl><type><name>IRRef</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name> <init>= <expr><call><name>CCI_XNARGS</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>n</name> <operator>&lt;=</operator> <name>CCI_NARGS_MAX</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Account for split args. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CCI_L</name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><operator>*</operator><name>args</name><operator>++</operator> <operator>=</operator> <name>ASMREF_L</name></expr>;</expr_stmt> <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  <while>while <condition>(<expr><name>n</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>REF_NIL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name>REF_NIL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>o</name> <operator>!=</operator> <name>IR_CARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Reconstruct CCallInfo flags for CALLX*. */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>asm_callx_flags</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>!=</operator> <name>REF_NIL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Count number of arguments first. */</comment>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ira</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nargs</name><operator>++</operator></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CARG</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>nargs</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>ira</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>ira</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_CARG</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Copy calling convention info. */</comment>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><operator>(</operator><name>CTypeID</name><operator>)</operator><call><name>IR</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>op2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nargs</name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_VARARG</name><operator>)</operator></expr> ?</condition><then> <expr><name>CCI_VARARG</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
    <expr_stmt><expr><name>nargs</name> <operator>|=</operator> <operator>(</operator><call><name>ctype_cconv</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>CCI_CC_SHIFT</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><operator>(</operator><name>nargs</name> <operator>|</operator> <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>&lt;&lt;</operator> <name>CCI_OTSHIFT</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_callid</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>, <parameter><decl><type><name>IRCallID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name>id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>asm_setupresult</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>asm_gencall</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_call</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name><name>args</name><index>[<expr><name>CCI_NARGS_MAX</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>asm_collectargs</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>asm_setupresult</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>asm_gencall</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- PHI and loop handling ----------------------------------------------- */</comment>

<comment type="block">/* Break a PHI cycle by renaming to a free register (evict if needed). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_phi_break</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>RegSet</name></type> <name>blocked</name></decl></parameter>, <parameter><decl><type><name>RegSet</name></type> <name>blockedby</name></decl></parameter>,
			  <parameter><decl><type><name>RegSet</name></type> <name>allow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>candidates</name> <init>= <expr><name>blocked</name> <operator>&amp;</operator> <name>allow</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>candidates</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* If this register file has candidates. */</comment>
    <comment type="block">/* Note: the set for ra_pick cannot be empty, since each register file
    ** has some registers never allocated to PHIs.
    */</comment>
    <decl_stmt><decl><type><name>Reg</name></type> <name>down</name></decl>, <decl><type ref="prev"/><name>up</name> <init>= <expr><call><name>ra_pick</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><operator>~</operator><name>blocked</name> <operator>&amp;</operator> <name>allow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* Get a free register. */</comment>
    <if_stmt><if>if <condition>(<expr><name>candidates</name> <operator>&amp;</operator> <operator>~</operator><name>blockedby</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Optimize shifts, else it's a cycle. */</comment>
      <expr_stmt><expr><name>candidates</name> <operator>=</operator> <name>candidates</name> <operator>&amp;</operator> <operator>~</operator><name>blockedby</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>down</name> <operator>=</operator> <call><name>rset_picktop</name><argument_list>(<argument><expr><name>candidates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Pick candidate PHI register. */</comment>
    <expr_stmt><expr><call><name>ra_rename</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>down</name></expr></argument>, <argument><expr><name>up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* And rename it to the free register. */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* PHI register shuffling.
**
** The allocator tries hard to preserve PHI register assignments across
** the loop body. Most of the time this loop does nothing, since there
** are no register mismatches.
**
** If a register mismatch is detected and ...
** - the register is currently free: rename it.
** - the register is blocked by an invariant: restore/remat and rename it.
** - Otherwise the register is used by another PHI, so mark it as blocked.
**
** The renames are order-sensitive, so just retry the loop if a register
** is marked as blocked, but has been freed in the meantime. A cycle is
** detected if all of the blocked registers are allocated. To break the
** cycle rename one of them to a free register and retry.
**
** Note that PHI spill slots are kept in sync and don't need to be shuffled.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_phi_shuffle</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>work</name></decl>;</decl_stmt>

  <comment type="block">/* Find and resolve PHI register mismatches. */</comment>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>RegSet</name></type> <name>blocked</name> <init>= <expr><name>RSET_EMPTY</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RegSet</name></type> <name>blockedby</name> <init>= <expr><name>RSET_EMPTY</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RegSet</name></type> <name>phiset</name> <init>= <expr><name><name>as</name><operator>-&gt;</operator><name>phiset</name></name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>phiset</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Check all left PHI operand registers. */</comment>
      <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>rset_pickbot</name><argument_list>(<argument><expr><name>phiset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irl</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>phireg</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Reg</name></type> <name>left</name> <init>= <expr><name><name>irl</name><operator>-&gt;</operator><name>r</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>left</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Mismatch? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rset_test</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* PHI register blocked? */</comment>
	  <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <comment type="block">/* Blocked by other PHI (w/reg)? */</comment>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ra_iskref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>irt_ismarked</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><call><name>rset_set</name><argument_list>(<argument><expr><name>blocked</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><call><name>ra_hasreg</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><call><name>rset_set</name><argument_list>(<argument><expr><name>blockedby</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name>left</name> <operator>=</operator> <name>RID_NONE</name></expr>;</expr_stmt>
	  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Otherwise grab register from invariant. */</comment>
	    <expr_stmt><expr><call><name>ra_restore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  </block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ra_hasreg</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>ra_rename</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>phiset</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>blocked</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Finished. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>blocked</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Break cycles if none are free. */</comment>
      <expr_stmt><expr><call><name>asm_phi_break</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>blocked</name></expr></argument>, <argument><expr><name>blockedby</name></expr></argument>, <argument><expr><name>RSET_GPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LJ_SOFTFP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>asm_phi_break</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>blocked</name></expr></argument>, <argument><expr><name>blockedby</name></expr></argument>, <argument><expr><name>RSET_FPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>  <comment type="block">/* Else retry some more renames. */</comment>
  </block_content>}</block></for>

  <comment type="block">/* Restore/remat invariants whose registers are modified inside the loop. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_SOFTFP</name></expr></cpp:if>
  <expr_stmt><expr><name>work</name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>modset</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>|</operator> <name><name>as</name><operator>-&gt;</operator><name>phiset</name></name><operator>)</operator> <operator>&amp;</operator> <name>RSET_FPR</name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>work</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>rset_pickbot</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ra_restore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>work</name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>modset</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>|</operator> <name><name>as</name><operator>-&gt;</operator><name>phiset</name></name><operator>)</operator></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>work</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>rset_pickbot</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ra_restore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Allocate and save all unsaved PHI regs and clear marks. */</comment>
  <expr_stmt><expr><name>work</name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>phiset</name></name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>work</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>rset_picktop</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>lref</name> <init>= <expr><name><name>as</name><operator>-&gt;</operator><name>phireg</name><index>[<expr><name>r</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>lref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Left PHI gained a spill slot? */</comment>
      <expr_stmt><expr><call><name>irt_clearmark</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Handled here, so clear marker now. */</comment>
      <expr_stmt><expr><call><name>ra_alloc1</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>lref</name></expr></argument>, <argument><expr><call><name>RID2RSET</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ra_save</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Save to spill slot inside the loop. */</comment>
      <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Copy unsynced left/right PHI spill slots. Rarely needed. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_phi_copyspill</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>need</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>orignins</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_PHI</name></expr>;</condition> <incr><expr><name>ir</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ra_hasspill</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>need</name> <operator>|=</operator> <ternary><condition><expr><call><name>irt_isfp</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>  <comment type="block">/* Unsynced spill slot? */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>need</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Copy integer spill slots. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><name>RID_TMP</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><name>RID_RET</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>RSET_GPR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rset_pickbot</name><argument_list>(<argument><expr><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>RSET_GPR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>emit_spload</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>IR</name><argument_list>(<argument><expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>SPOFS_TMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <for>for <control>(<init><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>orignins</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_PHI</name></expr>;</condition> <incr><expr><name>ir</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irl</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>irl</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>irt_isfp</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>emit_spstore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>irl</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>sps_scale</name><argument_list>(<argument><expr><name><name>irl</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>emit_spload</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>sps_scale</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rset_test</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>emit_spstore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>IR</name><argument_list>(<argument><expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>SPOFS_TMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_SOFTFP</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>need</name> <operator>&amp;</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Copy FP spill slots. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><name>RID_XMM0</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><name>RID_FPRET</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>RSET_FPR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rset_pickbot</name><argument_list>(<argument><expr><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>RSET_FPR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rset_test</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>emit_spload</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>IR</name><argument_list>(<argument><expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>SPOFS_TMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>orignins</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_PHI</name></expr>;</condition> <incr><expr><name>ir</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irl</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>irl</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>irt_isfp</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>emit_spstore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>irl</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>sps_scale</name><argument_list>(<argument><expr><name><name>irl</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>emit_spload</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>sps_scale</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rset_test</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>emit_spstore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>IR</name><argument_list>(<argument><expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>SPOFS_TMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Emit renames for left PHIs which are only spilled outside the loop. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_phi_fixup</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>work</name> <init>= <expr><name><name>as</name><operator>-&gt;</operator><name>phiset</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>work</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>rset_picktop</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>lref</name> <init>= <expr><name><name>as</name><operator>-&gt;</operator><name>phireg</name><index>[<expr><name>r</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>lref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>irt_ismarked</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>irt_clearmark</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Left PHI gained a spill slot before the loop? */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>ra_addrename</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>lref</name></expr></argument>, <argument><expr><name><name>as</name><operator>-&gt;</operator><name>loopsnapno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Setup right PHI reference. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_phi</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>allow</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>!</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <call><name>irt_isfp</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>RSET_FPR</name></expr> </then><else>: <expr><name>RSET_GPR</name></expr></else></ternary><operator>)</operator> <operator>&amp;</operator>
		 <operator>~</operator><name><name>as</name><operator>-&gt;</operator><name>phiset</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>afree</name> <init>= <expr><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>allow</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irl</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irr</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>RID_SINK</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Sink PHI. */</comment>
    <return>return;</return></block_content></block></if></if_stmt>
  <comment type="block">/* Spill slot shuffling is not implemented yet (but rarely needed). */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>irl</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>irr</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>, <argument><expr><name>LJ_TRERR_NYIPHI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <comment type="block">/* Leave at least one register free for non-PHIs (and PHI cycle breaking). */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>afree</name> <operator>&amp;</operator> <operator>(</operator><name>afree</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Two or more free registers? */</comment>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ra_noreg</name><argument_list>(<argument><expr><name><name>irr</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Get a register for the right PHI. */</comment>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ra_allocref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>, <argument><expr><name>allow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Duplicate right PHI, need a copy (rare). */</comment>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ra_scratch</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>allow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>irr</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>irr</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>r</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rset_set</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>phiset</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>phireg</name><index>[<expr><name>r</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><name><name>irl</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Marks left PHIs _with_ register. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ra_noreg</name><argument_list>(<argument><expr><name><name>irl</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>ra_sethint</name><argument_list>(<argument><expr><name><name>irl</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Set register hint for left PHI. */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Otherwise allocate a spill slot. */</comment>
    <comment type="block">/* This is overly restrictive, but it triggers only on synthetic code. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ra_hasreg</name><argument_list>(<argument><expr><name><name>irl</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ra_hasreg</name><argument_list>(<argument><expr><name><name>irr</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>, <argument><expr><name>LJ_TRERR_NYIPHI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>ra_spill</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>irr</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>  <comment type="block">/* Set right PHI spill slot. Sync left slot later. */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>asm_loop_fixup</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Middle part of a loop. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_loop</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MCode</name> <modifier>*</modifier></type><name>mcspill</name></decl>;</decl_stmt>
  <comment type="block">/* LOOP is a guard, so the snapno is up to date. */</comment>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>loopsnapno</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>snapno</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>gcsteps</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>asm_gc_check</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <comment type="block">/* LOOP marks the transition from the variant to the invariant part. */</comment>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>flagmcp</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>invmcp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>sectref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>neverfuse</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>fuseref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>asm_phi_shuffle</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mcspill</name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>mcp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>asm_phi_copyspill</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>asm_loop_fixup</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>mcloop</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>mcp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"===== LOOP ====="</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>as</name><operator>-&gt;</operator><name>realign</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RA_DBG_FLUSH</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>mcp</name></name> <operator>!=</operator> <name>mcspill</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>emit_jmp</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>mcspill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Target-specific assembler ------------------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_asm_x86.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM</name></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_asm_arm.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM64</name></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_asm_arm64.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_PPC</name></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_asm_ppc.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_MIPS</name></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_asm_mips.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Missing assembler for target CPU"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- Common instruction helpers ------------------------------------------ */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_SOFTFP32</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>asm_ldexp</name><parameter_list>(<parameter><type><name>as</name></type></parameter>, <parameter><type><name>ir</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>asm_callid(as, ir, IRCALL_ldexp)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>asm_fppowi</name><parameter_list>(<parameter><type><name>as</name></type></parameter>, <parameter><type><name>ir</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>asm_callid(as, ir, IRCALL_lj_vm_powi)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_pow</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>asm_callid</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>irt_isi64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRCALL_lj_carith_powi64</name></expr> </then><else>:
					  <expr><name>IRCALL_lj_carith_powu64</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  if <condition>(<expr><call><name>irt_isnum</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>asm_callid</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>IRCALL_pow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>asm_fppowi</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_div</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>asm_callid</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>irt_isi64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRCALL_lj_carith_divi64</name></expr> </then><else>:
					  <expr><name>IRCALL_lj_carith_divu64</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>asm_fpdiv</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_mod</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irt_isint</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>asm_callid</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>irt_isi64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRCALL_lj_carith_modi64</name></expr> </then><else>:
					  <expr><name>IRCALL_lj_carith_modu64</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>asm_callid</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>IRCALL_lj_vm_modi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_fuseequal</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Fuse HREF + EQ/NE. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ir</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_HREF</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>as</name><operator>-&gt;</operator><name>curins</name></name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>asm_href</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>asm_equal</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_alen</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>asm_callid</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>REF_NIL</name></expr> ?</condition><then> <expr><name>IRCALL_lj_tab_len</name></expr> </then><else>:
					  <expr><name>IRCALL_lj_tab_len_hint</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Instruction dispatch ------------------------------------------------ */</comment>

<comment type="block">/* Assemble a single instruction. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_ir</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <switch>switch <condition>(<expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr>)</condition> <block>{<block_content>
  <comment type="block">/* Miscellaneous ops. */</comment>
  <case>case <expr><name>IR_LOOP</name></expr>:</case> <expr_stmt><expr><call><name>asm_loop</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_NOP</name></expr>:</case> <case>case <expr><name>IR_XBAR</name></expr>:</case> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ra_used</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_USE</name></expr>:</case>
    <expr_stmt><expr><call><name>ra_alloc1</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>irt_isfp</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>RSET_FPR</name></expr> </then><else>: <expr><name>RSET_GPR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_PHI</name></expr>:</case> <expr_stmt><expr><call><name>asm_phi</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_HIOP</name></expr>:</case> <expr_stmt><expr><call><name>asm_hiop</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_GCSTEP</name></expr>:</case> <expr_stmt><expr><call><name>asm_gcstep</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_PROF</name></expr>:</case> <expr_stmt><expr><call><name>asm_prof</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

  <comment type="block">/* Guarded assertions. */</comment>
  <case>case <expr><name>IR_LT</name></expr>:</case> <case>case <expr><name>IR_GE</name></expr>:</case> <case>case <expr><name>IR_LE</name></expr>:</case> <case>case <expr><name>IR_GT</name></expr>:</case>
  <case>case <expr><name>IR_ULT</name></expr>:</case> <case>case <expr><name>IR_UGE</name></expr>:</case> <case>case <expr><name>IR_ULE</name></expr>:</case> <case>case <expr><name>IR_UGT</name></expr>:</case>
  <case>case <expr><name>IR_ABC</name></expr>:</case>
    <expr_stmt><expr><call><name>asm_comp</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>IR_EQ</name></expr>:</case> <case>case <expr><name>IR_NE</name></expr>:</case> <expr_stmt><expr><call><name>asm_fuseequal</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

  <case>case <expr><name>IR_RETF</name></expr>:</case> <expr_stmt><expr><call><name>asm_retf</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

  <comment type="block">/* Bit ops. */</comment>
  <case>case <expr><name>IR_BNOT</name></expr>:</case> <expr_stmt><expr><call><name>asm_bnot</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BSWAP</name></expr>:</case> <expr_stmt><expr><call><name>asm_bswap</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BAND</name></expr>:</case> <expr_stmt><expr><call><name>asm_band</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BOR</name></expr>:</case> <expr_stmt><expr><call><name>asm_bor</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BXOR</name></expr>:</case> <expr_stmt><expr><call><name>asm_bxor</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BSHL</name></expr>:</case> <expr_stmt><expr><call><name>asm_bshl</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BSHR</name></expr>:</case> <expr_stmt><expr><call><name>asm_bshr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BSAR</name></expr>:</case> <expr_stmt><expr><call><name>asm_bsar</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BROL</name></expr>:</case> <expr_stmt><expr><call><name>asm_brol</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BROR</name></expr>:</case> <expr_stmt><expr><call><name>asm_bror</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

  <comment type="block">/* Arithmetic ops. */</comment>
  <case>case <expr><name>IR_ADD</name></expr>:</case> <expr_stmt><expr><call><name>asm_add</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_SUB</name></expr>:</case> <expr_stmt><expr><call><name>asm_sub</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_MUL</name></expr>:</case> <expr_stmt><expr><call><name>asm_mul</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_MOD</name></expr>:</case> <expr_stmt><expr><call><name>asm_mod</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_NEG</name></expr>:</case> <expr_stmt><expr><call><name>asm_neg</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_SOFTFP32</name></expr></cpp:if>
  <case>case <expr><name>IR_DIV</name></expr>:</case> <case>case <expr><name>IR_POW</name></expr>:</case> <case>case <expr><name>IR_ABS</name></expr>:</case>
  <case>case <expr><name>IR_LDEXP</name></expr>:</case> <case>case <expr><name>IR_FPMATH</name></expr>:</case> <case>case <expr><name>IR_TOBIT</name></expr>:</case>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Unused for LJ_SOFTFP32. */</comment>
    <break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <case>case <expr><name>IR_DIV</name></expr>:</case> <expr_stmt><expr><call><name>asm_div</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_POW</name></expr>:</case> <expr_stmt><expr><call><name>asm_pow</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_ABS</name></expr>:</case> <expr_stmt><expr><call><name>asm_abs</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_LDEXP</name></expr>:</case> <expr_stmt><expr><call><name>asm_ldexp</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_FPMATH</name></expr>:</case> <expr_stmt><expr><call><name>asm_fpmath</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_TOBIT</name></expr>:</case> <expr_stmt><expr><call><name>asm_tobit</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <case>case <expr><name>IR_MIN</name></expr>:</case> <expr_stmt><expr><call><name>asm_min</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_MAX</name></expr>:</case> <expr_stmt><expr><call><name>asm_max</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

  <comment type="block">/* Overflow-checking arithmetic ops. */</comment>
  <case>case <expr><name>IR_ADDOV</name></expr>:</case> <expr_stmt><expr><call><name>asm_addov</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_SUBOV</name></expr>:</case> <expr_stmt><expr><call><name>asm_subov</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_MULOV</name></expr>:</case> <expr_stmt><expr><call><name>asm_mulov</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

  <comment type="block">/* Memory references. */</comment>
  <case>case <expr><name>IR_AREF</name></expr>:</case> <expr_stmt><expr><call><name>asm_aref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_HREF</name></expr>:</case> <expr_stmt><expr><call><name>asm_href</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_HREFK</name></expr>:</case> <expr_stmt><expr><call><name>asm_hrefk</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_NEWREF</name></expr>:</case> <expr_stmt><expr><call><name>asm_newref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_UREFO</name></expr>:</case> <case>case <expr><name>IR_UREFC</name></expr>:</case> <expr_stmt><expr><call><name>asm_uref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_FREF</name></expr>:</case> <expr_stmt><expr><call><name>asm_fref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_STRREF</name></expr>:</case> <expr_stmt><expr><call><name>asm_strref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_LREF</name></expr>:</case> <expr_stmt><expr><call><name>asm_lref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

  <comment type="block">/* Loads and stores. */</comment>
  <case>case <expr><name>IR_ALOAD</name></expr>:</case> <case>case <expr><name>IR_HLOAD</name></expr>:</case> <case>case <expr><name>IR_ULOAD</name></expr>:</case> <case>case <expr><name>IR_VLOAD</name></expr>:</case>
    <expr_stmt><expr><call><name>asm_ahuvload</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>IR_FLOAD</name></expr>:</case> <expr_stmt><expr><call><name>asm_fload</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_XLOAD</name></expr>:</case> <expr_stmt><expr><call><name>asm_xload</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_SLOAD</name></expr>:</case> <expr_stmt><expr><call><name>asm_sload</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_ALEN</name></expr>:</case> <expr_stmt><expr><call><name>asm_alen</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

  <case>case <expr><name>IR_ASTORE</name></expr>:</case> <case>case <expr><name>IR_HSTORE</name></expr>:</case> <case>case <expr><name>IR_USTORE</name></expr>:</case> <expr_stmt><expr><call><name>asm_ahustore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_FSTORE</name></expr>:</case> <expr_stmt><expr><call><name>asm_fstore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_XSTORE</name></expr>:</case> <expr_stmt><expr><call><name>asm_xstore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

  <comment type="block">/* Allocations. */</comment>
  <case>case <expr><name>IR_SNEW</name></expr>:</case> <case>case <expr><name>IR_XSNEW</name></expr>:</case> <expr_stmt><expr><call><name>asm_snew</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_TNEW</name></expr>:</case> <expr_stmt><expr><call><name>asm_tnew</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_TDUP</name></expr>:</case> <expr_stmt><expr><call><name>asm_tdup</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_CNEW</name></expr>:</case> <case>case <expr><name>IR_CNEWI</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
    <expr_stmt><expr><call><name>asm_cnew</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

  <comment type="block">/* Buffer operations. */</comment>
  <case>case <expr><name>IR_BUFHDR</name></expr>:</case> <expr_stmt><expr><call><name>asm_bufhdr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BUFPUT</name></expr>:</case> <expr_stmt><expr><call><name>asm_bufput</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BUFSTR</name></expr>:</case> <expr_stmt><expr><call><name>asm_bufstr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

  <comment type="block">/* Write barriers. */</comment>
  <case>case <expr><name>IR_TBAR</name></expr>:</case> <expr_stmt><expr><call><name>asm_tbar</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_OBAR</name></expr>:</case> <expr_stmt><expr><call><name>asm_obar</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

  <comment type="block">/* Type conversions. */</comment>
  <case>case <expr><name>IR_CONV</name></expr>:</case> <expr_stmt><expr><call><name>asm_conv</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_TOSTR</name></expr>:</case> <expr_stmt><expr><call><name>asm_tostr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_STRTO</name></expr>:</case> <expr_stmt><expr><call><name>asm_strto</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

  <comment type="block">/* Calls. */</comment>
  <case>case <expr><name>IR_CALLA</name></expr>:</case>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>gcsteps</name></name><operator>++</operator></expr>;</expr_stmt>
    <comment type="block">/* fallthrough */</comment>
  <case>case <expr><name>IR_CALLN</name></expr>:</case> <case>case <expr><name>IR_CALLL</name></expr>:</case> <case>case <expr><name>IR_CALLS</name></expr>:</case> <expr_stmt><expr><call><name>asm_call</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_CALLXS</name></expr>:</case> <expr_stmt><expr><call><name>asm_callx</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_CARG</name></expr>:</case> <break>break;</break>

  <default>default:</default>
    <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>J</name><operator>-&gt;</operator><name>errinfo</name></name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_trace_err_info</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>, <argument><expr><name>LJ_TRERR_NYIIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* -- Head of trace ------------------------------------------------------- */</comment>

<comment type="block">/* Head of a root trace. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_head_root</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>spadj</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>asm_head_root_base</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>emit_setvmstate</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>traceno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>spadj</name> <operator>=</operator> <call><name>asm_stack_adjust</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>spadjust</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>spadj</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>emit_spsub</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>spadj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Root traces assume a checked stack for the starting proto. */</comment>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>topslot</name></name> <operator>=</operator> <call><name>gcref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>startpt</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>pt</name><operator>.</operator><name>framesize</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Head of a side trace.
**
** The current simplistic algorithm requires that all slots inherited
** from the parent are live in a register between pass 2 and pass 3. This
** avoids the complexity of stack slot shuffling. But of course this may
** overflow the register set in some cases and cause the dreaded error:
** "NYI: register coalescing too complex". A refined algorithm is needed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_head_side</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef1</name></type> <name><name>sloadins</name><index>[<expr><name>RID_MAX</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>allow</name> <init>= <expr><name>RSET_ALL</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Inverse of all coalesced registers. */</comment>
  <decl_stmt><decl><type><name>RegSet</name></type> <name>live</name> <init>= <expr><name>RSET_EMPTY</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Live parent registers. */</comment>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irp</name> <init>= <expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name>REF_BASE</name></expr>]</index></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Parent base. */</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>spadj</name></decl>, <decl><type ref="prev"/><name>spdelta</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pass2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pass3</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>snapno</name></name> <operator>&amp;&amp;</operator> <name><name>as</name><operator>-&gt;</operator><name>topslot</name></name> <operator>&gt;</operator> <name><name>as</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>topslot</name></name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Force snap #0 alloc to prevent register overwrite in stack check. */</comment>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>snapno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>asm_snap_alloc</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>allow</name> <operator>=</operator> <call><name>asm_head_side_base</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>irp</name></expr></argument>, <argument><expr><name>allow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Scan all parent SLOADs and collect register dependencies. */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>stopins</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <name>REF_BASE</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RegSP</name></type> <name>rs</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_SLOAD</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRSLOAD_PARENT</name><operator>)</operator><operator>)</operator> <operator>||</operator>
	       <operator>(</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_HIOP</name><operator>)</operator> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_PVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rs</name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>parentmap</name><index>[<expr><name>i</name> <operator>-</operator> <name>REF_FIRST</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ra_hasreg</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>allow</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>ra_save</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pass2</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>rs</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Coalesce matching registers right now. */</comment>
      <expr_stmt><expr><call><name>ra_free</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><call><name>regsp_spill</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ra_hasreg</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>pass3</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ra_used</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>sloadins</name><index>[<expr><name>rs</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>rset_set</name><argument_list>(<argument><expr><name>live</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Block live parent register. */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Calculate stack frame adjustment. */</comment>
  <expr_stmt><expr><name>spadj</name> <operator>=</operator> <call><name>asm_stack_adjust</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>spdelta</name> <operator>=</operator> <name>spadj</name> <operator>-</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name><name>as</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>spadjust</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>spdelta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Don't shrink the stack frame. */</comment>
    <expr_stmt><expr><name>spadj</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name><name>as</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>spadjust</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>spdelta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>spadjust</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>spadj</name></expr>;</expr_stmt>

  <comment type="block">/* Reload spilled target registers. */</comment>
  <if_stmt><if>if <condition>(<expr><name>pass2</name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>stopins</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <name>REF_BASE</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>irt_ismarked</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>RegSet</name></type> <name>mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Reg</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RegSP</name></type> <name>rs</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>irt_clearmark</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rs</name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>parentmap</name><index>[<expr><name>i</name> <operator>-</operator> <name>REF_FIRST</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ra_hasspill</name><argument_list>(<argument><expr><call><name>regsp_spill</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>ra_sethint</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* Hint may be gone, set it again. */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>sps_scale</name><argument_list>(<argument><expr><call><name>regsp_spill</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>+</operator><name>spdelta</name> <operator>==</operator> <call><name>sps_scale</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Same spill slot, do nothing. */</comment>
	<expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>!</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <call><name>irt_isfp</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>RSET_FPR</name></expr> </then><else>: <expr><name>RSET_GPR</name></expr></else></ternary><operator>)</operator> <operator>&amp;</operator> <name>allow</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mask</name> <operator>==</operator> <name>RSET_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICOAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ra_allocref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ra_save</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>allow</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>rs</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Coalesce matching registers right now. */</comment>
	  <expr_stmt><expr><call><name>ra_free</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>live</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><call><name>regsp_spill</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>pass3</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Store trace number and adjust stack frame relative to the parent. */</comment>
  <expr_stmt><expr><call><name>emit_setvmstate</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>traceno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>emit_spsub</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>spdelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
  <comment type="block">/* Restore BASE register from parent spill slot. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><name><name>irp</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>emit_spload</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>IR</name><argument_list>(<argument><expr><name>REF_BASE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IR</name><argument_list>(<argument><expr><name>REF_BASE</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>r</name></expr></argument>, <argument><expr><call><name>sps_scale</name><argument_list>(<argument><expr><name><name>irp</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Restore target registers from parent spill slots. */</comment>
  <if_stmt><if>if <condition>(<expr><name>pass3</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>RegSet</name></type> <name>work</name> <init>= <expr><operator>~</operator><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>RSET_ALL</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>work</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>rset_pickbot</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><call><name>regcost_ref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cost</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>RegSP</name></type> <name>rs</name> <init>= <expr><name><name>as</name><operator>-&gt;</operator><name>parentmap</name><index>[<expr><name>ref</name> <operator>-</operator> <name>REF_FIRST</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><call><name>regsp_spill</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>int32_t</name></type> <name>ofs</name> <init>= <expr><call><name>sps_scale</name><argument_list>(<argument><expr><call><name>regsp_spill</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ra_free</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>emit_spload</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>ofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Shuffle registers to match up target regs with parent regs. */</comment>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>RegSet</name></type> <name>work</name></decl>;</decl_stmt>

    <comment type="block">/* Repeatedly coalesce free live registers by moving to their target. */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>work</name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>live</name><operator>)</operator> <operator>!=</operator> <name>RSET_EMPTY</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>Reg</name></type> <name>rp</name> <init>= <expr><call><name>rset_pickbot</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>sloadins</name><index>[<expr><name>rp</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>live</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>rset_clear</name><argument_list>(<argument><expr><name>allow</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ra_free</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>emit_movrr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* We're done if no live registers remain. */</comment>
    <if_stmt><if>if <condition>(<expr><name>live</name> <operator>==</operator> <name>RSET_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>

    <comment type="block">/* Break cycles by renaming one target to a temp. register. */</comment>
    <if_stmt><if>if <condition>(<expr><name>live</name> <operator>&amp;</operator> <name>RSET_GPR</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>RegSet</name></type> <name>tmpset</name> <init>= <expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <operator>~</operator><name>live</name> <operator>&amp;</operator> <name>allow</name> <operator>&amp;</operator> <name>RSET_GPR</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>tmpset</name> <operator>==</operator> <name>RSET_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICOAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>ra_rename</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>rset_pickbot</name><argument_list>(<argument><expr><name>live</name> <operator>&amp;</operator> <name>RSET_GPR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rset_pickbot</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>live</name> <operator>&amp;</operator> <name>RSET_FPR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>RegSet</name></type> <name>tmpset</name> <init>= <expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <operator>~</operator><name>live</name> <operator>&amp;</operator> <name>allow</name> <operator>&amp;</operator> <name>RSET_FPR</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>tmpset</name> <operator>==</operator> <name>RSET_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICOAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>ra_rename</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>rset_pickbot</name><argument_list>(<argument><expr><name>live</name> <operator>&amp;</operator> <name>RSET_FPR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rset_pickbot</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Continue with coalescing to fix up the broken cycle(s). */</comment>
  </block_content>}</block></for>

  <comment type="block">/* Inherit top stack slot already checked by parent trace. */</comment>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>topslot</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>topslot</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>topslot</name></name> <operator>&gt;</operator> <name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>topslot</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Need to check for higher slot? */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXITSTATE_CHECKEXIT</name></cpp:ifdef>
    <comment type="block">/* Highest exit + 1 indicates stack check. */</comment>
    <decl_stmt><decl><type><name>ExitNo</name></type> <name>exitno</name> <init>= <expr><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>nsnap</name></name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Reuse the parent exit in the context of the parent trace. */</comment>
    <decl_stmt><decl><type><name>ExitNo</name></type> <name>exitno</name> <init>= <expr><name><name>as</name><operator>-&gt;</operator><name>J</name><operator>-&gt;</operator><name>exitno</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>topslot</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>as</name><operator>-&gt;</operator><name>topslot</name></name></expr>;</expr_stmt>  <comment type="block">/* Remember for child traces. */</comment>
    <expr_stmt><expr><call><name>asm_stack_check</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name><name>as</name><operator>-&gt;</operator><name>topslot</name></name></expr></argument>, <argument><expr><name>irp</name></expr></argument>, <argument><expr><name>allow</name> <operator>&amp;</operator> <name>RSET_GPR</name></expr></argument>, <argument><expr><name>exitno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Tail of trace ------------------------------------------------------- */</comment>

<comment type="block">/* Get base slot for a snapshot. */</comment>
<function><type><specifier>static</specifier> <name>BCReg</name></type> <name>asm_baseslot</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>, <parameter><decl><type><name>SnapShot</name> <modifier>*</modifier></type><name>snap</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>gotframe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>snapmap</name><index>[<expr><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>n</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name><name>snap</name><operator>-&gt;</operator><name>nent</name></name></expr>;</init> <condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>n</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SnapEntry</name></type> <name>sn</name> <init>= <expr><name><name>map</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>sn</name> <operator>&amp;</operator> <name>SNAP_FRAME</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>gotframe</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><call><name>snap_slot</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>LJ_FR2</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Link to another trace. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_tail_link</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SnapNo</name></type> <name>snapno</name> <init>= <expr><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>nsnap</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Last snapshot. */</comment>
  <decl_stmt><decl><type><name>SnapShot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>snap</name><index>[<expr><name>snapno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>gotframe</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>baseslot</name> <init>= <expr><call><name>asm_baseslot</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>snap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gotframe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>topslot</name></name> <operator>=</operator> <name><name>snap</name><operator>-&gt;</operator><name>topslot</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ra_allocref</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>REF_BASE</name></expr></argument>, <argument><expr><call><name>RID2RSET</name><argument_list>(<argument><expr><name>RID_BASE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>link</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Setup fixed registers for exit to interpreter. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>snap_pc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>snapmap</name><index>[<expr><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name> <operator>+</operator> <name><name>snap</name><operator>-&gt;</operator><name>nent</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>mres</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_JLOOP</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* NYI: find a better way to do this. */</comment>
      <decl_stmt><decl><type><name>BCIns</name> <modifier>*</modifier></type><name>retpc</name> <init>= <expr><operator>&amp;</operator><call><name>traceref</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>, <argument><expr><call><name>bc_d</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>startins</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>bc_isret</name><argument_list>(<argument><expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>retpc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>pc</name> <operator>=</operator> <name>retpc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
    <expr_stmt><expr><call><name>emit_loadu64</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>RID_LPC</name></expr></argument>, <argument><expr><call><name>u64ptr</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>ra_allockreg</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>i32ptr</name><argument_list>(<argument><expr><call><name>J2GG</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>dispatch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RID_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ra_allockreg</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><call><name>i32ptr</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RID_LPC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>mres</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name><name>snap</name><operator>-&gt;</operator><name>nslots</name></name> <operator>-</operator> <name>baseslot</name> <operator>-</operator> <name>LJ_FR2</name><operator>)</operator></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BC_CALLM</name></expr>:</case> <case>case <expr><name>BC_CALLMT</name></expr>:</case>
      <expr_stmt><expr><name>mres</name> <operator>-=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>LJ_FR2</name> <operator>+</operator> <call><name>bc_a</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>bc_c</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>BC_RETM</name></expr>:</case> <expr_stmt><expr><name>mres</name> <operator>-=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><call><name>bc_a</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>bc_d</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>BC_TSETM</name></expr>:</case> <expr_stmt><expr><name>mres</name> <operator>-=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><call><name>bc_a</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <default>default:</default> <if_stmt><if>if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>BC_FUNCF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mres</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>ra_allockreg</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>mres</name></expr></argument>, <argument><expr><name>RID_RET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Return MULTRES or 0. */</comment>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>baseslot</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Save modified BASE for linking to trace with higher start frame. */</comment>
    <expr_stmt><expr><call><name>emit_setgl</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>RID_BASE</name></expr></argument>, <argument><expr><name>jit_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>emit_addptr</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>RID_BASE</name></expr></argument>, <argument><expr><literal type="number">8</literal><operator>*</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>baseslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>J</name><operator>-&gt;</operator><name>ktrace</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Patch ktrace slot with the final GCtrace pointer. */</comment>
    <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name><operator>-&gt;</operator><name>ktrace</name></name></expr></argument>)</argument_list></call><index>[<expr><name>LJ_GC64</name></expr>]</index><operator>.</operator><name>gcr</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name><operator>-&gt;</operator><name>curfinal</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name><operator>-&gt;</operator><name>ktrace</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>o</name> <operator>=</operator> <name>IR_KGC</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Sync the interpreter state with the on-trace state. */</comment>
  <expr_stmt><expr><call><name>asm_stack_restore</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Root traces that add frames need to check the stack at the end. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>as</name><operator>-&gt;</operator><name>parent</name></name> <operator>&amp;&amp;</operator> <name>gotframe</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>asm_stack_check</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name><name>as</name><operator>-&gt;</operator><name>topslot</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>&amp;</operator> <name>RSET_GPR</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Trace setup --------------------------------------------------------- */</comment>

<comment type="block">/* Clear reg/sp for all instructions and add register hints. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>asm_setup_regsp</name><parameter_list>(<parameter><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name> <init>= <expr><name><name>as</name><operator>-&gt;</operator><name>T</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>sink</name> <init>= <expr><name><name>T</name><operator>-&gt;</operator><name>sinktags</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>nins</name> <init>= <expr><name><name>T</name><operator>-&gt;</operator><name>nins</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lastir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>inloop</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_ARM</name></expr></cpp:if>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>rload</name> <init>= <expr><literal type="number">0xa6402a64</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>ra_setup</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Clear reg/sp for constants. */</comment>
  <for>for <control>(<init><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>nk</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>lastir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>REF_BASE</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ir</name> <operator>&lt;</operator> <name>lastir</name></expr>;</condition> <incr><expr><name>ir</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>REGSP_INIT</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>!=</operator> <name>IR_KNULL</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
      <comment type="block">/* The false-positive of irt_is64() for ASMREF_L (REF_NIL) is OK here. */</comment>
      <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Will become non-zero only for RIP-relative addresses. */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* Make life easier for backends by putting address of constant in i. */</comment>
      <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>ir</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* REF_BASE is used for implicit references to the BASE register. */</comment>
  <expr_stmt><expr><name><name>lastir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>REGSP_HINT</name><argument_list>(<argument><expr><name>RID_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>snaprename</name></name> <operator>=</operator> <name>nins</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>snapref</name></name> <operator>=</operator> <name>nins</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>snapno</name></name> <operator>=</operator> <name><name>T</name><operator>-&gt;</operator><name>nsnap</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>stopins</name></name> <operator>=</operator> <name>REF_BASE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>orignins</name></name> <operator>=</operator> <name>nins</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name> <operator>=</operator> <name>nins</name></expr>;</expr_stmt>

  <comment type="block">/* Setup register hints for parent link instructions. */</comment>
  <expr_stmt><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>REF_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>lastir</name> <operator>=</operator> <call><name>lj_snap_regspmap</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name><operator>-&gt;</operator><name>exitno</name></name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>lastir</name> <operator>-</operator> <name>ir</name> <operator>&gt;</operator> <name>LJ_MAX_JSLOTS</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICOAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>stopins</name></name> <operator>=</operator> <operator>(</operator><name>IRRef</name><operator>)</operator><operator>(</operator><operator>(</operator><name>lastir</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name><name>as</name><operator>-&gt;</operator><name>ir</name></name><operator>)</operator></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>parentmap</name></name></expr>;</init> <condition><expr><name>ir</name> <operator>&lt;</operator> <name>lastir</name></expr>;</condition> <incr><expr><name>ir</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>RegSP</name></type> <name>rs</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>rs</name></expr>;</expr_stmt>  <comment type="block">/* Copy original parent RegSP to parentmap. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ra_hasspill</name><argument_list>(<argument><expr><call><name>regsp_spill</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><call><name>REGSP_HINT</name><argument_list>(<argument><expr><call><name>regsp_reg</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>REGSP_INIT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>inloop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name> <operator>=</operator> <name>SPS_FIRST</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>lastir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>nins</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ir</name> <operator>&lt;</operator> <name>lastir</name></expr>;</condition> <incr><expr><name>ir</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>sink</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>RID_SINK</name></expr>)</condition><block type="pseudo"><block_content>
	<continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>RID_SUNK</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Revert after ASM restart. */</comment>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>=</operator> <name>RID_SINK</name></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <switch>switch <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>IR_LOOP</name></expr>:</case>
      <expr_stmt><expr><name>inloop</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_ARM</name></expr></cpp:if>
    <case>case <expr><name>IR_SLOAD</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRSLOAD_TYPECHECK</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_HIOP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><name>IR_ALOAD</name></expr>:</case> <case>case <expr><name>IR_HLOAD</name></expr>:</case> <case>case <expr><name>IR_ULOAD</name></expr>:</case> <case>case <expr><name>IR_VLOAD</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><call><name>REGSP_HINT</name><argument_list>(<argument><expr><operator>(</operator><name>rload</name> <operator>&amp;</operator> <literal type="number">15</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rload</name> <operator>=</operator> <call><name>lj_ror</name><argument_list>(<argument><expr><name>rload</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>IR_CALLXS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>CCallInfo</name></type> <name>ci</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>ci</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <call><name>asm_callx_flags</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>asm_setup_call_slots</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>inloop</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>modset</name></name> <operator>|=</operator> <name>RSET_SCRATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <continue>continue;</continue>
      </block_content>}</block>
    <case>case <expr><name>IR_CALLN</name></expr>:</case> <case>case <expr><name>IR_CALLA</name></expr>:</case> <case>case <expr><name>IR_CALLL</name></expr>:</case> <case>case <expr><name>IR_CALLS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>asm_setup_call_slots</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>inloop</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>modset</name></name> <operator>|=</operator> <ternary><condition><expr><operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CCI_NOFPRCLOBBER</name><operator>)</operator></expr> ?</condition><then>
		      <expr><operator>(</operator><name>RSET_SCRATCH</name> <operator>&amp;</operator> <operator>~</operator><name>RSET_FPR</name><operator>)</operator></expr> </then><else>: <expr><name>RSET_SCRATCH</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <continue>continue;</continue>
      </block_content>}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_SOFTFP</name> <operator>||</operator> <operator>(</operator><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name><operator>)</operator></expr></cpp:if>
    <case>case <expr><name>IR_HIOP</name></expr>:</case>
      <switch>switch <condition>(<expr><operator>(</operator><name>ir</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <name>LJ_TARGET_ARM</name></expr></cpp:if>
      <case>case <expr><name>IR_SLOAD</name></expr>:</case> <case>case <expr><name>IR_ALOAD</name></expr>:</case> <case>case <expr><name>IR_HLOAD</name></expr>:</case> <case>case <expr><name>IR_ULOAD</name></expr>:</case> <case>case <expr><name>IR_VLOAD</name></expr>:</case>
	<if_stmt><if>if <condition>(<expr><call><name>ra_hashint</name><argument_list>(<argument><expr><operator>(</operator><name>ir</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <operator>(</operator><name>ir</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>prev</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	  <continue>continue;</continue>
	</block_content>}</block></if></if_stmt>
	<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <name>LJ_NEED_FP64</name></expr></cpp:if>
      <case>case <expr><name>IR_CONV</name></expr>:</case>
	<if_stmt><if>if <condition>(<expr><call><name>irt_isfp</name><argument_list>(<argument><expr><operator>(</operator><name>ir</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>REGSP_HINT</name><argument_list>(<argument><expr><name>RID_FPRET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <continue>continue;</continue>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="block">/* fallthrough */</comment>
      <case>case <expr><name>IR_CALLN</name></expr>:</case> <case>case <expr><name>IR_CALLXS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_SOFTFP</name></expr></cpp:if>
      <case>case <expr><name>IR_MIN</name></expr>:</case> <case>case <expr><name>IR_MAX</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><operator>(</operator><name>ir</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>prev</name> <operator>=</operator> <call><name>REGSP_HINT</name><argument_list>(<argument><expr><name>RID_RETLO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>REGSP_HINT</name><argument_list>(<argument><expr><name>RID_RETHI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<continue>continue;</continue>
      <default>default:</default>
	<break>break;</break>
      </block_content>}</block></switch>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_SOFTFP</name></expr></cpp:if>
    <case>case <expr><name>IR_MIN</name></expr>:</case> <case>case <expr><name>IR_MAX</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name> <operator>!=</operator> <name>IR_HIOP</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* fallthrough */</comment>
    <comment type="block">/* C calls evict all scratch regs and return results in RID_RET. */</comment>
    <case>case <expr><name>IR_SNEW</name></expr>:</case> <case>case <expr><name>IR_XSNEW</name></expr>:</case> <case>case <expr><name>IR_NEWREF</name></expr>:</case> <case>case <expr><name>IR_BUFPUT</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>REGARG_NUMGPR</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* lj_str_new and lj_tab_newkey need 3 args. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>IR_CNEW</name></expr>:</case>
	<if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>!=</operator> <name>REF_NIL</name> <operator>&amp;&amp;</operator> <name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* lj_cdata_newv needs 4 args. */</comment>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><name>IR_CNEW</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><name>IR_TNEW</name></expr>:</case> <case>case <expr><name>IR_TDUP</name></expr>:</case> <case>case <expr><name>IR_CNEWI</name></expr>:</case> <case>case <expr><name>IR_TOSTR</name></expr>:</case>
    <case>case <expr><name>IR_BUFSTR</name></expr>:</case>
      <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>REGSP_HINT</name><argument_list>(<argument><expr><name>RID_RET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>inloop</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>modset</name></name> <operator>=</operator> <name>RSET_SCRATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    <case>case <expr><name>IR_STRTO</name></expr>:</case> <case>case <expr><name>IR_OBAR</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>inloop</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>modset</name></name> <operator>=</operator> <name>RSET_SCRATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_SOFTFP</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
    <case>case <expr><name>IR_LDEXP</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><name>IR_POW</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>inloop</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>modset</name></name> <operator>|=</operator> <name>RSET_SCRATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><call><name>irt_isnum</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Leave room to call pow(). */</comment>
	    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>REGSP_HINT</name><argument_list>(<argument><expr><name>RID_FPRET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<continue>continue;</continue>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment> <comment type="block">/* for integer POW */</comment>
    <case>case <expr><name>IR_DIV</name></expr>:</case> <case>case <expr><name>IR_MOD</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>REGSP_HINT</name><argument_list>(<argument><expr><name>RID_RET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>inloop</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>modset</name></name> <operator>|=</operator> <operator>(</operator><name>RSET_SCRATCH</name> <operator>&amp;</operator> <name>RSET_GPR</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>IR_FPMATH</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&lt;=</operator> <name>IRFPM_TRUNC</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_SSE4_1</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>REGSP_HINT</name><argument_list>(<argument><expr><name>RID_XMM0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>inloop</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>modset</name></name> <operator>|=</operator> <call><name>RSET_RANGE</name><argument_list>(<argument><expr><name>RID_XMM0</name></expr></argument>, <argument><expr><name>RID_XMM3</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>|</operator><call><name>RID2RSET</name><argument_list>(<argument><expr><name>RID_EAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <continue>continue;</continue>
	</block_content>}</block></if></if_stmt>
	<break>break;</break>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if <condition>(<expr><name>inloop</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>modset</name></name> <operator>|=</operator> <name>RSET_SCRATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
      <break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>REGSP_HINT</name><argument_list>(<argument><expr><name>RID_FPRET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
    <comment type="block">/* Non-constant shift counts need to be in RID_ECX on x86/x64. */</comment>
    <case>case <expr><name>IR_BSHL</name></expr>:</case> <case>case <expr><name>IR_BSHR</name></expr>:</case> <case>case <expr><name>IR_BSAR</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_BMI2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Except if BMI2 is available. */</comment>
	<break>break;</break></block_content></block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><name>IR_BROL</name></expr>:</case> <case>case <expr><name>IR_BROR</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ra_hashint</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>r</name> <operator>=</operator> <call><name>REGSP_HINT</name><argument_list>(<argument><expr><name>RID_ECX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>inloop</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>rset_set</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>modset</name></name></expr></argument>, <argument><expr><name>RID_ECX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Do not propagate hints across type conversions or loads. */</comment>
    <case>case <expr><name>IR_TOBIT</name></expr>:</case>
    <case>case <expr><name>IR_XLOAD</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_TARGET_ARM</name></expr></cpp:if>
    <case>case <expr><name>IR_ALOAD</name></expr>:</case> <case>case <expr><name>IR_HLOAD</name></expr>:</case> <case>case <expr><name>IR_ULOAD</name></expr>:</case> <case>case <expr><name>IR_VLOAD</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    <case>case <expr><name>IR_CONV</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>irt_isfp</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator> <operator>==</operator> <name>IRT_NUM</name> <operator>||</operator>
	  <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator> <operator>==</operator> <name>IRT_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
    <default>default:</default>
      <comment type="block">/* Propagate hints across likely 'op reg, imm' or 'op reg'. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	  <call><name>ra_hashint</name><argument_list>(<argument><expr><call><name>regsp_reg</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>REGSP_INIT</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>oddspill</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>evenspill</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>oddspill</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Assembler core ------------------------------------------------------ */</comment>

<comment type="block">/* Assemble a trace. */</comment>
<function><type><name>void</name></type> <name>lj_asm_trace</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ASMState</name></type> <name>as_</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ASMState</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name>as_</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MCode</name> <modifier>*</modifier></type><name>origtop</name></decl>;</decl_stmt>

  <comment type="block">/* Remove nops/renames left over from ASM restart due to LJ_TRERR_MCODELM. */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>nins</name> <init>= <expr><name><name>T</name><operator>-&gt;</operator><name>nins</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name>nins</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_NOP</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_RENAME</name></expr>)</condition> <block>{<block_content>
      <do>do <block>{<block_content> <expr_stmt><expr><name>ir</name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>nins</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_NOP</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_RENAME</name></expr>)</condition>;</do>
      <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>nins</name></name> <operator>=</operator> <name>nins</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <comment type="block">/* Ensure an initialized instruction beyond the last one for HIOP checks. */</comment>
  <comment type="block">/* This also allows one RENAME to be added without reallocating curfinal. */</comment>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>orignins</name></name> <operator>=</operator> <call><name>lj_ir_nextins</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>ir</name><index>[<expr><name><name>as</name><operator>-&gt;</operator><name>orignins</name></name></expr>]</index></name><operator>.</operator><name>o</name> <operator>=</operator> <name>IR_NOP</name></expr>;</expr_stmt>

  <comment type="block">/* Setup initial state. Copy some fields to reduce indirections. */</comment>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name> <operator>=</operator> <name>J</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>T</name></name> <operator>=</operator> <name>T</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>curfinal</name></name> <operator>=</operator> <call><name>lj_trace_alloc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* This copies the IR, too. */</comment>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>loopref</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>loopref</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>realign</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>loopinv</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <ternary><condition><expr><name><name>J</name><operator>-&gt;</operator><name>parent</name></name></expr> ?</condition><then> <expr><call><name>traceref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

  <comment type="block">/* Reserve MCode memory. */</comment>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>mctop</name></name> <operator>=</operator> <name>origtop</name> <operator>=</operator> <call><name>lj_mcode_reserve</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>mcbot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>mcp</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>mctop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>mclim</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>mcbot</name></name> <operator>+</operator> <name>MCLIM_REDZONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>asm_setup_target</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
  ** This is a loop, because the MCode may have to be (re-)assembled
  ** multiple times:
  **
  ** 1. as-&gt;realign is set (and the assembly aborted), if the arch-specific
  **    backend wants the MCode to be aligned differently.
  **
  **    This is currently only the case on x86/x64, where small loops get
  **    an aligned loop body plus a short branch. Not much effort is wasted,
  **    because the abort happens very quickly and only once.
  **
  ** 2. The IR is immovable, since the MCode embeds pointers to various
  **    constants inside the IR. But RENAMEs may need to be added to the IR
  **    during assembly, which might grow and reallocate the IR. We check
  **    at the end if the IR (in J-&gt;cur.ir) has actually grown, resize the
  **    copy (in J-&gt;curfinal.ir) and try again.
  **
  **    95% of all traces have zero RENAMEs, 3% have one RENAME, 1.5% have
  **    2 RENAMEs and only 0.5% have more than that. That's why we opt to
  **    always have one spare slot in the IR (see above), which means we
  **    have to redo the assembly for only ~2% of all traces.
  **
  **    Very, very rarely, this needs to be done repeatedly, since the
  **    location of constants inside the IR (actually, reachability from
  **    a global pointer) may affect register allocation and thus the
  **    number of RENAMEs.
  */</comment>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>mcp</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>mctop</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUA_USE_ASSERT</name></cpp:ifdef>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>mcp_prev</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>mcp</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>ir</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>curfinal</name><operator>-&gt;</operator><name>ir</name></name></expr>;</expr_stmt>  <comment type="block">/* Use the copied IR. */</comment>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>orignins</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RA_DBG_START</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"===== STOP ====="</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* General trace setup. Emit tail of trace. */</comment>
    <expr_stmt><expr><call><name>asm_tail_prep</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>mcloop</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>flagmcp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>topslot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>gcsteps</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>sectref</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>loopref</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>fuseref</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FUSE</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>as</name><operator>-&gt;</operator><name>loopref</name></name></expr> </then><else>: <expr><name>FUSE_DISABLED</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>asm_setup_regsp</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>as</name><operator>-&gt;</operator><name>loopref</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>asm_tail_link</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Assemble a trace in linear backwards order. */</comment>
    <for>for <control>(<init><expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name><operator>--</operator></expr>;</init> <condition><expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name> <operator>&gt;</operator> <name><name>as</name><operator>-&gt;</operator><name>stopins</name></name></expr>;</condition> <incr><expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>LJ_32</name> <operator>&amp;&amp;</operator> <call><name>irt_isint64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Handled by SPLIT. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ra_used</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ir_sideeff</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>as</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_DCE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Dead-code elimination can be soooo easy. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>irt_isguard</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>asm_snap_prep</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>RA_DBG_REF</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>asm_ir</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>realign</name></name> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>curfinal</name><operator>-&gt;</operator><name>nins</name></name> <operator>&gt;=</operator> <name><name>T</name><operator>-&gt;</operator><name>nins</name></name></expr>)</condition><block type="pseudo"><block_content>
      <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Retry in case only the MCode needs to be realigned. */</comment>

    <comment type="block">/* Emit head of trace. */</comment>
    <expr_stmt><expr><call><name>RA_DBG_REF</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkmclim</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>gcsteps</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>snap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ref</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>asm_snap_prep</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* The GC check is a guard. */</comment>
      <expr_stmt><expr><call><name>asm_gc_check</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>curins</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>stopins</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ra_evictk</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>asm_head_side</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>asm_head_root</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>asm_phi_fixup</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>curfinal</name><operator>-&gt;</operator><name>nins</name></name> <operator>&gt;=</operator> <name><name>T</name><operator>-&gt;</operator><name>nins</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* IR didn't grow? */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>curfinal</name><operator>-&gt;</operator><name>nk</name></name> <operator>==</operator> <name><name>T</name><operator>-&gt;</operator><name>nk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>curfinal</name><operator>-&gt;</operator><name>ir</name></name> <operator>+</operator> <name><name>as</name><operator>-&gt;</operator><name>orignins</name></name></expr></argument>, <argument><expr><name><name>T</name><operator>-&gt;</operator><name>ir</name></name> <operator>+</operator> <name><name>as</name><operator>-&gt;</operator><name>orignins</name></name></expr></argument>,
	     <argument><expr><operator>(</operator><name><name>T</name><operator>-&gt;</operator><name>nins</name></name> <operator>-</operator> <name><name>as</name><operator>-&gt;</operator><name>orignins</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IRIns</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Copy RENAMEs. */</comment>
      <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>nins</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>curfinal</name><operator>-&gt;</operator><name>nins</name></name></expr>;</expr_stmt>
      <break>break;</break>  <comment type="block">/* Done. */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Otherwise try again with a bigger IR. */</comment>
    <expr_stmt><expr><call><name>lj_trace_free</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>curfinal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>curfinal</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>  <comment type="block">/* In case lj_trace_alloc() OOMs. */</comment>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>curfinal</name></name> <operator>=</operator> <call><name>lj_trace_alloc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>realign</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>RA_DBGX</name><argument_list>(<argument><expr><operator>(</operator><name>as</name><operator>,</operator> <literal type="string">"===== START ===="</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>RA_DBG_FLUSH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>freeset</name></name> <operator>!=</operator> <name>RSET_ALL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>J</name></name></expr></argument>, <argument><expr><name>LJ_TRERR_BADRA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Ouch! Should never happen. */</comment>

  <comment type="block">/* Set trace entry point before fixing up tail to allow link to self. */</comment>
  <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>mcode</name></name> <operator>=</operator> <name><name>as</name><operator>-&gt;</operator><name>mcp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>mcloop</name></name> <operator>=</operator> <ternary><condition><expr><name><name>as</name><operator>-&gt;</operator><name>mcloop</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>as</name><operator>-&gt;</operator><name>mcloop</name></name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>as</name><operator>-&gt;</operator><name>mcp</name></name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>as</name><operator>-&gt;</operator><name>loopref</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>asm_tail_fixup</name><argument_list>(<argument><expr><name>as</name></expr></argument>, <argument><expr><name><name>T</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Note: this may change as-&gt;mctop! */</comment>
  <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>szmcode</name></name> <operator>=</operator> <operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>as</name><operator>-&gt;</operator><name>mctop</name></name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>as</name><operator>-&gt;</operator><name>mcp</name></name><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_MCODE_FIXUP</name></expr></cpp:if>
  <expr_stmt><expr><call><name>asm_mcode_fixup</name><argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>mcode</name></name></expr></argument>, <argument><expr><name><name>T</name><operator>-&gt;</operator><name>szmcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>lj_mcode_sync</name><argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>mcode</name></name></expr></argument>, <argument><expr><name>origtop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IR</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
