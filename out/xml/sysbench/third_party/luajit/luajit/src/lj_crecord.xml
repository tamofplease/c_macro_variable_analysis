<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_crecord.c"><comment type="block">/*
** Trace recorder for C data operations.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_ffrecord_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_frame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cdata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cconv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_carith.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_clib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ccall.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ircall.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_iropt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_record.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ffrecord.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_snap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_crecord.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strfmt.h"</cpp:file></cpp:include>

<comment type="block">/* Some local macros to save typing. Undef'd at the end. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IR</name><parameter_list>(<parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>			<cpp:value>(&amp;J-&gt;cur.ir[(ref)])</cpp:value></cpp:define>

<comment type="block">/* Pass IR on to next optimization in chain (FOLD). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>emitir</name><parameter_list>(<parameter><type><name>ot</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(lj_ir_set(J, (ot), (a), (b)), lj_opt_fold(J))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>emitconv</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>dt</name></type></parameter>, <parameter><type><name>st</name></type></parameter>, <parameter><type><name>flags</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>emitir(IRT(IR_CONV, (dt)), (a), (st)|((dt) &lt;&lt; 5)|(flags))</cpp:value></cpp:define>

<comment type="block">/* -- C type checks ------------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>GCcdata</name> <modifier>*</modifier></type><name>argv2cdata</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>tr</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trtypeid</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_iscdata</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>cd</name> <operator>=</operator> <call><name>cdataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Specialize to the CTypeID. */</comment>
  <expr_stmt><expr><name>trtypeid</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_U16</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFL_CDATA_CTYPEID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trtypeid</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Specialize to the CTypeID held by a cdata constructor. */</comment>
<function><type><specifier>static</specifier> <name>CTypeID</name></type> <name>crec_constructor</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>tr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>tref_iscdata</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name> <operator>==</operator> <name>CTID_CTYPEID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>id</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>CTypeID</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFL_CDATA_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>id</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CTypeID</name></type> <name>argv2ctype</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>tr</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isstr</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CPState</name></type> <name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>oldtop</name></decl>;</decl_stmt>
    <comment type="block">/* Specialize to the string containing the C type declaration. */</comment>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>L</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>cts</name></name> <operator>=</operator> <call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldtop</name> <operator>=</operator> <name><name>cp</name><operator>.</operator><name>cts</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>srcname</name></name> <operator>=</operator> <call><name>strdata</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>p</name></name> <operator>=</operator> <call><name>strdata</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>param</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>CPARSE_MODE_ABSTRACT</name><operator>|</operator><name>CPARSE_MODE_NOIMPLICIT</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>lj_cparse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>cp</name><operator>.</operator><name>cts</name><operator>-&gt;</operator><name>top</name></name> <operator>&gt;</operator> <name>oldtop</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Avoid new struct defs. */</comment>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name><name>cp</name><operator>.</operator><name>val</name><operator>.</operator><name>id</name></name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>argv2cdata</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name> <operator>==</operator> <name>CTID_CTYPEID</name></expr> ?</condition><then> <expr><call><name>crec_constructor</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr> </then><else>:
					<expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></else></ternary></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Convert CType to IRType (if possible). */</comment>
<function><type><specifier>static</specifier> <name>IRType</name></type> <name>crec_ct2irt</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_FP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>IRT_NUM</name></expr>;</return></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>IRT_FLOAT</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>b</name> <init>= <expr><call><name>lj_fls</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>b</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>IRT_I8</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>b</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>LJ_64</name> <operator>&amp;&amp;</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator></expr> ?</condition><then> <expr><name>IRT_P64</name></expr> </then><else>: <expr><name>IRT_P32</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_iscomplex</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>IRT_NUM</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>IRT_FLOAT</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>IRT_CDATA</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Optimized memory fill and copy -------------------------------------- */</comment>

<comment type="block">/* Maximum length and unroll of inlined copy/fill. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREC_COPY_MAXUNROLL</name></cpp:macro>		<cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREC_COPY_MAXLEN</name></cpp:macro>		<cpp:value>128</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREC_FILL_MAXUNROLL</name></cpp:macro>		<cpp:value>16</cpp:value></cpp:define>

<comment type="block">/* Number of windowed registers used for optimized memory copy. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREC_COPY_REGWIN</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_PPC</name> <operator>||</operator> <name>LJ_TARGET_MIPS</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREC_COPY_REGWIN</name></cpp:macro>		<cpp:value>8</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREC_COPY_REGWIN</name></cpp:macro>		<cpp:value>4</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* List of memory offsets for copy/fill. */</comment>
<typedef>typedef <type><struct>struct <name>CRecMemList</name> <block>{
  <decl_stmt><decl><type><name>CTSize</name></type> <name>ofs</name></decl>;</decl_stmt>		<comment type="block">/* Offset in bytes. */</comment>
  <decl_stmt><decl><type><name>IRType</name></type> <name>tp</name></decl>;</decl_stmt>		<comment type="block">/* Type of load/store. */</comment>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trofs</name></decl>;</decl_stmt>		<comment type="block">/* TRef of interned offset. */</comment>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trval</name></decl>;</decl_stmt>		<comment type="block">/* TRef of load value. */</comment>
}</block></struct></type> <name>CRecMemList</name>;</typedef>

<comment type="block">/* Generate copy list for element-wise struct copy. */</comment>
<function><type><specifier>static</specifier> <name>MSize</name></type> <name>crec_copy_struct</name><parameter_list>(<parameter><decl><type><name>CRecMemList</name> <modifier>*</modifier></type><name>ml</name></decl></parameter>, <parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>fid</name> <init>= <expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>mlp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>fid</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>df</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>fid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>fid</name> <operator>=</operator> <name><name>df</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>df</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>cct</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRType</name></type> <name>tp</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>gcref</name><argument_list>(<argument><expr><name><name>df</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Ignore unnamed fields. */</comment>
      <expr_stmt><expr><name>cct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>df</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Field type. */</comment>
      <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>crec_ct2irt</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>cct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>tp</name> <operator>==</operator> <name>IRT_CDATA</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* NYI: aggregates. */</comment>
      <if_stmt><if>if <condition>(<expr><name>mlp</name> <operator>&gt;=</operator> <name>CREC_COPY_MAXUNROLL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>ml</name><index>[<expr><name>mlp</name></expr>]</index></name><operator>.</operator><name>ofs</name> <operator>=</operator> <name><name>df</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ml</name><index>[<expr><name>mlp</name></expr>]</index></name><operator>.</operator><name>tp</name> <operator>=</operator> <name>tp</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mlp</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_iscomplex</name><argument_list>(<argument><expr><name><name>cct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>mlp</name> <operator>&gt;=</operator> <name>CREC_COPY_MAXUNROLL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>ml</name><index>[<expr><name>mlp</name></expr>]</index></name><operator>.</operator><name>ofs</name> <operator>=</operator> <name><name>df</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <operator>(</operator><name><name>cct</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ml</name><index>[<expr><name>mlp</name></expr>]</index></name><operator>.</operator><name>tp</name> <operator>=</operator> <name>tp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mlp</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ctype_isconstval</name><argument_list>(<argument><expr><name><name>df</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* NYI: bitfields and sub-structures. */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>mlp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate unrolled copy list, from highest to lowest step size/alignment. */</comment>
<function><type><specifier>static</specifier> <name>MSize</name></type> <name>crec_copy_unroll</name><parameter_list>(<parameter><decl><type><name>CRecMemList</name> <modifier>*</modifier></type><name>ml</name></decl></parameter>, <parameter><decl><type><name>CTSize</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>CTSize</name></type> <name>step</name></decl></parameter>,
			      <parameter><decl><type><name>IRType</name></type> <name>tp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>ofs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>mlp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tp</name> <operator>==</operator> <name>IRT_CDATA</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tp</name> <operator>=</operator> <name>IRT_U8</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><call><name>lj_fls</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <do>do <block>{<block_content>
    <while>while <condition>(<expr><name>ofs</name> <operator>+</operator> <name>step</name> <operator>&lt;=</operator> <name>len</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>mlp</name> <operator>&gt;=</operator> <name>CREC_COPY_MAXUNROLL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>ml</name><index>[<expr><name>mlp</name></expr>]</index></name><operator>.</operator><name>ofs</name> <operator>=</operator> <name>ofs</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ml</name><index>[<expr><name>mlp</name></expr>]</index></name><operator>.</operator><name>tp</name> <operator>=</operator> <name>tp</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mlp</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>ofs</name> <operator>+=</operator> <name>step</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>step</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>tp</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><name>ofs</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>;</do>
  <return>return <expr><name>mlp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Emit copy list with windowed loads/stores.
** LJ_TARGET_UNALIGNED: may emit unaligned loads/stores (not marked as such).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>crec_copy_emit</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>CRecMemList</name> <modifier>*</modifier></type><name>ml</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>mlp</name></decl></parameter>,
			   <parameter><decl><type><name>TRef</name></type> <name>trdst</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>trsrc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>rwin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>mlp</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trofs</name> <init>= <expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>ml</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ofs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trsptr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trsrc</name></expr></argument>, <argument><expr><name>trofs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ml</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trval</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name><name>ml</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trsptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ml</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trofs</name> <operator>=</operator> <name>trofs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rwin</name> <operator>+=</operator> <ternary><condition><expr><operator>(</operator><name>LJ_SOFTFP32</name> <operator>&amp;&amp;</operator> <name><name>ml</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tp</name> <operator>==</operator> <name>IRT_NUM</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rwin</name> <operator>&gt;=</operator> <name>CREC_COPY_REGWIN</name> <operator>||</operator> <name>i</name> <operator>&gt;=</operator> <name>mlp</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Flush buffered stores. */</comment>
      <expr_stmt><expr><name>rwin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for <control>( <init>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	<decl_stmt><decl><type><name>TRef</name></type> <name>trdptr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trdst</name></expr></argument>, <argument><expr><name><name>ml</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>trofs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XSTORE</name></expr></argument>, <argument><expr><name><name>ml</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trdptr</name></expr></argument>, <argument><expr><name><name>ml</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>trval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Optimized memory copy. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>crec_copy</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>trdst</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>trsrc</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>trlen</name></decl></parameter>,
		      <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isk</name><argument_list>(<argument><expr><name>trlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Length must be constant. */</comment>
    <decl_stmt><decl><type><name>CRecMemList</name></type> <name><name>ml</name><index>[<expr><name>CREC_COPY_MAXUNROLL</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MSize</name></type> <name>mlp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTSize</name></type> <name>step</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><operator>(</operator><name>CTSize</name><operator>)</operator><call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>trlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRType</name></type> <name>tp</name> <init>= <expr><name>IRT_CDATA</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>needxbar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* Shortcut. */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>CREC_COPY_MAXLEN</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fallback</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ct</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_isarray</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isarray</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>cct</name> <init>= <expr><call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>crec_ct2irt</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>cct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tp</name> <operator>==</operator> <name>IRT_CDATA</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>rawcopy</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>step</name> <operator>=</operator> <name><name>lj_ir_type_size</name><index>[<expr><name>tp</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name>len</name> <operator>&amp;</operator> <operator>(</operator><name>step</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_UNION</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>step</name> <operator>=</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <call><name>ctype_align</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<goto>goto <name>rawcopy</name>;</goto>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name>mlp</name> <operator>=</operator> <call><name>crec_copy_struct</name><argument_list>(<argument><expr><name>ml</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<goto>goto <name>emitcopy</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
    <label><name>rawcopy</name>:</label>
      <expr_stmt><expr><name>needxbar</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>LJ_TARGET_UNALIGNED</name> <operator>||</operator> <name>step</name> <operator>&gt;=</operator> <name>CTSIZE_PTR</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>step</name> <operator>=</operator> <name>CTSIZE_PTR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>mlp</name> <operator>=</operator> <call><name>crec_copy_unroll</name><argument_list>(<argument><expr><name>ml</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>emitcopy</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>mlp</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>crec_copy_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ml</name></expr></argument>, <argument><expr><name>mlp</name></expr></argument>, <argument><expr><name>trdst</name></expr></argument>, <argument><expr><name>trsrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>needxbar</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XBAR</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<label><name>fallback</name>:</label>
  <comment type="block">/* Call memcpy. Always needs a barrier to disable alias analysis. */</comment>
  <expr_stmt><expr><call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_memcpy</name></expr></argument>, <argument><expr><name>trdst</name></expr></argument>, <argument><expr><name>trsrc</name></expr></argument>, <argument><expr><name>trlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XBAR</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Generate unrolled fill list, from highest to lowest step size/alignment. */</comment>
<function><type><specifier>static</specifier> <name>MSize</name></type> <name>crec_fill_unroll</name><parameter_list>(<parameter><decl><type><name>CRecMemList</name> <modifier>*</modifier></type><name>ml</name></decl></parameter>, <parameter><decl><type><name>CTSize</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>CTSize</name></type> <name>step</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>ofs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>mlp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRType</name></type> <name>tp</name> <init>= <expr><name>IRT_U8</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><call><name>lj_fls</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <do>do <block>{<block_content>
    <while>while <condition>(<expr><name>ofs</name> <operator>+</operator> <name>step</name> <operator>&lt;=</operator> <name>len</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>mlp</name> <operator>&gt;=</operator> <name>CREC_COPY_MAXUNROLL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>ml</name><index>[<expr><name>mlp</name></expr>]</index></name><operator>.</operator><name>ofs</name> <operator>=</operator> <name>ofs</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ml</name><index>[<expr><name>mlp</name></expr>]</index></name><operator>.</operator><name>tp</name> <operator>=</operator> <name>tp</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mlp</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>ofs</name> <operator>+=</operator> <name>step</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>step</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>tp</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><name>ofs</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>;</do>
  <return>return <expr><name>mlp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Emit stores for fill list.
** LJ_TARGET_UNALIGNED: may emit unaligned stores (not marked as such).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>crec_fill_emit</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>CRecMemList</name> <modifier>*</modifier></type><name>ml</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>mlp</name></decl></parameter>,
			   <parameter><decl><type><name>TRef</name></type> <name>trdst</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>trfill</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>mlp</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trofs</name> <init>= <expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>ml</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ofs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trdptr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trdst</name></expr></argument>, <argument><expr><name>trofs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XSTORE</name></expr></argument>, <argument><expr><name><name>ml</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trdptr</name></expr></argument>, <argument><expr><name>trfill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Optimized memory fill. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>crec_fill</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>trdst</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>trlen</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>trfill</name></decl></parameter>,
		      <parameter><decl><type><name>CTSize</name></type> <name>step</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isk</name><argument_list>(<argument><expr><name>trlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Length must be constant. */</comment>
    <decl_stmt><decl><type><name>CRecMemList</name></type> <name><name>ml</name><index>[<expr><name>CREC_FILL_MAXUNROLL</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MSize</name></type> <name>mlp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTSize</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>CTSize</name><operator>)</operator><call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>trlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* Shortcut. */</comment>
    <if_stmt><if>if <condition>(<expr><name>LJ_TARGET_UNALIGNED</name> <operator>||</operator> <name>step</name> <operator>&gt;=</operator> <name>CTSIZE_PTR</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>step</name> <operator>=</operator> <name>CTSIZE_PTR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>step</name> <operator>*</operator> <name>CREC_FILL_MAXUNROLL</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fallback</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>mlp</name> <operator>=</operator> <call><name>crec_fill_unroll</name><argument_list>(<argument><expr><name>ml</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>mlp</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fallback</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isk</name><argument_list>(<argument><expr><name>trfill</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>ml</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tp</name> <operator>!=</operator> <name>IRT_U8</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>trfill</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>trfill</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>, <argument><expr><name>IRT_U8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ml</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tp</name> <operator>!=</operator> <name>IRT_U8</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Scatter U8 to U16/U32/U64. */</comment>
      <if_stmt><if>if <condition>(<expr><name>CTSIZE_PTR</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name><name>ml</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tp</name> <operator>==</operator> <name>IRT_U64</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>tref_isk</name><argument_list>(<argument><expr><name>trfill</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Pointless on x64 with zero-extended regs. */</comment>
	  <expr_stmt><expr><name>trfill</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>trfill</name></expr></argument>, <argument><expr><name>IRT_U64</name></expr></argument>, <argument><expr><name>IRT_U32</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>trfill</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_MUL</name></expr></argument>, <argument><expr><name>IRT_U64</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trfill</name></expr></argument>,
			<argument><expr><call><name>lj_ir_kint64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>U64x</name><argument_list>(<argument><expr><literal type="number">01010101</literal></expr></argument>,<argument><expr><literal type="number">01010101</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name>trfill</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_MUL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trfill</name></expr></argument>,
		   <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>ml</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tp</name> <operator>==</operator> <name>IRT_U16</name></expr> ?</condition><then> <expr><literal type="number">0x0101</literal></expr> </then><else>: <expr><literal type="number">0x01010101</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>crec_fill_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ml</name></expr></argument>, <argument><expr><name>mlp</name></expr></argument>, <argument><expr><name>trdst</name></expr></argument>, <argument><expr><name>trfill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
<label><name>fallback</name>:</label>
    <comment type="block">/* Call memset. Always needs a barrier to disable alias analysis. */</comment>
    <expr_stmt><expr><call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_memset</name></expr></argument>, <argument><expr><name>trdst</name></expr></argument>, <argument><expr><name>trfill</name></expr></argument>, <argument><expr><name>trlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Note: arg order! */</comment>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XBAR</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Convert C type to C type -------------------------------------------- */</comment>

<comment type="block">/*
** This code mirrors the code in lj_cconv.c. It performs the same steps
** for the trace recorder that lj_cconv.c does for the interpreter.
**
** One major difference is that we can get away with much fewer checks
** here. E.g. checks for casts, constness or correct types can often be
** omitted, even if they might fail. The interpreter subsequently throws
** an error, which aborts the trace.
**
** All operations are specialized to their C types, so the on-trace
** outcome must be the same as the outcome in the interpreter. If the
** interpreter doesn't throw an error, then the trace is correct, too.
** Care must be taken not to generate invalid (temporary) IR or to
** trigger asserts.
*/</comment>

<comment type="block">/* Determine whether a passed number or cdata number is non-zero. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>crec_isnonzero</name><parameter_list>(<parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_FP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TRef</name></type> <name>crec_ct_ct</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>dp</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>sp</name></decl></parameter>,
		       <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>svisnz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRType</name></type> <name>dt</name> <init>= <expr><call><name>crec_ct2irt</name><argument_list>(<argument><expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRType</name></type> <name>st</name> <init>= <expr><call><name>crec_ct2irt</name><argument_list>(<argument><expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>dsize</name> <init>= <expr><name><name>d</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>, <decl><type ref="prev"/><name>ssize</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>dinfo</name> <init>= <expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>, <decl><type ref="prev"/><name>sinfo</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>ctype_type</name><argument_list>(<argument><expr><name>dinfo</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>CT_MAYCONVERT</name> <operator>||</operator> <call><name>ctype_type</name><argument_list>(<argument><expr><name>sinfo</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>CT_MAYCONVERT</name></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>err_conv</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/*
  ** Note: Unlike lj_cconv_ct_ct(), sp holds the _value_ of pointers and
  ** numbers up to 8 bytes. Otherwise sp holds a pointer.
  */</comment>

  <switch>switch <condition>(<expr><call><name>cconv_idx2</name><argument_list>(<argument><expr><name>dinfo</name></expr></argument>, <argument><expr><name>sinfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
  <comment type="block">/* Destination is a bool. */</comment>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>:</case>
    <goto>goto <name>xstore</name>;</goto>  <comment type="block">/* Source operand is already normalized. */</comment>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>:</case>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>st</name> <operator>!=</operator> <name>IRT_CDATA</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Specialize to the result of a comparison against 0. */</comment>
      <decl_stmt><decl><type><name>TRef</name></type> <name>zero</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>st</name> <operator>==</operator> <name>IRT_NUM</name>  <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_FLOAT</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>:
		  <expr><ternary><condition><expr><operator>(</operator><name>st</name> <operator>==</operator> <name>IRT_I64</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_U64</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>lj_ir_kint64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>:
		  <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>isnz</name> <init>= <expr><call><name>crec_isnonzero</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>svisnz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><ternary><condition><expr><name>isnz</name></expr> ?</condition><then> <expr><name>IR_NE</name></expr> </then><else>: <expr><name>IR_EQ</name></expr></else></ternary></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>isnz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>xstore</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <goto>goto <name>err_nyi</name>;</goto>

  <comment type="block">/* Destination is an integer. */</comment>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>:</case>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>:</case>
  <label><name>conv_I_I</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>dt</name> <operator>==</operator> <name>IRT_CDATA</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_CDATA</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_nyi</name>;</goto></block_content></block></if></if_stmt>
    <comment type="block">/* Extend 32 to 64 bit integer. */</comment>
    <if_stmt><if>if <condition>(<expr><name>dsize</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>ssize</name> <operator>&lt;</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>LJ_64</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sinfo</name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><ternary><condition><expr><name>ssize</name> <operator>&lt;</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><name>IRT_INT</name></expr> </then><else>: <expr><name>st</name></expr></else></ternary></expr></argument>,
		    <argument><expr><ternary><condition><expr><operator>(</operator><name>sinfo</name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>IRCONV_SEXT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>dsize</name> <operator>&lt;</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>ssize</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Truncate from 64 bit integer. */</comment>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><ternary><condition><expr><name>dsize</name> <operator>&lt;</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><name>IRT_INT</name></expr> </then><else>: <expr><name>dt</name></expr></else></ternary></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>st</name> <operator>==</operator> <name>IRT_INT</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <label><name>xstore</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>dt</name> <operator>==</operator> <name>IRT_I64</name> <operator>||</operator> <name>dt</name> <operator>==</operator> <name>IRT_U64</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>sp</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XSTORE</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>:</case>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Load re. */</comment>
    <comment type="block">/* fallthrough */</comment>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>dt</name> <operator>==</operator> <name>IRT_CDATA</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_CDATA</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_nyi</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><ternary><condition><expr><name>dsize</name> <operator>&lt;</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><name>IRT_INT</name></expr> </then><else>: <expr><name>dt</name></expr></else></ternary></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>IRCONV_ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>xstore</name>;</goto>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>:</case>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>:</case>
    <expr_stmt><expr><name>sinfo</name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_NUM</name></expr></argument>, <argument><expr><name>CTF_UNSIGNED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ssize</name> <operator>=</operator> <name>CTSIZE_PTR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>st</name> <operator>=</operator> <name>IRT_UINTP</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>dsize</name> <operator>^</operator> <name>ssize</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">8</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Must insert no-op type conversion. */</comment>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><ternary><condition><expr><name>dsize</name> <operator>&lt;</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><name>IRT_INT</name></expr> </then><else>: <expr><name>dt</name></expr></else></ternary></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>xstore</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <goto>goto <name>conv_I_I</name>;</goto>

  <comment type="block">/* Destination is a floating-point number. */</comment>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>:</case>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>:</case>
  <label><name>conv_F_I</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>dt</name> <operator>==</operator> <name>IRT_CDATA</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_CDATA</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_nyi</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><ternary><condition><expr><name>ssize</name> <operator>&lt;</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><name>IRT_INT</name></expr> </then><else>: <expr><name>st</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>xstore</name>;</goto>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>:</case>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Load re. */</comment>
    <comment type="block">/* fallthrough */</comment>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>:</case>
  <label><name>conv_F_F</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>dt</name> <operator>==</operator> <name>IRT_CDATA</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_CDATA</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_nyi</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dt</name> <operator>!=</operator> <name>st</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <goto>goto <name>xstore</name>;</goto>

  <comment type="block">/* Destination is a complex number. */</comment>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>:</case>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>:</case>
    <block>{<block_content>  <comment type="block">/* Clear im. */</comment>
      <decl_stmt><decl><type><name>TRef</name></type> <name>ptr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>dsize</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XSTORE</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <comment type="block">/* Convert to re. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>sinfo</name> <operator>&amp;</operator> <name>CTF_FP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>conv_F_F</name>;</goto></block_content></block></if> <else>else<block type="pseudo"><block_content> <goto>goto <name>conv_F_I</name>;</goto></block_content></block></else></if_stmt>

  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>dt</name> <operator>==</operator> <name>IRT_CDATA</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_CDATA</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_nyi</name>;</goto></block_content></block></if></if_stmt>
    <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>re</name></decl>, <decl><type ref="prev"/><name>im</name></decl>, <decl><type ref="prev"/><name>ptr</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>re</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>ssize</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>im</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>dt</name> <operator>!=</operator> <name>st</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>re</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>im</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>im</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XSTORE</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>dsize</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XSTORE</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>im</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <break>break;</break>

  <comment type="block">/* Destination is a vector. */</comment>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>V</name></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>:</case>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>V</name></expr></argument>, <argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>:</case>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>V</name></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>:</case>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>V</name></expr></argument>, <argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>:</case>
    <goto>goto <name>err_nyi</name>;</goto>

  <comment type="block">/* Destination is a pointer. */</comment>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>:</case>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>:</case>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>:</case>
    <comment type="block">/* There are only 32 bit pointers/addresses on 32 bit machines.
    ** Also ok on x64, since all 32 bit ops clear the upper part of the reg.
    */</comment>
    <goto>goto <name>xstore</name>;</goto>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>st</name> <operator>==</operator> <name>IRT_CDATA</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_nyi</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LJ_64</name> <operator>&amp;&amp;</operator> <name>ssize</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Truncate from 64 bit integer. */</comment>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>IRT_U32</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <goto>goto <name>xstore</name>;</goto>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>st</name> <operator>==</operator> <name>IRT_CDATA</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_nyi</name>;</goto></block_content></block></if></if_stmt>
    <comment type="block">/* The signed conversion is cheaper. x64 really has 47 bit pointers. */</comment>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>LJ_64</name> <operator>&amp;&amp;</operator> <name>dsize</name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator></expr> ?</condition><then> <expr><name>IRT_I64</name></expr> </then><else>: <expr><name>IRT_U32</name></expr></else></ternary></expr></argument>,
		  <argument><expr><name>st</name></expr></argument>, <argument><expr><name>IRCONV_ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>xstore</name>;</goto>

  <comment type="block">/* Destination is an array. */</comment>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>:</case>
  <comment type="block">/* Destination is a struct/union. */</comment>
  <case>case <expr><call><name>CCX</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>dp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_conv</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>crec_copy</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>dsize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <default>default:</default>
  <label><name>err_conv</name>:</label>
  <label><name>err_nyi</name>:</label>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICONV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Convert C type to TValue (load) ------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>TRef</name></type> <name>crec_tv_ct</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>CTypeID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>sp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><call><name>crec_ct2irt</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>sinfo</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isnum</name><argument_list>(<argument><expr><name>sinfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_CDATA</name></expr>)</condition><block type="pseudo"><block_content>
      <goto>goto <name>err_nyi</name>;</goto></block_content></block></if></if_stmt>  <comment type="block">/* NYI: copyval of &gt;64 bit integers. */</comment>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_FLOAT</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_U32</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Keep uint32_t/float as numbers. */</comment>
      <return>return <expr><call><name>emitconv</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRT_NUM</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_I64</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_U64</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Box 64 bit integer. */</comment>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>sinfo</name> <operator>&amp;</operator> <name>CTF_BOOL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Assume not equal to zero. Fixup and emit pending guard later. */</comment>
      <expr_stmt><expr><call><name>lj_ir_set</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_NE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>=</operator> <name>LJ_POST_FIXGUARD</name></expr>;</expr_stmt>
      <return>return <expr><name>TREF_TRUE</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><name>tr</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name>sinfo</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isenum</name><argument_list>(<argument><expr><name>sinfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Box pointers and enums. */</comment>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isrefarray</name><argument_list>(<argument><expr><name>sinfo</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isstruct</name><argument_list>(<argument><expr><name>sinfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sid</name> <operator>=</operator> <call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>CTINFO_REF</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Create ref. */</comment>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_iscomplex</name><argument_list>(<argument><expr><name>sinfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Unbox/box complex. */</comment>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>esz</name> <init>= <expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>ptr</name></decl>, <decl><type ref="prev"/><name>tr1</name></decl>, <decl><type ref="prev"/><name>tr2</name></decl>, <decl><type ref="prev"/><name>dp</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_CNEW</name></expr></argument>, <argument><expr><name>IRT_CDATA</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TREF_NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tr1</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>esz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tr2</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GCcdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XSTORE</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>tr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GCcdata</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>esz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XSTORE</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>tr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>dp</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* NYI: copyval of vectors. */</comment>
  <label><name>err_nyi</name>:</label>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICONV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Box pointer, ref, enum or 64 bit integer. */</comment>
  <return>return <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_CNEWI</name></expr></argument>, <argument><expr><name>IRT_CDATA</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Convert TValue to C type (store) ------------------------------------ */</comment>

<function><type><specifier>static</specifier> <name>TRef</name></type> <name>crec_ct_tv</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>dp</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>sp</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>sval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>sid</name> <init>= <expr><name>CTID_P_VOID</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>svisnz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>sid</name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>svisnz</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><operator>(</operator><ternary><condition><expr><call><name>tvisint</name><argument_list>(<argument><expr><name>sval</name></expr></argument>)</argument_list></call></expr>?</condition><then><expr><operator>(</operator><call><name>intV</name><argument_list>(<argument><expr><name>sval</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></then><else>:<expr><operator>!</operator><call><name>tviszero</name><argument_list>(<argument><expr><name>sval</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_isnum</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>sid</name> <operator>=</operator> <name>CTID_DOUBLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>svisnz</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><operator>(</operator><ternary><condition><expr><call><name>tvisint</name><argument_list>(<argument><expr><name>sval</name></expr></argument>)</argument_list></call></expr>?</condition><then><expr><operator>(</operator><call><name>intV</name><argument_list>(<argument><expr><name>sval</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></then><else>:<expr><operator>!</operator><call><name>tviszero</name><argument_list>(<argument><expr><name>sval</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_isbool</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>tref_istrue</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sid</name> <operator>=</operator> <name>CTID_BOOL</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_isnil</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_isudata</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCudata</name> <modifier>*</modifier></type><name>ud</name> <init>= <expr><call><name>udataV</name><argument_list>(<argument><expr><name>sval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ud</name><operator>-&gt;</operator><name>udtype</name></name> <operator>==</operator> <name>UDTYPE_IO_FILE</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_U8</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>IRFL_UDATA_UDTYPE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>UDTYPE_IO_FILE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>IRFL_UDATA_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GCudata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_isstr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Match string against enum constant. */</comment>
      <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strV</name><argument_list>(<argument><expr><name>sval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>ofs</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>cct</name> <init>= <expr><call><name>lj_ctype_getfield</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="block">/* Specialize to the name of the enum constant. */</comment>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>cct</name> <operator>&amp;&amp;</operator> <call><name>ctype_isconstval</name><argument_list>(<argument><expr><name><name>cct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>cct</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>size</name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>svisnz</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><operator>(</operator><name>ofs</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>ofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sid</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>cct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>  <comment type="block">/* else: interpreter will throw. */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isrefarray</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Copy string to array. */</comment>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* NYI */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Otherwise pass the string data as a const char[]. */</comment>
      <comment type="block">/* Don't use STRREF. It folds with SNEW, which loses the trailing NUL. */</comment>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GCstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sid</name> <operator>=</operator> <name>CTID_A_CCHAR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_islightud</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BAND</name></expr></argument>, <argument><expr><name>IRT_P64</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>,
		<argument><expr><call><name>lj_ir_kint64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>U64x</name><argument_list>(<argument><expr><literal type="number">00007fff</literal></expr></argument>,<argument><expr><name>ffffffff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* NYI: tref_istab(sp). */</comment>
    <decl_stmt><decl><type><name>IRType</name></type> <name>t</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>sid</name> <operator>=</operator> <call><name>argv2cdata</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>sval</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>svisnz</name> <operator>=</operator> <call><name>cdataptr</name><argument_list>(<argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><name>sval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isfunc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>sid</name> <operator>=</operator> <call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_PTR</name></expr></argument>, <argument><expr><name>CTALIGN_PTR</name><operator>|</operator><name>sid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <name>IRT_PTR</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>crec_ct2irt</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>IRFL_CDATA_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isref</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>svisnz</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>svisnz</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>crec_ct2irt</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<goto>goto <name>doconv</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_I64</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_U64</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>IRFL_CDATA_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>doconv</name>;</goto>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_INT</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_U32</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>IRFL_CDATA_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>doconv</name>;</goto>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GCcdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>t</name> <operator>!=</operator> <name>IRT_CDATA</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Load number value. */</comment>
    <goto>goto <name>doconv</name>;</goto>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>doconv</name>:</label>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>crec_ct_ct</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>svisnz</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- C data metamethods -------------------------------------------------- */</comment>

<comment type="block">/* This would be rather difficult in FOLD, so do it here:
** (base+k)+(idx*sz)+ofs ==&gt; (base+idx*sz)+(ofs+k)
** (base+(idx+k)*sz)+ofs ==&gt; (base+idx*sz)+(ofs+k*sz)
*/</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>crec_reassoc_ofs</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>tr</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name> <modifier>*</modifier></type><name>ofsp</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_ADD</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_ADDOV</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_SUBOV</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irk</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>k</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT64</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><call><name>ir_kint64</name><argument_list>(<argument><expr><name>irk</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name> <operator>*</operator> <name>sz</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name><name>irk</name><operator>-&gt;</operator><name>i</name></name> <operator>*</operator> <name>sz</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_SUBOV</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>ofsp</name> <operator>-=</operator> <name>k</name></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>ofsp</name> <operator>+=</operator> <name>k</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>  <comment type="block">/* Not a TRef, but the caller doesn't care. */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>tr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Tailcall to function. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>crec_tailcall</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>kfunc</name> <init>= <expr><call><name>lj_ir_kfunc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>funcV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>kfunc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>TREF_FRAME</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>kfunc</name> <operator>|</operator> <name>TREF_FRAME</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Pending tailcall. */</comment>
</block_content>}</block></function>

<comment type="block">/* Record ctype __index/__newindex metamethods. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>crec_index_meta</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>,
			    <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>ctype_typeid</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>lj_ctype_meta</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr> ?</condition><then> <expr><name>MM_newindex</name></expr> </then><else>: <expr><name>MM_index</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tv</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tvisfunc</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>crec_tailcall</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>tvistab</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tref_isstr</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Specialize to result of __index lookup. */</comment>
    <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lj_tab_get</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><call><name>tabV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_record_constify</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Always specialize to the key. */</comment>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>strV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* NYI: resolving of non-function metamethods. */</comment>
    <comment type="block">/* NYI: non-string keys for __index table. */</comment>
    <comment type="block">/* NYI: stores to __newindex table. */</comment>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Record bitfield load/store. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>crec_index_bf</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>CTInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><name>IRT_I8</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><call><name>lj_fls</name><argument_list>(<argument><expr><call><name>ctype_bitcsz</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>info</name><operator>&amp;</operator><name>CTF_UNSIGNED</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>pos</name> <init>= <expr><call><name>ctype_bitpos</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>bsz</name> <init>= <expr><call><name>ctype_bitbsz</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>shift</name> <init>= <expr><literal type="number">32</literal> <operator>-</operator> <name>bsz</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>t</name> <operator>&lt;=</operator> <name>IRT_U32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* NYI: 64 bit bitfields. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* __index metamethod. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_BOOL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BAND</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>pos</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Assume not equal to zero. Fixup and emit pending guard later. */</comment>
      <expr_stmt><expr><call><name>lj_ir_set</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_NE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>=</operator> <name>LJ_POST_FIXGUARD</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <name>TREF_TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSHL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>shift</name> <operator>-</operator> <name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSAR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>shift</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>bsz</name> <operator>&lt;</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Full-size fields cannot end up here. */</comment>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSHR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BAND</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>bsz</name><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* We can omit the U32 to NUM conversion, since bsz &lt; 32. */</comment>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* __newindex metamethod. */</comment>
    <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>,
			  <argument><expr><ternary><condition><expr><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_BOOL</name><operator>)</operator></expr> ?</condition><then> <expr><name>CTID_BOOL</name></expr> </then><else>:
			  <expr><ternary><condition><expr><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator></expr> ?</condition><then> <expr><name>CTID_UINT32</name></expr> </then><else>: <expr><name>CTID_INT32</name></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>mask</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>bsz</name><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>pos</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>sp</name> <init>= <expr><call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSHL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Use of the target type avoids forwarding conversions. */</comment>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BAND</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BAND</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>~</operator><name>mask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BOR</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XSTORE</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_cdata_index</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>ptr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>ofs</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>GCcdata</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>argv2cdata</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>sid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Resolve pointer or reference for cdata object. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>LJ_64</name> <operator>&amp;&amp;</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator></expr> ?</condition><then> <expr><name>IRT_P64</name></expr> </then><else>: <expr><name>IRT_P32</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isref</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>IRFL_CDATA_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ofs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>crec_reassoc_ofs</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>again</name>:</label>
  <expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isnumber</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>lj_opt_narrow_cindex</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_ispointer</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name></decl>;</decl_stmt>
  <label><name>integer_key</name>:</label>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_COMPLEX</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BAND</name></expr></argument>, <argument><expr><name>IRT_INTP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>lj_ctype_size</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>(</operator><name>sid</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>crec_reassoc_ofs</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofs</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_ARM</name> <operator>||</operator> <name>LJ_TARGET_PPC</name></expr></cpp:if>
      <comment type="block">/* Hoist base add to allow fusion of index/shift into operands. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_LOOP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>ofs</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_ARM</name></expr></cpp:if>
	  <operator>&amp;&amp;</operator> <operator>(</operator><name>sz</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>sz</name> <operator>==</operator> <literal type="number">4</literal><operator>)</operator></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	  )</condition> <block>{<block_content>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ofs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ofs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_MUL</name></expr></argument>, <argument><expr><name>IRT_INTP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_iscdata</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cdk</name> <init>= <expr><call><name>cdataV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctk</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>cdk</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><call><name>crec_ct2irt</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ctk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_ispointer</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>t</name> <operator>&gt;=</operator> <name>IRT_I8</name> <operator>&amp;&amp;</operator> <name>t</name> <operator>&lt;=</operator> <name>IRT_U64</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>ctk</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>IRFL_CDATA_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ctk</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>IRFL_CDATA_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>,
		     <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GCcdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <name><name>ctk</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>intptr_t</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>ctk</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>IRT_INTP</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>, <argument><expr><name>IRCONV_SEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LJ_64</name> <operator>&amp;&amp;</operator> <name><name>ctk</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>intptr_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>IRT_INTP</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <goto>goto <name>integer_key</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_isstr</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>cd</name> <operator>&amp;&amp;</operator> <name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name> <operator>==</operator> <name>CTID_CTYPEID</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>crec_constructor</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>fofs</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>fct</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>fct</name> <operator>=</operator> <call><name>lj_ctype_getfield</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>fct</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>ofs</name> <operator>+=</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>fofs</name></expr>;</expr_stmt>
	<comment type="block">/* Always specialize to the field name. */</comment>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ctype_isconstval</name><argument_list>(<argument><expr><name><name>fct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name><name>fct</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;=</operator> <literal type="number">0x80000000u</literal> <operator>&amp;&amp;</operator>
	      <operator>(</operator><call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>fct</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>info</name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>fct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return;</return>
	  </block_content>}</block></if></if_stmt>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>fct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <return>return;</return>  <comment type="block">/* Interpreter will throw for newindex. */</comment>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isbitfield</name><argument_list>(<argument><expr><name><name>fct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>ofs</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ofs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <expr_stmt><expr><call><name>crec_index_bf</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>fct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <return>return;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>fct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>sid</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>fct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_iscomplex</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>name</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
	  <operator>(</operator><operator>(</operator><call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'r'</literal> <operator>&amp;&amp;</operator> <call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="char">'e'</literal><operator>)</operator> <operator>||</operator>
	   <operator>(</operator><call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'i'</literal> <operator>&amp;&amp;</operator> <call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="char">'m'</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Always specialize to the field name. */</comment>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ofs</name> <operator>+=</operator> <operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>sid</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sid</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Automatically perform '-&gt;'. */</comment>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>cct</name> <init>= <expr><call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>cct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>ct</name> <operator>=</operator> <name>cct</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tref_isstr</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>again</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>crec_index_meta</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>ofs</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ofs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Resolve reference for field. */</comment>
  <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isref</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sid</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <while>while <condition>(<expr><call><name>ctype_isattrib</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>  <comment type="block">/* Skip attributes. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* __index metamethod. */</comment>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>crec_tv_ct</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* __newindex metamethod. */</comment>
    <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Record setting a finalizer. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>crec_finalizer</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>trcd</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>trfin</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>fin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>tvisgcv</name><argument_list>(<argument><expr><name>fin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>trfin</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>trfin</name> <operator>=</operator> <call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>gcval</name><argument_list>(<argument><expr><name>fin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisnil</name><argument_list>(<argument><expr><name>fin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>trfin</name> <operator>=</operator> <call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_lj_cdata_setfin</name></expr></argument>, <argument><expr><name>trcd</name></expr></argument>,
	     <argument><expr><name>trfin</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>itype</name><argument_list>(<argument><expr><name>fin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record cdata allocation. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>crec_alloc</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>, <parameter><decl><type><name>CTypeID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>info</name> <init>= <expr><call><name>lj_ctype_info</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trcd</name></decl>, <decl><type ref="prev"/><name>trid</name> <init>= <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>fin</name></decl>;</decl_stmt>
  <comment type="block">/* Use special instruction to box pointer or 32/64 bit integer. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>ctype_isinteger</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>sz</name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name>sz</name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>sp</name> <init>= <expr><ternary><condition><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>:
	      <expr><ternary><condition><expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr> </then><else>:
	      <expr><ternary><condition><expr><name>sz</name> <operator>==</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>:
	      <expr><operator>(</operator><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call>, <call><name>lj_ir_kint64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_CNEWI</name></expr></argument>, <argument><expr><name>IRT_CDATA</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trid</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trsz</name> <init>= <expr><name>TREF_NIL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_VLA</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Calculate VLA/VLS size at runtime. */</comment>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>sz0</name></decl>, <decl><type ref="prev"/><name>sz1</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICONV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* NYI: init VLA/VLS. */</comment>
      <expr_stmt><expr><name>trsz</name> <operator>=</operator> <call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_INT32</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sz0</name> <operator>=</operator> <call><name>lj_ctype_vlsize</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sz1</name> <operator>=</operator> <call><name>lj_ctype_vlsize</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>trsz</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_MULOV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trsz</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>sz1</name><operator>-</operator><name>sz0</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>trsz</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_ADDOV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trsz</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>sz0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Simplify logic below. */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_align</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>CT_MEMALIGN</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>trsz</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>trcd</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_CNEW</name></expr></argument>, <argument><expr><name>IRT_CDATA</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trid</name></expr></argument>, <argument><expr><name>trsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;</operator> <literal type="number">128</literal> <operator>||</operator> <operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_VLA</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>dp</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>align</name></decl>;</decl_stmt>
    <label><name>special</name>:</label>  <comment type="block">/* Only handle bulk zero-fill for large/VLA/VLS types. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICONV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* NYI: init large/VLA/VLS types. */</comment>
      <expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trcd</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GCcdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>trsz</name> <operator>==</operator> <name>TREF_NIL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>trsz</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>align</name> <operator>=</operator> <call><name>ctype_align</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>align</name> <operator>&lt;</operator> <name>CT_MEMALIGN</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>align</name> <operator>=</operator> <name>CT_MEMALIGN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>crec_fill</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>trsz</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>align</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
	<operator>!</operator><call><name>lj_cconv_multi_init</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <goto>goto <name>single_init</name>;</goto>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isarray</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>dc</name> <init>= <expr><call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* Array element type. */</comment>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>ofs</name></decl>, <decl><type ref="prev"/><name>esize</name> <init>= <expr><name><name>dc</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TRef</name></type> <name>sp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TValue</name></type> <name>tv</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>sval</name> <init>= <expr><operator>&amp;</operator><name>tv</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>tv</name><operator>.</operator><name>u64</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>dc</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>dc</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
	  <name>esize</name> <operator>*</operator> <name>CREC_FILL_MAXUNROLL</name> <operator>&lt;</operator> <name>sz</name></expr>)</condition><block type="pseudo"><block_content>
	<goto>goto <name>special</name>;</goto></block_content></block></if></if_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>ofs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ofs</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>ofs</name> <operator>+=</operator> <name>esize</name></expr></incr>)</control> <block>{<block_content>
	<decl_stmt><decl><type><name>TRef</name></type> <name>dp</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trcd</name></expr></argument>,
			 <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ofs</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GCcdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>sval</name> <operator>=</operator> <operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>sp</name> <operator>=</operator> <ternary><condition><expr><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>dc</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>TREF_NIL</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>sval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CTypeID</name></type> <name>fid</name> <init>= <expr><name><name>d</name><operator>-&gt;</operator><name>sib</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>MSize</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>fid</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>df</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>fid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>fid</name> <operator>=</operator> <name><name>df</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>df</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>dc</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>TRef</name></type> <name>sp</name></decl>, <decl><type ref="prev"/><name>dp</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>TValue</name></type> <name>tv</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>sval</name> <init>= <expr><operator>&amp;</operator><name>tv</name></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>gcref</name><argument_list>(<argument><expr><name><name>df</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Ignore unnamed fields. */</comment>
	  <expr_stmt><expr><name>dc</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>df</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Field type. */</comment>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>dc</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>dc</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>dc</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICONV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* NYI: init aggregates. */</comment>
	  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sval</name> <operator>=</operator> <operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	  </block_content>}</block></if> <else>else <block>{<block_content>
	    <expr_stmt><expr><name>sp</name> <operator>=</operator> <ternary><condition><expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>dc</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>TREF_NIL</name></expr> </then><else>: <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	  </block_content>}</block></else></if_stmt>
	  <expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trcd</name></expr></argument>,
		      <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>df</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GCcdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>sval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ctype_isconstval</name><argument_list>(<argument><expr><name><name>df</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <comment type="block">/* NYI: init bitfields and sub-structures. */</comment>
	  <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICONV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>dp</name></decl>;</decl_stmt>
    <label><name>single_init</name>:</label>
      <expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trcd</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GCcdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<decl_stmt><decl><type><name>TValue</name></type> <name>tv</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>u64</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>trcd</name></expr>;</expr_stmt>
  <comment type="block">/* Handle __gc metamethod. */</comment>
  <expr_stmt><expr><name>fin</name> <operator>=</operator> <call><name>lj_ctype_meta</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>MM_gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>fin</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>crec_finalizer</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>trcd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Record argument conversions. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>crec_call_args</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>,
			   <parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name><name>args</name><index>[<expr><name>CCI_NARGS_MAX</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>fid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ABI_WIN</name></expr></cpp:if>
  <decl_stmt><decl><type><name>TRef</name> <modifier>*</modifier></type><name>arg0</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>arg1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>ngpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_cconv</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTCC_THISCALL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>ngpr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>ctype_cconv</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTCC_FASTCALL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>ngpr</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Skip initial attributes. */</comment>
  <expr_stmt><expr><name>fid</name> <operator>=</operator> <name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>fid</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctf</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>fid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isattrib</name><argument_list>(<argument><expr><name><name>ctf</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>fid</name> <operator>=</operator> <name><name>ctf</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>base</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>o</name> <operator>=</operator> <name><name>rd</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><operator>*</operator><name>base</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr><operator>,</operator> <expr><name>base</name><operator>++</operator></expr><operator>,</operator> <expr><name>o</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>did</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name>CCI_NARGS_MAX</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>fid</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Get argument type from field. */</comment>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctf</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>fid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>fid</name> <operator>=</operator> <name><name>ctf</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>ctf</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>did</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ctf</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_VARARG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Too many arguments. */</comment>
      <expr_stmt><expr><name>did</name> <operator>=</operator> <call><name>lj_ccall_ctid_vararg</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Infer vararg type. */</comment>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>did</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
	  <call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>*</operator><name>base</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isinteger_or_bool</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>d</name><operator>-&gt;</operator><name>size</name></name><operator>==</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>IRT_U8</name></expr> </then><else>: <expr><name>IRT_U16</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>d</name><operator>-&gt;</operator><name>size</name></name><operator>==</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>IRT_I8</name></expr> </then><else>: <expr><name>IRT_I16</name></expr></else></ternary></expr></argument>,<argument><expr><name>IRCONV_SEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>LJ_SOFTFP32</name> <operator>&amp;&amp;</operator> <call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
    <comment type="block">/* 64 bit args must not end up in registers for fastcall/thiscall. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ABI_WIN</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Sigh, the Windows/x86 ABI allows reordering across 64 bit args. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>tref_typerange</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRT_I64</name></expr></argument>, <argument><expr><name>IRT_U64</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ngpr</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>arg0</name> <operator>=</operator> <operator>&amp;</operator><name><name>args</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>args</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt> <expr_stmt><expr><name>ngpr</name><operator>--</operator></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>ngpr</name></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><name>arg1</name> <operator>=</operator> <operator>&amp;</operator><name><name>args</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>args</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt> <expr_stmt><expr><name>ngpr</name><operator>--</operator></expr>;</expr_stmt>
	  </block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>arg0</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><operator>*</operator><name>arg0</name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt> <expr_stmt><expr><name>arg0</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>arg1</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><operator>*</operator><name>arg1</name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt> <expr_stmt><expr><name>arg1</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ngpr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ngpr</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>ngpr</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>tref_typerange</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRT_I64</name></expr></argument>, <argument><expr><name>IRT_U64</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<comment type="block">/* No reordering for other x86 ABIs. Simply add alignment args. */</comment>
	<do>do <block>{<block_content> <expr_stmt><expr><name><name>args</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><operator>--</operator><name>ngpr</name></expr>)</condition>;</do>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name>ngpr</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>args</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>tr</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <return>return <expr><name>tr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a snapshot for the caller, simulating a 'false' return value. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>crec_snap_caller</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>top</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>ftr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>delta</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>frame_islua</name><argument_list>(<argument><expr><name>base</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <call><name>frame_pc</name><argument_list>(<argument><expr><name>base</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>delta</name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name><operator>+</operator><call><name>bc_a</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>base</name> <operator>-</operator> <name>delta</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name> <operator>=</operator> <name>TREF_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>-=</operator> <name>delta</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>-=</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><name>delta</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><name>delta</name><operator>-</operator><name>LJ_FR2</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_snap_add</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>top</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>+=</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><name>delta</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name> <operator>=</operator> <name>ftr</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record function call. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>crec_call</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>, <parameter><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRType</name></type> <name>tp</name> <init>= <expr><name>IRT_PTR</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>tp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>LJ_64</name> <operator>&amp;&amp;</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator></expr> ?</condition><then> <expr><name>IRT_P64</name></expr> </then><else>: <expr><name>IRT_P32</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isfunc</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>func</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>IRFL_CDATA_PTR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctr</name> <init>= <expr><call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><call><name>crec_ct2irt</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ctr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TValue</name></type> <name>tv</name></decl>;</decl_stmt>
    <comment type="block">/* Check for blacklisted C functions that might call a callback. */</comment>
    <expr_stmt><expr><call><name>setlightudV</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>,
		<argument><expr><call><name>cdata_getptr</name><argument_list>(<argument><expr><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>LJ_64</name> <operator>&amp;&amp;</operator> <name>tp</name> <operator>==</operator> <name>IRT_P64</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">8</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tvistrue</name><argument_list>(<argument><expr><call><name>lj_tab_get</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>cts</name><operator>-&gt;</operator><name>miscmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BLACKL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isvoid</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <name>IRT_NIL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		 <call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_CDATA</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_VARARG</name><operator>)</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
	<operator>||</operator> <call><name>ctype_cconv</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CTCC_CDECL</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>func</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>func</name></expr></argument>,
		    <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_typeid</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CALLXS</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>crec_call_args</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isbool</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>frame_islua</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>bc_b</name><argument_list>(<argument><expr><call><name>frame_pc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Don't check result if ignored. */</comment>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>crec_snap_caller</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
	<comment type="block">/* Note: only the x86/x64 backend supports U8 and only for EQ(tr, 0). */</comment>
	<expr_stmt><expr><call><name>lj_ir_set</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_NE</name></expr></argument>, <argument><expr><name>IRT_U8</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>lj_ir_set</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_NE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>=</operator> <name>LJ_POST_FIXGUARDSNAP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <name>TREF_TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_PTR</name> <operator>||</operator> <operator>(</operator><name>LJ_64</name> <operator>&amp;&amp;</operator> <name>t</name> <operator>==</operator> <name>IRT_P32</name><operator>)</operator> <operator>||</operator>
	       <name>t</name> <operator>==</operator> <name>IRT_I64</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_U64</name> <operator>||</operator> <call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>trid</name> <init>= <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_CNEWI</name></expr></argument>, <argument><expr><name>IRT_CDATA</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trid</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_I64</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_U64</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_FLOAT</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_U32</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRT_NUM</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_I8</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_I16</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>IRCONV_SEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_U8</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_U16</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_cdata_call</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>argv2cdata</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MMS</name></type> <name>mm</name> <init>= <expr><name>MM_call</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>CTID_CTYPEID</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>crec_constructor</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mm</name> <operator>=</operator> <name>MM_new</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>crec_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Record ctype __call/__new metamethod. */</comment>
  <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tv</name> <operator>=</operator> <call><name>lj_ctype_meta</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>id</name></expr></else></ternary></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tv</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tvisfunc</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>crec_tailcall</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mm</name> <operator>==</operator> <name>MM_new</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>crec_alloc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* No metamethod or NYI: non-function metamethods. */</comment>
  <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TRef</name></type> <name>crec_arith_int64</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier><modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>MMS</name></type> <name>mm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRType</name></type> <name>dt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IROp</name></type> <name>op</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>size</name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator> <operator>||</operator>
	<operator>(</operator><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>size</name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>dt</name> <operator>=</operator> <name>IRT_U64</name></expr>;</expr_stmt> <expr_stmt><expr><name>id</name> <operator>=</operator> <name>CTID_UINT64</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>dt</name> <operator>=</operator> <name>IRT_I64</name></expr>;</expr_stmt> <expr_stmt><expr><name>id</name> <operator>=</operator> <name>CTID_INT64</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>mm</name> <operator>&lt;</operator> <name>MM_add</name> <operator>&amp;&amp;</operator>
	  <operator>!</operator><operator>(</operator><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name> <operator>|</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name><operator>)</operator> <operator>&amp;</operator> <name>CTF_FP</name><operator>)</operator> <operator>&amp;&amp;</operator>
	  <name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>size</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>size</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Try to narrow comparison. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name> <operator>^</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name><operator>)</operator> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator> <operator>||</operator>
	    <operator>(</operator><call><name>tref_isk</name><argument_list>(<argument><expr><name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>dt</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator></expr> ?</condition><then> <expr><name>IRT_U32</name></expr> </then><else>: <expr><name>IRT_INT</name></expr></else></ternary></expr>;</expr_stmt>
	  <goto>goto <name>comp</name>;</goto>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_isk</name><argument_list>(<argument><expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>dt</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator></expr> ?</condition><then> <expr><name>IRT_U32</name></expr> </then><else>: <expr><name>IRT_INT</name></expr></else></ternary></expr>;</expr_stmt>
	  <goto>goto <name>comp</name>;</goto>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>IRType</name></type> <name>st</name> <init>= <expr><call><name>tref_type</name><argument_list>(<argument><expr><name><name>sp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>st</name> <operator>==</operator> <name>IRT_NUM</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>sp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name><name>sp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>IRCONV_ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>st</name> <operator>==</operator> <name>IRT_I64</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_U64</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>sp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name><name>sp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>dt</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>,
			 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>info</name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>IRCONV_SEXT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>mm</name> <operator>&lt;</operator> <name>MM_add</name></expr>)</condition> <block>{<block_content>
    <label><name>comp</name>:</label>
      <comment type="block">/* Assume true comparison. Fixup and emit pending guard later. */</comment>
      <if_stmt><if>if <condition>(<expr><name>mm</name> <operator>==</operator> <name>MM_eq</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>op</name> <operator>=</operator> <name>IR_EQ</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name>op</name> <operator>=</operator> <ternary><condition><expr><name>mm</name> <operator>==</operator> <name>MM_lt</name></expr> ?</condition><then> <expr><name>IR_LT</name></expr> </then><else>: <expr><name>IR_LE</name></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dt</name> <operator>==</operator> <name>IRT_U32</name> <operator>||</operator> <name>dt</name> <operator>==</operator> <name>IRT_U64</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>op</name> <operator>+=</operator> <operator>(</operator><name>IR_ULT</name><operator>-</operator><name>IR_LT</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>lj_ir_set</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>=</operator> <name>LJ_POST_FIXGUARD</name></expr>;</expr_stmt>
      <return>return <expr><name>TREF_TRUE</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>mm</name><operator>+</operator><operator>(</operator><name>int</name><operator>)</operator><name>IR_ADD</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>MM_add</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_CNEWI</name></expr></argument>, <argument><expr><name>IRT_CDATA</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TRef</name></type> <name>crec_arith_ptr</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier><modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>MMS</name></type> <name>mm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctp</name> <init>= <expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ctp</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isrefarray</name><argument_list>(<argument><expr><name><name>ctp</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mm</name> <operator>==</operator> <name>MM_sub</name> <operator>||</operator> <name>mm</name> <operator>==</operator> <name>MM_eq</name> <operator>||</operator> <name>mm</name> <operator>==</operator> <name>MM_lt</name> <operator>||</operator> <name>mm</name> <operator>==</operator> <name>MM_le</name><operator>)</operator> <operator>&amp;&amp;</operator>
	<operator>(</operator><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isrefarray</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>mm</name> <operator>==</operator> <name>MM_sub</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Pointer difference. */</comment>
	<decl_stmt><decl><type><name>TRef</name></type> <name>tr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name> <init>= <expr><call><name>lj_ctype_size</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ctp</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>sz</name> <operator>&amp;</operator> <operator>(</operator><name>sz</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* NYI: integer division. */</comment>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_SUB</name></expr></argument>, <argument><expr><name>IRT_INTP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BSAR</name></expr></argument>, <argument><expr><name>IRT_INTP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>lj_fls</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRT_NUM</name></expr></argument>, <argument><expr><name>IRT_INTP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>tr</name></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Pointer comparison (unsigned). */</comment>
	<comment type="block">/* Assume true comparison. Fixup and emit pending guard later. */</comment>
	<decl_stmt><decl><type><name>IROp</name></type> <name>op</name> <init>= <expr><ternary><condition><expr><name>mm</name> <operator>==</operator> <name>MM_eq</name></expr> ?</condition><then> <expr><name>IR_EQ</name></expr> </then><else>: <expr><ternary><condition><expr><name>mm</name> <operator>==</operator> <name>MM_lt</name></expr> ?</condition><then> <expr><name>IR_ULT</name></expr> </then><else>: <expr><name>IR_ULE</name></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>lj_ir_set</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>=</operator> <name>LJ_POST_FIXGUARD</name></expr>;</expr_stmt>
	<return>return <expr><name>TREF_TRUE</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>mm</name> <operator>==</operator> <name>MM_add</name> <operator>||</operator> <name>mm</name> <operator>==</operator> <name>MM_sub</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mm</name> <operator>==</operator> <name>MM_add</name> <operator>&amp;&amp;</operator> <call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>ctp</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	     <operator>(</operator><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isrefarray</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>  <comment type="block">/* Swap pointer and index. */</comment>
    <expr_stmt><expr><name>ctp</name> <operator>=</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><call><name>tref_type</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name> <init>= <expr><call><name>lj_ctype_size</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ctp</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_NUM</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRT_INTP</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>IRCONV_ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>t</name> <operator>==</operator> <name>IRT_I64</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_U64</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRT_INTP</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>,
		    <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>t</name> <operator>-</operator> <name>IRT_I8</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>IRCONV_SEXT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_typerange</name><argument_list>(<argument><expr><name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>IRT_I8</name></expr></argument>, <argument><expr><name>IRT_U32</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRT_INTP</name></expr></argument>, <argument><expr><name>t</name></expr></argument>,
		    <argument><expr><ternary><condition><expr><operator>(</operator><name>t</name> <operator>==</operator> <name>IRT_NUM</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_FLOAT</name><operator>)</operator></expr> ?</condition><then> <expr><name>IRCONV_ANY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_MUL</name></expr></argument>, <argument><expr><name>IRT_INTP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>mm</name><operator>+</operator><operator>(</operator><name>int</name><operator>)</operator><name>IR_ADD</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>MM_add</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_PTR</name></expr></argument>, <argument><expr><name>CTALIGN_PTR</name><operator>|</operator><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ctp</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_CNEWI</name></expr></argument>, <argument><expr><name>IRT_CDATA</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* Record ctype arithmetic metamethods. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>crec_arith_meta</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier><modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>,
			    <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tviscdata</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>argv2cdata</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>tv</name> <operator>=</operator> <call><name>lj_ctype_meta</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>(</operator><name>MMS</name><operator>)</operator><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tv</name> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>tviscdata</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>argv2cdata</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>tv</name> <operator>=</operator> <call><name>lj_ctype_meta</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>(</operator><name>MMS</name><operator>)</operator><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>tv</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tvisfunc</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>crec_tailcall</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>  <comment type="block">/* NYI: non-function metamethods. */</comment>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>MMS</name><operator>)</operator><name><name>rd</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <name>MM_eq</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Fallback cdata pointer comparison. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Assume true comparison. Fixup and emit pending guard later. */</comment>
      <expr_stmt><expr><call><name>lj_ir_set</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>=</operator> <name>LJ_POST_FIXGUARD</name></expr>;</expr_stmt>
      <return>return <expr><name>TREF_TRUE</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><name>TREF_FALSE</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_cdata_arith</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name><name>sp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name><name>s</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_DOUBLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tr</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_iscdata</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>argv2cdata</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRType</name></type> <name>t</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>crec_ct2irt</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Resolve pointer or reference. */</comment>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFL_CDATA_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ctype_isref</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>crec_ct2irt</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_I64</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_U64</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFL_CDATA_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<goto>goto <name>ok</name>;</goto>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_INT</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_U32</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFL_CDATA_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<goto>goto <name>ok</name>;</goto>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isfunc</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFL_CDATA_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>,
	  <argument><expr><call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_PTR</name></expr></argument>, <argument><expr><name>CTALIGN_PTR</name><operator>|</operator><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<goto>goto <name>ok</name>;</goto>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GCcdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_CDATA</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>tr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_I64</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>IRT_U64</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_isnil</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_P_VOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_INT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_isstr</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>tr2</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal><operator>-</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>argv2cdata</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>tr2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal><operator>-</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Match string against enum constant. */</comment>
	<decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CTSize</name></type> <name>ofs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>cct</name> <init>= <expr><call><name>lj_ctype_getfield</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>cct</name> <operator>&amp;&amp;</operator> <call><name>ctype_isconstval</name><argument_list>(<argument><expr><name><name>cct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <comment type="block">/* Specialize to the name of the enum constant. */</comment>
	  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>cct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>ofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Interpreter will throw or return false. */</comment>
	  <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_P_VOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GCstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_P_VOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>tref_isnum</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_P_VOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <label><name>ok</name>:</label>
    <expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ct</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MMS</name></type> <name>mm</name> <init>= <expr><operator>(</operator><name>MMS</name><operator>)</operator><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mm</name> <operator>==</operator> <name>MM_len</name> <operator>||</operator> <name>mm</name> <operator>==</operator> <name>MM_concat</name> <operator>||</operator>
	 <operator>(</operator><operator>!</operator><operator>(</operator><name>tr</name> <operator>=</operator> <call><name>crec_arith_int64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
	  <operator>!</operator><operator>(</operator><name>tr</name> <operator>=</operator> <call><name>crec_arith_ptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
	<operator>!</operator><operator>(</operator><name>tr</name> <operator>=</operator> <call><name>crec_arith_meta</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
    <comment type="block">/* Fixup cdata comparisons, too. Avoids some cdata escapes. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>==</operator> <name>LJ_POST_FIXGUARD</name> <operator>&amp;&amp;</operator> <call><name>frame_iscont</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	<operator>!</operator><call><name>irt_isguard</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>guardemit</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>frame_contpc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>BC_ISNEP</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>tmptv</name><operator>.</operator><name>u64</name></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>pc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>=</operator> <name>LJ_POST_FIXCOMP</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* -- C library namespace metamethods ------------------------------------- */</comment>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_clib_index</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isudata</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tref_isstr</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <call><name>udataV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>udtype</name> <operator>==</operator> <name>UDTYPE_FFI_CLIB</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CLibrary</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><operator>(</operator><name>CLibrary</name> <operator>*</operator><operator>)</operator><call><name>uddata</name><argument_list>(<argument><expr><call><name>udataV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>lj_ctype_getname</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>CLNS_INDEX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>lj_tab_getstr</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>cache</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>id</name> <operator>&amp;&amp;</operator> <name>tv</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Specialize to the symbol name and make the result a constant. */</comment>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isconstval</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;=</operator> <literal type="number">0x80000000u</literal> <operator>&amp;&amp;</operator>
	    <operator>(</operator><call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>info</name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isextern</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>CTypeID</name></type> <name>sid</name> <init>= <expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TRef</name></type> <name>ptr</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>checkptr32</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>lj_ir_kintp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>crec_tv_ct</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_kgc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IRT_CDATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NOCACHE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: interpreter will throw. */</comment>
</block_content>}</block></function>

<comment type="block">/* -- FFI library functions ----------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>TRef</name></type> <name>crec_toint</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>sp</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>sval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_INT32</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>sval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_ffi_new</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>crec_alloc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>, <argument><expr><call><name>argv2ctype</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_ffi_errno</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYICALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_lj_vm_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_ffi_string</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tr</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trlen</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isnil</name><argument_list>(<argument><expr><name>trlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>trlen</name> <operator>=</operator> <call><name>crec_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>trlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_P_CVOID</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_P_CCHAR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>trlen</name> <operator>=</operator> <call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_strlen</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XSNEW</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>trlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: interpreter will throw. */</comment>
</block_content>}</block></function>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_ffi_copy</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trdst</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>trsrc</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>trlen</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>trdst</name> <operator>&amp;&amp;</operator> <name>trsrc</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>trlen</name> <operator>||</operator> <call><name>tref_isstr</name><argument_list>(<argument><expr><name>trsrc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>trdst</name> <operator>=</operator> <call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_P_VOID</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>trdst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>trsrc</name> <operator>=</operator> <call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_P_CVOID</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>trsrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>trlen</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>trlen</name> <operator>=</operator> <call><name>crec_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>trlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>trlen</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>IRFL_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>trlen</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trlen</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>crec_copy</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>trdst</name></expr></argument>, <argument><expr><name>trsrc</name></expr></argument>, <argument><expr><name>trlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: interpreter will throw. */</comment>
</block_content>}</block></function>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_ffi_fill</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trdst</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>trlen</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>trfill</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>trdst</name> <operator>&amp;&amp;</operator> <name>trlen</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CTSize</name></type> <name>step</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tviscdata</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Get alignment of original destination. */</comment>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>step</name> <operator>=</operator> <operator>(</operator><literal type="number">1u</literal><operator>&lt;&lt;</operator><call><name>ctype_align</name><argument_list>(<argument><expr><call><name>lj_ctype_info</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_typeid</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>trdst</name> <operator>=</operator> <call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_P_VOID</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>trdst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>trlen</name> <operator>=</operator> <call><name>crec_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>trlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>trfill</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>trfill</name> <operator>=</operator> <call><name>crec_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>trfill</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>trfill</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>crec_fill</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>trdst</name></expr></argument>, <argument><expr><name>trlen</name></expr></argument>, <argument><expr><name>trfill</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: interpreter will throw. */</comment>
</block_content>}</block></function>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_ffi_typeof</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>tref_iscdata</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trid</name> <init>= <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>argv2ctype</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_CNEWI</name></expr></argument>, <argument><expr><name>IRT_CDATA</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>CTID_CTYPEID</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>setfuncV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>errinfo</name></name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>fn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_trace_err_info</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYIFFU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_ffi_istype</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>argv2ctype</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_iscdata</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>argv2ctype</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>=</operator> <name>LJ_POST_FIXBOOL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>TREF_TRUE</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>TREF_FALSE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_ffi_abi</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isstr</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Specialize to the ABI string to make the boolean result a constant. */</comment>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>strV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>=</operator> <name>LJ_POST_FIXBOOL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>TREF_TRUE</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Record ffi.sizeof(), ffi.alignof(), ffi.offsetof(). */</comment>
<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_ffi_xof</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>argv2ctype</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <name>FF_ffi_sizeof</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>lj_ctype_rawref</name><argument_list>(<argument><expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isvltype</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <name>FF_ffi_offsetof</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Specialize to the field name. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isstr</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>strV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>  <comment type="block">/* Just in case. */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>=</operator> <name>LJ_POST_FIXCONST</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_ffi_gc</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>argv2cdata</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>crec_finalizer</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- 64 bit bit.* library functions -------------------------------------- */</comment>

<comment type="block">/* Determine bit operation type from argument type. */</comment>
<function><type><specifier>static</specifier> <name>CTypeID</name></type> <name>crec_bit64_type</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>tviscdata</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>lj_ctype_rawref</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <operator>(</operator><name>CTMASK_NUM</name><operator>|</operator><name>CTF_BOOL</name><operator>|</operator><name>CTF_FP</name><operator>|</operator><name>CTF_UNSIGNED</name><operator>)</operator><operator>)</operator> <operator>==</operator>
	<call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_NUM</name></expr></argument>, <argument><expr><name>CTF_UNSIGNED</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>CTID_UINT64</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Use uint64_t, since it has the highest rank. */</comment>
    <return>return <expr><name>CTID_INT64</name></expr>;</return>  <comment type="block">/* Otherwise use int64_t. */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Use regular 32 bit ops. */</comment>
</block_content>}</block></function>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_bit64_tobit</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_INT64</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		       <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>, <argument><expr><call><name>tref_type</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name> <name>LJ_FASTCALL</name></type> <name>recff_bit64_unary</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>crec_bit64_type</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>id</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>id</name><operator>-</operator><name>CTID_INT64</name><operator>+</operator><name>IRT_I64</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_CNEWI</name></expr></argument>, <argument><expr><name>IRT_CDATA</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>LJ_FASTCALL</name></type> <name>recff_bit64_nary</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>aid</name> <init>= <expr><call><name>crec_bit64_type</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>id</name> <operator>&lt;</operator> <name>aid</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>id</name> <operator>=</operator> <name>aid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Determine highest type rank of all arguments. */</comment>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>id</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>ot</name> <init>= <expr><call><name>IRT</name><argument_list>(<argument><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>id</name><operator>-</operator><name>CTID_INT64</name><operator>+</operator><name>IRT_I64</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>tr2</name> <init>= <expr><call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><name>ot</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_CNEWI</name></expr></argument>, <argument><expr><name>IRT_CDATA</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>LJ_FASTCALL</name></type> <name>recff_bit64_shift</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tsh</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>tref_iscdata</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>tsh</name> <operator>=</operator> <call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_INT64</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		     <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>tsh</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>tsh</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>tsh</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>, <argument><expr><call><name>tref_type</name><argument_list>(<argument><expr><name>tsh</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>tsh</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>crec_bit64_type</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>id</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>op</name> <init>= <expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tsh</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tsh</name> <operator>=</operator> <call><name>lj_opt_narrow_tobit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><ternary><condition><expr><name>op</name> <operator>&lt;</operator> <name>IR_BROL</name></expr> ?</condition><then> <expr><name>LJ_TARGET_MASKSHIFT</name></expr> </then><else>: <expr><name>LJ_TARGET_MASKROT</name></expr></else></ternary><operator>)</operator> <operator>&amp;&amp;</operator>
	<operator>!</operator><call><name>tref_isk</name><argument_list>(<argument><expr><name>tsh</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>tsh</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BAND</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tsh</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">63</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LJ_TARGET_UNIFYROT</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <operator>(</operator><ternary><condition><expr><name>LJ_TARGET_UNIFYROT</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>IR_BROR</name></expr> </then><else>: <expr><name>IR_BROL</name></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>op</name> <operator>=</operator> <ternary><condition><expr><name>LJ_TARGET_UNIFYROT</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>IR_BROL</name></expr> </then><else>: <expr><name>IR_BROR</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>tsh</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_NEG</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tsh</name></expr></argument>, <argument><expr><name>tsh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>id</name><operator>-</operator><name>CTID_INT64</name><operator>+</operator><name>IRT_I64</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tsh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_CNEWI</name></expr></argument>, <argument><expr><name>IRT_CDATA</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>TRef</name></type> <name>recff_bit64_tohex</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>hdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>crec_bit64_type</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name></decl>, <decl><type ref="prev"/><name>trsf</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SFormat</name></type> <name>sf</name> <init>= <expr><operator>(</operator><name>STRFMT_UINT</name><operator>|</operator><name>STRFMT_T_HEX</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>n</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>trsf</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>id2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><call><name>lj_carith_check64</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>id2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>id2</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>trsf</name> <operator>=</operator> <call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_INT32</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>trsf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>trsf</name> <operator>=</operator> <call><name>lj_opt_narrow_tobit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>trsf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trsf</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Specialize to n. */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><name>id</name></expr> ?</condition><then> <expr><literal type="number">16</literal></expr> </then><else>: <expr><literal type="number">8</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><name>n</name></expr>;</expr_stmt> <expr_stmt><expr><name>sf</name> <operator>|=</operator> <name>STRFMT_F_UPPER</name></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>sf</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>SFormat</name><operator>)</operator><operator>(</operator><operator>(</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><literal type="number">255</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>STRFMT_SH_PREC</name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>id</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BAND</name></expr></argument>, <argument><expr><name>IRT_U64</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>,
		  <argument><expr><call><name>lj_ir_kint64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>*</operator><name>n</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>lj_opt_narrow_tobit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BAND</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>*</operator><name>n</name><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitconv</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRT_U64</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* No sign-extension. */</comment>
    <expr_stmt><expr><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_lj_strfmt_putfxint</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>sf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Miscellaneous library functions ------------------------------------- */</comment>

<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>lj_crecord_tonumber</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>d</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>lj_ctype_rawref</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_iscomplex</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isinteger_or_bool</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator>
	<operator>!</operator><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_INT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>crec_ct_tv</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* Specialize to the ctype that couldn't be converted. */</comment>
    <expr_stmt><expr><call><name>argv2cdata</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>emitir</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>emitconv</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
