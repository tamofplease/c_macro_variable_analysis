<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_lex.c"><comment type="block">/*
** Lexical analyzer.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
**
** Major portions taken verbatim or adapted from the Lua interpreter.
** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_lex_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_buf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_str.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cdata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lualib.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_lex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_parse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_char.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strfmt.h"</cpp:file></cpp:include>

<comment type="block">/* Lua lexer token names. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>tokennames</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TKSTR1</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>#name,</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TKSTR2</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>sym</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>#sym,</cpp:value></cpp:define>
<macro><name>TKDEF</name><argument_list>(<argument>TKSTR1</argument>, <argument>TKSTR2</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TKSTR1</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TKSTR2</name></cpp:undef>
  <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* -- Buffer handling ----------------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEX_EOF</name></cpp:macro>			<cpp:value>(-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lex_iseol</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(ls-&gt;c == '\n' || ls-&gt;c == '\r')</cpp:value></cpp:define>

<comment type="block">/* Get more input from reader. */</comment>
<function><type><specifier>static</specifier> <name>LJ_NOINLINE</name> <name>LexChar</name></type> <name>lex_more</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name><name>ls</name><operator>-&gt;</operator><name>rfunc</name></name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>rdata</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>sz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>LEX_EOF</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;=</operator> <name>LJ_MAX_BUF</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>!=</operator> <operator>~</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_err_mem</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <operator>~</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><literal type="number">0</literal> <operator>-</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>p</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;=</operator> <name>LJ_MAX_BUF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sz</name> <operator>=</operator> <name>LJ_MAX_BUF</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>endmark</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>pe</name></name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>sz</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>LexChar</name><operator>)</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get next character. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>LexChar</name></type> <name>lex_next</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <ternary><condition><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>&lt;</operator> <name><name>ls</name><operator>-&gt;</operator><name>pe</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>LexChar</name><operator>)</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><operator>*</operator><name><name>ls</name><operator>-&gt;</operator><name>p</name></name><operator>++</operator></expr> </then><else>: <expr><call><name>lex_more</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Save character. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>void</name></type> <name>lex_save</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>LexChar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_buf_putb</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Save previous character and get next character. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>LexChar</name></type> <name>lex_savenext</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lex_save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Skip line break. Handles "\n", "\r", "\r\n" or "\n\r". */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lex_newline</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>LexChar</name></type> <name>old</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>lex_iseol</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Skip "\n" or "\r". */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>lex_iseol</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>!=</operator> <name>old</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Skip "\n\r" or "\r\n". */</comment>
  <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name> <operator>&gt;=</operator> <name>LJ_MAX_LINE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name></expr></argument>, <argument><expr><name>LJ_ERR_XLINES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Scanner for terminals ----------------------------------------------- */</comment>

<comment type="block">/* Parse a number literal. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lex_number</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>StrScanFmt</name></type> <name>fmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LexChar</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>xp</name> <init>= <expr><literal type="char">'e'</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>c</name></name><operator>)</operator> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>lex_savenext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>|</operator> <literal type="number">0x20</literal><operator>)</operator> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>xp</name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <while>while <condition>(<expr><call><name>lj_char_isident</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>||</operator>
	 <operator>(</operator><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <literal type="char">'+'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>|</operator> <literal type="number">0x20</literal><operator>)</operator> <operator>==</operator> <name>xp</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lex_savenext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>lex_save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>lj_strscan_scan</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>sbufB</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sbuflen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>tv</name></expr></argument>,
	  <argument><expr><operator>(</operator><ternary><condition><expr><name>LJ_DUALNUM</name></expr> ?</condition><then> <expr><name>STRSCAN_OPT_TOINT</name></expr> </then><else>: <expr><name>STRSCAN_OPT_TONUM</name></expr></else></ternary><operator>)</operator> <operator>|</operator>
	  <operator>(</operator><ternary><condition><expr><name>LJ_HASFFI</name></expr> ?</condition><then> <expr><operator>(</operator><name>STRSCAN_OPT_LL</name><operator>|</operator><name>STRSCAN_OPT_IMAG</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>LJ_DUALNUM</name> <operator>&amp;&amp;</operator> <name>fmt</name> <operator>==</operator> <name>STRSCAN_INT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>setitype</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>LJ_TISNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fmt</name> <operator>==</operator> <name>STRSCAN_NUM</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Already in correct format. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fmt</name> <operator>!=</operator> <name>STRSCAN_ERROR</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>fmt</name> <operator>==</operator> <name>STRSCAN_I64</name> <operator>||</operator> <name>fmt</name> <operator>==</operator> <name>STRSCAN_U64</name> <operator>||</operator> <name>fmt</name> <operator>==</operator> <name>STRSCAN_IMAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>oldtop</name> <init>= <expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>luaopen_ffi</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Load FFI library on-demand. */</comment>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>==</operator> <name>STRSCAN_IMAG</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>cd</name> <operator>=</operator> <call><name>lj_cdata_new_</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>CTID_COMPLEX_DOUBLE</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <call><name>numV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>cd</name> <operator>=</operator> <call><name>lj_cdata_new_</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><ternary><condition><expr><name>fmt</name><operator>==</operator><name>STRSCAN_I64</name></expr> ?</condition><then> <expr><name>CTID_INT64</name></expr> </then><else>: <expr><name>CTID_UINT64</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>tv</name><operator>-&gt;</operator><name>u64</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>lj_parse_keepcdata</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>fmt</name> <operator>==</operator> <name>STRSCAN_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_number</name></expr></argument>, <argument><expr><name>LJ_ERR_XNUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Skip equal signs for "[=...=[" and "]=...=]" and return their count. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lex_skipeq</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LexChar</name></type> <name>s</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>s</name> <operator>==</operator> <literal type="char">'['</literal> <operator>||</operator> <name>s</name> <operator>==</operator> <literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><call><name>lex_savenext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <name>count</name> <operator>&lt;</operator> <literal type="number">0x20000000</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <name>s</name><operator>)</operator></expr> ?</condition><then> <expr><name>count</name></expr> </then><else>: <expr><operator>(</operator><operator>-</operator><name>count</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse a long string or long comment (tv set to NULL). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lex_longstring</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lex_savenext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Skip second '['. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>lex_iseol</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Skip initial newline. */</comment>
    <expr_stmt><expr><call><name>lex_newline</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LEX_EOF</name></expr>:</case>
      <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_eof</name></expr></argument>, <argument><expr><ternary><condition><expr><name>tv</name></expr> ?</condition><then> <expr><name>LJ_ERR_XLSTR</name></expr> </then><else>: <expr><name>LJ_ERR_XLCOM</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><literal type="char">']'</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>lex_skipeq</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>sep</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lex_savenext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Skip second ']'. */</comment>
	<goto>goto <name>endloop</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
    <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
      <expr_stmt><expr><call><name>lex_save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lex_newline</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tv</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_buf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Don't waste space for comments. */</comment>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><call><name>lex_savenext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for> <label><name>endloop</name>:</label>
  <if_stmt><if>if <condition>(<expr><name>tv</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>lj_parse_keepstr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>sbufB</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name>MSize</name><operator>)</operator><name>sep</name><operator>)</operator></expr></argument>,
				      <argument><expr><call><name>sbuflen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name>MSize</name><operator>)</operator><name>sep</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse a string. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lex_string</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>LexChar</name></type> <name>delim</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Delimiter is '\'' or '"'. */</comment>
  <expr_stmt><expr><call><name>lex_savenext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>!=</operator> <name>delim</name></expr>)</condition> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LEX_EOF</name></expr>:</case>
      <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_eof</name></expr></argument>, <argument><expr><name>LJ_ERR_XSTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
    <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
      <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_string</name></expr></argument>, <argument><expr><name>LJ_ERR_XSTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    <case>case <expr><literal type="char">'\\'</literal></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>LexChar</name></type> <name>c</name> <init>= <expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* Skip the '\\'. */</comment>
      <switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><literal type="char">'a'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\a'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'b'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'f'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'n'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'r'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'t'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'v'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\v'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'x'</literal></expr>:</case>  <comment type="block">/* Hexadecimal escape '\xXX'. */</comment>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">15u</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_char_isxdigit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_xesc</name>;</goto></block_content></block></if></if_stmt>
	  <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">9</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>c</name> <operator>+=</operator> <operator>(</operator><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">15u</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_char_isxdigit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_xesc</name>;</goto></block_content></block></if></if_stmt>
	  <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<break>break;</break>
      <case>case <expr><literal type="char">'u'</literal></expr>:</case>  <comment type="block">/* Unicode escape '\u{XX...}'. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_xesc</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<do>do <block>{<block_content>
	  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>&amp;</operator> <literal type="number">15u</literal><operator>)</operator></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_char_isxdigit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_xesc</name>;</goto></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
	  </block_content>}</block></if></if_stmt>
	  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0x110000</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_xesc</name>;</goto></block_content></block></if></if_stmt>  <comment type="block">/* Out of Unicode range. */</comment>
	</block_content>}</block> while <condition>(<expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition>;</do>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0x800</literal></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
	  <expr_stmt><expr><call><name>lex_save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal> <operator>|</operator> <operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0x10000</literal></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><call><name>lex_save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0xf0</literal> <operator>|</operator> <operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">18</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>lex_save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  </block_content>}</block></if> <else>else <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0xd800</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;</operator> <literal type="number">0xe000</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_xesc</name>;</goto></block_content></block></if></if_stmt>  <comment type="block">/* No surrogates. */</comment>
	    <expr_stmt><expr><call><name>lex_save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0xe0</literal> <operator>|</operator> <operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  </block_content>}</block></else></if_stmt>
	  <expr_stmt><expr><call><name>lex_save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><literal type="char">'z'</literal></expr>:</case>  <comment type="block">/* Skip whitespace. */</comment>
	<expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>lj_char_isspace</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <if_stmt><if>if <condition>(<expr><call><name>lex_iseol</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lex_newline</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt></block_content></block></while>
	<continue>continue;</continue>
      <case>case <expr><literal type="char">'\n'</literal></expr>:</case> <case>case <expr><literal type="char">'\r'</literal></expr>:</case> <expr_stmt><expr><call><name>lex_save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>lex_newline</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <continue>continue;</continue>
      <case>case <expr><literal type="char">'\\'</literal></expr>:</case> <case>case <expr><literal type="char">'\"'</literal></expr>:</case> <case>case <expr><literal type="char">'\''</literal></expr>:</case> <break>break;</break>
      <case>case <expr><name>LEX_EOF</name></expr>:</case> <continue>continue;</continue>
      <default>default:</default>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <goto>goto <name>err_xesc</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>  <comment type="block">/* Decimal escape '\ddd'. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition> <block>{<block_content>
	    <label><name>err_xesc</name>:</label>
	      <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_string</name></expr></argument>, <argument><expr><name>LJ_ERR_XESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>
	    <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  </block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>lex_save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></switch>
      <expr_stmt><expr><call><name>lex_save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
      </block_content>}</block>
    <default>default:</default>
      <expr_stmt><expr><call><name>lex_savenext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>lex_savenext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Skip trailing delimiter. */</comment>
  <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>tv</name></expr></argument>,
	  <argument><expr><call><name>lj_parse_keepstr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>sbufB</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sbuflen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Main lexical scanner ------------------------------------------------ */</comment>

<comment type="block">/* Get next lexical token. */</comment>
<function><type><specifier>static</specifier> <name>LexToken</name></type> <name>lex_scan</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_buf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>lj_char_isident</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Numeric literal. */</comment>
	<expr_stmt><expr><call><name>lex_number</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>TK_number</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Identifier or reserved word. */</comment>
      <do>do <block>{<block_content>
	<expr_stmt><expr><call><name>lex_savenext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block> while <condition>(<expr><call><name>lj_char_isident</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
      <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>lj_parse_keepstr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>sbufB</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sbuflen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>reserved</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Reserved word? */</comment>
	<return>return <expr><name>TK_OFS</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>reserved</name></name></expr>;</return></block_content></block></if></if_stmt>
      <return>return <expr><name>TK_name</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
    <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
      <expr_stmt><expr><call><name>lex_newline</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    <case>case <expr><literal type="char">' '</literal></expr>:</case>
    <case>case <expr><literal type="char">'\t'</literal></expr>:</case>
    <case>case <expr><literal type="char">'\v'</literal></expr>:</case>
    <case>case <expr><literal type="char">'\f'</literal></expr>:</case>
      <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    <case>case <expr><literal type="char">'-'</literal></expr>:</case>
      <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="char">'-'</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Long comment "--[=*[...]=*]". */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>sep</name> <init>= <expr><call><name>lex_skipeq</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>lj_buf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* `lex_skipeq' may dirty the buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name>sep</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>lex_longstring</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>lj_buf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <continue>continue;</continue>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Short comment "--.*\n". */</comment>
      <while>while <condition>(<expr><operator>!</operator><call><name>lex_iseol</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>!=</operator> <name>LEX_EOF</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
      <continue>continue;</continue>
    <case>case <expr><literal type="char">'['</literal></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>sep</name> <init>= <expr><call><name>lex_skipeq</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>sep</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lex_longstring</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>TK_string</name></expr>;</return>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>sep</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
	<return>return <expr><literal type="char">'['</literal></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_string</name></expr></argument>, <argument><expr><name>LJ_ERR_XLDELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></else></if_stmt>
      </block_content>}</block>
    <case>case <expr><literal type="char">'='</literal></expr>:</case>
      <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="char">'='</literal></expr>;</return></block_content></block></if> <else>else <block>{<block_content> <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>TK_eq</name></expr>;</return> </block_content>}</block></else></if_stmt>
    <case>case <expr><literal type="char">'&lt;'</literal></expr>:</case>
      <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="char">'&lt;'</literal></expr>;</return></block_content></block></if> <else>else <block>{<block_content> <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>TK_le</name></expr>;</return> </block_content>}</block></else></if_stmt>
    <case>case <expr><literal type="char">'&gt;'</literal></expr>:</case>
      <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="char">'&gt;'</literal></expr>;</return></block_content></block></if> <else>else <block>{<block_content> <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>TK_ge</name></expr>;</return> </block_content>}</block></else></if_stmt>
    <case>case <expr><literal type="char">'~'</literal></expr>:</case>
      <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="char">'~'</literal></expr>;</return></block_content></block></if> <else>else <block>{<block_content> <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>TK_ne</name></expr>;</return> </block_content>}</block></else></if_stmt>
    <case>case <expr><literal type="char">':'</literal></expr>:</case>
      <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="char">':'</literal></expr>;</return></block_content></block></if> <else>else <block>{<block_content> <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>TK_label</name></expr>;</return> </block_content>}</block></else></if_stmt>
    <case>case <expr><literal type="char">'"'</literal></expr>:</case>
    <case>case <expr><literal type="char">'\''</literal></expr>:</case>
      <expr_stmt><expr><call><name>lex_string</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TK_string</name></expr>;</return>
    <case>case <expr><literal type="char">'.'</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>lex_savenext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <return>return <expr><name>TK_dots</name></expr>;</return>   <comment type="block">/* ... */</comment>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>TK_concat</name></expr>;</return>   <comment type="block">/* .. */</comment>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<return>return <expr><literal type="char">'.'</literal></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>lex_number</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>TK_number</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    <case>case <expr><name>LEX_EOF</name></expr>:</case>
      <return>return <expr><name>TK_eof</name></expr>;</return>
    <default>default:</default> <block>{<block_content>
      <decl_stmt><decl><type><name>LexChar</name></type> <name>c</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>c</name></expr>;</return>  <comment type="block">/* Single-char tokens (+ - / ...). */</comment>
    </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* -- Lexer API ----------------------------------------------------------- */</comment>

<comment type="block">/* Setup lexer state. */</comment>
<function><type><name>int</name></type> <name>lj_lex_setup</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>header</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name> <operator>=</operator> <name>L</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>pe</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>sizevstack</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>vtop</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>bcstack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>sizebcstack</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <name>TK_eof</name></expr>;</expr_stmt>  <comment type="block">/* No look-ahead token. */</comment>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>lastline</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>endmark</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Read-ahead first char. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <literal type="number">0xef</literal> <operator>&amp;&amp;</operator> <name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name><name>ls</name><operator>-&gt;</operator><name>pe</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>ls</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xbb</literal> <operator>&amp;&amp;</operator>
      <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>ls</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xbf</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Skip UTF-8 BOM (if buffered). */</comment>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>header</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Skip POSIX #! header line. */</comment>
    <do>do <block>{<block_content>
      <expr_stmt><expr><call><name>lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <name>LEX_EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>lex_iseol</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
    <expr_stmt><expr><call><name>lex_newline</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>header</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <name><name>LUA_SIGNATURE</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Bytecode dump. */</comment>
    <if_stmt><if>if <condition>(<expr><name>header</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/*
      ** Loading bytecode with an extra header is disabled for security
      ** reasons. This may circumvent the usual check for bytecode vs.
      ** Lua code by looking at the first char. Since this is a potential
      ** security violation no attempt is made to echo the chunkname either.
      */</comment>
      <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><call><name>lj_err_str</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_BCBAD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lj_err_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_ERRSYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Cleanup lexer state. */</comment>
<function><type><name>void</name></type> <name>lj_lex_cleanup</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_mem_freevec</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>bcstack</name></name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>sizebcstack</name></name></expr></argument>, <argument><expr><name>BCInsLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_mem_freevec</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>sizevstack</name></name></expr></argument>, <argument><expr><name>VarInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_buf_free</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return next lexical token. */</comment>
<function><type><name>void</name></type> <name>lj_lex_next</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>lastline</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <name>TK_eof</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* No lookahead token? */</comment>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>=</operator> <call><name>lex_scan</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>tokval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Get next token. */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Otherwise return lookahead token. */</comment>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <name>TK_eof</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>tokval</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>lookaheadval</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Look ahead for the next token. */</comment>
<function><type><name>LexToken</name></type> <name>lj_lex_lookahead</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <name>TK_eof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <call><name>lex_scan</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>lookaheadval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Convert token to string. */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lj_lex_token2str</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>LexToken</name></type> <name>tok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>tok</name> <operator>&gt;</operator> <name>TK_OFS</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name><name>tokennames</name><index>[<expr><name>tok</name><operator>-</operator><name>TK_OFS</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>lj_char_iscntrl</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"char(%d)"</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Lexer error. */</comment>
<function><type><name>void</name></type> <name>lj_lex_error</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>LexToken</name></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>em</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tokstr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>argp</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>tokstr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tok</name> <operator>==</operator> <name>TK_name</name> <operator>||</operator> <name>tok</name> <operator>==</operator> <name>TK_string</name> <operator>||</operator> <name>tok</name> <operator>==</operator> <name>TK_number</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lex_save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tokstr</name> <operator>=</operator> <call><name>sbufB</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>tokstr</name> <operator>=</operator> <call><name>lj_lex_token2str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_err_lex</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>chunkname</name></name></expr></argument>, <argument><expr><name>tokstr</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></argument>, <argument><expr><name>em</name></expr></argument>, <argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize strings for reserved words. */</comment>
<function><type><name>void</name></type> <name>lj_lex_init</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TK_RESERVED</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>lj_str_newz</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>tokennames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fixstring</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Reserved words are never collected. */</comment>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>reserved</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

</unit>
