<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lib_ffi.c"><comment type="block">/*
** FFI library.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lib_ffi_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_LIB</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lauxlib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lualib.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_str.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_meta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cdata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cconv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_carith.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ccall.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ccallback.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_clib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strfmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_lib.h"</cpp:file></cpp:include>

<comment type="block">/* -- C type checks ------------------------------------------------------- */</comment>

<comment type="block">/* Check first argument for a C type and returns its ID. */</comment>
<function><type><specifier>static</specifier> <name>CTypeID</name></type> <name>ffi_checkctype</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>o</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
  <label><name>err_argtype</name>:</label>
    <expr_stmt><expr><call><name>lj_err_argtype</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"C type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Parse an abstract C type declaration. */</comment>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CPState</name></type> <name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>errcode</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>L</name></name> <operator>=</operator> <name>L</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>cts</name></name> <operator>=</operator> <name>cts</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>srcname</name></name> <operator>=</operator> <call><name>strdata</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>p</name></name> <operator>=</operator> <call><name>strdata</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>param</name></name> <operator>=</operator> <name>param</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>CPARSE_MODE_ABSTRACT</name><operator>|</operator><name>CPARSE_MODE_NOIMPLICIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>lj_cparse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>errcode</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_err_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Propagate errors. */</comment>
    <return>return <expr><name><name>cp</name><operator>.</operator><name>val</name><operator>.</operator><name>id</name></name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tviscdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_argtype</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>param</name> <operator>&amp;&amp;</operator> <name>param</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_err_arg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LJ_ERR_FFI_NUMPARAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cd</name> <operator>=</operator> <call><name>cdataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name> <operator>==</operator> <name>CTID_CTYPEID</name></expr> ?</condition><then> <expr><operator>*</operator><operator>(</operator><name>CTypeID</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></else></ternary></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Check argument for C data and return it. */</comment>
<function><type><specifier>static</specifier> <name>GCcdata</name> <modifier>*</modifier></type><name>ffi_checkcdata</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>narg</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>o</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <call><name>tviscdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_argt</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>narg</name></expr></argument>, <argument><expr><name>LUA_TCDATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>cdataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Convert argument to C pointer. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>ffi_checkptr</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>, <parameter><decl><type><name>CTypeID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>narg</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>o</name> <operator>&gt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_arg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>narg</name></expr></argument>, <argument><expr><name>LJ_ERR_NOVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_cconv_ct_tv</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>CCF_ARG</name><argument_list>(<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Convert argument to int32_t. */</comment>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>ffi_checkint</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>narg</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>o</name> <operator>&gt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_arg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>narg</name></expr></argument>, <argument><expr><name>LJ_ERR_NOVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_cconv_ct_tv</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_INT32</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><name>o</name></expr></argument>,
		 <argument><expr><call><name>CCF_ARG</name><argument_list>(<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- C type metamethods -------------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJLIB_MODULE_ffi_meta</name></cpp:macro></cpp:define>

<comment type="block">/* Handle ctype __index/__newindex metamethods. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ffi_index_meta</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>, <parameter><decl><type><name>MMS</name></type> <name>mm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>ctype_typeid</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>lj_ctype_meta</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tv</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <label><name>err_index</name>:</label>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>strdata</name><argument_list>(<argument><expr><call><name>lj_ctype_repr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lj_err_callerv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_BADMEMBER</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strVdata</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><ternary><condition><expr><call><name>tviscdata</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then>
	<expr><call><name>strdata</name><argument_list>(<argument><expr><call><name>lj_ctype_repr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>:
	<expr><call><name>lj_typename</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lj_err_callerv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_BADIDXW</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisfunc</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>mm</name> <operator>==</operator> <name>MM_index</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lj_meta_tget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>base</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>o</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>tvisnil</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_index</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lj_meta_tset</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>base</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>o</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>base</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tv</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>lj_meta_tailcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___index</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_index <literal type="number">0</literal></argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>qual</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>o</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <call><name>tviscdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Also checks for presence of key. */</comment>
    <expr_stmt><expr><call><name>lj_err_argt</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LUA_TCDATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>lj_cdata_index</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>o</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>qual</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>ffi_index_meta</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>MM_index</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lj_cdata_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___newindex</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_index <literal type="number">1</literal></argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>qual</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>o</name><operator>+</operator><literal type="number">2</literal> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <call><name>tviscdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Also checks for key and value. */</comment>
    <expr_stmt><expr><call><name>lj_err_argt</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LUA_TCDATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>lj_cdata_index</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>o</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>qual</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>qual</name> <operator>&amp;</operator> <name>CTF_CONST</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_WRCONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ffi_index_meta</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>MM_newindex</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_cdata_set</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>o</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>

<comment type="block">/* Common handler for cdata arithmetic. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ffi_arith</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MMS</name></type> <name>mm</name> <init>= <expr><operator>(</operator><name>MMS</name><operator>)</operator><operator>(</operator><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>ffid</name></name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name>FF_ffi_meta___eq</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>MM_eq</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>lj_carith_op</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The following functions must be in contiguous ORDER MM. */</comment>
<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___eq</argument>)</argument_list></macro>		<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_arith MM_eq</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___len</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_arith MM_len</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___lt</argument>)</argument_list></macro>		<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_arith MM_lt</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___le</argument>)</argument_list></macro>		<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_arith MM_le</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___concat</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_arith MM_concat</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<comment type="block">/* Forward declaration. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>lj_cf_ffi_new</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>;</function_decl>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___call</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_call</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>ffi_checkcdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MMS</name></type> <name>mm</name> <init>= <expr><name>MM_call</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name> <operator>==</operator> <name>CTID_CTYPEID</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>id</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>CTypeID</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mm</name> <operator>=</operator> <name>MM_new</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>lj_ccall_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Handle ctype __call/__new metamethod. */</comment>
  <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>tv</name> <operator>=</operator> <call><name>lj_ctype_meta</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tv</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_meta_tailcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>mm</name> <operator>==</operator> <name>MM_call</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_callerv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_BADCALL</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><call><name>lj_ctype_repr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>lj_cf_ffi_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___add</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_arith MM_add</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___sub</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_arith MM_sub</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___mul</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_arith MM_mul</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___div</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_arith MM_div</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___mod</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_arith MM_mod</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___pow</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_arith MM_pow</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___unm</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>cdata_arith MM_unm</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>
<comment type="block">/* End of contiguous ORDER MM. */</comment>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___tostring</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>ffi_checkcdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><literal type="string">"cdata&lt;%s&gt;: %p"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>CTID_CTYPEID</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"ctype&lt;%s&gt;"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>id</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>CTypeID</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isref</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_iscomplex</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>lj_ctype_repr_complex</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>checkgc</name>;</goto>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <call><name>ctype_isinteger</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>lj_ctype_repr_int64</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>,
					       <argument><expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>checkgc</name>;</goto>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isfunc</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"cdata&lt;%s&gt;: %d"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>cdata_getptr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isvector</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Handle ctype __tostring metamethod. */</comment>
	<decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>lj_ctype_meta</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_typeid</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MM_tostring</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>tv</name></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><call><name>lj_meta_tailcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><call><name>lj_ctype_repr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>checkgc</name>:</label>
  <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ffi_pairs</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>MMS</name></type> <name>mm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>ffi_checkcdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>tv</name> <operator>=</operator> <call><name>lj_ctype_meta</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tv</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_callerv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_BADMM</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><call><name>lj_ctype_repr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><call><name>mmname_str</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>lj_meta_tailcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___pairs</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_pairs</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>MM_pairs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_meta___ipairs</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_pairs</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>MM_ipairs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_PUSH</name><argument_list>(<argument><literal type="string">"ffi"</literal></argument>)</argument_list></macro> <macro><name>LJLIB_SET</name><argument_list>(<argument>__metatable</argument>)</argument_list></macro>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_libdef.h"</cpp:file></cpp:include>

<comment type="block">/* -- C library metamethods ----------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJLIB_MODULE_ffi_clib</name></cpp:macro></cpp:define>

<comment type="block">/* Index C library by a name. */</comment>
<function><type><specifier>static</specifier> <name>TValue</name> <modifier>*</modifier></type><name>ffi_clib_index</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CLibrary</name> <modifier>*</modifier></type><name>cl</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>o</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <call><name>tvisudata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>udataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>udtype</name> <operator>==</operator> <name>UDTYPE_FFI_CLIB</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_argt</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LUA_TUSERDATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>cl</name> <operator>=</operator> <operator>(</operator><name>CLibrary</name> <operator>*</operator><operator>)</operator><call><name>uddata</name><argument_list>(<argument><expr><call><name>udataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>o</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <call><name>tvisstr</name><argument_list>(<argument><expr><name>o</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_argt</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>LUA_TSTRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>lj_clib_index</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>, <argument><expr><call><name>strV</name><argument_list>(<argument><expr><name>o</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_clib___index</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>clib_index <literal type="number">1</literal></argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>ffi_clib_index</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tviscdata</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>cdataV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isextern</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CTypeID</name></type> <name>sid</name> <init>= <expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>lj_cconv_tv_ct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_clib___newindex</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>clib_index <literal type="number">0</literal></argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>ffi_clib_index</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>o</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <call><name>tviscdata</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>cdataV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isextern</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CTInfo</name></type> <name>qual</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>  <comment type="block">/* Skip attributes and collect qualifiers. */</comment>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isattrib</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ctype_attrib</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTA_QUAL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>qual</name> <operator>|=</operator> <name><name>d</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>info</name></name><operator>|</operator><name>qual</name><operator>)</operator> <operator>&amp;</operator> <name>CTF_CONST</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lj_cconv_ct_tv</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_WRCONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* unreachable */</comment>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_clib___gc</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>o</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <call><name>tvisudata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>udataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>udtype</name> <operator>==</operator> <name>UDTYPE_FFI_CLIB</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_clib_unload</name><argument_list>(<argument><expr><operator>(</operator><name>CLibrary</name> <operator>*</operator><operator>)</operator><call><name>uddata</name><argument_list>(<argument><expr><call><name>udataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_libdef.h"</cpp:file></cpp:include>

<comment type="block">/* -- Callback function metamethods --------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJLIB_MODULE_ffi_callback</name></cpp:macro></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ffi_callback_set</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>ffi_checkcdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>LJ_32</name> <operator>||</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>MSize</name></type> <name>slot</name> <init>= <expr><call><name>lj_ccallback_ptr2slot</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>&lt;</operator> <name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>sizeid</name></name> <operator>&amp;&amp;</operator> <name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>cbid</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name><name>cts</name><operator>-&gt;</operator><name>miscmap</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>lj_tab_setint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>fn</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>setfuncV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lj_gc_anybarriert</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>cbid</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>topid</name></name> <operator>=</operator> <ternary><condition><expr><name>slot</name> <operator>&lt;</operator> <name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>topid</name></name></expr> ?</condition><then> <expr><name>slot</name></expr> </then><else>: <expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>topid</name></name></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_BADCBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_callback_free</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>ffi_callback_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_callback_set</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><call><name>lj_lib_checkfunc</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>ffi_callback_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_PUSH</name><argument_list>(<argument>top-<literal type="number">1</literal></argument>)</argument_list></macro> <macro><name>LJLIB_SET</name><argument_list>(<argument>__index</argument>)</argument_list></macro>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_libdef.h"</cpp:file></cpp:include>

<comment type="block">/* -- FFI library functions ----------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJLIB_MODULE_ffi</name></cpp:macro></cpp:define>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_cdef</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>lj_lib_checkstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CPState</name></type> <name>cp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>errcode</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>L</name></name> <operator>=</operator> <name>L</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>cts</name></name> <operator>=</operator> <call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>srcname</name></name> <operator>=</operator> <call><name>strdata</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>p</name></name> <operator>=</operator> <call><name>strdata</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>param</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>CPARSE_MODE_MULTI</name><operator>|</operator><name>CPARSE_MODE_DIRECT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>lj_cparse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>errcode</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_err_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Propagate errors. */</comment>
  <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_new</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>.</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>ffi_checkctype</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>info</name> <init>= <expr><call><name>lj_ctype_info</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_VLA</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>o</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>lj_ctype_vlsize</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><operator>(</operator><name>CTSize</name><operator>)</operator><call><name>ffi_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>==</operator> <name>CTSIZE_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_arg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>cd</name> <operator>=</operator> <call><name>lj_cdata_newx</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setcdataV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>o</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Anchor the uninitialized cdata. */</comment>
  <expr_stmt><expr><call><name>lj_cconv_ct_init</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>o</name></expr></argument>, <argument><expr><operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>o</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Initialize cdata. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Handle ctype __gc metamethod. Use the fast lookup here. */</comment>
    <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>lj_tab_getinth</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>miscmap</name></name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>tv</name> <operator>&amp;&amp;</operator> <call><name>tvistab</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>tv</name> <operator>=</operator> <call><name>lj_meta_fast</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>tabV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MM_gc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name><name>cts</name><operator>-&gt;</operator><name>finalizer</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Add to finalizer table, if still enabled. */</comment>
	<expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lj_tab_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>o</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lj_gc_anybarriert</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>marked</name></name> <operator>|=</operator> <name>LJ_GC_CDATA_FIN</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>  <comment type="block">/* Only return the cdata itself. */</comment>
  <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_cast</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>ffi_new</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>ffi_checkctype</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lj_lib_checkany</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>o</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Make sure this is the last item on the stack. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_arg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>tviscdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>cdataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name> <operator>==</operator> <name>id</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>lj_cdata_new</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lj_cconv_ct_tv</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>CCF_CAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setcdataV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_typeof</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>.</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>ffi_checkctype</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>lj_cdata_new</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_CTYPEID</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>CTypeID</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setcdataV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<comment type="block">/* Internal and unsupported API. */</comment>
<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_typeinfo</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><operator>(</operator><name>CTypeID</name><operator>)</operator><call><name>ffi_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>id</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>id</name> <operator>&lt;</operator> <name><name>cts</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_createtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Increment hash size if fields are added. */</comment>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>tabV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><call><name>lj_tab_setstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>lj_str_newlit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"info"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <name>CTSIZE_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><call><name>lj_tab_setstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>lj_str_newlit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><call><name>lj_tab_setstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>lj_str_newlit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"sib"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>gco2str</name><argument_list>(<argument><expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lj_tab_setstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>lj_str_newlit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_istype</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>.</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id1</name> <init>= <expr><call><name>ffi_checkctype</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lj_lib_checkany</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>b</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tviscdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>cdataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>id2</name> <init>= <expr><ternary><condition><expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name> <operator>==</operator> <name>CTID_CTYPEID</name></expr> ?</condition><then> <expr><operator>*</operator><operator>(</operator><name>CTypeID</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr> </then><else>:
						<expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct1</name> <init>= <expr><call><name>lj_ctype_rawref</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct2</name> <init>= <expr><call><name>lj_ctype_rawref</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ct1</name> <operator>==</operator> <name>ct2</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>b</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_type</name><argument_list>(<argument><expr><name><name>ct1</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ctype_type</name><argument_list>(<argument><expr><name><name>ct2</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	       <name><name>ct1</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <name><name>ct2</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_ispointer</name><argument_list>(<argument><expr><name><name>ct1</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>lj_cconv_compatptr</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct1</name></expr></argument>, <argument><expr><name>ct2</name></expr></argument>, <argument><expr><name>CCF_IGNQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>ct1</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isvoid</name><argument_list>(<argument><expr><name><name>ct1</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name><name>ct1</name><operator>-&gt;</operator><name>info</name></name> <operator>^</operator> <name><name>ct2</name><operator>-&gt;</operator><name>info</name></name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>CTF_QUAL</name><operator>|</operator><name>CTF_LONG</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ct1</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct2</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	       <name>ct1</name> <operator>==</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>b</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tmptv2</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Remember for trace recorder. */</comment>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_sizeof</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>ffi_xof FF_ffi_sizeof</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>ffi_checkctype</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><call><name>tviscdata</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>cdataisv</name><argument_list>(<argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>cdatavlen</name><argument_list>(<argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>lj_ctype_rawref</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isvltype</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>lj_ctype_vlsize</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><operator>(</operator><name>CTSize</name><operator>)</operator><call><name>ffi_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <ternary><condition><expr><call><name>ctype_hassize</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr> </then><else>: <expr><name>CTSIZE_INVALID</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name>sz</name> <operator>==</operator> <name>CTSIZE_INVALID</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_alignof</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>ffi_xof FF_ffi_alignof</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>ffi_checkctype</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>info</name> <init>= <expr><call><name>lj_ctype_info</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>ctype_align</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_offsetof</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>ffi_xof FF_ffi_offsetof</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>ffi_checkctype</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>lj_lib_checkstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>lj_ctype_rawref</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>ofs</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <name>CTSIZE_INVALID</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>fct</name> <init>= <expr><call><name>lj_ctype_getfield</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>fct</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>fct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isbitfield</name><argument_list>(<argument><expr><name><name>fct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><call><name>ctype_bitpos</name><argument_list>(<argument><expr><name><name>fct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><call><name>ctype_bitbsz</name><argument_list>(<argument><expr><name><name>fct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">3</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_errno</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>.</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&gt;</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <call><name>ffi_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_string</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>.</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lj_lib_checkany</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>o</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name>o</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>ffi_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_cconv_ct_tv</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_P_CVOID</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>o</name></expr></argument>,
		   <argument><expr><call><name>CCF_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lj_cconv_ct_tv</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_P_CCHAR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>o</name></expr></argument>,
		   <argument><expr><call><name>CCF_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>o</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Make sure this is the last item on the stack. */</comment>
  <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>lj_str_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_copy</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>.</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><call><name>ffi_checkptr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>CTID_P_VOID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>ffi_checkptr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>CTID_P_CVOID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>len</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>o</name><operator>+</operator><literal type="number">1</literal> <operator>&gt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>len</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* Copy Lua string including trailing '\0'. */</comment>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>CTSize</name><operator>)</operator><call><name>ffi_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_fill</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>.</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><call><name>ffi_checkptr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>CTID_P_VOID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>CTSize</name><operator>)</operator><call><name>ffi_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>fill</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">2</literal> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>fill</name> <operator>=</operator> <call><name>ffi_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>

<comment type="block">/* Test ABI string. */</comment>
<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_abi</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>.</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>lj_lib_checkstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>b</name> <init>= <expr><call><name>lj_cparse_case</name><argument_list>(<argument><expr><name>s</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
    <argument><expr><literal type="string">"\00564bit"</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <literal type="string">"\00532bit"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ARCH_HASFPU</name></expr></cpp:if>
    <literal type="string">"\003fpu"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ABI_SOFTFP</name></expr></cpp:if>
    <literal type="string">"\006softfp"</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <literal type="string">"\006hardfp"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ABI_EABI</name></expr></cpp:if>
    <literal type="string">"\004eabi"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ABI_WIN</name></expr></cpp:if>
    <literal type="string">"\003win"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_UWP</name></expr></cpp:if>
    <literal type="string">"\003uwp"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_LE</name></expr></cpp:if>
    <literal type="string">"\002le"</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <literal type="string">"\002be"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
    <literal type="string">"\004gc64"</literal></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  )</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tmptv2</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Remember for trace recorder. */</comment>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_PUSH</name><argument_list>(<argument>top-<literal type="number">8</literal></argument>)</argument_list></macro> <macro><name>LJLIB_SET</name><argument_list>(<argument>!</argument>)</argument_list></macro>  <comment type="block">/* Store reference to miscmap table. */</comment>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_metatype</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>ffi_checkctype</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><call><name>lj_lib_checktab</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name><name>cts</name><operator>-&gt;</operator><name>miscmap</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* Only allow raw types. */</comment>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_iscomplex</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
	<call><name>ctype_isvector</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_arg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>tv</name> <operator>=</operator> <call><name>lj_tab_setinth</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_PROTMT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_gc_anybarriert</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cd</name> <operator>=</operator> <call><name>lj_cdata_new</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_CTYPEID</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>CTypeID</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setcdataV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_PUSH</name><argument_list>(<argument>top-<literal type="number">7</literal></argument>)</argument_list></macro> <macro><name>LJLIB_SET</name><argument_list>(<argument>!</argument>)</argument_list></macro>  <comment type="block">/* Store reference to finalizer table. */</comment>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_gc</argument>)</argument_list></macro>	<macro><name>LJLIB_REC</name><argument_list>(<argument>.</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>ffi_checkcdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>fin</name> <init>= <expr><call><name>lj_lib_checkany</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
	<call><name>ctype_isrefarray</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_arg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_cdata_setfin</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><call><name>gcval</name><argument_list>(<argument><expr><name>fin</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>itype</name><argument_list>(<argument><expr><name>fin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Pass through the cdata object. */</comment>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_PUSH</name><argument_list>(<argument>top-<literal type="number">5</literal></argument>)</argument_list></macro> <macro><name>LJLIB_SET</name><argument_list>(<argument>!</argument>)</argument_list></macro>  <comment type="block">/* Store clib metatable in func environment. */</comment>

<macro><name>LJLIB_CF</name><argument_list>(<argument>ffi_load</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>lj_lib_checkstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>global</name> <init>= <expr><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <call><name>tvistruecond</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_clib_load</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>tabref</name><argument_list>(<argument><expr><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>env</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>global</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_PUSH</name><argument_list>(<argument>top-<literal type="number">4</literal></argument>)</argument_list></macro> <macro><name>LJLIB_SET</name><argument_list>(<argument>C</argument>)</argument_list></macro>
<macro><name>LJLIB_PUSH</name><argument_list>(<argument>top-<literal type="number">3</literal></argument>)</argument_list></macro> <macro><name>LJLIB_SET</name><argument_list>(<argument>os</argument>)</argument_list></macro>
<macro><name>LJLIB_PUSH</name><argument_list>(<argument>top-<literal type="number">2</literal></argument>)</argument_list></macro> <macro><name>LJLIB_SET</name><argument_list>(<argument>arch</argument>)</argument_list></macro>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_libdef.h"</cpp:file></cpp:include>

<comment type="block">/* ------------------------------------------------------------------------ */</comment>

<comment type="block">/* Create special weak-keyed finalizer table. */</comment>
<function><type><specifier>static</specifier> <name>GCtab</name> <modifier>*</modifier></type><name>ffi_finalizer</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* NOBARRIER: The table is new (marked white). */</comment>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>lj_tab_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lj_tab_setstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>lj_str_newlit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"__mode"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
	  <argument><expr><call><name>lj_str_newlit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"k"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>nomm</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>~</operator><operator>(</operator><literal type="number">1u</literal><operator>&lt;&lt;</operator><name>MM_mode</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Register FFI module as loaded. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ffi_register_module</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>lj_tab_getstr</name><argument_list>(<argument><expr><call><name>tabV</name><argument_list>(<argument><expr><call><name>registry</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lj_str_newlit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"_LOADED"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>&amp;&amp;</operator> <call><name>tvistab</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>tabV</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lj_tab_setstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>lj_str_newlit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_FFILIBNAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_gc_anybarriert</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>LUALIB_API</name> <name>int</name></type> <name>luaopen_ffi</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>lj_ctype_init</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><operator>(</operator><name><name>cts</name><operator>-&gt;</operator><name>miscmap</name></name> <operator>=</operator> <call><name>lj_tab_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cts</name><operator>-&gt;</operator><name>finalizer</name></name> <operator>=</operator> <call><name>ffi_finalizer</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>LJ_LIB_REG</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ffi_meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOBARRIER: basemt is a GC root. */</comment>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><call><name>basemt_it</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LJ_TCDATA</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><call><name>tabV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>LJ_LIB_REG</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ffi_clib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>LJ_LIB_REG</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ffi_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOBARRIER: the key is new and lj_tab_newkey() handles the barrier. */</comment>
  <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lj_tab_setstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>cts</name><operator>-&gt;</operator><name>miscmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cts</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>strempty</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>tabV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_clib_default</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>tabV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Create ffi.C default namespace. */</comment>
  <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_OS_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ARCH_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>LJ_LIB_REG</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ffi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Note: no global "ffi" created! */</comment>
  <expr_stmt><expr><call><name>ffi_register_module</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
