<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_cdata.c"><comment type="block">/*
** C data management.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cconv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cdata.h"</cpp:file></cpp:include>

<comment type="block">/* -- C data allocation --------------------------------------------------- */</comment>

<comment type="block">/* Allocate a new C data object holding a reference to another object. */</comment>
<function><type><name>GCcdata</name> <modifier>*</modifier></type><name>lj_cdata_newref</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>CTypeID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>refid</name> <init>= <expr><call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>CTINFO_REF</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>lj_cdata_new</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>refid</name></expr></argument>, <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <return>return <expr><name>cd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Allocate variable-sized or specially aligned C data object. */</comment>
<function><type><name>GCcdata</name> <modifier>*</modifier></type><name>lj_cdata_newv</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>CTypeID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>CTSize</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>CTSize</name></type> <name>align</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>extra</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>GCcdataVar</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GCcdata</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<operator>(</operator><ternary><condition><expr><name>align</name> <operator>&gt;</operator> <name>CT_MEMALIGN</name></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">1u</literal><operator>&lt;&lt;</operator><name>align</name><operator>)</operator> <operator>-</operator> <operator>(</operator><literal type="number">1u</literal><operator>&lt;&lt;</operator><name>CT_MEMALIGN</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lj_mem_newt</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>extra</name> <operator>+</operator> <name>sz</name></expr></argument>, <argument><expr><name>char</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>adata</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>p</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GCcdataVar</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GCcdata</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>almask</name> <init>= <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>align</name><operator>)</operator> <operator>-</operator> <literal type="number">1u</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><operator>(</operator><name>GCcdata</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>adata</name> <operator>+</operator> <name>almask</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><name>almask</name><operator>)</operator> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GCcdata</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>cd</name> <operator>-</operator> <name>p</name> <operator>&lt;</operator> <literal type="number">65536</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cdatav</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>offset</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>cd</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cdatav</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>extra</name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cdatav</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>len</name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>g</name> <operator>=</operator> <call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>nextgc</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>root</name></name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>newwhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>marked</name></name> <operator>|=</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>gct</name></name> <operator>=</operator> <operator>~</operator><name>LJ_TCDATA</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
  <return>return <expr><name>cd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Allocate arbitrary C data object. */</comment>
<function><type><name>GCcdata</name> <modifier>*</modifier></type><name>lj_cdata_newx</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CTypeID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>CTSize</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>CTInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_VLA</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>ctype_align</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>CT_MEMALIGN</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_cdata_new</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_cdata_newv</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><call><name>ctype_align</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Free a C data object. */</comment>
<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>lj_cdata_free</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>marked</name></name> <operator>&amp;</operator> <name>LJ_GC_CDATA_FIN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>markfinalized</name><argument_list>(<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>root</name> <operator>=</operator> <call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>nextgc</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>nextgc</name></name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><operator>!</operator><call><name>cdataisv</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name> <init>= <expr><ternary><condition><expr><call><name>ctype_hassize</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr> </then><else>: <expr><name>CTSIZE_PTR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_hassize</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isfunc</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
	       <call><name>ctype_isextern</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_mem_free</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GCcdata</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lj_mem_free</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>memcdatav</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizecdatav</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lj_cdata_setfin</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>finalizer</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Add cdata to finalizer table, if still enabled. */</comment>
    <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setcdataV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_gc_anybarriert</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tv</name> <operator>=</operator> <call><name>lj_tab_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>it</name> <operator>==</operator> <name>LJ_TNIL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>marked</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LJ_GC_CDATA_FIN</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>setgcV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>marked</name></name> <operator>|=</operator> <name>LJ_GC_CDATA_FIN</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- C data indexing ----------------------------------------------------- */</comment>

<comment type="block">/* Index C data by a TValue. Return CType and pointer. */</comment>
<function><type><name>CType</name> <modifier>*</modifier></type><name>lj_cdata_index</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,
		      <parameter><decl><type><name>CTInfo</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>idx</name></decl>;</decl_stmt>

  <comment type="block">/* Resolve reference for cdata object. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isref</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>collect_attrib</name>:</label>
  <comment type="block">/* Skip attributes and collect qualifiers. */</comment>
  <while>while <condition>(<expr><call><name>ctype_isattrib</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_attrib</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTA_QUAL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>qual</name> <operator>|=</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ctype_isref</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Interning rejects refs to refs. */</comment>

  <if_stmt><if>if <condition>(<expr><call><name>tvisint</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><call><name>intV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>integer_key</name>;</goto>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisnum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Numeric key. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
    <comment type="block">/* Workaround for MSVC bug. */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <name>lua_Number</name></type> <name>n</name> <init>= <expr><call><name>numV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <ternary><condition><expr><name>LJ_64</name></expr> ?</condition><then> <expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>n</name></expr> </then><else>: <expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><call><name>lj_num2int</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  <label><name>integer_key</name>:</label>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_ispointer</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name> <init>= <expr><call><name>lj_ctype_size</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* Element size. */</comment>
      <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>==</operator> <name>CTSIZE_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>cdata_getptr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <operator>(</operator><name>CTF_VECTOR</name><operator>|</operator><name>CTF_COMPLEX</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_COMPLEX</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>idx</name> <operator>&amp;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>qual</name> <operator>|=</operator> <name>CTF_CONST</name></expr>;</expr_stmt>  <comment type="block">/* Valarray elements are constant. */</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>idx</name><operator>*</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>sz</name></expr>;</expr_stmt>
      <return>return <expr><name>ct</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tviscdata</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Integer cdata key. */</comment>
    <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cdk</name> <init>= <expr><call><name>cdataV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctk</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>cdk</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ctk</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ctk</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ctk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isinteger</name><argument_list>(<argument><expr><name><name>ctk</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lj_cconv_ct_ct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_INT_PSZ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ctk</name></expr></argument>,
		     <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>idx</name></expr></argument>, <argument><expr><call><name>cdataptr</name><argument_list>(<argument><expr><name>cdk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>integer_key</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* String key. */</comment>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>ofs</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>fct</name> <init>= <expr><call><name>lj_ctype_getfieldq</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofs</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>fct</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>ofs</name></expr>;</expr_stmt>
	<return>return <expr><name>fct</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_iscomplex</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>name</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>qual</name> <operator>|=</operator> <name>CTF_CONST</name></expr>;</expr_stmt>  <comment type="block">/* Complex fields are constant. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'r'</literal> <operator>&amp;&amp;</operator> <call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	  <return>return <expr><name>ct</name></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'i'</literal> <operator>&amp;&amp;</operator> <call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="char">'m'</literal></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name> <operator>+</operator> <operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	  <return>return <expr><name>ct</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name> <operator>==</operator> <name>CTID_CTYPEID</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Allow indexing a (pointer to) struct constructor to get constants. */</comment>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>sct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>CTypeID</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>sct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>sct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>sct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>CTSize</name></type> <name>ofs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>fct</name> <init>= <expr><call><name>lj_ctype_getfield</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sct</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>fct</name> <operator>&amp;&amp;</operator> <call><name>ctype_isconstval</name><argument_list>(<argument><expr><name><name>fct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>fct</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>ct</name> <operator>=</operator> <name>sct</name></expr>;</expr_stmt>  <comment type="block">/* Allow resolving metamethods for constructors, too. */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Automatically perform '-&gt;'. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>cdata_getptr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>collect_attrib</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>qual</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Lookup failed. */</comment>
  <return>return <expr><name>ct</name></expr>;</return>  <comment type="block">/* But return the resolved raw type. */</comment>
</block_content>}</block></function>

<comment type="block">/* -- C data getters ------------------------------------------------------ */</comment>

<comment type="block">/* Get constant value and convert to TValue. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cdata_getconst</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctt</name> <init>= <expr><call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_isinteger</name><argument_list>(<argument><expr><name><name>ctt</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ctt</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;=</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Constants are already zero-extended/sign-extended to 32 bits. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ctt</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setnumV</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Get C data value and convert to TValue. */</comment>
<function><type><name>int</name></type> <name>lj_cdata_get</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>sid</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>ctype_isconstval</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>cdata_getconst</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* No GC step needed. */</comment>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isbitfield</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>lj_cconv_tv_bf</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Get child type of pointer/array/field. */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_ispointer</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sid</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Resolve reference for field. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isref</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>sp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sid</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Skip attributes. */</comment>
  <while>while <condition>(<expr><call><name>ctype_isattrib</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

  <return>return <expr><call><name>lj_cconv_tv_ct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- C data setters ------------------------------------------------------ */</comment>

<comment type="block">/* Convert TValue and set C data value. */</comment>
<function><type><name>void</name></type> <name>lj_cdata_set</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dp</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>CTInfo</name></type> <name>qual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isconstval</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <goto>goto <name>err_const</name>;</goto>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isbitfield</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>info</name></name><operator>|</operator><name>qual</name><operator>)</operator> <operator>&amp;</operator> <name>CTF_CONST</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_const</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_cconv_bf_tv</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Get child type of pointer/array/field. */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_ispointer</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Resolve reference for field. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isref</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dp</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>dp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Skip attributes and collect qualifiers. */</comment>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isattrib</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_attrib</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTA_QUAL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>qual</name> <operator>|=</operator> <name><name>d</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_hassize</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ctype_isvoid</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>info</name></name><operator>|</operator><name>qual</name><operator>)</operator> <operator>&amp;</operator> <name>CTF_CONST</name><operator>)</operator></expr>)</condition> <block>{<block_content>
  <label><name>err_const</name>:</label>
    <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_WRCONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>lj_cconv_ct_tv</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
