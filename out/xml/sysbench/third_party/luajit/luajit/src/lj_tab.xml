<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_tab.c"><comment type="block">/*
** Table handling.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
**
** Major portions taken verbatim or adapted from the Lua interpreter.
** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_tab_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>

<comment type="block">/* -- Object hashing ------------------------------------------------------ */</comment>

<comment type="block">/* Hash values are masked with the table hash mask and used as an index. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>Node</name> <modifier>*</modifier></type><name>hashmask</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>&amp;</operator><name><name>n</name><index>[<expr><name>hash</name> <operator>&amp;</operator> <name><name>t</name><operator>-&gt;</operator><name>hmask</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* String hashes are precomputed when they are interned. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashstr</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>hashmask(t, (s)-&gt;hash)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashlohi</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>lo</name></type></parameter>, <parameter><type><name>hi</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>hashmask((t), hashrot((lo), (hi)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashnum</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>hashlohi((t), (o)-&gt;u32.lo, ((o)-&gt;u32.hi &lt;&lt; 1))</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashgcref</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>hashlohi((t), (uint32_t)gcrefu(r), (uint32_t)(gcrefu(r) &gt;&gt; 32))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashgcref</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>hashlohi((t), gcrefu(r), gcrefu(r) + HASH_BIAS)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Hash an arbitrary key and return its anchor position in the hash table. */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>hashkey</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>tvisint</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>hashstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>strV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>tvisnum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>hashnum</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>tvisbool</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>hashmask</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>boolV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><call><name>hashgcref</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>gcr</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
  <comment type="block">/* Only hash 32 bits of lightuserdata on a 64 bit CPU. Good enough? */</comment>
</block_content>}</block></function>

<comment type="block">/* -- Table creation and destruction -------------------------------------- */</comment>

<comment type="block">/* Create new hash part for table. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>void</name></type> <name>newhpart</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>hbits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>hsize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>hbits</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>hbits</name> <operator>&gt;</operator> <name>LJ_MAX_HBITS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_msg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_TABOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>hsize</name> <operator>=</operator> <literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>hbits</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>lj_mem_newvec</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>hsize</name></expr></argument>, <argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setfreetop</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>hsize</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>=</operator> <name>hsize</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Q: Why all of these copies of t-&gt;hmask, t-&gt;node etc. to local variables?
** A: Because alias analysis for C is _really_ tough.
**    Even state-of-the-art C compilers won't produce good code without this.
*/</comment>

<comment type="block">/* Clear hash part of table. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>void</name></type> <name>clearhpart</name><parameter_list>(<parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>hmask</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>hmask</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Clear array part of table. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>void</name></type> <name>clearapart</name><parameter_list>(<parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>asize</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>array</name> <init>= <expr><call><name>tvref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>asize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/* Create a new table. Note: the slots are not initialized (yet). */</comment>
<function><type><specifier>static</specifier> <name>GCtab</name> <modifier>*</modifier></type><name>newtab</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>asize</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>hbits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
  <comment type="block">/* First try to colocate the array part. */</comment>
  <if_stmt><if>if <condition>(<expr><name>LJ_MAX_COLOSIZE</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>asize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>asize</name> <operator>&lt;=</operator> <name>LJ_MAX_COLOSIZE</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>nilnode</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>GCtab</name></expr></argument>)</argument_list></sizeof> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>GCtab</name> <operator>*</operator><operator>)</operator><call><name>lj_mem_newgco</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>sizetabcolo</name><argument_list>(<argument><expr><name>asize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>gct</name></name> <operator>=</operator> <operator>~</operator><name>LJ_TTAB</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>nomm</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>~</operator><literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>colo</name></name> <operator>=</operator> <operator>(</operator><name>int8_t</name><operator>)</operator><name>asize</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><operator>(</operator><name>TValue</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>t</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GCtab</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name> <operator>=</operator> <name>asize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nilnode</name> <operator>=</operator> <operator>&amp;</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nilnode</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>nilnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>freetop</name></name></expr></argument>, <argument><expr><name>nilnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Otherwise separately allocate the array part. */</comment>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>nilnode</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>lj_mem_newobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>GCtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>gct</name></name> <operator>=</operator> <operator>~</operator><name>LJ_TTAB</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>nomm</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>~</operator><literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>colo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* In case the array allocation fails. */</comment>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nilnode</name> <operator>=</operator> <operator>&amp;</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nilnode</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>nilnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>freetop</name></name></expr></argument>, <argument><expr><name>nilnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>asize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>asize</name> <operator>&gt;</operator> <name>LJ_MAX_ASIZE</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_err_msg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_TABOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><call><name>lj_mem_newvec</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>, <argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name> <operator>=</operator> <name>asize</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>hbits</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>newhpart</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>hbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a new table.
**
** IMPORTANT NOTE: The API differs from lua_createtable()!
**
** The array size is non-inclusive. E.g. asize=128 creates array slots
** for 0..127, but not for 128. If you need slots 1..128, pass asize=129
** (slot 0 is wasted in this case).
**
** The hash size is given in hash bits. hbits=0 means no hash part.
** hbits=1 creates 2 hash slots, hbits=2 creates 4 hash slots and so on.
*/</comment>
<function><type><name>GCtab</name> <modifier>*</modifier></type><name>lj_tab_new</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>asize</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>hbits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>newtab</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>, <argument><expr><name>hbits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>clearapart</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clearhpart</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The API of this function conforms to lua_createtable(). */</comment>
<function><type><name>GCtab</name> <modifier>*</modifier></type><name>lj_tab_new_ah</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>lj_tab_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>a</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>a</name><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><call><name>hsize2hbits</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
<function><type><name>GCtab</name> <modifier>*</modifier> <name>LJ_FASTCALL</name></type> <name>lj_tab_new1</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>ahsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>newtab</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ahsize</name> <operator>&amp;</operator> <literal type="number">0xffffff</literal></expr></argument>, <argument><expr><name>ahsize</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>clearapart</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clearhpart</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Duplicate a table. */</comment>
<function><type><name>GCtab</name> <modifier>*</modifier> <name>LJ_FASTCALL</name></type> <name>lj_tab_dup</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GCtab</name> <modifier>*</modifier></type><name>kt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>asize</name></decl>, <decl><type ref="prev"/><name>hmask</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>newtab</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>kt</name><operator>-&gt;</operator><name>asize</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>kt</name><operator>-&gt;</operator><name>hmask</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>lj_fls</name><argument_list>(<argument><expr><name><name>kt</name><operator>-&gt;</operator><name>hmask</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>kt</name><operator>-&gt;</operator><name>asize</name></name> <operator>==</operator> <name><name>t</name><operator>-&gt;</operator><name>asize</name></name> <operator>&amp;&amp;</operator> <name><name>kt</name><operator>-&gt;</operator><name>hmask</name></name> <operator>==</operator> <name><name>t</name><operator>-&gt;</operator><name>hmask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>nomm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Keys with metamethod names may be present. */</comment>
  <expr_stmt><expr><name>asize</name> <operator>=</operator> <name><name>kt</name><operator>-&gt;</operator><name>asize</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>asize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>array</name> <init>= <expr><call><name>tvref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>karray</name> <init>= <expr><call><name>tvref</name><argument_list>(<argument><expr><name><name>kt</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>asize</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* An inlined loop beats memcpy for &lt; 512 bytes. */</comment>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>asize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>karray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>karray</name></expr></argument>, <argument><expr><name>asize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>hmask</name> <operator>=</operator> <name><name>kt</name><operator>-&gt;</operator><name>hmask</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>hmask</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>knode</name> <init>= <expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>kt</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>d</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>node</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>knode</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setfreetop</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>getfreetop</name><argument_list>(<argument><expr><name>kt</name></expr></argument>, <argument><expr><name>knode</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>d</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>hmask</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>kn</name> <init>= <expr><operator>&amp;</operator><name><name>knode</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>nextnode</name><argument_list>(<argument><expr><name>kn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="block">/* Don't use copyTV here, since it asserts on a copy of a dead key. */</comment>
      <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name><name>kn</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name><name>kn</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>next</name> <operator>==</operator> <name>NULL</name></expr>?</condition><then> <expr><name>next</name></expr> </then><else>: <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>next</name> <operator>+</operator> <name>d</name><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Clear a table. */</comment>
<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>lj_tab_clear</name><parameter_list>(<parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>clearapart</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setfreetop</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clearhpart</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Free a table. */</comment>
<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>lj_tab_free</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_mem_freevec</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>LJ_MAX_COLOSIZE</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>t</name><operator>-&gt;</operator><name>colo</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_mem_freevec</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>tvref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name></expr></argument>, <argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>LJ_MAX_COLOSIZE</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>t</name><operator>-&gt;</operator><name>colo</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_mem_free</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>sizetabcolo</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>colo</name></name> <operator>&amp;</operator> <literal type="number">0x7f</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_mem_freet</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Table resizing ------------------------------------------------------ */</comment>

<comment type="block">/* Resize a table to fit the new array/hash part sizes. */</comment>
<function><type><name>void</name></type> <name>lj_tab_resize</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>asize</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>hbits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>oldnode</name> <init>= <expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>oldasize</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>oldhmask</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>asize</name> <operator>&gt;</operator> <name>oldasize</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Array part grows? */</comment>
    <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>asize</name> <operator>&gt;</operator> <name>LJ_MAX_ASIZE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_err_msg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_TABOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>LJ_MAX_COLOSIZE</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>t</name><operator>-&gt;</operator><name>colo</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="block">/* A colocated array must be separated and copied. */</comment>
      <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>oarray</name> <init>= <expr><call><name>tvref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>lj_mem_newvec</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>, <argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>colo</name></name> <operator>=</operator> <operator>(</operator><name>int8_t</name><operator>)</operator><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>colo</name></name> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Mark as separated (colo &lt; 0). */</comment>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>oldasize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oarray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>array</name> <operator>=</operator> <operator>(</operator><name>TValue</name> <operator>*</operator><operator>)</operator><call><name>lj_mem_realloc</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>tvref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><name>oldasize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>asize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name> <operator>=</operator> <name>asize</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>oldasize</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>asize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* Clear newly allocated slots. */</comment>
      <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Create new (empty) hash part. */</comment>
  <if_stmt><if>if <condition>(<expr><name>hbits</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>newhpart</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>hbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clearhpart</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>nilnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>freetop</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>nilnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>asize</name> <operator>&lt;</operator> <name>oldasize</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Array part shrinks? */</comment>
    <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>array</name> <init>= <expr><call><name>tvref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name> <operator>=</operator> <name>asize</name></expr>;</expr_stmt>  <comment type="block">/* Note: This 'shrinks' even colocated arrays. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>asize</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>oldasize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* Reinsert old array values. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lj_tab_setinth</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <comment type="block">/* Physically shrink only separated arrays. */</comment>
    <if_stmt><if>if <condition>(<expr><name>LJ_MAX_COLOSIZE</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>t</name><operator>-&gt;</operator><name>colo</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><call><name>lj_mem_realloc</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>array</name></expr></argument>,
	      <argument><expr><name>oldasize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>asize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>oldhmask</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Reinsert pairs from old hash part. */</comment>
    <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>oldhmask</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>&amp;</operator><name><name>oldnode</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lj_tab_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>g</name> <operator>=</operator> <call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_mem_freevec</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>oldnode</name></expr></argument>, <argument><expr><name>oldhmask</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>countint</name><parameter_list>(<parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>bins</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>tvisint</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tvisnum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>nk</name> <init>= <expr><call><name>numV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>lj_num2int</name><argument_list>(<argument><expr><name>nk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>k</name> <operator>&lt;</operator> <name>LJ_MAX_ASIZE</name> <operator>&amp;&amp;</operator> <name>nk</name> <operator>==</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>bins</name><index>[<expr><operator>(</operator><ternary><condition><expr><name>k</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><call><name>lj_fls</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>k</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>countarray</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>bins</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>na</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for <control>(<init><expr><name>na</name> <operator>=</operator> <name>i</name> <operator>=</operator> <name>b</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>b</name> <operator>&lt;</operator> <name>LJ_MAX_ABITS</name></expr>;</condition> <incr><expr><name>b</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>top</name> <init>= <expr><literal type="number">2u</literal> <operator>&lt;&lt;</operator> <name>b</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>top</name> <operator>&gt;=</operator> <name><name>t</name><operator>-&gt;</operator><name>asize</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>top</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>asize</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>top</name></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>tvref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>top</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>bins</name><index>[<expr><name>b</name></expr>]</index></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>na</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>na</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>counthash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>bins</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>narray</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>total</name></decl>, <decl><type ref="prev"/><name>na</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>hmask</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>total</name> <operator>=</operator> <name>na</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>hmask</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>na</name> <operator>+=</operator> <call><name>countint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>bins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>total</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>narray</name> <operator>+=</operator> <name>na</name></expr>;</expr_stmt>
  <return>return <expr><name>total</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>bestasize</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name><name>bins</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>narray</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>b</name></decl>, <decl><type ref="prev"/><name>sum</name></decl>, <decl><type ref="prev"/><name>na</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nn</name> <init>= <expr><operator>*</operator><name>narray</name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>b</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>sum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><literal type="number">2</literal><operator>*</operator><name>nn</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1u</literal><operator>&lt;&lt;</operator><name>b</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>sum</name> <operator>!=</operator> <name>nn</name></expr>;</condition> <incr><expr><name>b</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name><name>bins</name><index>[<expr><name>b</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name>sum</name> <operator>+=</operator> <name><name>bins</name><index>[<expr><name>b</name></expr>]</index></name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><literal type="number">1u</literal><operator>&lt;&lt;</operator><name>b</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <operator>(</operator><literal type="number">2u</literal><operator>&lt;&lt;</operator><name>b</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>na</name> <operator>=</operator> <name>sum</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt></block_content></block></for>
  <expr_stmt><expr><operator>*</operator><name>narray</name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
  <return>return <expr><name>na</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rehashtab</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>ek</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name><name>bins</name><index>[<expr><name>LJ_MAX_ABITS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>total</name></decl>, <decl><type ref="prev"/><name>asize</name></decl>, <decl><type ref="prev"/><name>na</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LJ_MAX_ABITS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bins</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><name>asize</name> <operator>=</operator> <call><name>countarray</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>bins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>total</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>asize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>total</name> <operator>+=</operator> <call><name>counthash</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>bins</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>asize</name> <operator>+=</operator> <call><name>countint</name><argument_list>(<argument><expr><name>ek</name></expr></argument>, <argument><expr><name>bins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>na</name> <operator>=</operator> <call><name>bestasize</name><argument_list>(<argument><expr><name>bins</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>total</name> <operator>-=</operator> <name>na</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_tab_resize</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>, <argument><expr><call><name>hsize2hbits</name><argument_list>(<argument><expr><name>total</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<function><type><name>void</name></type> <name>lj_tab_rehash</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>rehashtab</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>niltv</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>lj_tab_reasize</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>nasize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_tab_resize</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>nasize</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>lj_fls</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Table getters ------------------------------------------------------- */</comment>

<function><type><name>cTValue</name> <modifier>*</modifier> <name>LJ_FASTCALL</name></type> <name>lj_tab_getinth</name><parameter_list>(<parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>k</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>k</name><operator>.</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><name>key</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>hashnum</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tvisnum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>n</name></name> <operator>==</operator> <name><name>k</name><operator>.</operator><name>n</name></name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block> while <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>nextnode</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>;</do>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>cTValue</name> <modifier>*</modifier></type><name>lj_tab_getstr</name><parameter_list>(<parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>hashstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <do>do <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>key</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block> while <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>nextnode</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>;</do>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>cTValue</name> <modifier>*</modifier></type><name>lj_tab_get</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>lj_tab_getstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>strV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>tv</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>tv</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisint</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>lj_tab_getint</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>intV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>tv</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>tv</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisnum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>nk</name> <init>= <expr><call><name>numV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>lj_num2int</name><argument_list>(<argument><expr><name>nk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nk</name> <operator>==</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>lj_tab_getint</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>tv</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>tv</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <goto>goto <name>genlookup</name>;</goto>  <comment type="block">/* Else use the generic lookup. */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
  <label><name>genlookup</name>:</label>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>hashkey</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>lj_obj_equal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>nextnode</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>niltv</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Table setters ------------------------------------------------------- */</comment>

<comment type="block">/* Insert new key. Use Brent's variation to optimize the chain length. */</comment>
<function><type><name>TValue</name> <modifier>*</modifier></type><name>lj_tab_newkey</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>hashkey</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>nodebase</name> <init>= <expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>collide</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>freenode</name> <init>= <expr><call><name>getfreetop</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>nodebase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>freenode</name> <operator>&gt;=</operator> <name>nodebase</name> <operator>&amp;&amp;</operator> <name>freenode</name> <operator>&lt;=</operator> <name>nodebase</name><operator>+</operator><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>freenode</name> <operator>==</operator> <name>nodebase</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* No free node found? */</comment>
	<expr_stmt><expr><call><name>rehashtab</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Rehash table. */</comment>
	<return>return <expr><call><name>lj_tab_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* Retry key insertion. */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>--</operator><name>freenode</name><operator>)</operator><operator>-&gt;</operator><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
    <expr_stmt><expr><call><name>setfreetop</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>nodebase</name></expr></argument>, <argument><expr><name>freenode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>freenode</name> <operator>!=</operator> <operator>&amp;</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nilnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>collide</name> <operator>=</operator> <call><name>hashkey</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>collide</name> <operator>!=</operator> <name>n</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Colliding node not the main node? */</comment>
      <while>while <condition>(<expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>collide</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Find predecessor. */</comment>
	<expr_stmt><expr><name>collide</name> <operator>=</operator> <call><name>nextnode</name><argument_list>(<argument><expr><name>collide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
      <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>collide</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>freenode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Relink chain. */</comment>
      <comment type="block">/* Copy colliding node into free node and free main node. */</comment>
      <expr_stmt><expr><name><name>freenode</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>freenode</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>freenode</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Rechain pseudo-resurrected string keys with colliding hashes. */</comment>
      <while>while <condition>(<expr><call><name>nextnode</name><argument_list>(<argument><expr><name>freenode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>nn</name> <init>= <expr><call><name>nextnode</name><argument_list>(<argument><expr><name>freenode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nn</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>hashkey</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nn</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>n</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>freenode</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>nn</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>nn</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>nn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <comment type="block">/*
	  ** Rechaining a resurrected string key creates a new dilemma:
	  ** Another string key may have originally been resurrected via
	  ** _any_ of the previous nodes as a chain anchor. Including
	  ** a node that had to be moved, which makes them unreachable.
	  ** It's not feasible to check for all previous nodes, so rechain
	  ** any string key that's currently in a non-main positions.
	  */</comment>
	  <while>while <condition>(<expr><operator>(</operator><name>nn</name> <operator>=</operator> <call><name>nextnode</name><argument_list>(<argument><expr><name>freenode</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nn</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	      <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>mn</name> <init>= <expr><call><name>hashkey</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nn</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	      <if_stmt><if>if <condition>(<expr><name>mn</name> <operator>!=</operator> <name>freenode</name> <operator>&amp;&amp;</operator> <name>mn</name> <operator>!=</operator> <name>nn</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>freenode</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>nn</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nn</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>mn</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>mn</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>nn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      </block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>freenode</name> <operator>=</operator> <name>nn</name></expr>;</expr_stmt>
	      </block_content>}</block></else></if_stmt>
	    </block_content>}</block></if> <else>else <block>{<block_content>
	      <expr_stmt><expr><name>freenode</name> <operator>=</operator> <name>nn</name></expr>;</expr_stmt>
	    </block_content>}</block></else></if_stmt>
	  </block_content>}</block></while>
	  <break>break;</break>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><name>freenode</name> <operator>=</operator> <name>nn</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Otherwise use free node. */</comment>
      <expr_stmt><expr><call><name>setmrefr</name><argument_list>(<argument><expr><name><name>freenode</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Insert into chain. */</comment>
      <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>freenode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <name>freenode</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>u64</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>u64</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><call><name>tvismzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>u64</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_gc_anybarriert</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TValue</name> <modifier>*</modifier></type><name>lj_tab_setinth</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>k</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>k</name><operator>.</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><name>key</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>hashnum</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tvisnum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>n</name></name> <operator>==</operator> <name><name>k</name><operator>.</operator><name>n</name></name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block> while <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>nextnode</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>;</do>
  <return>return <expr><call><name>lj_tab_newkey</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TValue</name> <modifier>*</modifier></type><name>lj_tab_setstr</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>k</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>hashstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <do>do <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>key</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block> while <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>nextnode</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>;</do>
  <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>lj_tab_newkey</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TValue</name> <modifier>*</modifier></type><name>lj_tab_set</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>nomm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Invalidate negative metamethod cache. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>lj_tab_setstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>strV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisint</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>lj_tab_setint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>intV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisnum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>nk</name> <init>= <expr><call><name>numV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>lj_num2int</name><argument_list>(<argument><expr><name>nk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nk</name> <operator>==</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>lj_tab_setint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tvisnan</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_err_msg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_NANIDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Else use the generic lookup. */</comment>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisnil</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lj_err_msg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_NILIDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>hashkey</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>lj_obj_equal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block> while <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>nextnode</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>;</do>
  <return>return <expr><call><name>lj_tab_newkey</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Table traversal ----------------------------------------------------- */</comment>

<comment type="block">/* Get the traversal index of a key. */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>keyindex</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>tmp</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tvisint</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>intV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>k</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>asize</name></name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>k</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Array key indexes: [0..t-&gt;asize-1] */</comment>
    <expr_stmt><expr><call><name>setnumV</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>key</name> <operator>=</operator> <operator>&amp;</operator><name>tmp</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisnum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>nk</name> <init>= <expr><call><name>numV</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>lj_num2int</name><argument_list>(<argument><expr><name>nk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>k</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>asize</name></name> <operator>&amp;&amp;</operator> <name>nk</name> <operator>==</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>k</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Array key indexes: [0..t-&gt;asize-1] */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>hashkey</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <do>do <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>lj_obj_equal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name> <operator>+</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>n</name> <operator>-</operator> <call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Hash key indexes: [t-&gt;asize..t-&gt;asize+t-&gt;nmask] */</comment>
    </block_content>}</block> while <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>nextnode</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>;</do>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>u32</name><operator>.</operator><name>hi</name></name> <operator>==</operator> <literal type="number">0xfffe7fff</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* ITERN was despecialized while running. */</comment>
      <return>return <expr><name><name>key</name><operator>-&gt;</operator><name>u32</name><operator>.</operator><name>lo</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_err_msg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_NEXTIDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* unreachable */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>~</operator><literal type="number">0u</literal></expr>;</return>  <comment type="block">/* A nil key starts the traversal. */</comment>
</block_content>}</block></function>

<comment type="block">/* Advance to the next step in a table traversal. */</comment>
<function><type><name>int</name></type> <name>lj_tab_next</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><call><name>keyindex</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* Find predecessor key index. */</comment>
  <for>for <control>(<init><expr><name>i</name><operator>++</operator></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>asize</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* First traverse the array keys. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><call><name>arrayslot</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>key</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>arrayslot</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt></block_content></block></for>
  <for>for <control>(<init><expr><name>i</name> <operator>-=</operator> <name><name>t</name><operator>-&gt;</operator><name>asize</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>t</name><operator>-&gt;</operator><name>hmask</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* Then traverse the hash keys. */</comment>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>&amp;</operator><call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>key</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* End of traversal. */</comment>
</block_content>}</block></function>

<comment type="block">/* -- Table length calculation -------------------------------------------- */</comment>

<comment type="block">/* Compute table length. Slow path with mixed array/hash lookups. */</comment>
<function><type><name>LJ_NOINLINE</name> <specifier>static</specifier> <name>MSize</name></type> <name>tab_len_slow</name><parameter_list>(<parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>hi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>lo</name> <init>= <expr><name>hi</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>hi</name><operator>++</operator></expr>;</expr_stmt>
  <comment type="block">/* Widening search for an upper bound. */</comment>
  <while>while <condition>(<expr><operator>(</operator><name>tv</name> <operator>=</operator> <call><name>lj_tab_getint</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>hi</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>lo</name> <operator>=</operator> <name>hi</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>hi</name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>hi</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>INT_MAX</name><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Punt and do a linear search. */</comment>
      <expr_stmt><expr><name>lo</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <while>while <condition>(<expr><operator>(</operator><name>tv</name> <operator>=</operator> <call><name>lj_tab_getint</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>lo</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lo</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <return>return <expr><operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><name>lo</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <comment type="block">/* Binary search to find a non-nil to nil transition. */</comment>
  <while>while <condition>(<expr><name>hi</name> <operator>-</operator> <name>lo</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>mid</name> <init>= <expr><operator>(</operator><name>lo</name><operator>+</operator><name>hi</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tvb</name> <init>= <expr><call><name>lj_tab_getint</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>tvb</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name>tvb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><operator>(</operator><name>MSize</name><operator>)</operator><name>lo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compute table length. Fast path. */</comment>
<function><type><name>MSize</name> <name>LJ_FASTCALL</name></type> <name>lj_tab_len</name><parameter_list>(<parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>hi</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>asize</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>hi</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hi</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <comment type="block">/* In a growing array the last array element is very likely nil. */</comment>
  <if_stmt><if>if <condition>(<expr><name>hi</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>LJ_LIKELY</name><argument_list>(<argument><expr><call><name>tvisnil</name><argument_list>(<argument><expr><call><name>arrayslot</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Binary search to find a non-nil to nil transition in the array. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>lo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>hi</name> <operator>-</operator> <name>lo</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>mid</name> <init>= <expr><operator>(</operator><name>lo</name><operator>+</operator><name>hi</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>tvisnil</name><argument_list>(<argument><expr><call><name>arrayslot</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><operator>(</operator><name>MSize</name><operator>)</operator><name>lo</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Without a hash part, there's an implicit nil after the last element. */</comment>
  <return>return <expr><ternary><condition><expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name></expr> ?</condition><then> <expr><call><name>tab_len_slow</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>(</operator><name>MSize</name><operator>)</operator><name>hi</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
<comment type="block">/* Verify hinted table length or compute it. */</comment>
<function><type><name>MSize</name> <name>LJ_FASTCALL</name></type> <name>lj_tab_len_hint</name><parameter_list>(<parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>asize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>asize</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>arrayslot</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name>hint</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>asize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tvisnil</name><argument_list>(<argument><expr><name>tv</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>MSize</name><operator>)</operator><name>hint</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>hint</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;=</operator> <name>asize</name> <operator>&amp;&amp;</operator> <call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>(</operator><name>MSize</name><operator>)</operator><name>hint</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>lj_tab_len</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
