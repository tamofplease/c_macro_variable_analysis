<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_ffrecord.c"><comment type="block">/*
** Fast function call recorder.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_ffrecord_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_str.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_frame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_bc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ircall.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_iropt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_record.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ffrecord.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_crecord.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_vm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strfmt.h"</cpp:file></cpp:include>

<comment type="block">/* Some local macros to save typing. Undef'd at the end. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IR</name><parameter_list>(<parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>			<cpp:value>(&amp;J-&gt;cur.ir[(ref)])</cpp:value></cpp:define>

<comment type="block">/* Pass IR on to next optimization in chain (FOLD). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>emitir</name><parameter_list>(<parameter><type><name>ot</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(lj_ir_set(J, (ot), (a), (b)), lj_opt_fold(J))</cpp:value></cpp:define>

<comment type="block">/* -- Fast function recording handlers ------------------------------------ */</comment>

<comment type="block">/* Conventions for fast function call handlers:
**
** The argument slots start at J-&gt;base[0]. All of them are guaranteed to be
** valid and type-specialized references. J-&gt;base[J-&gt;maxslot] is set to 0
** as a sentinel. The runtime argument values start at rd-&gt;argv[0].
**
** In general fast functions should check for presence of all of their
** arguments and for the correct argument types. Some simplifications
** are allowed if the interpreter throws instead. But even if recording
** is aborted, the generated IR must be consistent (no zero-refs).
**
** The number of results in rd-&gt;nres is set to 1. Handlers that return
** a different number of results need to override it. A negative value
** prevents return processing (e.g. for pending calls).
**
** Results need to be stored starting at J-&gt;base[0]. Return processing
** moves them to the right slots later.
**
** The per-ffid auxiliary data is the value of the 2nd part of the
** LJLIB_REC() annotation. This allows handling similar functionality
** in a common handler.
*/</comment>

<comment type="block">/* Type of handler to record a fast function. */</comment>
<typedef>typedef <function_decl><type><name>void</name></type> (<name>LJ_FASTCALL</name> <modifier>*</modifier><name>RecordFunc</name>)<parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* Get runtime value of int argument. */</comment>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>argv2int</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_strscan_numberobj</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><ternary><condition><expr><call><name>tvisint</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>intV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>lj_num2int</name><argument_list>(<argument><expr><call><name>numV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get runtime value of string argument. */</comment>
<function><type><specifier>static</specifier> <name>GCstr</name> <modifier>*</modifier></type><name>argv2str</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><call><name>tvisstr</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>strV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnumber</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>lj_strfmt_number</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>s</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return number of results wanted by caller. */</comment>
<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type> <name>results_wanted</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>frame_islua</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><call><name>bc_b</name><argument_list>(<argument><expr><call><name>frame_pc</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Trace stitching: add continuation below frame to start a new trace. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recff_stitch</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ASMFunction</name></type> <name>cont</name> <init>= <expr><name>lj_cont_stitch</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>nslot</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LJ_FR2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>nframe</name> <init>= <expr><name>base</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LJ_FR2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>frame_pc</name><argument_list>(<argument><expr><name>base</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>pframe</name> <init>= <expr><call><name>frame_prevl</name><argument_list>(<argument><expr><name>base</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Move func + args up in Lua stack and insert continuation. */</comment>
  <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setframe_ftsz</name><argument_list>(<argument><expr><name>nframe</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>nframe</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pframe</name><operator>)</operator> <operator>+</operator> <name>FRAME_CONT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setcont</name><argument_list>(<argument><expr><name>base</name><operator>-</operator><name>LJ_FR2</name></expr></argument>, <argument><expr><name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setframe_pc</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name>base</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Incorrect, but rec_check_slots() won't run anymore. */</comment>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name>LJ_FR2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name>LJ_FR2</name></expr>;</expr_stmt>

  <comment type="block">/* Ditto for the IR. */</comment>
  <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TRef</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>TREF_FRAME</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_k64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IR_KNUM</name></expr></argument>, <argument><expr><call><name>u64ptr</name><argument_list>(<argument><expr><call><name>contptr</name><argument_list>(<argument><expr><name>cont</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_k64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IR_KNUM</name></expr></argument>, <argument><expr><call><name>u64ptr</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>|</operator> <name>TREF_CONT</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>contptr</name><argument_list>(<argument><expr><name>cont</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>|</operator> <name>TREF_CONT</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>ktrace</name></name> <operator>=</operator> <call><name>tref_ref</name><argument_list>(<argument><expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_ktrace</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name>LJ_FR2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name>LJ_FR2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name><operator>++</operator></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>lj_record_stop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRLINK_STITCH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Undo Lua stack changes. */</comment>
  <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setframe_pc</name><argument_list>(<argument><expr><name>base</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>-=</operator> <literal type="number">2</literal> <operator>+</operator> <name>LJ_FR2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-=</operator> <literal type="number">2</literal> <operator>+</operator> <name>LJ_FR2</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Fallback handler for fast functions that are not recorded (yet). */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_nyi</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name> <operator>&lt;</operator> <operator>(</operator><name>IRRef</name><operator>)</operator><name><name>J</name><operator>-&gt;</operator><name>param</name><index>[<expr><name>JIT_P_minstitch</name></expr>]</index></name> <operator>+</operator> <name>REF_BASE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lj_trace_err_info</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_TRACEUV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* Can only stitch from Lua call. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>&amp;&amp;</operator> <call><name>frame_islua</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>BCOp</name></type> <name>op</name> <init>= <expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><call><name>frame_pc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="block">/* Stitched trace cannot start with *M op with variable # of args. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>op</name> <operator>==</operator> <name>BC_CALLM</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>BC_CALLMT</name> <operator>||</operator>
	    <name>op</name> <operator>==</operator> <name>BC_RETM</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>BC_TSETM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<switch>switch <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>ffid</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>FF_error</name></expr>:</case>
	<case>case <expr><name>FF_debug_sethook</name></expr>:</case>
	<case>case <expr><name>FF_jit_flush</name></expr>:</case>
	  <break>break;</break>  <comment type="block">/* Don't stitch across special builtins. */</comment>
	<default>default:</default>
	  <expr_stmt><expr><call><name>recff_stitch</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Use trace stitching. */</comment>
	  <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	  <return>return;</return>
	</block_content>}</block></switch>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Otherwise stop trace and return to interpreter. */</comment>
    <expr_stmt><expr><call><name>lj_record_stop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRLINK_RETURN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Fallback handler for unsupported variants of fast functions. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>recff_nyiu</name></cpp:macro>	<cpp:value>recff_nyi</cpp:value></cpp:define>

<comment type="block">/* Must stop the trace for classic C functions with arbitrary side-effects. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>recff_c</name></cpp:macro>		<cpp:value>recff_nyi</cpp:value></cpp:define>

<comment type="block">/* Emit BUFHDR for the global temporary buffer. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>recff_bufhdr</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFHDR</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tmpbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IRBUFHDR_RESET</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Base library fast functions ----------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_assert</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Arguments already specialized. The interpreter throws for nil/false. */</comment>
  <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>;</expr_stmt>  <comment type="block">/* Pass through all arguments. */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_type</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Arguments already specialized. Result is a constant string. Neat, huh? */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>t</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tvisnumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>~</operator><name>LJ_TNUMX</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_GC64</name> <operator>&amp;&amp;</operator> <call><name>tvislightud</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>~</operator><name>LJ_TLIGHTUD</name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>~</operator><call><name>itype</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>strV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>upvalue</name><index>[<expr><name>t</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_getmetatable</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tr</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>RecordIndex</name></type> <name>ix</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>tabv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name>MM_metatable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>.</operator><name>mobj</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>.</operator><name>mt</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: Interpreter will throw. */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_setmetatable</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>mt</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_istab</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>tref_istab</name><argument_list>(<argument><expr><name>mt</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>mt</name> <operator>&amp;&amp;</operator> <call><name>tref_isnil</name><argument_list>(<argument><expr><name>mt</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>fref</name></decl>, <decl><type ref="prev"/><name>mtref</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RecordIndex</name></type> <name>ix</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>tabv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name>MM_metatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Guard for no __metatable. */</comment>
    <expr_stmt><expr><name>fref</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FREF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFL_TAB_META</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mtref</name> <operator>=</operator> <ternary><condition><expr><call><name>tref_isnil</name><argument_list>(<argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>lj_ir_knull</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>mt</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FSTORE</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fref</name></expr></argument>, <argument><expr><name>mtref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isnil</name><argument_list>(<argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_TBAR</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: Interpreter will throw. */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_rawget</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RecordIndex</name></type> <name>ix</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_istab</name><argument_list>(<argument><expr><name><name>ix</name><operator>.</operator><name>tab</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ix</name><operator>.</operator><name>key</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>idxchain</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>tabv</name></name></expr></argument>, <argument><expr><call><name>tabV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>keyv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_record_idx</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: Interpreter will throw. */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_rawset</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RecordIndex</name></type> <name>ix</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_istab</name><argument_list>(<argument><expr><name><name>ix</name><operator>.</operator><name>tab</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ix</name><operator>.</operator><name>key</name></name> <operator>&amp;&amp;</operator> <name><name>ix</name><operator>.</operator><name>val</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>idxchain</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>tabv</name></name></expr></argument>, <argument><expr><call><name>tabV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>keyv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>valv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_record_idx</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Pass through table at J-&gt;base[0] as result. */</comment>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: Interpreter will throw. */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_rawequal</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tra</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trb</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tra</name> <operator>&amp;&amp;</operator> <name>trb</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>diff</name> <init>= <expr><call><name>lj_record_objcmp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>tra</name></expr></argument>, <argument><expr><name>trb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>diff</name></expr> ?</condition><then> <expr><name>TREF_FALSE</name></expr> </then><else>: <expr><name>TREF_TRUE</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: Interpreter will throw. */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_52</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_rawlen</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isstr</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFL_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>tref_istab</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ALEN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>TREF_NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <comment type="block">/* else: Interpreter will throw. */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Determine mode of select() call. */</comment>
<function><type><name>int32_t</name></type> <name>lj_ffrecord_select_mode</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>tr</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isstr</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><call><name>strVdata</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* select('#', ...) */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>strV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>trptr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_STRREF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TRef</name></type> <name>trchar</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>IRT_U8</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trptr</name></expr></argument>, <argument><expr><name>IRXLOAD_READONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trchar</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* select(n, ...) */</comment>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>start</name> <init>= <expr><call><name>argv2int</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* A bit misleading. */</comment>
    <return>return <expr><name>start</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_select</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tr</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>start</name> <init>= <expr><call><name>lj_ffrecord_select_mode</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* select('#', ...) */</comment>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_isk</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* select(k, ...) */</comment>
      <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>start</name> <operator>&gt;</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <name>n</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name> <operator>-</operator> <name>start</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>start</name><operator>+</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
      </block_content>}</block></if></if_stmt>  <comment type="block">/* else: Interpreter will throw. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>recff_nyiu</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: Interpreter will throw. */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_tonumber</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>base</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tr</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tref_isnil</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isk</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name> <operator>!=</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>recff_nyiu</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isnumber_str</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isstr</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TValue</name></type> <name>tmp</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_strscan_num</name><argument_list>(<argument><expr><call><name>strV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>recff_nyiu</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Would need an inverted STRTO for this case. */</comment>
	<return>return;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_STRTO</name></expr></argument>, <argument><expr><name>IRT_NUM</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_iscdata</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lj_crecord_tonumber</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TValue</name> <modifier>*</modifier></type><name>recff_metacall_cp</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>lua_CFunction</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name> <init>= <expr><operator>(</operator><name>jit_State</name> <operator>*</operator><operator>)</operator><name>ud</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_record_tailcall</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>recff_metacall</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>, <parameter><decl><type><name>MMS</name></type> <name>mm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RecordIndex</name></type> <name>ix</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>tabv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Has metamethod? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>errcode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TValue</name></type> <name>argv0</name></decl>;</decl_stmt>
    <comment type="block">/* Temporarily insert metamethod below object. */</comment>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr>]</index></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>.</operator><name>mobj</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argv0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>mobjv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Need to protect lj_record_tailcall because it may throw. */</comment>
    <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>lj_vm_cpcall</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>recff_metacall_cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Always undo Lua stack changes to avoid confusing the interpreter. */</comment>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>errcode</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_err_throw</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Propagate errors. */</comment>
    <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Pending call. */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Tailcalled to metamethod. */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_tostring</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isstr</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Ignore __tostring in the string base metatable. */</comment>
    <comment type="block">/* Pass on result in J-&gt;base[0]. */</comment>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tr</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>recff_metacall</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>, <argument><expr><name>MM_tostring</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isnumber</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_TOSTR</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>,
			  <argument><expr><ternary><condition><expr><call><name>tref_isnum</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRTOSTR_NUM</name></expr> </then><else>: <expr><name>IRTOSTR_INT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_ispri</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>lj_strfmt_obj</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>recff_nyiu</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_ipairs_aux</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RecordIndex</name></type> <name>ix</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_istab</name><argument_list>(<argument><expr><name><name>ix</name><operator>.</operator><name>tab</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* No support for string coercion. */</comment>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>keyv</name></name></expr></argument>, <argument><expr><call><name>numberVint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>tabv</name></name></expr></argument>, <argument><expr><call><name>tabV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>idxchain</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>key</name></name> <operator>=</operator> <call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>.</operator><name>key</name></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_record_idx</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <ternary><condition><expr><call><name>tref_isnil</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: Interpreter will throw. */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_xpairs</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>LJ_52</name> <operator>||</operator> <operator>(</operator><name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <call><name>tref_iscdata</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
	<call><name>recff_metacall</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>, <argument><expr><name>MM_pairs</name> <operator>+</operator> <name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tref_istab</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_kfunc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>funcV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>upvalue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr> ?</condition><then> <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>TREF_NIL</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>  <comment type="block">/* else: Interpreter will throw. */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_pcall</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
    <comment type="block">/* Shift function arguments up. */</comment>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TRef</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>lj_record_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Pending call. */</comment>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: Interpreter will throw. */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TValue</name> <modifier>*</modifier></type><name>recff_xpcall_cp</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>lua_CFunction</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name> <init>= <expr><operator>(</operator><name>jit_State</name> <operator>*</operator><operator>)</operator><name>ud</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_record_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_xpcall</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TValue</name></type> <name>argv0</name></decl>, <decl><type ref="prev"/><name>argv1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>errcode</name></decl>;</decl_stmt>
    <comment type="block">/* Swap function and traceback. */</comment>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argv0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argv1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argv1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
    <comment type="block">/* Shift function arguments up. */</comment>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TRef</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Need to protect lj_record_call because it may throw. */</comment>
    <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>lj_vm_cpcall</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>recff_xpcall_cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Always undo Lua stack swap to avoid confusing the interpreter. */</comment>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argv1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>errcode</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_err_throw</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Propagate errors. */</comment>
    <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Pending call. */</comment>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: Interpreter will throw. */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_getfenv</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Only support getfenv(0) for now. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isint</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tref_isk</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trl</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_LREF</name></expr></argument>, <argument><expr><name>IRT_THREAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trl</name></expr></argument>, <argument><expr><name>IRFL_THREAD_ENV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>recff_nyiu</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Math library fast functions ----------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_math_abs</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_ir_tonum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_ABS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_ksimd</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_KSIMD_ABS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record rounding functions math.floor and math.ceil. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_math_round</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Pass through integers unmodified. */</comment>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_FPMATH</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lj_ir_tonum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Result is integral (or NaN/Inf), but may not fit an int32_t. */</comment>
    <if_stmt><if>if <condition>(<expr><name>LJ_DUALNUM</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Try to narrow using a guarded conversion to int. */</comment>
      <decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name> <init>= <expr><call><name>lj_vm_foldfpm</name><argument_list>(<argument><expr><call><name>numberVnum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><call><name>lj_num2int</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRCONV_INT_NUM</name><operator>|</operator><name>IRCONV_CHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Record unary math.* functions, mapped to IR_FPMATH opcode. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_math_unary</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_FPMATH</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lj_ir_tonum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record math.log. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_math_log</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_ir_tonum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUAJIT_NO_LOG2</name></cpp:ifdef>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>fpm</name> <init>= <expr><name>IRFPM_LOG</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>fpm</name> <init>= <expr><name>IRFPM_LOG2</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trb</name> <init>= <expr><call><name>lj_ir_tonum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_FPMATH</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>trb</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_FPMATH</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trb</name></expr></argument>, <argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>trb</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_DIV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lj_ir_knum_one</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_MUL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>trb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_FPMATH</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFPM_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record math.atan2. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_math_atan2</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_ir_tonum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr2</name> <init>= <expr><call><name>lj_ir_tonum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_atan2</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record math.ldexp. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_math_ldexp</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_ir_tonum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr2</name> <init>= <expr><call><name>lj_ir_tonum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr2</name> <init>= <expr><call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_LDEXP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_math_call</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_ir_tonum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_CALLN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_math_pow</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_opt_narrow_pow</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				 <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_math_minmax</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_ir_tonumber</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>op</name> <init>= <expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr2</name> <init>= <expr><call><name>lj_ir_tonumber</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><name>IRT_INT</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tref_isinteger</name><argument_list>(<argument><expr><name>tr2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>tr2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tr2</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr2</name></expr></argument>, <argument><expr><name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <name>IRT_NUM</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_math_random</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCudata</name> <modifier>*</modifier></type><name>ud</name> <init>= <expr><call><name>udataV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>upvalue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name></decl>, <decl><type ref="prev"/><name>one</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_ir_kgc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>ud</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IRT_UDATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Prevent collection. */</comment>
  <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_lj_math_random_step</name></expr></argument>, <argument><expr><call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>uddata</name><argument_list>(<argument><expr><name>ud</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>one</name> <operator>=</operator> <call><name>lj_ir_knum_one</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_SUB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr1</name> <init>= <expr><call><name>lj_ir_tonum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* d = floor(d*(r2-r1+1.0)) + r1 */</comment>
      <decl_stmt><decl><type><name>TRef</name></type> <name>tr2</name> <init>= <expr><call><name>lj_ir_tonum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>tr2</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_SUB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr2</name></expr></argument>, <argument><expr><name>tr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tr2</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr2</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_MUL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_FPMATH</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFPM_FLOOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* d = floor(d*r1) + 1.0 */</comment>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_MUL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_FPMATH</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFPM_FLOOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Bit library fast functions ------------------------------------------ */</comment>

<comment type="block">/* Record bit.tobit. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_bit_tobit</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>tref_iscdata</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>recff_bit64_tobit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return;</return> </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_opt_narrow_tobit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record unary bit.bnot, bit.bswap. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_bit_unary</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>recff_bit64_unary</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lj_opt_narrow_tobit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record N-ary bit.band, bit.bor, bit.bxor. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_bit_nary</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>recff_bit64_nary</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_opt_narrow_tobit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>ot</name> <init>= <expr><call><name>IRTI</name><argument_list>(<argument><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><name>ot</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_opt_narrow_tobit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
  </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* Record bit shifts. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_bit_shift</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>recff_bit64_shift</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_opt_narrow_tobit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tsh</name> <init>= <expr><call><name>lj_opt_narrow_tobit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IROp</name></type> <name>op</name> <init>= <expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><ternary><condition><expr><name>op</name> <operator>&lt;</operator> <name>IR_BROL</name></expr> ?</condition><then> <expr><name>LJ_TARGET_MASKSHIFT</name></expr> </then><else>: <expr><name>LJ_TARGET_MASKROT</name></expr></else></ternary><operator>)</operator> <operator>&amp;&amp;</operator>
	<operator>!</operator><call><name>tref_isk</name><argument_list>(<argument><expr><name>tsh</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>tsh</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BAND</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tsh</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LJ_TARGET_UNIFYROT</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <operator>(</operator><ternary><condition><expr><name>LJ_TARGET_UNIFYROT</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>IR_BROR</name></expr> </then><else>: <expr><name>IR_BROL</name></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <ternary><condition><expr><name>LJ_TARGET_UNIFYROT</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>IR_BROL</name></expr> </then><else>: <expr><name>IR_BROR</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name>tsh</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_NEG</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tsh</name></expr></argument>, <argument><expr><name>tsh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tsh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_bit_tohex</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <decl_stmt><decl><type><name>TRef</name></type> <name>hdr</name> <init>= <expr><call><name>recff_bufhdr</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>recff_bit64_tohex</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFSTR</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>recff_nyiu</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Don't bother working around this NYI. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* -- String library fast functions --------------------------------------- */</comment>

<comment type="block">/* Specialize to relative starting position for string. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>recff_string_start</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>tr</name></decl></parameter>,
			       <parameter><decl><type><name>TRef</name></type> <name>trlen</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>tr0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>start</name> <init>= <expr><operator>*</operator><name>st</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_LT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trlen</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <name>start</name> <operator>+</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><ternary><condition><expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_LT</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_GE</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <name>tr0</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>start</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <name>tr0</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_GE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>start</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>st</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
  <return>return <expr><name>tr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Handle string.byte (rd-&gt;data = 0) and string.sub (rd-&gt;data = 1). */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_string_range</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trstr</name> <init>= <expr><call><name>lj_ir_tostr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trlen</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trstr</name></expr></argument>, <argument><expr><name>IRFL_STR_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr0</name> <init>= <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trstart</name></decl>, <decl><type ref="prev"/><name>trend</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>argv2str</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* string.sub(str, start [,end]) */</comment>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>argv2int</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>trstart</name> <operator>=</operator> <call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>trend</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isnil</name><argument_list>(<argument><expr><name>trend</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>trend</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>end</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>trend</name> <operator>=</operator> <call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>trend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>argv2int</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* string.byte(str, [,start [,end]]) */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isnil</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>trstart</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>argv2int</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>trstart</name> <operator>=</operator> <call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tref_isnil</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>trend</name> <operator>=</operator> <call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>argv2int</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>trend</name> <operator>=</operator> <name>trstart</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>end</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>end</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_LT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trend</name></expr></argument>, <argument><expr><name>tr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>trend</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trlen</name></expr></argument>, <argument><expr><name>trend</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> <operator>=</operator> <name>end</name><operator>+</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>str</name><operator>-&gt;</operator><name>len</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>MSize</name><operator>)</operator><name>end</name> <operator>&lt;=</operator> <name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_ULE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trend</name></expr></argument>, <argument><expr><name>trlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_UGT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trend</name></expr></argument>, <argument><expr><name>trlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>trend</name> <operator>=</operator> <name>trlen</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>trstart</name> <operator>=</operator> <call><name>recff_string_start</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><name>trstart</name></expr></argument>, <argument><expr><name>trlen</name></expr></argument>, <argument><expr><name>tr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Return string.sub result. */</comment>
    <if_stmt><if>if <condition>(<expr><name>end</name> <operator>-</operator> <name>start</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Also handle empty range here, to avoid extra traces. */</comment>
      <decl_stmt><decl><type><name>TRef</name></type> <name>trptr</name></decl>, <decl><type ref="prev"/><name>trslen</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_SUB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trend</name></expr></argument>, <argument><expr><name>trstart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_GE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trslen</name></expr></argument>, <argument><expr><name>tr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>trptr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_STRREF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trstr</name></expr></argument>, <argument><expr><name>trstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_SNEW</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trptr</name></expr></argument>, <argument><expr><name>trslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Range underflow: return empty string. */</comment>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_LT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trend</name></expr></argument>, <argument><expr><name>trstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>strempty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Return string.byte result(s). */</comment>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><name>end</name> <operator>-</operator> <name>start</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>trslen</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_SUB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trend</name></expr></argument>, <argument><expr><name>trstart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trslen</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>+</operator> <name>len</name> <operator>&gt;</operator> <name>LJ_MAX_JSLOTS</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_trace_err_info</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_STACKOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	<decl_stmt><decl><type><name>TRef</name></type> <name>tmp</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trstart</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_STRREF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trstr</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>IRT_U8</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>IRXLOAD_READONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Empty range or range underflow: return no results. */</comment>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_LE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trend</name></expr></argument>, <argument><expr><name>trstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_string_char</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>k255</name> <init>= <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* Convert char values to strings. */</comment>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_ULE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>k255</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_TOSTR</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRTOSTR_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Concatenate the strings, if there's more than one. */</comment>
    <decl_stmt><decl><type><name>TRef</name></type> <name>hdr</name> <init>= <expr><call><name>recff_bufhdr</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>tr</name> <init>= <expr><name>hdr</name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFPUT</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFSTR</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>strempty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_string_rep</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>str</name> <init>= <expr><call><name>lj_ir_tostr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>rep</name> <init>= <expr><call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>hdr</name></decl>, <decl><type ref="prev"/><name>tr</name></decl>, <decl><type ref="prev"/><name>str2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isnil</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>sep</name> <init>= <expr><call><name>lj_ir_tostr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>vrep</name> <init>= <expr><call><name>argv2int</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><ternary><condition><expr><name>vrep</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>IR_GT</name></expr> </then><else>: <expr><name>IR_LE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>vrep</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>hdr2</name> <init>= <expr><call><name>recff_bufhdr</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TRef</name></type> <name>tr2</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFPUT</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hdr2</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>tr2</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFPUT</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr2</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFSTR</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr2</name></expr></argument>, <argument><expr><name>hdr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>tr</name> <operator>=</operator> <name>hdr</name> <operator>=</operator> <call><name>recff_bufhdr</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>str2</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFPUT</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>str</name> <operator>=</operator> <name>str2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rep</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_lj_buf_putstr_rep</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFSTR</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_string_op</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>str</name> <init>= <expr><call><name>lj_ir_tostr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>hdr</name> <init>= <expr><call><name>recff_bufhdr</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFSTR</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_string_find</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trstr</name> <init>= <expr><call><name>lj_ir_tostr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trpat</name> <init>= <expr><call><name>lj_ir_tostr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trlen</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trstr</name></expr></argument>, <argument><expr><name>IRFL_STR_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr0</name> <init>= <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trstart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>argv2str</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>pat</name> <init>= <expr><call><name>argv2str</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>start</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isnil</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>trstart</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>trstart</name> <operator>=</operator> <call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>argv2int</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>trstart</name> <operator>=</operator> <call><name>recff_string_start</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><name>trstart</name></expr></argument>, <argument><expr><name>trlen</name></expr></argument>, <argument><expr><name>tr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>MSize</name><operator>)</operator><name>start</name> <operator>&lt;=</operator> <name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_ULE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trstart</name></expr></argument>, <argument><expr><name>trlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_UGT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trstart</name></expr></argument>, <argument><expr><name>trlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_52</name></expr></cpp:if>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt>
    <return>return;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>trstart</name> <operator>=</operator> <name>trlen</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Fixed arg or no pattern matching chars? (Specialized to pattern string.) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>tref_istruecond</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
      <operator>(</operator><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trpat</name></expr></argument>, <argument><expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
       <operator>!</operator><call><name>lj_str_haspattern</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Search for fixed string. */</comment>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trsptr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_STRREF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trstr</name></expr></argument>, <argument><expr><name>trstart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trpptr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_STRREF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trpat</name></expr></argument>, <argument><expr><name>tr0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trslen</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_SUB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trlen</name></expr></argument>, <argument><expr><name>trstart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trplen</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trpat</name></expr></argument>, <argument><expr><name>IRFL_STR_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_lj_str_find</name></expr></argument>, <argument><expr><name>trsptr</name></expr></argument>, <argument><expr><name>trpptr</name></expr></argument>, <argument><expr><name>trslen</name></expr></argument>, <argument><expr><name>trplen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trp0</name> <init>= <expr><call><name>lj_ir_kkptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>lj_str_find</name><argument_list>(<argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>+</operator><operator>(</operator><name>MSize</name><operator>)</operator><name>start</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name><operator>-</operator><operator>(</operator><name>MSize</name><operator>)</operator><name>start</name></expr></argument>, <argument><expr><name><name>pat</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>pos</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_NE</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>trp0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Recompute offset. trsptr may not point into trstr after folding. */</comment>
      <expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_SUB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>trsptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>trplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>trp0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Search for pattern. */</comment>
    <expr_stmt><expr><call><name>recff_nyiu</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_string_format</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trfmt</name> <init>= <expr><call><name>lj_ir_tostr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>argv2str</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>arg</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>hdr</name></decl>, <decl><type ref="prev"/><name>tr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FormatState</name></type> <name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SFormat</name></type> <name>sf</name></decl>;</decl_stmt>
  <comment type="block">/* Specialize to the format string. */</comment>
  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trfmt</name></expr></argument>, <argument><expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tr</name> <operator>=</operator> <name>hdr</name> <operator>=</operator> <call><name>recff_bufhdr</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_strfmt_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fs</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fmt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><operator>(</operator><name>sf</name> <operator>=</operator> <call><name>lj_strfmt_parse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fs</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>STRFMT_EOF</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Parse format. */</comment>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tra</name> <init>= <expr><ternary><condition><expr><name>sf</name> <operator>==</operator> <name>STRFMT_LIT</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>arg</name><operator>++</operator></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>trsf</name> <init>= <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>sf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRCallID</name></type> <name>id</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><call><name>STRFMT_TYPE</name><argument_list>(<argument><expr><name>sf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>STRFMT_LIT</name></expr>:</case>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFPUT</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>,
		  <argument><expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>lj_str_new</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>STRFMT_INT</name></expr>:</case>
      <expr_stmt><expr><name>id</name> <operator>=</operator> <name>IRCALL_lj_strfmt_putfnum_int</name></expr>;</expr_stmt>
    <label><name>handle_int</name>:</label>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>tra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<goto>goto <name>handle_num</name>;</goto></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>sf</name> <operator>==</operator> <name>STRFMT_INT</name></expr>)</condition> <block>{<block_content> <comment type="block">/* Shortcut for plain %d. */</comment>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFPUT</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>,
		    <argument><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_TOSTR</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tra</name></expr></argument>, <argument><expr><name>IRTOSTR_INT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
	<expr_stmt><expr><name>tra</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>, <argument><expr><name>IRT_U64</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tra</name></expr></argument>,
		     <argument><expr><operator>(</operator><name>IRT_INT</name><operator>|</operator><operator>(</operator><name>IRT_U64</name><operator>&lt;&lt;</operator><literal type="number">5</literal><operator>)</operator><operator>|</operator><name>IRCONV_SEXT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_lj_strfmt_putfxint</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>trsf</name></expr></argument>, <argument><expr><name>tra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>recff_nyiu</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Don't bother working around this NYI. */</comment>
	<return>return;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>STRFMT_UINT</name></expr>:</case>
      <expr_stmt><expr><name>id</name> <operator>=</operator> <name>IRCALL_lj_strfmt_putfnum_uint</name></expr>;</expr_stmt>
      <goto>goto <name>handle_int</name>;</goto>
    <case>case <expr><name>STRFMT_NUM</name></expr>:</case>
      <expr_stmt><expr><name>id</name> <operator>=</operator> <name>IRCALL_lj_strfmt_putfnum</name></expr>;</expr_stmt>
    <label><name>handle_num</name>:</label>
      <expr_stmt><expr><name>tra</name> <operator>=</operator> <call><name>lj_ir_tonum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>tra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>trsf</name></expr></argument>, <argument><expr><name>tra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>LJ_SOFTFP32</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>STRFMT_STR</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isstr</name><argument_list>(<argument><expr><name>tra</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>recff_nyiu</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* NYI: __tostring and non-string types for %s. */</comment>
	<return>return;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>sf</name> <operator>==</operator> <name>STRFMT_STR</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Shortcut for plain %s. */</comment>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFPUT</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><operator>(</operator><name>sf</name> <operator>&amp;</operator> <name>STRFMT_T_QUOTED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_lj_strfmt_putquoted</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_lj_strfmt_putfstr</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>trsf</name></expr></argument>, <argument><expr><name>tra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>STRFMT_CHAR</name></expr>:</case>
      <expr_stmt><expr><name>tra</name> <operator>=</operator> <call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>tra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>sf</name> <operator>==</operator> <name>STRFMT_CHAR</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Shortcut for plain %c. */</comment>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFPUT</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>,
		    <argument><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_TOSTR</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tra</name></expr></argument>, <argument><expr><name>IRTOSTR_CHAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_lj_strfmt_putfchar</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>trsf</name></expr></argument>, <argument><expr><name>tra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>STRFMT_PTR</name></expr>:</case>  <comment type="block">/* NYI */</comment>
    <case>case <expr><name>STRFMT_ERR</name></expr>:</case>
    <default>default:</default>
      <expr_stmt><expr><call><name>recff_nyiu</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></switch>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFSTR</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Table library fast functions ---------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_table_insert</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RecordIndex</name></type> <name>ix</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_istab</name><argument_list>(<argument><expr><name><name>ix</name><operator>.</operator><name>tab</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ix</name><operator>.</operator><name>val</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Simple push: t[#t+1] = v */</comment>
      <decl_stmt><decl><type><name>TRef</name></type> <name>trlen</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ALEN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>.</operator><name>tab</name></name></expr></argument>, <argument><expr><name>TREF_NIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>tabV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>key</name></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trlen</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>tabv</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>keyv</name></name></expr></argument>, <argument><expr><call><name>lj_tab_len</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>idxchain</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lj_record_idx</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Set new value. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Complex case: insert in the middle. */</comment>
      <expr_stmt><expr><call><name>recff_nyiu</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: Interpreter will throw. */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_table_concat</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tab</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_istab</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>sep</name> <init>= <expr><ternary><condition><expr><operator>!</operator><call><name>tref_isnil</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
	       <expr><call><name>lj_ir_tostr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>lj_ir_knull</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tri</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tref_isnil</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
	       <expr><call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tre</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tref_isnil</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
	       <expr><call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>:
	       <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ALEN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>TREF_NIL</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>hdr</name> <init>= <expr><call><name>recff_bufhdr</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_lj_buf_puttab</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>tri</name></expr></argument>, <argument><expr><name>tre</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_NE</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFSTR</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: Interpreter will throw. */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_table_new</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tra</name> <init>= <expr><call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>trh</name> <init>= <expr><call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_lj_tab_new_ah</name></expr></argument>, <argument><expr><name>tra</name></expr></argument>, <argument><expr><name>trh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_table_clear</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_istab</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>nres</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_lj_tab_clear</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* else: Interpreter will throw. */</comment>
</block_content>}</block></function>

<comment type="block">/* -- I/O library fast functions ------------------------------------------ */</comment>

<comment type="block">/* Get FILE* for I/O function. Any I/O error aborts recording, so there's
** no need to encode the alternate cases for any of the guards.
*/</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>recff_io_fp</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name> <modifier>*</modifier></type><name>udp</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name></decl>, <decl><type ref="prev"/><name>ud</name></decl>, <decl><type ref="prev"/><name>fp</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>id</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* io.func() */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
    <comment type="block">/* TODO: fix ARM32 asm_fload(), so we can use this for all archs. */</comment>
    <expr_stmt><expr><name>ud</name> <operator>=</operator> <call><name>lj_ir_ggfload</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRT_UDATA</name></expr></argument>, <argument><expr><call><name>GG_OFS</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>gcroot</name><index>[<expr><name>id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>gcroot</name><index>[<expr><name>id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ud</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>IRT_UDATA</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* fp:method() */</comment>
    <expr_stmt><expr><name>ud</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isudata</name><argument_list>(<argument><expr><name>ud</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_U8</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ud</name></expr></argument>, <argument><expr><name>IRFL_UDATA_UDTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>UDTYPE_IO_FILE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>udp</name> <operator>=</operator> <name>ud</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ud</name></expr></argument>, <argument><expr><name>IRFL_UDATA_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_NE</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>lj_ir_knull</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>fp</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_io_write</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>ud</name></decl>, <decl><type ref="prev"/><name>fp</name> <init>= <expr><call><name>recff_io_fp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ud</name></expr></argument>, <argument><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>zero</name> <init>= <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>one</name> <init>= <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>i</name> <init>= <expr><ternary><condition><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>str</name> <init>= <expr><call><name>lj_ir_tostr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>buf</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_STRREF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>len</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>IRFL_STR_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isk</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irs</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TOSTR</name> <operator>&amp;&amp;</operator> <name><name>irs</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRTOSTR_CHAR</name><operator>)</operator></expr> ?</condition><then>
		<expr><name><name>irs</name><operator>-&gt;</operator><name>op1</name></name></expr> </then><else>:
		<expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>IRT_U8</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>IRXLOAD_READONLY</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_fputc</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>results_wanted</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Check result only if not ignored. */</comment>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_NE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_fwrite</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>one</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>results_wanted</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Check result only if not ignored. */</comment>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>LJ_52</name></expr> ?</condition><then> <expr><name>ud</name></expr> </then><else>: <expr><name>TREF_TRUE</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_io_flush</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>ud</name></decl>, <decl><type ref="prev"/><name>fp</name> <init>= <expr><call><name>recff_io_fp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ud</name></expr></argument>, <argument><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_fflush</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>results_wanted</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Check result only if not ignored. */</comment>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>TREF_TRUE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Debug library fast functions ---------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>recff_debug_getmetatable</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordFFData</name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>mt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>mtref</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_istab</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>mt</name> <operator>=</operator> <call><name>tabref</name><argument_list>(<argument><expr><call><name>tabV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mtref</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFL_TAB_META</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_isudata</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>mt</name> <operator>=</operator> <call><name>tabref</name><argument_list>(<argument><expr><call><name>udataV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mtref</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFL_UDATA_META</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>mt</name> <operator>=</operator> <call><name>tabref</name><argument_list>(<argument><expr><call><name>basemt_obj</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>mt</name></expr> ?</condition><then> <expr><call><name>lj_ir_ktab</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>TREF_NIL</name></expr></else></ternary></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><ternary><condition><expr><name>mt</name></expr> ?</condition><then> <expr><name>IR_NE</name></expr> </then><else>: <expr><name>IR_EQ</name></expr></else></ternary></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mtref</name></expr></argument>, <argument><expr><call><name>lj_ir_knull</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>mt</name></expr> ?</condition><then> <expr><name>mtref</name></expr> </then><else>: <expr><name>TREF_NIL</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Record calls to fast functions -------------------------------------- */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_recdef.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>recdef_lookup</name><parameter_list>(<parameter><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>ffid</name></name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>recff_idmap</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>recff_idmap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name><name>recff_idmap</name><index>[<expr><name><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>ffid</name></name></expr>]</index></name></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Record entry to a fast function or C function. */</comment>
<function><type><name>void</name></type> <name>lj_ffrecord_func</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RecordFFData</name></type> <name>rd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>m</name> <init>= <expr><call><name>recdef_lookup</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>fn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>rd</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>m</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rd</name><operator>.</operator><name>nres</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Default is one result. */</comment>
  <expr_stmt><expr><name><name>rd</name><operator>.</operator><name>argv</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Mark end of arguments. */</comment>
  <expr_stmt><expr><operator>(</operator><name><name>recff_func</name><index>[<expr><name>m</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>]</index></name><operator>)</operator><operator>(</operator><name>J</name><operator>,</operator> <operator>&amp;</operator><name>rd</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Call recff_* handler. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>rd</name><operator>.</operator><name>nres</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>==</operator> <name>LJ_POST_NONE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>=</operator> <name>LJ_POST_FFRETRY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_record_ret</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>rd</name><operator>.</operator><name>nres</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>emitir</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
