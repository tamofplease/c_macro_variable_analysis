<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_record.c"><comment type="block">/*
** Trace recorder (bytecode -&gt; SSA IR).
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_record_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_str.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_meta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_frame.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_bc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ff.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASPROFILE</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_debug.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ircall.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_iropt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_record.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ffrecord.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_snap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_vm.h"</cpp:file></cpp:include>

<comment type="block">/* Some local macros to save typing. Undef'd at the end. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IR</name><parameter_list>(<parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>			<cpp:value>(&amp;J-&gt;cur.ir[(ref)])</cpp:value></cpp:define>

<comment type="block">/* Pass IR on to next optimization in chain (FOLD). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>emitir</name><parameter_list>(<parameter><type><name>ot</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(lj_ir_set(J, (ot), (a), (b)), lj_opt_fold(J))</cpp:value></cpp:define>

<comment type="block">/* Emit raw IR without passing through optimizations. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>emitir_raw</name><parameter_list>(<parameter><type><name>ot</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(lj_ir_set(J, (ot), (a), (b)), lj_ir_emit(J))</cpp:value></cpp:define>

<comment type="block">/* -- Sanity checks ------------------------------------------------------- */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUA_USE_ASSERT</name></cpp:ifdef>
<comment type="block">/* Sanity check the whole IR -- sloooow. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_check_ir</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nins</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name></expr></init></decl>, <decl><type ref="prev"/><name>nk</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nk</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>nk</name> <operator>&lt;=</operator> <name>REF_BIAS</name> <operator>&amp;&amp;</operator> <name>nins</name> <operator>&gt;=</operator> <name>REF_BIAS</name> <operator>&amp;&amp;</operator> <name>nins</name> <operator>&lt;</operator> <literal type="number">65536</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nk</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nins</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>mode</name> <init>= <expr><name><name>lj_ir_mode</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>op1</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>op2</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><call><name>irm_op1</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>IRMnone</name></expr>:</case> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>op1</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>IRMref</name></expr>:</case> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>op1</name> <operator>&gt;=</operator> <name>nk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><ternary><condition><expr><name>i</name> <operator>&gt;=</operator> <name>REF_BIAS</name></expr> ?</condition><then> <expr><name>op1</name> <operator>&lt;</operator> <name>i</name></expr> </then><else>: <expr><name>op1</name> <operator>&gt;</operator> <name>i</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>IRMlit</name></expr>:</case> <break>break;</break>
    <case>case <expr><name>IRMcst</name></expr>:</case> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name>REF_BIAS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>!=</operator> <name>IR_KNULL</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></switch>
    <switch>switch <condition>(<expr><call><name>irm_op2</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>IRMnone</name></expr>:</case> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>op2</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>IRMref</name></expr>:</case> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>op2</name> <operator>&gt;=</operator> <name>nk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><ternary><condition><expr><name>i</name> <operator>&gt;=</operator> <name>REF_BIAS</name></expr> ?</condition><then> <expr><name>op2</name> <operator>&lt;</operator> <name>i</name></expr> </then><else>: <expr><name>op2</name> <operator>&gt;</operator> <name>i</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>IRMlit</name></expr>:</case> <break>break;</break>
    <case>case <expr><name>IRMcst</name></expr>:</case> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    </block_content>}</block></switch>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>&gt;=</operator> <name>nk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><ternary><condition><expr><name>i</name> <operator>&gt;=</operator> <name>REF_BIAS</name></expr> ?</condition><then> <expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>&lt;</operator> <name>i</name></expr> </then><else>: <expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>&gt;</operator> <name>i</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_NOP</name> <operator>||</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Compare stack slots and frames of the recorder and the VM. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_check_slots</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>nslots</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>&gt;=</operator> <literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>==</operator> <literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name> <operator>||</operator> <operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <name>TREF_FRAME</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>nslots</name> <operator>&lt;=</operator> <name>LJ_MAX_JSLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>nslots</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>s</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>tr</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><index>[<expr><name>s</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Silence compiler. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LJ_FR2</name> <operator>||</operator> <name>ref</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>tr</name> <operator>&amp;</operator> <operator>(</operator><name>TREF_FRAME</name> <operator>|</operator> <name>TREF_CONT</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>ref</name> <operator>&gt;=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nk</name></name> <operator>&amp;&amp;</operator> <name>ref</name> <operator>&lt;</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>irt_t</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>tref_t</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>tref_isfunc</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name>tr</name> <operator>&amp;</operator> <operator>~</operator><name>TREF_FRAME</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>tr</name> <operator>&amp;</operator> <name>TREF_FRAME</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><call><name>gco2func</name><argument_list>(<argument><expr><call><name>frame_gc</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BCReg</name></type> <name>delta</name> <init>= <expr><operator>(</operator><name>BCReg</name><operator>)</operator><operator>(</operator><name>tv</name> <operator>-</operator> <call><name>frame_prev</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ir_knum</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name> <operator>==</operator> <name><name>tv</name><operator>-&gt;</operator><name>u64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>s</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>tref_isfunc</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tref_isk</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>fn</name> <operator>==</operator> <call><name>ir_kfunc</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><ternary><condition><expr><name>s</name> <operator>&gt;</operator> <name>delta</name> <operator>+</operator> <name>LJ_FR2</name></expr> ?</condition><then> <expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>s</name><operator>-</operator><name>delta</name></expr>]</index></name> <operator>&amp;</operator> <name>TREF_FRAME</name><operator>)</operator></expr>
				      </then><else>: <expr><operator>(</operator><name>s</name> <operator>==</operator> <name>delta</name> <operator>+</operator> <name>LJ_FR2</name><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>tr</name> <operator>&amp;</operator> <name>TREF_CONT</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ir_knum</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name> <operator>==</operator> <name><name>tv</name><operator>-&gt;</operator><name>u64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ir_kptr</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>gcrefp</name><argument_list>(<argument><expr><name><name>tv</name><operator>-&gt;</operator><name>gcr</name></name></expr></argument>, <argument><expr><name>void</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>s</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr>]</index></name> <operator>&amp;</operator> <name>TREF_FRAME</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>tvisnumber</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>tref_isnumber</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* Could be IRT_INT etc., too. */</comment>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>itype2irt</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>tref_type</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tref_isk</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Compare constants. */</comment>
	  <decl_stmt><decl><type><name>TValue</name></type> <name>tvk</name></decl>;</decl_stmt>
	  <expr_stmt><expr><call><name>lj_ir_kvalue</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tvk</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>tvisnum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tvk</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tvisnan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tvk</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>lj_obj_equal</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tvk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	  <else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>tvisnum</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tvisnan</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>==</operator> <name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- Type handling and specialization ------------------------------------ */</comment>

<comment type="block">/* Note: these functions return tagged references (TRef). */</comment>

<comment type="block">/* Specialize a slot to a specific type. Note: slot can be negative! */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>sloadt</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>slot</name></decl></parameter>, <parameter><decl><type><name>IRType</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Caller may set IRT_GUARD in t. */</comment>
  <decl_stmt><decl><type><name>TRef</name></type> <name>ref</name> <init>= <expr><call><name>emitir_raw</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_SLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name><operator>+</operator><name>slot</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt>
  <return>return <expr><name>ref</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Specialize a slot to the runtime type. Note: slot can be negative! */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>sload</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><call><name>itype2irt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>slot</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>ref</name> <init>= <expr><call><name>emitir_raw</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_SLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name><operator>+</operator><name>slot</name></expr></argument>,
			<argument><expr><name>IRSLOAD_TYPECHECK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>irtype_ispri</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>TREF_PRI</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Canonicalize primitive refs. */</comment>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt>
  <return>return <expr><name>ref</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get TRef from slot. Load slot and specialize if not done already. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getslot</name><parameter_list>(<parameter><type><name>J</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(J-&gt;base[(s)] ? J-&gt;base[(s)] : sload(J, (int32_t)(s)))</cpp:value></cpp:define>

<comment type="block">/* Get TRef for current function. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>getcurrf</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>==</operator> <literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sloadt</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr></argument>, <argument><expr><name>IRT_FUNC</name></expr></argument>, <argument><expr><name>IRSLOAD_READONLY</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compare for raw object equality.
** Returns 0 if the objects are the same.
** Returns 1 if they are different, but the same type.
** Returns 2 for two different types.
** Comparisons between primitives always return 1 -- no caller cares about it.
*/</comment>
<function><type><name>int</name></type> <name>lj_record_objcmp</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>av</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>bv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>diff</name> <init>= <expr><operator>!</operator><call><name>lj_obj_equal</name><argument_list>(<argument><expr><name>av</name></expr></argument>, <argument><expr><name>bv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isk2</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Shortcut, also handles primitives. */</comment>
    <decl_stmt><decl><type><name>IRType</name></type> <name>ta</name> <init>= <expr><ternary><condition><expr><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRT_INT</name></expr> </then><else>: <expr><call><name>tref_type</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRType</name></type> <name>tb</name> <init>= <expr><ternary><condition><expr><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRT_INT</name></expr> </then><else>: <expr><call><name>tref_type</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ta</name> <operator>!=</operator> <name>tb</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Widen mixed number/int comparisons to number/number comparison. */</comment>
      <if_stmt><if>if <condition>(<expr><name>ta</name> <operator>==</operator> <name>IRT_INT</name> <operator>&amp;&amp;</operator> <name>tb</name> <operator>==</operator> <name>IRT_NUM</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ta</name> <operator>=</operator> <name>IRT_NUM</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ta</name> <operator>==</operator> <name>IRT_NUM</name> <operator>&amp;&amp;</operator> <name>tb</name> <operator>==</operator> <name>IRT_INT</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<return>return <expr><literal type="number">2</literal></expr>;</return>  <comment type="block">/* Two different types are never equal. */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><ternary><condition><expr><name>diff</name></expr> ?</condition><then> <expr><name>IR_NE</name></expr> </then><else>: <expr><name>IR_EQ</name></expr></else></ternary></expr></argument>, <argument><expr><name>ta</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>diff</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Constify a value. Returns 0 for non-representable object types. */</comment>
<function><type><name>TRef</name></type> <name>lj_record_constify</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>tvisgcv</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_ir_kgc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>gcV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>itype2irt</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>tvisint</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>intV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>tvisnum</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_ir_knumint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>numV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>tvisbool</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>TREF_PRI</name><argument_list>(<argument><expr><call><name>itype2irt</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* Can't represent lightuserdata (pointless). */</comment>
</block_content>}</block></function>

<comment type="block">/* -- Record loop ops ----------------------------------------------------- */</comment>

<comment type="block">/* Loop event. */</comment>
<typedef>typedef <type><enum>enum <block>{
  <decl><name>LOOPEV_LEAVE</name></decl>,		<comment type="block">/* Loop is left or not entered. */</comment>
  <decl><name>LOOPEV_ENTERLO</name></decl>,	<comment type="block">/* Loop is entered with a low iteration count left. */</comment>
  <decl><name>LOOPEV_ENTER</name></decl>		<comment type="block">/* Loop is entered. */</comment>
}</block></enum></type> <name>LoopEvent</name>;</typedef>

<comment type="block">/* Canonicalize slots: convert integers to numbers. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>canonicalize_slots</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>s</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>LJ_DUALNUM</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name><operator>+</operator><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>s</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>s</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>s</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_SLOAD</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRSLOAD_READONLY</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Stop recording. */</comment>
<function><type><name>void</name></type> <name>lj_record_stop</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TraceLink</name></type> <name>linktype</name></decl></parameter>, <parameter><decl><type><name>TraceNo</name></type> <name>lnk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUAJIT_ENABLE_TABLE_BUMP</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>retryrec</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_RETRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>lj_trace_end</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>linktype</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>linktype</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>link</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>lnk</name></expr>;</expr_stmt>
  <comment type="block">/* Looping back at the same stack level? */</comment>
  <if_stmt><if>if <condition>(<expr><name>lnk</name> <operator>==</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>traceno</name></name> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>retdepth</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_LOOP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Shall we try to create a loop? */</comment>
      <goto>goto <name>nocanon</name>;</goto></block_content></block></if></if_stmt>  <comment type="block">/* Do not canonicalize or we lose the narrowing. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>root</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Otherwise ensure we always link to the root trace. */</comment>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>link</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>root</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>canonicalize_slots</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>nocanon</name>:</label>
  <comment type="block">/* Note: all loop ops must set J-&gt;pc to the following instruction! */</comment>
  <expr_stmt><expr><call><name>lj_snap_add</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Add loop snapshot. */</comment>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>mergesnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* In case recording continues. */</comment>
</block_content>}</block></function>

<comment type="block">/* Search bytecode backwards for a int/num constant slot initializer. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>find_kinit</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>endpc</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>slot</name></decl></parameter>, <parameter><decl><type><name>IRType</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* This algorithm is rather simplistic and assumes quite a bit about
  ** how the bytecode is generated. It works fine for FORI initializers,
  ** but it won't necessarily work in other cases (e.g. iterator arguments).
  ** It doesn't do anything fancy, either (like backpropagating MOVs).
  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>startpc</name> <init>= <expr><call><name>proto_bc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>pc</name> <operator>=</operator> <name>endpc</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>pc</name> <operator>&gt;</operator> <name>startpc</name></expr>;</condition> <incr><expr><name>pc</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>BCIns</name></type> <name>ins</name> <init>= <expr><operator>*</operator><name>pc</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCOp</name></type> <name>op</name> <init>= <expr><call><name>bc_op</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* First try to find the last instruction that stores to this slot. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>bcmode_a</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BCMbase</name> <operator>&amp;&amp;</operator> <call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>slot</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Multiple results, e.g. from a CALL or KNIL. */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>bcmode_a</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BCMdst</name> <operator>&amp;&amp;</operator> <call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>slot</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>BC_KSHORT</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>BC_KNUM</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Found const. initializer. */</comment>
	<comment type="block">/* Now try to verify there's no forward jump across it. */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>kpc</name> <init>= <expr><name>pc</name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init>;</init> <condition><expr><name>pc</name> <operator>&gt;</operator> <name>startpc</name></expr>;</condition> <incr><expr><name>pc</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
	  <if_stmt><if>if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_JMP</name></expr>)</condition> <block>{<block_content>
	    <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>pc</name><operator>+</operator><call><name>bc_j</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	    <if_stmt><if>if <condition>(<expr><name>target</name> <operator>&gt;</operator> <name>kpc</name> <operator>&amp;&amp;</operator> <name>target</name> <operator>&lt;=</operator> <name>endpc</name></expr>)</condition><block type="pseudo"><block_content>
	      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Conditional assignment. */</comment>
	  </block_content>}</block></if></if_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>BC_KSHORT</name></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>int16_t</name><operator>)</operator><call><name>bc_d</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <return>return <expr><ternary><condition><expr><name>t</name> <operator>==</operator> <name>IRT_INT</name></expr> ?</condition><then> <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>proto_knumtv</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>, <argument><expr><call><name>bc_d</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_INT</name></expr>)</condition> <block>{<block_content>
	    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>numberVint</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <if_stmt><if>if <condition>(<expr><call><name>tvisint</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>numV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* -0 is ok here. */</comment>
	      <return>return <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Type mismatch. */</comment>
	  </block_content>}</block></if> <else>else <block>{<block_content>
	    <return>return <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>numberVnum</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	  </block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Non-constant initializer. */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* No assignment to this slot found? */</comment>
</block_content>}</block></function>

<comment type="block">/* Load and optionally convert a FORI argument from a slot. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>fori_load</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>slot</name></decl></parameter>, <parameter><decl><type><name>IRType</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>conv</name> <init>= <expr><ternary><condition><expr><operator>(</operator><call><name>tvisint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>slot</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>t</name><operator>==</operator><name>IRT_INT</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>IRSLOAD_CONVERT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sloadt</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>slot</name></expr></argument>,
		<argument><expr><name>t</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>IRSLOAD_TYPECHECK</name><operator>)</operator> <operator>||</operator>
		      <operator>(</operator><name>conv</name> <operator>&amp;&amp;</operator> <name>t</name> <operator>==</operator> <name>IRT_INT</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>mode</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr> ?</condition><then>
		     <expr><name>IRT_GUARD</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		<argument><expr><name>mode</name> <operator>+</operator> <name>conv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Peek before FORI to find a const initializer. Otherwise load from slot. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>fori_arg</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>fori</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>slot</name></decl></parameter>,
		     <parameter><decl><type><name>IRType</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>slot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tr</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>find_kinit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>fori</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tr</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>fori_load</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>tr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the direction of the FOR loop iterator.
** It's important to exactly reproduce the semantics of the interpreter.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rec_for_direction</name><parameter_list>(<parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><operator>(</operator><ternary><condition><expr><call><name>tvisint</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>intV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>u32</name><operator>.</operator><name>hi</name></name></expr></else></ternary><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Simulate the runtime behavior of the FOR loop iterator. */</comment>
<function><type><specifier>static</specifier> <name>LoopEvent</name></type> <name>rec_for_iter</name><parameter_list>(<parameter><decl><type><name>IROp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isforl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>stopv</name> <init>= <expr><call><name>numberVnum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>o</name><index>[<expr><name>FORL_STOP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>idxv</name> <init>= <expr><call><name>numberVnum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>o</name><index>[<expr><name>FORL_IDX</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>stepv</name> <init>= <expr><call><name>numberVnum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>o</name><index>[<expr><name>FORL_STEP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>isforl</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>idxv</name> <operator>+=</operator> <name>stepv</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>rec_for_direction</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>o</name><index>[<expr><name>FORL_STEP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>idxv</name> <operator>&lt;=</operator> <name>stopv</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>op</name> <operator>=</operator> <name>IR_LE</name></expr>;</expr_stmt>
      <return>return <expr><ternary><condition><expr><name>idxv</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>stepv</name> <operator>&gt;</operator> <name>stopv</name></expr> ?</condition><then> <expr><name>LOOPEV_ENTERLO</name></expr> </then><else>: <expr><name>LOOPEV_ENTER</name></expr></else></ternary></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>op</name> <operator>=</operator> <name>IR_GT</name></expr>;</expr_stmt> <return>return <expr><name>LOOPEV_LEAVE</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>stopv</name> <operator>&lt;=</operator> <name>idxv</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>op</name> <operator>=</operator> <name>IR_GE</name></expr>;</expr_stmt>
      <return>return <expr><ternary><condition><expr><name>idxv</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>stepv</name> <operator>&lt;</operator> <name>stopv</name></expr> ?</condition><then> <expr><name>LOOPEV_ENTERLO</name></expr> </then><else>: <expr><name>LOOPEV_ENTER</name></expr></else></ternary></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>op</name> <operator>=</operator> <name>IR_LT</name></expr>;</expr_stmt> <return>return <expr><name>LOOPEV_LEAVE</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Record checks for FOR loop overflow and step direction. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_for_check</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>IRType</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>,
			  <parameter><decl><type><name>TRef</name></type> <name>stop</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>step</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>init</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isk</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Non-constant step: need a guard for the direction. */</comment>
    <decl_stmt><decl><type><name>TRef</name></type> <name>zero</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>t</name> <operator>==</operator> <name>IRT_INT</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>lj_ir_knum_zero</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><ternary><condition><expr><name>dir</name></expr> ?</condition><then> <expr><name>IR_GE</name></expr> </then><else>: <expr><name>IR_LT</name></expr></else></ternary></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Add hoistable overflow checks for a narrowed FORL index. */</comment>
    <if_stmt><if>if <condition>(<expr><name>init</name> <operator>&amp;&amp;</operator> <name>t</name> <operator>==</operator> <name>IRT_INT</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>tref_isk</name><argument_list>(<argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Constant stop: optimize check away or to a range check for step. */</comment>
	<decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_LE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><literal type="number">0x7fffffff</literal><operator>-</operator><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_GE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><literal type="number">0x80000000</literal><operator>-</operator><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<comment type="block">/* Stop+step variable: need full overflow check. */</comment>
	<decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_ADDOV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_USE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ADDOV is weak. Avoid dead result. */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>init</name> <operator>&amp;&amp;</operator> <name>t</name> <operator>==</operator> <name>IRT_INT</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tref_isk</name><argument_list>(<argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Constant step: optimize overflow check to a range check for stop. */</comment>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>dir</name></expr> ?</condition><then> <expr><literal type="number">0x7fffffff</literal></expr> </then><else>: <expr><literal type="number">0x80000000</literal></expr></else></ternary><operator>)</operator> <operator>-</operator> <name>k</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><ternary><condition><expr><name>dir</name></expr> ?</condition><then> <expr><name>IR_LE</name></expr> </then><else>: <expr><name>IR_GE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stop</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Record a FORL instruction. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_for_loop</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>fori</name></decl></parameter>, <parameter><decl><type><name>ScEvEntry</name> <modifier>*</modifier></type><name>scev</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>init</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>ra</name> <init>= <expr><call><name>bc_a</name><argument_list>(<argument><expr><operator>*</operator><name>fori</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>idx</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name><operator>+</operator><name>FORL_IDX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><ternary><condition><expr><name>idx</name></expr> ?</condition><then> <expr><call><name>tref_type</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr> </then><else>:
	     <expr><ternary><condition><expr><operator>(</operator><name>init</name> <operator>||</operator> <name>LJ_DUALNUM</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>lj_opt_narrow_forl</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>IRT_NUM</name></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr><name>IRSLOAD_INHERIT</name> <operator>+</operator>
    <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>!</operator><name>LJ_DUALNUM</name> <operator>||</operator> <call><name>tvisint</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>t</name> <operator>==</operator> <name>IRT_INT</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>IRSLOAD_READONLY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>stop</name> <init>= <expr><call><name>fori_arg</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>fori</name></expr></argument>, <argument><expr><name>ra</name><operator>+</operator><name>FORL_STOP</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>step</name> <init>= <expr><call><name>fori_arg</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>fori</name></expr></argument>, <argument><expr><name>ra</name><operator>+</operator><name>FORL_STEP</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tc</name></decl>, <decl><type ref="prev"/><name>dir</name> <init>= <expr><call><name>rec_for_direction</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tv</name><index>[<expr><name>FORL_STEP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>fori</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_FORI</name> <operator>||</operator> <call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>fori</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_JFORI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>scev</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>scev</name><operator>-&gt;</operator><name>dir</name></name> <operator>=</operator> <name>dir</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>scev</name><operator>-&gt;</operator><name>stop</name></name> <operator>=</operator> <call><name>tref_ref</name><argument_list>(<argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>scev</name><operator>-&gt;</operator><name>step</name></name> <operator>=</operator> <call><name>tref_ref</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rec_for_check</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>scev</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <call><name>tref_ref</name><argument_list>(<argument><expr><call><name>find_kinit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>fori</name></expr></argument>, <argument><expr><name>ra</name><operator>+</operator><name>FORL_IDX</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tc</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>LJ_DUALNUM</name> <operator>&amp;&amp;</operator>
	<operator>!</operator><operator>(</operator><name><name>scev</name><operator>-&gt;</operator><name>start</name></name> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name><name>scev</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name><name>scev</name><operator>-&gt;</operator><name>step</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	  <call><name>tvisint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tv</name><index>[<expr><name>FORL_IDX</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>t</name> <operator>==</operator> <name>IRT_INT</name><operator>)</operator><operator>)</operator><operator>)</operator></expr> ?</condition><then>
	<expr><name>IRSLOAD_TYPECHECK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tc</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name><operator>+</operator><name>FORL_STOP</name></expr>]</index></name> <operator>=</operator> <name>stop</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name><operator>+</operator><name>FORL_STEP</name></expr>]</index></name> <operator>=</operator> <name>step</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>idx</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>fori_load</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name><operator>+</operator><name>FORL_IDX</name></expr></argument>, <argument><expr><name>t</name></expr></argument>,
		    <argument><expr><name>IRSLOAD_INHERIT</name> <operator>+</operator> <name>tc</name> <operator>+</operator> <operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>start</name></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>init</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name><operator>+</operator><name>FORL_IDX</name></expr>]</index></name> <operator>=</operator> <name>idx</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name><operator>+</operator><name>FORL_EXT</name></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>scev</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <call><name>tref_ref</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>scev</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>, <argument><expr><name>fori</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>ra</name><operator>+</operator><name>FORL_EXT</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record FORL/JFORL or FORI/JFORI. */</comment>
<function><type><specifier>static</specifier> <name>LoopEvent</name></type> <name>rec_for</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>fori</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isforl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>ra</name> <init>= <expr><call><name>bc_a</name><argument_list>(<argument><expr><operator>*</operator><name>fori</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name> <modifier>*</modifier></type><name>tr</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IROp</name></type> <name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LoopEvent</name></type> <name>ev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>stop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRType</name></type> <name>t</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>isforl</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Handle FORL/JFORL opcodes. */</comment>
    <decl_stmt><decl><type><name>TRef</name></type> <name>idx</name> <init>= <expr><name><name>tr</name><index>[<expr><name>FORL_IDX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>mref</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>pc</name></name></expr></argument>, <argument><expr><specifier>const</specifier> <name>BCIns</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>fori</name> <operator>&amp;&amp;</operator> <call><name>tref_ref</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>idx</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>t</name><operator>.</operator><name>irt</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>stop</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>stop</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>step</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tr</name><index>[<expr><name>FORL_EXT</name></expr>]</index></name> <operator>=</operator> <name><name>tr</name><index>[<expr><name>FORL_IDX</name></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>ScEvEntry</name></type> <name>scev</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>rec_for_loop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>fori</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scev</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>scev</name><operator>.</operator><name>t</name><operator>.</operator><name>irt</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>stop</name> <operator>=</operator> <name><name>scev</name><operator>.</operator><name>stop</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Handle FORI/JFORI opcodes. */</comment>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lj_meta_for</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>LJ_DUALNUM</name> <operator>||</operator> <call><name>tref_isint</name><argument_list>(<argument><expr><name><name>tr</name><index>[<expr><name>FORL_IDX</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><call><name>lj_opt_narrow_forl</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr> </then><else>:
						   <expr><name>IRT_NUM</name></expr></else></ternary></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FORL_IDX</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>FORL_STEP</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tr</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sload</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>tref_isnumber_str</name><argument_list>(<argument><expr><name><name>tr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>tref_isstr</name><argument_list>(<argument><expr><name><name>tr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>tr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_STRTO</name></expr></argument>, <argument><expr><name>IRT_NUM</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_INT</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isinteger</name><argument_list>(<argument><expr><name><name>tr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>tr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>IRCONV_INT_NUM</name><operator>|</operator><name>IRCONV_CHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isnum</name><argument_list>(<argument><expr><name><name>tr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>tr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>tr</name><index>[<expr><name>FORL_EXT</name></expr>]</index></name> <operator>=</operator> <name><name>tr</name><index>[<expr><name>FORL_IDX</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>stop</name> <operator>=</operator> <name><name>tr</name><index>[<expr><name>FORL_STOP</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rec_for_check</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>rec_for_direction</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tv</name><index>[<expr><name>FORL_STEP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
		  <argument><expr><name>stop</name></expr></argument>, <argument><expr><name><name>tr</name><index>[<expr><name>FORL_STEP</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>ev</name> <operator>=</operator> <call><name>rec_for_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>isforl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>ev</name> <operator>==</operator> <name>LOOPEV_LEAVE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>ra</name><operator>+</operator><name>FORL_EXT</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <name>fori</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>ra</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <name>fori</name><operator>+</operator><call><name>bc_j</name><argument_list>(<argument><expr><operator>*</operator><name>fori</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>lj_snap_add</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tr</name><index>[<expr><name>FORL_IDX</name></expr>]</index></name></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>ev</name> <operator>==</operator> <name>LOOPEV_LEAVE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>ra</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <name>fori</name><operator>+</operator><call><name>bc_j</name><argument_list>(<argument><expr><operator>*</operator><name>fori</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>ra</name><operator>+</operator><name>FORL_EXT</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <name>fori</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>ev</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Record ITERL/JITERL. */</comment>
<function><type><specifier>static</specifier> <name>LoopEvent</name></type> <name>rec_iterl</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name></type> <name>iterins</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>ra</name> <init>= <expr><call><name>bc_a</name><argument_list>(<argument><expr><name>iterins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isnil</name><argument_list>(<argument><expr><call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Looping back? */</comment>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name></expr>]</index></name></expr>;</expr_stmt>  <comment type="block">/* Copy result of ITERC to control var. */</comment>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>ra</name><operator>-</operator><literal type="number">1</literal><operator>+</operator><call><name>bc_b</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name> <operator>+=</operator> <call><name>bc_j</name><argument_list>(<argument><expr><name>iterins</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>LOOPEV_ENTER</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>ra</name><operator>-</operator><literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><name>LOOPEV_LEAVE</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Record LOOP/JLOOP. Now, that was easy. */</comment>
<function><type><specifier>static</specifier> <name>LoopEvent</name></type> <name>rec_loop</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>ra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>ra</name> <operator>&lt;</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>ra</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>LOOPEV_ENTER</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check if a loop repeatedly failed to trace because it didn't loop back. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>innerloopleft</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PENALTY_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><call><name>mref</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>penalty</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pc</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>BCIns</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pc</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>penalty</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reason</name> <operator>==</operator> <name>LJ_TRERR_LLEAVE</name> <operator>||</operator>
	   <name><name>J</name><operator>-&gt;</operator><name>penalty</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reason</name> <operator>==</operator> <name>LJ_TRERR_LINNER</name><operator>)</operator> <operator>&amp;&amp;</operator>
	  <name><name>J</name><operator>-&gt;</operator><name>penalty</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name> <operator>&gt;=</operator> <literal type="number">2</literal><operator>*</operator><name>PENALTY_MIN</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt></block_content></block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Handle the case when an interpreted loop op is hit. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_loop_interp</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>, <parameter><decl><type><name>LoopEvent</name></type> <name>ev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>exitno</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>pc</name> <operator>==</operator> <name><name>J</name><operator>-&gt;</operator><name>startpc</name></name> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>retdepth</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Same loop? */</comment>
      <if_stmt><if>if <condition>(<expr><name>ev</name> <operator>==</operator> <name>LOOPEV_LEAVE</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Must loop back to form a root trace. */</comment>
	<expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_LLEAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>lj_record_stop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRLINK_LOOP</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>traceno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Looping trace. */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ev</name> <operator>!=</operator> <name>LOOPEV_LEAVE</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Entering inner loop? */</comment>
      <comment type="block">/* It's usually better to abort here and wait until the inner loop
      ** is traced. But if the inner loop repeatedly didn't loop back,
      ** this indicates a low trip count. In this case try unrolling
      ** an inner loop even in a root trace. But it's better to be a bit
      ** more conservative here and only do it for very short loops.
      */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>bc_j</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>innerloopleft</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_LINNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Root trace hit an inner loop. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ev</name> <operator>!=</operator> <name>LOOPEV_ENTERLO</name> <operator>&amp;&amp;</operator>
	   <name><name>J</name><operator>-&gt;</operator><name>loopref</name></name> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name> <operator>-</operator> <name><name>J</name><operator>-&gt;</operator><name>loopref</name></name> <operator>&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>||</operator> <operator>--</operator><name><name>J</name><operator>-&gt;</operator><name>loopunroll</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_LUNROLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Limit loop unrolling. */</comment>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>loopref</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ev</name> <operator>!=</operator> <name>LOOPEV_LEAVE</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Side trace enters an inner loop. */</comment>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>loopref</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>J</name><operator>-&gt;</operator><name>loopunroll</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_LUNROLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Limit loop unrolling. */</comment>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* Side trace continues across a loop that's left or not entered. */</comment>
</block_content>}</block></function>

<comment type="block">/* Handle the case when an already compiled loop op is hit. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_loop_jit</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TraceNo</name></type> <name>lnk</name></decl></parameter>, <parameter><decl><type><name>LoopEvent</name></type> <name>ev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>exitno</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Root trace hit an inner loop. */</comment>
    <comment type="block">/* Better let the inner loop spawn a side trace back here. */</comment>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_LINNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ev</name> <operator>!=</operator> <name>LOOPEV_LEAVE</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Side trace enters a compiled loop. */</comment>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>instunroll</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Cannot continue across a compiled loop op. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name> <operator>==</operator> <name><name>J</name><operator>-&gt;</operator><name>startpc</name></name> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>retdepth</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_record_stop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRLINK_LOOP</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>traceno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* Form extra loop. */</comment>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_record_stop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRLINK_ROOT</name></expr></argument>, <argument><expr><name>lnk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* Link to the loop. */</comment>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* Side trace continues across a loop that's left or not entered. */</comment>
</block_content>}</block></function>

<comment type="block">/* -- Record profiler hook checks ----------------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASPROFILE</name></expr></cpp:if>

<comment type="block">/* Need to insert profiler hook check? */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rec_profile_need</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>ppt</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>prof_mode</name></name> <operator>==</operator> <literal type="char">'f'</literal> <operator>||</operator> <name><name>J</name><operator>-&gt;</operator><name>prof_mode</name></name> <operator>==</operator> <literal type="char">'l'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pt</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>ppt</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>prev_pt</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>prev_pt</name></name> <operator>=</operator> <name>pt</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>pt</name> <operator>!=</operator> <name>ppt</name> <operator>&amp;&amp;</operator> <name>ppt</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>prev_line</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>prof_mode</name></name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCLine</name></type> <name>line</name> <init>= <expr><call><name>lj_debug_line</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><call><name>proto_bcpos</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCLine</name></type> <name>pline</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>prev_line</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>prev_line</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pline</name> <operator>!=</operator> <name>line</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_profile_ins</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>prof_mode</name></name> <operator>&amp;&amp;</operator> <call><name>rec_profile_need</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_PROF</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_snap_add</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_profile_ret</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>prof_mode</name></name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_PROF</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>prev_pt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_snap_add</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- Record calls and returns -------------------------------------------- */</comment>

<comment type="block">/* Specialize to the runtime value of the called function or its prototype. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>rec_call_specialize</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>tr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>kfunc</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isluafunc</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>funcproto</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Too many closures created? Probably not a monomorphic function. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&gt;=</operator> <name>PROTO_CLC_POLY</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Specialize to prototype instead. */</comment>
      <decl_stmt><decl><type><name>TRef</name></type> <name>trpt</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFL_FUNC_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trpt</name></expr></argument>, <argument><expr><call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>proto_bc</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>lj_ir_kgc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IRT_PROTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Prevent GC of proto. */</comment>
      <return>return <expr><name>tr</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* Don't specialize to non-monomorphic builtins. */</comment>
    <switch>switch <condition>(<expr><name><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>ffid</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>FF_coroutine_wrap_aux</name></expr>:</case>
    <case>case <expr><name>FF_string_gmatch_aux</name></expr>:</case>
      <comment type="block">/* NYI: io_file_iter doesn't have an ffid, yet. */</comment>
      <block>{<block_content>  <comment type="block">/* Specialize to the ffid. */</comment>
	<decl_stmt><decl><type><name>TRef</name></type> <name>trid</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_U8</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>IRFL_FUNC_FFID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trid</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>ffid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
      <return>return <expr><name>tr</name></expr>;</return>
    <default>default:</default>
      <comment type="block">/* NYI: don't specialize to non-monomorphic C functions. */</comment>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Otherwise specialize to the function (closure) value itself. */</comment>
  <expr_stmt><expr><name>kfunc</name> <operator>=</operator> <call><name>lj_ir_kfunc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_FUNC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>kfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>kfunc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Record call setup. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_call_setup</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>nargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RecordIndex</name></type> <name>ix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>functv</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>func</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>kfunc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fbase</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>func</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Ensure func has a reference. */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>func</name><operator>+</operator><name>LJ_FR2</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>  <comment type="block">/* Ensure all args have a reference. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isfunc</name><argument_list>(<argument><expr><name><name>fbase</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Resolve __call metamethod. */</comment>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <name><name>fbase</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>tabv</name></name></expr></argument>, <argument><expr><name>functv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name>MM_call</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>tref_isfunc</name><argument_list>(<argument><expr><name><name>ix</name><operator>.</operator><name>mobj</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NOMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>++</operator><name>nargs</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <name>LJ_FR2</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* Shift arguments up. */</comment>
      <expr_stmt><expr><name><name>fbase</name><index>[<expr><name>i</name><operator>+</operator><name>LJ_FR2</name></expr>]</index></name> <operator>=</operator> <name><name>fbase</name><index>[<expr><name>i</name><operator>+</operator><name>LJ_FR2</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
    <expr_stmt><expr><name><name>fbase</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>fbase</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>fbase</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>.</operator><name>mobj</name></name></expr>;</expr_stmt>  <comment type="block">/* Replace function. */</comment>
    <expr_stmt><expr><name>functv</name> <operator>=</operator> <operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>mobjv</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>kfunc</name> <operator>=</operator> <call><name>rec_call_specialize</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>funcV</name><argument_list>(<argument><expr><name>functv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fbase</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
  <expr_stmt><expr><name><name>fbase</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>kfunc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fbase</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>TREF_FRAME</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>fbase</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>kfunc</name> <operator>|</operator> <name>TREF_FRAME</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><name>nargs</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record call. */</comment>
<function><type><name>void</name></type> <name>lj_record_call</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>nargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>rec_call_setup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Bump frame. */</comment>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>+=</operator> <name>func</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>+=</operator> <name>func</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>&gt;=</operator> <name>LJ_MAX_JSLOTS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_STACKOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Record tail call. */</comment>
<function><type><name>void</name></type> <name>lj_record_tailcall</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>nargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>rec_call_setup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>frame_isvarg</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>cbase</name> <init>= <expr><operator>(</operator><name>BCReg</name><operator>)</operator><call><name>frame_delta</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYIRETL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>-=</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><name>cbase</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>-=</operator> <name>cbase</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>func</name> <operator>+=</operator> <name>cbase</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Move func + args down. */</comment>
  <if_stmt><if>if <condition>(<expr><name>LJ_FR2</name> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>func</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>TREF_FRAME</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>func</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TRef</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Note: the new TREF_FRAME is now at J-&gt;base[-1] (even for slot #0). */</comment>
  <comment type="block">/* Tailcalls can form a loop, so count towards the loop unroll limit. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>J</name><operator>-&gt;</operator><name>tailcalled</name></name> <operator>&gt;</operator> <name><name>J</name><operator>-&gt;</operator><name>loopunroll</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_LUNROLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Check unroll limits for down-recursion. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_downrec_unroll</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>ptref</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>ptref</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_KGC</name></expr>]</index></name></expr>;</init> <condition><expr><name>ptref</name></expr>;</condition> <incr><expr><name>ptref</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>ptref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><call><name>ir_kgc</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name>ptref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>obj2gco</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_RETF</name></expr>]</index></name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name></expr></incr>)</control><block type="pseudo"><block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>op1</name> <operator>==</operator> <name>ptref</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
      <if_stmt><if>if <condition>(<expr><name>count</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name> <operator>==</operator> <name><name>J</name><operator>-&gt;</operator><name>startpc</name></name></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>count</name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>tailcalled</name></name> <operator>&gt;</operator> <name><name>J</name><operator>-&gt;</operator><name>param</name><index>[<expr><name>JIT_P_recunroll</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_DOWNREC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt></block_content></block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>TRef</name></type> <name>rec_cat</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>baseslot</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>topslot</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Record return. */</comment>
<function><type><name>void</name></type> <name>lj_record_ret</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>rbase</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>gotresults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>gotresults</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rbase</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>  <comment type="block">/* Ensure all results have a reference. */</comment>
  <while>while <condition>(<expr><call><name>frame_ispcall</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Immediately resolve pcall() returns. */</comment>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>cbase</name> <init>= <expr><operator>(</operator><name>BCReg</name><operator>)</operator><call><name>frame_delta</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYIRETL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>&gt;</operator> <literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>gotresults</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rbase</name> <operator>+=</operator> <name>cbase</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>-=</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><name>cbase</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>-=</operator> <name>cbase</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>--</operator><name>rbase</name></expr>]</index></name> <operator>=</operator> <name>TREF_TRUE</name></expr>;</expr_stmt>  <comment type="block">/* Prepend true to results. */</comment>
    <expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <comment type="block">/* Return to lower frame via interpreter for unhandled cases. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>pt</name></name> <operator>&amp;&amp;</operator> <call><name>bc_isret</name><argument_list>(<argument><expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
       <operator>(</operator><operator>!</operator><call><name>frame_islua</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call> <operator>||</operator>
	<operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>exitno</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
	 <operator>!</operator><call><name>bc_isret</name><argument_list>(<argument><expr><call><name>bc_op</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>startins</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
    <comment type="block">/* NYI: specialize to frame type and return directly, not via RET*. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>rbase</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>  <comment type="block">/* Purge dead slots. */</comment>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>rbase</name> <operator>+</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><name>gotresults</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_record_stop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRLINK_RETURN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Return to interpreter. */</comment>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>frame_isvarg</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>cbase</name> <init>= <expr><operator>(</operator><name>BCReg</name><operator>)</operator><call><name>frame_delta</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* NYI: return of vararg func to lower frame. */</comment>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYIRETL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>&gt;</operator> <literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rbase</name> <operator>+=</operator> <name>cbase</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>-=</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><name>cbase</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>-=</operator> <name>cbase</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>frame_islua</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Return to Lua frame. */</comment>
    <decl_stmt><decl><type><name>BCIns</name></type> <name>callins</name> <init>= <expr><operator>*</operator><operator>(</operator><call><name>frame_pc</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>nresults</name> <init>= <expr><ternary><condition><expr><call><name>bc_b</name><argument_list>(<argument><expr><name>callins</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><call><name>bc_b</name><argument_list>(<argument><expr><name>callins</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr> </then><else>:<expr><name>gotresults</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>cbase</name> <init>= <expr><call><name>bc_a</name><argument_list>(<argument><expr><name>callins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>funcproto</name><argument_list>(<argument><expr><call><name>frame_func</name><argument_list>(<argument><expr><name>frame</name> <operator>-</operator> <operator>(</operator><name>cbase</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTO_NOJIT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_CJITOFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>pt</name></name> <operator>&amp;&amp;</operator> <name>frame</name> <operator>==</operator> <name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>check_downrec_unroll</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><operator>(</operator><name>rbase</name> <operator>+</operator> <name>gotresults</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lj_snap_purge</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lj_record_stop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRLINK_DOWNREC</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>traceno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Down-rec. */</comment>
	<return>return;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>lj_snap_add</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nresults</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* Adjust results. */</comment>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>&lt;</operator> <name>gotresults</name></expr> ?</condition><then> <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>rbase</name><operator>+</operator><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>TREF_NIL</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>cbase</name><operator>+</operator><operator>(</operator><name>BCReg</name><operator>)</operator><name>nresults</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Return to a frame that is part of the trace. */</comment>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>&gt;</operator> <name>cbase</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>-=</operator> <name>cbase</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>-=</operator> <name>cbase</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>exitno</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
	       <operator>!</operator><call><name>bc_isret</name><argument_list>(<argument><expr><call><name>bc_op</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>startins</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Return to lower frame would leave the loop in a root trace. */</comment>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_LLEAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Tailcalled to ff with side-effects. */</comment>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYIRETL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* No way to insert snapshot here. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Return to lower frame. Guard for the target we return to. */</comment>
      <decl_stmt><decl><type><name>TRef</name></type> <name>trpt</name> <init>= <expr><call><name>lj_ir_kgc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IRT_PROTO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TRef</name></type> <name>trpc</name> <init>= <expr><call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>frame_pc</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_RETF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trpt</name></expr></argument>, <argument><expr><name>trpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>retdepth</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>==</operator> <literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Shift result slots up and clear the slots of the new frame below. */</comment>
      <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>cbase</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TRef</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TRef</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>cbase</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>frame_iscont</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Return to continuation frame. */</comment>
    <decl_stmt><decl><type><name>ASMFunction</name></type> <name>cont</name> <init>= <expr><call><name>frame_contf</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>cbase</name> <init>= <expr><operator>(</operator><name>BCReg</name><operator>)</operator><call><name>frame_delta</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>-=</operator> <literal type="number">2</literal><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYIRETL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>-=</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><name>cbase</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>-=</operator> <name>cbase</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>cbase</name><operator>-</operator><operator>(</operator><literal type="number">2</literal><operator>&lt;&lt;</operator><name>LJ_FR2</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cont</name> <operator>==</operator> <name>lj_cont_ra</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Copy result to destination slot. */</comment>
      <decl_stmt><decl><type><name>BCReg</name></type> <name>dst</name> <init>= <expr><call><name>bc_a</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><call><name>frame_contpc</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>dst</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>gotresults</name></expr> ?</condition><then> <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>cbase</name><operator>+</operator><name>rbase</name></expr>]</index></name></expr> </then><else>: <expr><name>TREF_NIL</name></expr></else></ternary></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&gt;=</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>dst</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cont</name> <operator>==</operator> <name>lj_cont_nop</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Nothing to do here. */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cont</name> <operator>==</operator> <name>lj_cont_cat</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>BCReg</name></type> <name>bslot</name> <init>= <expr><call><name>bc_b</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><call><name>frame_contpc</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><ternary><condition><expr><name>gotresults</name></expr> ?</condition><then> <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>cbase</name><operator>+</operator><name>rbase</name></expr>]</index></name></expr> </then><else>: <expr><name>TREF_NIL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>bslot</name> <operator>!=</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Concatenate the remainder. */</comment>
	<decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>, <decl><type ref="prev"/><name>save</name></decl>;</decl_stmt>  <comment type="block">/* Simulate lower frame and result. */</comment>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save</name></expr></argument>, <argument><expr><name>b</name><operator>-</operator><operator>(</operator><literal type="number">2</literal><operator>&lt;&lt;</operator><name>LJ_FR2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>gotresults</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>b</name><operator>-</operator><operator>(</operator><literal type="number">2</literal><operator>&lt;&lt;</operator><name>LJ_FR2</name><operator>)</operator></expr></argument>, <argument><expr><name>b</name><operator>+</operator><name>rbase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name>b</name><operator>-</operator><operator>(</operator><literal type="number">2</literal><operator>&lt;&lt;</operator><name>LJ_FR2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>b</name> <operator>-</operator> <name>cbase</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>rec_cat</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>bslot</name></expr></argument>, <argument><expr><name>cbase</name><operator>-</operator><operator>(</operator><literal type="number">2</literal><operator>&lt;&lt;</operator><name>LJ_FR2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>cbase</name></expr>;</expr_stmt>  <comment type="block">/* Undo. */</comment>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>b</name><operator>-</operator><operator>(</operator><literal type="number">2</literal><operator>&lt;&lt;</operator><name>LJ_FR2</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>tr</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Store final result. */</comment>
	<decl_stmt><decl><type><name>BCReg</name></type> <name>dst</name> <init>= <expr><call><name>bc_a</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><call><name>frame_contpc</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>dst</name></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&gt;=</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>dst</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>  <comment type="block">/* Otherwise continue with another __concat call. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="block">/* Result type already specialized. */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>cont</name> <operator>==</operator> <name>lj_cont_condf</name> <operator>||</operator> <name>cont</name> <operator>==</operator> <name>lj_cont_condt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYIRETL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* NYI: handle return to C frame. */</comment>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>&gt;=</operator> <literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Metamethod handling ------------------------------------------------- */</comment>

<comment type="block">/* Prepare to record call to metamethod. */</comment>
<function><type><specifier>static</specifier> <name>BCReg</name></type> <name>rec_mm_prep</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>ASMFunction</name></type> <name>cont</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>top</name> <init>= <expr><ternary><condition><expr><name>cont</name> <operator>==</operator> <name>lj_cont_cat</name></expr> ?</condition><then> <expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr> </then><else>: <expr><call><name>curr_proto</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>top</name></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_k64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IR_KNUM</name></expr></argument>, <argument><expr><call><name>u64ptr</name><argument_list>(<argument><expr><call><name>contptr</name><argument_list>(<argument><expr><name>cont</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>top</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>TREF_CONT</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>top</name></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>contptr</name><argument_list>(<argument><expr><name>cont</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>|</operator> <name>TREF_CONT</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name><operator>++</operator></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>top</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>  <comment type="block">/* Clear frame gap to avoid resurrecting previous refs. */</comment>
  <return>return <expr><name>top</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Record metamethod lookup. */</comment>
<function><type><name>int</name></type> <name>lj_record_mm_lookup</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordIndex</name> <modifier>*</modifier></type><name>ix</name></decl></parameter>, <parameter><decl><type><name>MMS</name></type> <name>mm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RecordIndex</name></type> <name>mix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>mt</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_istab</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>mt</name> <operator>=</operator> <call><name>tabref</name><argument_list>(<argument><expr><call><name>tabV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><name>IRFL_TAB_META</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tref_isudata</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>udtype</name> <init>= <expr><call><name>udataV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>udtype</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>mt</name> <operator>=</operator> <call><name>tabref</name><argument_list>(<argument><expr><call><name>udataV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The metatables of special userdata objects are treated as immutable. */</comment>
    <if_stmt><if>if <condition>(<expr><name>udtype</name> <operator>!=</operator> <name>UDTYPE_USERDATA</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>mo</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <name>udtype</name> <operator>==</operator> <name>UDTYPE_FFI_CLIB</name></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Specialize to the C library namespace object. */</comment>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>udataV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<comment type="block">/* Specialize to the type of userdata. */</comment>
	<decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_U8</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><name>IRFL_UDATA_UDTYPE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>udtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
  <label><name>immutable_mt</name>:</label>
      <expr_stmt><expr><name>mo</name> <operator>=</operator> <call><name>lj_tab_getstr</name><argument_list>(<argument><expr><name>mt</name></expr></argument>, <argument><expr><call><name>mmname_str</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>mo</name> <operator>||</operator> <call><name>tvisnil</name><argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* No metamethod. */</comment>
      <comment type="block">/* Treat metamethod or index table as immutable, too. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>tvisfunc</name><argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>tvistab</name><argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BADTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>mobjv</name></name></expr></argument>, <argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>mobj</name></name> <operator>=</operator> <call><name>lj_ir_kgc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>gcV</name><argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><call><name>tvisfunc</name><argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRT_FUNC</name></expr> </then><else>: <expr><name>IRT_TAB</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>mtv</name></name> <operator>=</operator> <name>mt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>mt</name></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt>  <comment type="block">/* Dummy value for comparison semantics. */</comment>
      <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Got metamethod or index table. */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>mix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><name>IRFL_UDATA_META</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* Specialize to base metatable. Must flush mcode in lua_setmetatable(). */</comment>
    <expr_stmt><expr><name>mt</name> <operator>=</operator> <call><name>tabref</name><argument_list>(<argument><expr><call><name>basemt_obj</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>mt</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>mt</name></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* No metamethod. */</comment>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* The cdata metatable is treated as immutable. */</comment>
    <if_stmt><if>if <condition>(<expr><name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <call><name>tref_iscdata</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>immutable_mt</name>;</goto></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
    <comment type="block">/* TODO: fix ARM32 asm_fload(), so we can use this for all archs. */</comment>
    <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>mt</name></name> <operator>=</operator> <name><name>mix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <call><name>lj_ir_ggfload</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>,
      <argument><expr><call><name>GG_OFS</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>gcroot</name><index>[<expr><name>GCROOT_BASEMT</name><operator>+</operator><call><name>itypemap</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>mt</name></name> <operator>=</operator> <name><name>mix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <call><name>lj_ir_ktab</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <goto>goto <name>nocheck</name>;</goto>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>mt</name></name> <operator>=</operator> <ternary><condition><expr><name>mt</name></expr> ?</condition><then> <expr><name><name>mix</name><operator>.</operator><name>tab</name></name></expr> </then><else>: <expr><name>TREF_NIL</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><ternary><condition><expr><name>mt</name></expr> ?</condition><then> <expr><name>IR_NE</name></expr> </then><else>: <expr><name>IR_EQ</name></expr></else></ternary></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>mix</name><operator>.</operator><name>tab</name></name></expr></argument>, <argument><expr><call><name>lj_ir_knull</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>nocheck</name>:</label>
  <if_stmt><if>if <condition>(<expr><name>mt</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>mmstr</name> <init>= <expr><call><name>mmname_str</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>mo</name> <init>= <expr><call><name>lj_tab_getstr</name><argument_list>(<argument><expr><name>mt</name></expr></argument>, <argument><expr><name>mmstr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>mo</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>mobjv</name></name></expr></argument>, <argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>mtv</name></name> <operator>=</operator> <name>mt</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mix</name><operator>.</operator><name>tabv</name></name></expr></argument>, <argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mix</name><operator>.</operator><name>keyv</name></name></expr></argument>, <argument><expr><name>mmstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mix</name><operator>.</operator><name>key</name></name> <operator>=</operator> <call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>mmstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mix</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mix</name><operator>.</operator><name>idxchain</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>mobj</name></name> <operator>=</operator> <call><name>lj_record_idx</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>!</operator><call><name>tref_isnil</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>mobj</name></name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* 1 if metamethod found, 0 if not. */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* No metamethod. */</comment>
</block_content>}</block></function>

<comment type="block">/* Record call to arithmetic metamethod. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>rec_mm_arith</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordIndex</name> <modifier>*</modifier></type><name>ix</name></decl></parameter>, <parameter><decl><type><name>MMS</name></type> <name>mm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Set up metamethod call first to save ix-&gt;tab and ix-&gt;tabv. */</comment>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>func</name> <init>= <expr><call><name>rec_mm_prep</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><ternary><condition><expr><name>mm</name> <operator>==</operator> <name>MM_concat</name></expr> ?</condition><then> <expr><name>lj_cont_cat</name></expr> </then><else>: <expr><name>lj_cont_ra</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>func</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>basev</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>func</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>base</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>base</name><index>[<expr><literal type="number">2</literal><operator>+</operator><name>LJ_FR2</name></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>basev</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>basev</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Lookup mm on 1st operand. */</comment>
    <if_stmt><if>if <condition>(<expr><name>mm</name> <operator>!=</operator> <name>MM_unm</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Lookup mm on 2nd operand. */</comment>
	<goto>goto <name>ok</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NOMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<label><name>ok</name>:</label>
  <expr_stmt><expr><name><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>mobj</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
  <expr_stmt><expr><name><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>basev</name><operator>+</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>mobjv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_record_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* No result yet. */</comment>
</block_content>}</block></function>

<comment type="block">/* Record call to __len metamethod. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>rec_mm_len</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>tr</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RecordIndex</name></type> <name>ix</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>tabv</name></name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name>MM_len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>func</name> <init>= <expr><call><name>rec_mm_prep</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>lj_cont_ra</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>func</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>basev</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>func</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>.</operator><name>mobj</name></name></expr>;</expr_stmt> <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>basev</name><operator>+</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>mobjv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>base</name> <operator>+=</operator> <name>LJ_FR2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>basev</name> <operator>+=</operator> <name>LJ_FR2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>basev</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_52</name></expr></cpp:if>
    <expr_stmt><expr><name><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>basev</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name>basev</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>lj_record_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>LJ_52</name> <operator>&amp;&amp;</operator> <call><name>tref_istab</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ALEN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>TREF_NIL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NOMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* No result yet. */</comment>
</block_content>}</block></function>

<comment type="block">/* Call a comparison metamethod. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_mm_callcomp</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordIndex</name> <modifier>*</modifier></type><name>ix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>func</name> <init>= <expr><call><name>rec_mm_prep</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>op</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name>lj_cont_condf</name></expr> </then><else>: <expr><name>lj_cont_condt</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>func</name> <operator>+</operator> <name>LJ_FR2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>func</name> <operator>+</operator> <name>LJ_FR2</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>base</name><index>[<expr><operator>-</operator><name>LJ_FR2</name></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>mobj</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>tv</name><operator>-</operator><name>LJ_FR2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>mobjv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>tv</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>valv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>tv</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_record_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record call to equality comparison metamethod (for tab and udata only). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_mm_equal</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordIndex</name> <modifier>*</modifier></type><name>ix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>valv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>MM_eq</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Lookup mm on 1st operand. */</comment>
    <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>bv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>mo1</name> <init>= <expr><name><name>ix</name><operator>-&gt;</operator><name>mobj</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TValue</name></type> <name>mo1v</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mo1v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>mobjv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Avoid the 2nd lookup and the objcmp if the metatables are equal. */</comment>
    <expr_stmt><expr><name>bv</name> <operator>=</operator> <operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tvistab</name><argument_list>(<argument><expr><name>bv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tabref</name><argument_list>(<argument><expr><call><name>tabV</name><argument_list>(<argument><expr><name>bv</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>ix</name><operator>-&gt;</operator><name>mtv</name></name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>mt2</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>IRFL_TAB_META</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mt2</name></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>mt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisudata</name><argument_list>(<argument><expr><name>bv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tabref</name><argument_list>(<argument><expr><call><name>udataV</name><argument_list>(<argument><expr><name>bv</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>ix</name><operator>-&gt;</operator><name>mtv</name></name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>mt2</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>IRFL_UDATA_META</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mt2</name></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>mt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Lookup metamethod on 2nd operand and compare both. */</comment>
      <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>, <argument><expr><name>bv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>MM_eq</name></expr></argument>)</argument_list></call> <operator>||</operator>
	  <call><name>lj_record_objcmp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>mo1</name></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>mobj</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mo1v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>mobjv</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>rec_mm_callcomp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Record call to ordered comparison metamethods (for arbitrary objects). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_mm_comp</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordIndex</name> <modifier>*</modifier></type><name>ix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>valv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>MMS</name></type> <name>mm</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>op</name> <operator>&amp;</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><name>MM_le</name></expr> </then><else>: <expr><name>MM_lt</name></expr></else></ternary></expr></init></decl>;</decl_stmt>  <comment type="block">/* Try __le + __lt or only __lt. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_52</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Lookup mm on 1st operand. */</comment>
      <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Lookup mm on 2nd operand. */</comment>
	<goto>goto <name>nomatch</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>rec_mm_callcomp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Lookup mm on 1st operand. */</comment>
      <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>bv</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TRef</name></type> <name>mo1</name> <init>= <expr><name><name>ix</name><operator>-&gt;</operator><name>mobj</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TValue</name></type> <name>mo1v</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mo1v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>mobjv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Avoid the 2nd lookup and the objcmp if the metatables are equal. */</comment>
      <expr_stmt><expr><name>bv</name> <operator>=</operator> <operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>tvistab</name><argument_list>(<argument><expr><name>bv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tabref</name><argument_list>(<argument><expr><call><name>tabV</name><argument_list>(<argument><expr><name>bv</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>ix</name><operator>-&gt;</operator><name>mtv</name></name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>TRef</name></type> <name>mt2</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>IRFL_TAB_META</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mt2</name></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>mt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisudata</name><argument_list>(<argument><expr><name>bv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tabref</name><argument_list>(<argument><expr><call><name>udataV</name><argument_list>(<argument><expr><name>bv</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>ix</name><operator>-&gt;</operator><name>mtv</name></name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>TRef</name></type> <name>mt2</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>IRFL_UDATA_META</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mt2</name></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>mt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Lookup metamethod on 2nd operand and compare both. */</comment>
	<expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>, <argument><expr><name>bv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call> <operator>||</operator>
	    <call><name>lj_record_objcmp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>mo1</name></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>mobj</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mo1v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>mobjv</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <goto>goto <name>nomatch</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>rec_mm_callcomp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <label><name>nomatch</name>:</label>
    <comment type="block">/* Lookup failed. Retry with  __lt and swapped operands. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>op</name> <operator>&amp;</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Already at __lt. Interpreter will throw. */</comment>
    <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>valv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>valv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>^=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<comment type="block">/* Setup call to cdata comparison metamethod. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_mm_comp_cdata</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordIndex</name> <modifier>*</modifier></type><name>ix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>MMS</name></type> <name>mm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_snap_add</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_iscdata</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>valv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>tref_iscdata</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rec_mm_callcomp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- Indexed access ------------------------------------------------------ */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUAJIT_ENABLE_TABLE_BUMP</name></cpp:ifdef>
<comment type="block">/* Bump table allocations in bytecode when they grow during recording. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_idx_bump</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordIndex</name> <modifier>*</modifier></type><name>ix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RBCHashEntry</name> <modifier>*</modifier></type><name>rbc</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>rbchash</name><index>[<expr><operator>(</operator><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name> <operator>&amp;</operator> <operator>(</operator><name>RBCHASH_SLOTS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_ref</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>rbc</name><operator>-&gt;</operator><name>ref</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>mref</name><argument_list>(<argument><expr><name><name>rbc</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>, <argument><expr><specifier>const</specifier> <name>BCIns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>tb</name> <init>= <expr><call><name>tabV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>nhbits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>lj_tab_set</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>tb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Grow table right now. */</comment>
    <expr_stmt><expr><name>nhbits</name> <operator>=</operator> <ternary><condition><expr><name><name>tb</name><operator>-&gt;</operator><name>hmask</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>lj_fls</name><argument_list>(<argument><expr><name><name>tb</name><operator>-&gt;</operator><name>hmask</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TNEW</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>ah</name> <init>= <expr><call><name>bc_d</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>asize</name> <init>= <expr><name>ah</name> <operator>&amp;</operator> <literal type="number">0x7ff</literal></expr></init></decl>, <decl><type ref="prev"/><name>hbits</name> <init>= <expr><name>ah</name> <operator>&gt;&gt;</operator> <literal type="number">11</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>nhbits</name> <operator>&gt;</operator> <name>hbits</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hbits</name> <operator>=</operator> <name>nhbits</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>tb</name><operator>-&gt;</operator><name>asize</name></name> <operator>&gt;</operator> <name>asize</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>asize</name> <operator>=</operator> <ternary><condition><expr><name><name>tb</name><operator>-&gt;</operator><name>asize</name></name> <operator>&lt;=</operator> <literal type="number">0x7ff</literal></expr> ?</condition><then> <expr><name><name>tb</name><operator>-&gt;</operator><name>asize</name></name></expr> </then><else>: <expr><literal type="number">0x7ff</literal></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>asize</name> <operator>|</operator> <operator>(</operator><name>hbits</name><operator>&lt;&lt;</operator><literal type="number">11</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>ah</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Has the size changed? */</comment>
	<comment type="block">/* Patch bytecode, but continue recording (for more patching). */</comment>
	<expr_stmt><expr><call><name>setbc_d</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><operator>(</operator><name>asize</name> <operator>|</operator> <operator>(</operator><name>hbits</name><operator>&lt;&lt;</operator><literal type="number">11</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Patching TNEW operands is only safe if the trace is aborted. */</comment>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name>asize</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>hbits</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>retryrec</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Abort the trace at the end of recording. */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TDUP</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>tpl</name> <init>= <expr><call><name>gco2tab</name><argument_list>(<argument><expr><call><name>proto_kgc</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>gcref</name><argument_list>(<argument><expr><name><name>rbc</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pt</name></expr></argument>, <argument><expr><operator>~</operator><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><call><name>bc_d</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="block">/* Grow template table, but preserve keys with nil values. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tb</name><operator>-&gt;</operator><name>asize</name></name> <operator>&gt;</operator> <name><name>tpl</name><operator>-&gt;</operator><name>asize</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>nhbits</name><operator>)</operator><operator>-</operator><literal type="number">1</literal> <operator>==</operator> <name><name>tpl</name><operator>-&gt;</operator><name>hmask</name></name><operator>)</operator> <operator>||</operator>
	  <operator>(</operator><name><name>tb</name><operator>-&gt;</operator><name>asize</name></name> <operator>==</operator> <name><name>tpl</name><operator>-&gt;</operator><name>asize</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>nhbits</name><operator>)</operator><operator>-</operator><literal type="number">1</literal> <operator>&gt;</operator> <name><name>tpl</name><operator>-&gt;</operator><name>hmask</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>tpl</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>hmask</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>hmask</name></name></expr></init></decl>, <decl><type ref="prev"/><name>asize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>hmask</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name></expr></argument>, <argument><expr><name>tpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tref_isk</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lj_tab_set</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>tpl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <if_stmt><if>if <condition>(<expr><call><name>tvisnil</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>tpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>lj_tab_resize</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>tpl</name></expr></argument>, <argument><expr><name><name>tb</name><operator>-&gt;</operator><name>asize</name></name></expr></argument>, <argument><expr><name>nhbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>noderef</name><argument_list>(<argument><expr><name><name>tpl</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hmask</name> <operator>=</operator> <name><name>tpl</name><operator>-&gt;</operator><name>hmask</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>hmask</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	  <comment type="block">/* This is safe, since template tables only hold immutable values. */</comment>
	  <if_stmt><if>if <condition>(<expr><call><name>tvistab</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* The shape of the table may have changed. Clean up array part, too. */</comment>
	<expr_stmt><expr><name>asize</name> <operator>=</operator> <name><name>tpl</name><operator>-&gt;</operator><name>asize</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>tvref</name><argument_list>(<argument><expr><name><name>tpl</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>asize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><call><name>tvistab</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>retryrec</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Abort the trace at the end of recording. */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Record bounds-check. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_idx_abc</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>asizeref</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>ikey</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>asize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Try to emit invariant bounds checks. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>JIT_F_OPT_LOOP</name><operator>|</operator><name>JIT_F_OPT_ABC</name><operator>)</operator><operator>)</operator> <operator>==</operator>
      <operator>(</operator><name>JIT_F_OPT_LOOP</name><operator>|</operator><name>JIT_F_OPT_ABC</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>ikey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>ofs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ofsref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Handle constant offsets. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_ADD</name> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ofsref</name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ofs</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>ofsref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Got scalar evolution analysis results for this reference? */</comment>
    <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>==</operator> <name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>idx</name></name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>stop</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>irt_isint</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_SLOAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stop</name> <operator>=</operator> <call><name>numberVint</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name><operator>)</operator><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>+</operator> <name>FORL_STOP</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Runtime value for stop of loop is within bounds? */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>stop</name> <operator>+</operator> <name>ofs</name> <operator>&lt;</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>asize</name></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Emit invariant bounds check for stop. */</comment>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_ABC</name></expr></argument>, <argument><expr><name>IRT_P32</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>asizeref</name></expr></argument>, <argument><expr><ternary><condition><expr><name>ofs</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>stop</name></name></expr> </then><else>:
	       <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>stop</name></name></expr></argument>, <argument><expr><name>ofsref</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Emit invariant bounds check for start, if not const or negative. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>dir</name></name> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>start</name></name> <operator>&amp;&amp;</operator>
	      <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>IR</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name> <operator>+</operator> <name>ofs</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_ABC</name></expr></argument>, <argument><expr><name>IRT_P32</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>asizeref</name></expr></argument>, <argument><expr><name>ikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_ABC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>asizeref</name></expr></argument>, <argument><expr><name>ikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Emit regular bounds check. */</comment>
</block_content>}</block></function>

<comment type="block">/* Record indexed key lookup. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>rec_idx_key</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordIndex</name> <modifier>*</modifier></type><name>ix</name></decl></parameter>, <parameter><decl><type><name>IRRef</name> <modifier>*</modifier></type><name>rbref</name></decl></parameter>,
			<parameter><decl><type><name>IRType1</name> <modifier>*</modifier></type><name>rbguard</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>tabV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>oldv</name></name> <operator>=</operator> <call><name>lj_tab_get</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Lookup previous value. */</comment>
  <expr_stmt><expr><operator>*</operator><name>rbref</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rbguard</name><operator>-&gt;</operator><name>irt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Integer keys are looked up in the array part first. */</comment>
  <expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isnumber</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>numberVint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>numV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <name>LJ_MAX_ASIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>MSize</name><operator>)</operator><name>k</name> <operator>&lt;</operator> <name>LJ_MAX_ASIZE</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Potential array key? */</comment>
      <decl_stmt><decl><type><name>TRef</name></type> <name>ikey</name> <init>= <expr><call><name>lj_opt_narrow_index</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TRef</name></type> <name>asizeref</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><name>IRFL_TAB_ASIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>MSize</name><operator>)</operator><name>k</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>asize</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Currently an array key? */</comment>
	<decl_stmt><decl><type><name>TRef</name></type> <name>arrayref</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>rec_idx_abc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>asizeref</name></expr></argument>, <argument><expr><name>ikey</name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arrayref</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><name>IRFL_TAB_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_AREF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arrayref</name></expr></argument>, <argument><expr><name>ikey</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Currently not in array (may be an array extension)? */</comment>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_ULE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>asizeref</name></expr></argument>, <argument><expr><name>ikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Inv. bounds check. */</comment>
	<if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>tref_isk</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>lj_ir_knum_zero</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Canonicalize 0 or +-0.0 to +0.0. */</comment>
	<comment type="block">/* And continue with the hash lookup. */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>tref_isk</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* We can rule out const numbers which failed the integerness test
      ** above. But all other numbers are potential array keys.
      */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* True sparse tables have an empty array part. */</comment>
	<comment type="block">/* Guard that the array part stays empty. */</comment>
	<decl_stmt><decl><type><name>TRef</name></type> <name>tmp</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><name>IRFL_TAB_ASIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYITMIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Otherwise the key is located in the hash part. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Shortcut for empty hash part. */</comment>
    <comment type="block">/* Guard that the hash part stays empty. */</comment>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tmp</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><name>IRFL_TAB_HMASK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>lj_ir_kkptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>niltvg</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Hash keys are based on numbers, not ints. */</comment>
    <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isk</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Optimize lookup of constant hash keys. */</comment>
    <decl_stmt><decl><type><name>MSize</name></type> <name>hslot</name> <init>= <expr><operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>ix</name><operator>-&gt;</operator><name>oldv</name></name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index><operator>.</operator><name>val</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>hslot</name> <operator>&lt;=</operator> <name><name>t</name><operator>-&gt;</operator><name>hmask</name></name><operator>*</operator><operator>(</operator><name>MSize</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator>
	<name>hslot</name> <operator>&lt;=</operator> <literal type="number">65535</literal><operator>*</operator><operator>(</operator><name>MSize</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>node</name></decl>, <decl><type ref="prev"/><name>kslot</name></decl>, <decl><type ref="prev"/><name>hm</name></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>rbref</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name></expr>;</expr_stmt>  <comment type="block">/* Mark possible rollback point. */</comment>
      <expr_stmt><expr><operator>*</operator><name>rbguard</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>guardemit</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>hm</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><name>IRFL_TAB_HMASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hm</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><name>IRFL_TAB_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>kslot</name> <operator>=</operator> <call><name>lj_ir_kslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hslot</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_HREFK</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>kslot</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Fall back to a regular hash lookup. */</comment>
  <return>return <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HREF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Determine whether a key is NOT one of the fast metamethod names. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nommstr</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isstr</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isk</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>ir_kstr</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>mm</name></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>mm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>mm</name> <operator>&lt;=</operator> <name>MM_FAST</name></expr>;</condition> <incr><expr><name>mm</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	<if_stmt><if>if <condition>(<expr><call><name>mmname_str</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>str</name></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>  <comment type="block">/* MUST be one the fast metamethod names. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Variable string key MAY be a metamethod name. */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* CANNOT be a metamethod name. */</comment>
</block_content>}</block></function>

<comment type="block">/* Record indexed load/store. */</comment>
<function><type><name>TRef</name></type> <name>lj_record_idx</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>RecordIndex</name> <modifier>*</modifier></type><name>ix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>xref</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IROp</name></type> <name>xrefop</name></decl>, <decl><type ref="prev"/><name>loadop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>rbref</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRType1</name></type> <name>rbguard</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>oldv</name></decl>;</decl_stmt>

  <while>while <condition>(<expr><operator>!</operator><call><name>tref_istab</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <comment type="block">/* Handle non-table lookup. */</comment>
    <comment type="block">/* Never call raw lj_record_idx() on non-table. */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>idxchain</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr> ?</condition><then> <expr><name>MM_newindex</name></expr> </then><else>: <expr><name>MM_index</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NOMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <label><name>handlemm</name>:</label>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isfunc</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>mobj</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Handle metamethod call. */</comment>
      <decl_stmt><decl><type><name>BCReg</name></type> <name>func</name> <init>= <expr><call><name>rec_mm_prep</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr> ?</condition><then> <expr><name>lj_cont_nop</name></expr> </then><else>: <expr><name>lj_cont_ra</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TRef</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>func</name> <operator>+</operator> <name>LJ_FR2</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>func</name> <operator>+</operator> <name>LJ_FR2</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>base</name><index>[<expr><operator>-</operator><name>LJ_FR2</name></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>mobj</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>base</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>base</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setfuncV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>tv</name><operator>-</operator><name>LJ_FR2</name></expr></argument>, <argument><expr><call><name>funcV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>mobjv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>tv</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>tv</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>base</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>tv</name><operator>+</operator><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>valv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lj_record_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* mobj(tab, key, val) */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>lj_record_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* res = mobj(tab, key) */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* No result yet. */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Otherwise retry lookup with metaobject. */</comment>
    <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name> <operator>=</operator> <name><name>ix</name><operator>-&gt;</operator><name>mobj</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>mobjv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>ix</name><operator>-&gt;</operator><name>idxchain</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_IDXLOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* First catch nil and NaN keys for tables. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>tvisnum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tvisnan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>keyv</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Better fail early. */</comment>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_STORENN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isk</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>ix</name><operator>-&gt;</operator><name>idxchain</name></name> <operator>&amp;&amp;</operator> <call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>MM_index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<goto>goto <name>handlemm</name>;</goto></block_content></block></if></if_stmt>
      <return>return <expr><name>TREF_NIL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Record the key lookup. */</comment>
  <expr_stmt><expr><name>xref</name> <operator>=</operator> <call><name>rec_idx_key</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rbref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rbguard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>xrefop</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>xref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>o</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>loadop</name> <operator>=</operator> <ternary><condition><expr><name>xrefop</name> <operator>==</operator> <name>IR_AREF</name></expr> ?</condition><then> <expr><name>IR_ALOAD</name></expr> </then><else>: <expr><name>IR_HLOAD</name></expr></else></ternary></expr>;</expr_stmt>
  <comment type="block">/* The lj_meta_tset() inconsistency is gone, but better play safe. */</comment>
  <expr_stmt><expr><name>oldv</name> <operator>=</operator> <ternary><condition><expr><name>xrefop</name> <operator>==</operator> <name>IR_KKPTR</name></expr> ?</condition><then> <expr><operator>(</operator><name>cTValue</name> <operator>*</operator><operator>)</operator><call><name>ir_kptr</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>xref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>ix</name><operator>-&gt;</operator><name>oldv</name></name></expr></else></ternary></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>ix</name><operator>-&gt;</operator><name>val</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Indexed load */</comment>
    <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><call><name>itype2irt</name><argument_list>(<argument><expr><name>oldv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>res</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>oldv</name> <operator>==</operator> <call><name>niltvg</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xref</name></expr></argument>, <argument><expr><call><name>lj_ir_kkptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>niltvg</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>loadop</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>rbref</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* HREFK + load forwarded? */</comment>
      <expr_stmt><expr><call><name>lj_ir_rollback</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rbref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Rollback to eliminate hmask guard. */</comment>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>guardemit</name></name> <operator>=</operator> <name>rbguard</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>IRT_NIL</name> <operator>&amp;&amp;</operator> <name><name>ix</name><operator>-&gt;</operator><name>idxchain</name></name> <operator>&amp;&amp;</operator> <call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>MM_index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <goto>goto <name>handlemm</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>irtype_ispri</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>TREF_PRI</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Canonicalize primitives. */</comment>
    <return>return <expr><name>res</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Indexed store. */</comment>
    <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><call><name>tabref</name><argument_list>(<argument><expr><call><name>tabV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>-&gt;</operator><name>tabv</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>keybarrier</name> <init>= <expr><call><name>tref_isgcv</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tref_isnil</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>xref</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>rbref</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* HREFK forwarded? */</comment>
      <expr_stmt><expr><call><name>lj_ir_rollback</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rbref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Rollback to eliminate hmask guard. */</comment>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>guardemit</name></name> <operator>=</operator> <name>rbguard</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tvisnil</name><argument_list>(<argument><expr><name>oldv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Previous value was nil? */</comment>
      <comment type="block">/* Need to duplicate the hasmm check for the early guards. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>hasmm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ix</name><operator>-&gt;</operator><name>idxchain</name></name> <operator>&amp;&amp;</operator> <name>mt</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>mo</name> <init>= <expr><call><name>lj_tab_getstr</name><argument_list>(<argument><expr><name>mt</name></expr></argument>, <argument><expr><call><name>mmname_str</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MM_newindex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>hasmm</name> <operator>=</operator> <name>mo</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>hasmm</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>loadop</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* Guard for nil value. */</comment>
      <if type="elseif">else if <condition>(<expr><name>xrefop</name> <operator>==</operator> <name>IR_HREF</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><ternary><condition><expr><name>oldv</name> <operator>==</operator> <call><name>niltvg</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IR_EQ</name></expr> </then><else>: <expr><name>IR_NE</name></expr></else></ternary></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>,
	       <argument><expr><name>xref</name></expr></argument>, <argument><expr><call><name>lj_ir_kkptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>niltvg</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ix</name><operator>-&gt;</operator><name>idxchain</name></name> <operator>&amp;&amp;</operator> <call><name>lj_record_mm_lookup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>, <argument><expr><name>MM_newindex</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>hasmm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<goto>goto <name>handlemm</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><name>hasmm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>oldv</name> <operator>==</operator> <call><name>niltvg</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Need to insert a new key. */</comment>
	<decl_stmt><decl><type><name>TRef</name></type> <name>key</name> <init>= <expr><name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* NEWREF needs a TValue as a key. */</comment>
	  <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>xref</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_NEWREF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>keybarrier</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* NEWREF already takes care of the key barrier. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUAJIT_ENABLE_TABLE_BUMP</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_SINK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Avoid a separate flag. */</comment>
	  <expr_stmt><expr><call><name>rec_idx_bump</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>lj_opt_fwd_wasnonnil</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>loadop</name></expr></argument>, <argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>xref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Cannot derive that the previous value was non-nil, must do checks. */</comment>
      <if_stmt><if>if <condition>(<expr><name>xrefop</name> <operator>==</operator> <name>IR_HREF</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Guard against store to niltv. */</comment>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_NE</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xref</name></expr></argument>, <argument><expr><call><name>lj_ir_kkptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>niltvg</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ix</name><operator>-&gt;</operator><name>idxchain</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Metamethod lookup required? */</comment>
	<comment type="block">/* A check for NULL metatable is cheaper (hoistable) than a load. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mt</name></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>TRef</name></type> <name>mtref</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><name>IRFL_TAB_META</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mtref</name></expr></argument>, <argument><expr><call><name>lj_ir_knull</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><call><name>itype2irt</name><argument_list>(<argument><expr><name>oldv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>loadop</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Guard for non-nil value. */</comment>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>keybarrier</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Previous non-nil value kept the key alive. */</comment>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* Convert int to number before storing. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LJ_DUALNUM</name> <operator>&amp;&amp;</operator> <call><name>tref_isinteger</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>ix</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>loadop</name><operator>+</operator><name>IRDELTA_L2S</name></expr></argument>, <argument><expr><call><name>tref_type</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xref</name></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>keybarrier</name> <operator>||</operator> <call><name>tref_isgcv</name><argument_list>(<argument><expr><name><name>ix</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_TBAR</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Invalidate neg. metamethod cache for stores with certain string keys. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>nommstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>fref</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FREF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ix</name><operator>-&gt;</operator><name>tab</name></name></expr></argument>, <argument><expr><name>IRFL_TAB_NOMM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FSTORE</name></expr></argument>, <argument><expr><name>IRT_U8</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fref</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_tsetm</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>ra</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>rn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>RecordIndex</name></type> <name>ix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>basev</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>tabV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>basev</name><index>[<expr><name>ra</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>tabv</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>idxchain</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUAJIT_ENABLE_TABLE_BUMP</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_SINK</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name> <operator>&lt;</operator> <name>i</name><operator>+</operator><name>rn</name><operator>-</operator><name>ra</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_tab_reasize</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name>rn</name><operator>-</operator><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>keyv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rec_idx_bump</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for <control>(<init>;</init> <condition><expr><name>ra</name> <operator>&lt;</operator> <name>rn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ra</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>keyv</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>key</name></name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>valv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>basev</name><index>[<expr><name>ra</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_record_idx</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* -- Upvalue access ------------------------------------------------------ */</comment>

<comment type="block">/* Check whether upvalue is immutable and ok to constify. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rec_upvalue_constify</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>GCupval</name> <modifier>*</modifier></type><name>uvp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>uvp</name><operator>-&gt;</operator><name>immutable</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>uvval</name><argument_list>(<argument><expr><name>uvp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Don't constify objects that may retain large amounts of memory. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>tviscdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>cdataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cdataisv</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>cd</name><operator>-&gt;</operator><name>marked</name></name> <operator>&amp;</operator> <name>LJ_GC_CDATA_FIN</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_hassize</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;=</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>tvistab</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>tvisudata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>tvisthread</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Record upvalue load/store. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>rec_upvalue</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>uv</name></decl></parameter>, <parameter><decl><type><name>TRef</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCupval</name> <modifier>*</modifier></type><name>uvp</name> <init>= <expr><operator>&amp;</operator><call><name>gcref</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>fn</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>uvptr</name><index>[<expr><name>uv</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>uv</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>fn</name> <init>= <expr><call><name>getcurrf</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>uref</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>needbarrier</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>rec_upvalue_constify</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>uvp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Try to constify immutable upvalue. */</comment>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name></decl>, <decl><type ref="prev"/><name>kfunc</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>val</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tref_isk</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Late specialization of current function. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&gt;=</operator> <name>PROTO_CLC_POLY</name></expr>)</condition><block type="pseudo"><block_content>
	<goto>goto <name>noconstify</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>kfunc</name> <operator>=</operator> <call><name>lj_ir_kfunc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>fn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_FUNC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>kfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>kfunc</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>kfunc</name> <operator>|</operator> <name>TREF_FRAME</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>fn</name> <operator>=</operator> <name>kfunc</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>lj_record_constify</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>uvval</name><argument_list>(<argument><expr><name>uvp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>tr</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>tr</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<label><name>noconstify</name>:</label>
  <comment type="block">/* Note: this effectively limits LJ_MAX_UPVAL to 127. */</comment>
  <expr_stmt><expr><name>uv</name> <operator>=</operator> <operator>(</operator><name>uv</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><call><name>hashrot</name><argument_list>(<argument><expr><name><name>uvp</name><operator>-&gt;</operator><name>dhash</name></name></expr></argument>, <argument><expr><name><name>uvp</name><operator>-&gt;</operator><name>dhash</name></name> <operator>+</operator> <name>HASH_BIAS</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>uvp</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>uref</name> <operator>=</operator> <call><name>tref_ref</name><argument_list>(<argument><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_UREFO</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* In current stack? */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>uvval</name><argument_list>(<argument><expr><name>uvp</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>tvref</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	<call><name>uvval</name><argument_list>(<argument><expr><name>uvp</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>tvref</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>maxstack</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>slot</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><call><name>uvval</name><argument_list>(<argument><expr><name>uvp</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Aliases an SSA slot? */</comment>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>,
	       <argument><expr><name>REF_BASE</name></expr></argument>,
	       <argument><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uref</name></expr></argument>,
		      <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>slot</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>LJ_FR2</name><operator>)</operator> <operator>*</operator> <operator>-</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>-=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name></expr>;</expr_stmt>  <comment type="block">/* Note: slot number may be negative! */</comment>
	<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	  <return>return <expr><call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>&gt;=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><operator>(</operator><name>slot</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_UGT</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>,
	   <argument><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_SUB</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uref</name></expr></argument>, <argument><expr><name>REF_BASE</name></expr></argument>)</argument_list></call></expr></argument>,
	   <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name><operator>)</operator> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>needbarrier</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>uref</name> <operator>=</operator> <call><name>tref_ref</name><argument_list>(<argument><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_UREFC</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Upvalue load */</comment>
    <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><call><name>itype2irt</name><argument_list>(<argument><expr><call><name>uvval</name><argument_list>(<argument><expr><name>uvp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>res</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_ULOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>irtype_ispri</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>TREF_PRI</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Canonicalize primitive refs. */</comment>
    <return>return <expr><name>res</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Upvalue store. */</comment>
    <comment type="block">/* Convert int to number before storing. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LJ_DUALNUM</name> <operator>&amp;&amp;</operator> <call><name>tref_isinteger</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_USTORE</name></expr></argument>, <argument><expr><call><name>tref_type</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uref</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>needbarrier</name> <operator>&amp;&amp;</operator> <call><name>tref_isgcv</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_OBAR</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uref</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Record calls to Lua functions --------------------------------------- */</comment>

<comment type="block">/* Check unroll limits for calls. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>check_call_unroll</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TraceNo</name></type> <name>lnk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>mref</name><argument_list>(<argument><expr><call><name>frame_func</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>l</name><operator>.</operator><name>pc</name></name></expr></argument>, <argument><expr><name>void</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>depth</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTO_VARARG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>depth</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Vararg frame still missing. */</comment>
  <for>for <control>(<init>;</init> <condition><expr><name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>depth</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* Count frames with same prototype. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>frame_iscont</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>depth</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prev</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>mref</name><argument_list>(<argument><expr><call><name>frame_func</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>l</name><operator>.</operator><name>pc</name></name></expr></argument>, <argument><expr><name>void</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pc</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name> <operator>==</operator> <name><name>J</name><operator>-&gt;</operator><name>startpc</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>tailcalled</name></name> <operator>&gt;</operator> <name><name>J</name><operator>-&gt;</operator><name>param</name><index>[<expr><name>JIT_P_recunroll</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>retdepth</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_record_stop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRLINK_TAILREC</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>traceno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* Tail-rec. */</comment>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_record_stop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRLINK_UPREC</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>traceno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* Up-recursion. */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name><name>J</name><operator>-&gt;</operator><name>param</name><index>[<expr><name>JIT_P_callunroll</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>lnk</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Possible tail- or up-recursion. */</comment>
	<expr_stmt><expr><call><name>lj_trace_flush</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>lnk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Flush trace that only returns. */</comment>
	<comment type="block">/* Set a small, pseudo-random hotcount for a quick retry of JFUNC*. */</comment>
	<expr_stmt><expr><call><name>hotcount_set</name><argument_list>(<argument><expr><call><name>J2GG</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>LJ_PRNG_BITS</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_CUNROLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Record Lua function setup. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_func_setup</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>numparams</name> <init>= <expr><name><name>pt</name><operator>-&gt;</operator><name>numparams</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTO_NOJIT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_CJITOFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>+</operator> <name><name>pt</name><operator>-&gt;</operator><name>framesize</name></name> <operator>&gt;=</operator> <name>LJ_MAX_JSLOTS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_STACKOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <comment type="block">/* Fill up missing parameters with nil. */</comment>
  <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>numparams</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt></block_content></block></for>
  <comment type="block">/* The remaining slots should never be read before they are written. */</comment>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>numparams</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record Lua vararg function setup. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_func_vararg</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>fixargs</name></decl>, <decl><type ref="prev"/><name>vframe</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTO_VARARG</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>+</operator> <name>vframe</name> <operator>+</operator> <name><name>pt</name><operator>-&gt;</operator><name>framesize</name></name> <operator>&gt;=</operator> <name>LJ_MAX_JSLOTS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_STACKOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>vframe</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name></expr>;</expr_stmt>  <comment type="block">/* Copy function up. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>vframe</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>TREF_FRAME</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* Copy fixarg slots up and set their original slots to nil. */</comment>
  <expr_stmt><expr><name>fixargs</name> <operator>=</operator> <ternary><condition><expr><name><name>pt</name><operator>-&gt;</operator><name>numparams</name></name> <operator>&lt;</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr> ?</condition><then> <expr><name><name>pt</name><operator>-&gt;</operator><name>numparams</name></name></expr> </then><else>: <expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr></else></ternary></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>fixargs</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>vframe</name><operator>+</operator><name>s</name></expr>]</index></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>s</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>fixargs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>+=</operator> <name>vframe</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>+=</operator> <name>vframe</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record entry to a Lua function. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_func_lua</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>rec_func_setup</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_call_unroll</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record entry to an already compiled function. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_func_jit</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>TraceNo</name></type> <name>lnk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>rec_func_setup</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>T</name> <operator>=</operator> <call><name>traceref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>lnk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>T</name><operator>-&gt;</operator><name>linktype</name></name> <operator>==</operator> <name>LJ_TRLINK_RETURN</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Trace returns to interpreter? */</comment>
    <expr_stmt><expr><call><name>check_call_unroll</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>lnk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Temporarily unpatch JFUNC* to continue recording across function. */</comment>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>patchins</name></name> <operator>=</operator> <operator>*</operator><name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>patchpc</name></name> <operator>=</operator> <operator>(</operator><name>BCIns</name> <operator>*</operator><operator>)</operator><name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name><name>J</name><operator>-&gt;</operator><name>patchpc</name></name> <operator>=</operator> <name><name>T</name><operator>-&gt;</operator><name>startins</name></name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>instunroll</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Cannot continue across a compiled function. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name> <operator>==</operator> <name><name>J</name><operator>-&gt;</operator><name>startpc</name></name> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>retdepth</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_record_stop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRLINK_TAILREC</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>traceno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* Extra tail-rec. */</comment>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_record_stop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRLINK_ROOT</name></expr></argument>, <argument><expr><name>lnk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* Link to the function. */</comment>
</block_content>}</block></function>

<comment type="block">/* -- Vararg handling ----------------------------------------------------- */</comment>

<comment type="block">/* Detect y = select(x, ...) idiom. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>select_detect</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCIns</name></type> <name>ins</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>pc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_CALLM</name> <operator>&amp;&amp;</operator> <call><name>bc_b</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>bc_c</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tvisfunc</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>funcV</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>ffid</name></name> <operator>==</operator> <name>FF_select</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TRef</name></type> <name>kfunc</name> <init>= <expr><call><name>lj_ir_kfunc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>funcV</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>, <argument><expr><name>IRT_FUNC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>kfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Record vararg instruction. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_varg</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>nresults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>numparams</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>pt</name><operator>-&gt;</operator><name>numparams</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>nvararg</name> <init>= <expr><call><name>frame_delta</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator> <name>numparams</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>LJ_FR2</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>frame_isvarg</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>LJ_FR2</name> <operator>&amp;&amp;</operator> <name>dst</name> <operator>&gt;</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>dst</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Prevent resurrection of unrelated slot. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Simple case: varargs defined on-trace. */</comment>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nvararg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nvararg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>nresults</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>nresults</name> <operator>=</operator> <name>nvararg</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>dst</name> <operator>+</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><name>nvararg</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dst</name> <operator>+</operator> <name>nresults</name> <operator>&gt;</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>dst</name> <operator>+</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><name>nresults</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nresults</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>dst</name><operator>+</operator><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>&lt;</operator> <name>nvararg</name></expr> ?</condition><then> <expr><call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <name>nvararg</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>LJ_FR2</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>TREF_NIL</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Unknown number of varargs passed to trace. */</comment>
    <decl_stmt><decl><type><name>TRef</name></type> <name>fr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_SLOAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LJ_FR2</name></expr></argument>, <argument><expr><name>IRSLOAD_READONLY</name><operator>|</operator><name>IRSLOAD_FRAME</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>frofs</name> <init>= <expr><literal type="number">8</literal><operator>*</operator><operator>(</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name><operator>+</operator><name>numparams</name><operator>)</operator><operator>+</operator><name>FRAME_VARG</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nresults</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Known fixed number of results. */</comment>
      <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>i</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>nvararg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>nload</name> <init>= <expr><ternary><condition><expr><name>nvararg</name> <operator>&gt;=</operator> <name>nresults</name></expr> ?</condition><then> <expr><name>nresults</name></expr> </then><else>: <expr><name>nvararg</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TRef</name></type> <name>vbase</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>nvararg</name> <operator>&gt;=</operator> <name>nresults</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_GE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>frofs</name><operator>+</operator><literal type="number">8</literal><operator>*</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>nresults</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fr</name></expr></argument>,
		 <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>frame_ftsz</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>vbase</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_SUB</name></expr></argument>, <argument><expr><name>IRT_IGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>REF_BASE</name></expr></argument>, <argument><expr><name>fr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vbase</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>vbase</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>frofs</name><operator>-</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nload</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	  <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><call><name>itype2irt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name><operator>-</operator><name>nvararg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>TRef</name></type> <name>aref</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_AREF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>,
			     <argument><expr><name>vbase</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_VLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <if_stmt><if>if <condition>(<expr><call><name>irtype_ispri</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>TREF_PRI</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Canonicalize primitives. */</comment>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>dst</name><operator>+</operator><name>i</name></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
	</block_content>}</block></for>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_LE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>frofs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nvararg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nvararg</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nresults</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>dst</name><operator>+</operator><name>i</name></expr>]</index></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt></block_content></block></for>
      <if_stmt><if>if <condition>(<expr><name>dst</name> <operator>+</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><name>nresults</name> <operator>&gt;</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>dst</name> <operator>+</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><name>nresults</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>select_detect</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* y = select(x, ...) */</comment>
      <decl_stmt><decl><type><name>TRef</name></type> <name>tridx</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>dst</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name>TREF_NIL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>idx</name> <init>= <expr><call><name>lj_ffrecord_select_mode</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>tridx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>dst</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>nyivarg</name>;</goto></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>tridx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>tridx</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tridx</name></expr></argument>, <argument><expr><name>IRCONV_INT_NUM</name><operator>|</operator><name>IRCONV_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>tref_isk</name><argument_list>(<argument><expr><name>tridx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><ternary><condition><expr><name>idx</name> <operator>&lt;=</operator> <name>nvararg</name></expr> ?</condition><then> <expr><name>IR_GE</name></expr> </then><else>: <expr><name>IR_LT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
	       <argument><expr><name>fr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>frofs</name><operator>+</operator><literal type="number">8</literal><operator>*</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>frofs</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>  <comment type="block">/* Bias for 1-based index. */</comment>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>idx</name> <operator>&lt;=</operator> <name>nvararg</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Compute size. */</comment>
	<decl_stmt><decl><type><name>TRef</name></type> <name>tmp</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>-</operator><name>frofs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>numparams</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_GE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSHR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>tridx</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tridx</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>rec_idx_abc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>tridx</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>nvararg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<decl_stmt><decl><type><name>TRef</name></type> <name>tmp</name> <init>= <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>frofs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>TRef</name></type> <name>tmp2</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSHL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tridx</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp2</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_LT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fr</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>idx</name> <operator>&lt;=</operator> <name>nvararg</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>IRType</name></type> <name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TRef</name></type> <name>aref</name></decl>, <decl><type ref="prev"/><name>vbase</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_SUB</name></expr></argument>, <argument><expr><name>IRT_IGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>REF_BASE</name></expr></argument>, <argument><expr><name>fr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>vbase</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>vbase</name></expr></argument>,
		       <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>frofs</name><operator>-</operator><operator>(</operator><literal type="number">8</literal><operator>&lt;&lt;</operator><name>LJ_FR2</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>itype2irt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>idx</name><operator>-</operator><literal type="number">2</literal><operator>-</operator><name>LJ_FR2</name><operator>-</operator><name>nvararg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aref</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_AREF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>vbase</name></expr></argument>, <argument><expr><name>tridx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_VLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>irtype_ispri</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>TREF_PRI</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Canonicalize primitives. */</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>dst</name><operator>-</operator><literal type="number">2</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>dst</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>bcskip</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>  <comment type="block">/* Skip CALLM + select. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
    <label><name>nyivarg</name>:</label>
      <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>errinfo</name></name></expr></argument>, <argument><expr><name>BC_VARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lj_trace_err_info</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYIBC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>&gt;=</operator> <name>LJ_MAX_JSLOTS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_STACKOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Record allocations -------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>TRef</name></type> <name>rec_tnew</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>ah</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>asize</name> <init>= <expr><name>ah</name> <operator>&amp;</operator> <literal type="number">0x7ff</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>hbits</name> <init>= <expr><name>ah</name> <operator>&gt;&gt;</operator> <literal type="number">11</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>asize</name> <operator>==</operator> <literal type="number">0x7ff</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>asize</name> <operator>=</operator> <literal type="number">0x801</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_TNEW</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>asize</name></expr></argument>, <argument><expr><name>hbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUAJIT_ENABLE_TABLE_BUMP</name></cpp:ifdef>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>rbchash</name><index>[<expr><operator>(</operator><name>tr</name> <operator>&amp;</operator> <operator>(</operator><name>RBCHASH_SLOTS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>]</index></name><operator>.</operator><name>ref</name> <operator>=</operator> <call><name>tref_ref</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>rbchash</name><index>[<expr><operator>(</operator><name>tr</name> <operator>&amp;</operator> <operator>(</operator><name>RBCHASH_SLOTS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>]</index></name><operator>.</operator><name>pc</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>rbchash</name><index>[<expr><operator>(</operator><name>tr</name> <operator>&amp;</operator> <operator>(</operator><name>RBCHASH_SLOTS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>]</index></name><operator>.</operator><name>pt</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>tr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Concatenation ------------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>TRef</name></type> <name>rec_cat</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>baseslot</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>topslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name> <modifier>*</modifier></type><name>top</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>topslot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name></type> <name><name>savetv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RecordIndex</name></type> <name>ix</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>baseslot</name> <operator>&lt;</operator> <name>topslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>baseslot</name></expr>;</init> <condition><expr><name>s</name> <operator>&lt;=</operator> <name>topslot</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>  <comment type="block">/* Ensure all arguments have a reference. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>tref_isnumber_str</name><argument_list>(<argument><expr><name><name>top</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tref_isnumber_str</name><argument_list>(<argument><expr><name><name>top</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name></decl>, <decl><type ref="prev"/><name>hdr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>trp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>xbase</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>base</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>baseslot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* First convert numbers to strings. */</comment>
    <for>for <control>(<init><expr><name>trp</name> <operator>=</operator> <name>top</name></expr>;</init> <condition><expr><name>trp</name> <operator>&gt;=</operator> <name>base</name></expr>;</condition> <incr><expr><name>trp</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>tref_isnumber</name><argument_list>(<argument><expr><operator>*</operator><name>trp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><operator>*</operator><name>trp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_TOSTR</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>trp</name></expr></argument>,
		      <argument><expr><ternary><condition><expr><call><name>tref_isnum</name><argument_list>(<argument><expr><operator>*</operator><name>trp</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRTOSTR_NUM</name></expr> </then><else>: <expr><name>IRTOSTR_INT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>tref_isstr</name><argument_list>(<argument><expr><operator>*</operator><name>trp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>xbase</name> <operator>=</operator> <operator>++</operator><name>trp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <name>hdr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFHDR</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr><call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tmpbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IRBUFHDR_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do <block>{<block_content>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFPUT</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><operator>*</operator><name>trp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>trp</name> <operator>&lt;=</operator> <name>top</name></expr>)</condition>;</do>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BUFSTR</name></expr></argument>, <argument><expr><name>IRT_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><operator>(</operator><name>xbase</name> <operator>-</operator> <name><name>J</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>xbase</name> <operator>==</operator> <name>base</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>tr</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Return simple concatenation result. */</comment>
    <comment type="block">/* Pass partial result. */</comment>
    <expr_stmt><expr><name>topslot</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>xbase</name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>top</name> <operator>=</operator> <name>xbase</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>keyv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>strempty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Simulate string result. */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>topslot</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>keyv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>topslot</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>tabv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>topslot</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <name><name>top</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name><name>top</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>savetv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>topslot</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>savetv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Save slots. */</comment>
  <expr_stmt><expr><call><name>rec_mm_arith</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name>MM_concat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Call __concat metamethod. */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>topslot</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>savetv</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>savetv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Restore slots. */</comment>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* No result yet. */</comment>
</block_content>}</block></function>

<comment type="block">/* -- Record bytecode ops ------------------------------------------------- */</comment>

<comment type="block">/* Prepare for comparison. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_comp_prep</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent merging with snapshot #0 (GC exit) since we fixup the PC. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nsnap</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ref</name> <operator>==</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>emitir_raw</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_NOP</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_snap_add</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Fixup comparison. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rec_comp_fixup</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cond</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCIns</name></type> <name>jmpins</name> <init>= <expr><name><name>pc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>npc</name> <init>= <expr><name>pc</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>cond</name></expr> ?</condition><then> <expr><call><name>bc_j</name><argument_list>(<argument><expr><name>jmpins</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SnapShot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snap</name><index>[<expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nsnap</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Set PC to opposite target to avoid re-recording the comp. in side trace. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
  <decl_stmt><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>flink</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snapmap</name><index>[<expr><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name> <operator>+</operator> <name><name>snap</name><operator>-&gt;</operator><name>nent</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>pcbase</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbase</name></expr></argument>, <argument><expr><name>flink</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pcbase</name> <operator>=</operator> <operator>(</operator><name>pcbase</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><call><name>u64ptr</name><argument_list>(<argument><expr><name>npc</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>flink</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcbase</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snapmap</name><index>[<expr><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name> <operator>+</operator> <name><name>snap</name><operator>-&gt;</operator><name>nent</name></name></expr>]</index></name> <operator>=</operator> <call><name>SNAP_MKPC</name><argument_list>(<argument><expr><name>npc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>bc_a</name><argument_list>(<argument><expr><name>jmpins</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <call><name>bc_a</name><argument_list>(<argument><expr><name>jmpins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_snap_shrink</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Shrink last snapshot if possible. */</comment>
</block_content>}</block></function>

<comment type="block">/* Record the next bytecode instruction (_before_ it's executed). */</comment>
<function><type><name>void</name></type> <name>lj_record_ins</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>lbase</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RecordIndex</name></type> <name>ix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCIns</name></type> <name>ins</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCOp</name></type> <name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>ra</name></decl>, <decl><type ref="prev"/><name>rb</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* Perform post-processing action before recording the next instruction. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>!=</operator> <name>LJ_POST_NONE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LJ_POST_FIXCOMP</name></expr>:</case>  <comment type="block">/* Fixup comparison. */</comment>
      <expr_stmt><expr><name>pc</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>BCIns</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>tmptv</name><operator>.</operator><name>u64</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>rec_comp_fixup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><operator>(</operator><operator>!</operator><call><name>tvistruecond</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tmptv2</name></expr></argument>)</argument_list></call> <operator>^</operator> <operator>(</operator><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><name>LJ_POST_FIXGUARD</name></expr>:</case>  <comment type="block">/* Fixup and emit pending guard. */</comment>
    <case>case <expr><name>LJ_POST_FIXGUARDSNAP</name></expr>:</case>  <comment type="block">/* Fixup and emit pending guard and snapshot. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvistruecond</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tmptv2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>fold</name><operator>.</operator><name>ins</name><operator>.</operator><name>o</name></name> <operator>^=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Flip guard to opposite. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>==</operator> <name>LJ_POST_FIXGUARDSNAP</name></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>SnapShot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snap</name><index>[<expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nsnap</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snapmap</name><index>[<expr><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name><operator>+</operator><name><name>snap</name><operator>-&gt;</operator><name>nent</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* False -&gt; true. */</comment>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>lj_opt_fold</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Emit pending guard. */</comment>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><name>LJ_POST_FIXBOOL</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvistruecond</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tmptv2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>BCReg</name></type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* Fixup stack slot (if any). */</comment>
	  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>s</name></expr>]</index></name> <operator>==</operator> <name>TREF_TRUE</name> <operator>&amp;&amp;</operator> <call><name>tvisfalse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tv</name><index>[<expr><name>s</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <name>TREF_FALSE</name></expr>;</expr_stmt>
	    <break>break;</break>
	  </block_content>}</block></if></if_stmt></block_content></block></for>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>LJ_POST_FIXCONST</name></expr>:</case>
      <block>{<block_content>
	<decl_stmt><decl><type><name>BCReg</name></type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* Constify stack slots (if any). */</comment>
	  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>s</name></expr>]</index></name> <operator>==</operator> <name>TREF_NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tv</name><index>[<expr><name>s</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <call><name>lj_record_constify</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tv</name><index>[<expr><name>s</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
      </block_content>}</block>
      <break>break;</break>
    <case>case <expr><name>LJ_POST_FFRETRY</name></expr>:</case>  <comment type="block">/* Suppress recording of retried fast function. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>BC__MAX</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return;</return></block_content></block></if></if_stmt>
      <break>break;</break>
    <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>postproc</name></name> <operator>=</operator> <name>LJ_POST_NONE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Need snapshot before recording next bytecode (e.g. after a store). */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_snap_purge</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_snap_add</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>mergesnap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Skip some bytecodes. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>bcskip</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>bcskip</name></name><operator>--</operator></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Record only closed loops for root traces. */</comment>
  <expr_stmt><expr><name>pc</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
     <operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pc</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>J</name><operator>-&gt;</operator><name>bc_min</name></name><operator>)</operator> <operator>&gt;=</operator> <name><name>J</name><operator>-&gt;</operator><name>bc_extent</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_LLEAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUA_USE_ASSERT</name></cpp:ifdef>
  <expr_stmt><expr><call><name>rec_check_slots</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rec_check_ir</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASPROFILE</name></expr></cpp:if>
  <expr_stmt><expr><call><name>rec_profile_ins</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Keep a copy of the runtime values of var/num/str operands. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rav</name></cpp:macro>	<cpp:value>(&amp;ix.valv)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rbv</name></cpp:macro>	<cpp:value>(&amp;ix.tabv)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rcv</name></cpp:macro>	<cpp:value>(&amp;ix.keyv)</cpp:value></cpp:define>

  <expr_stmt><expr><name>lbase</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ins</name> <operator>=</operator> <operator>*</operator><name>pc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>bc_op</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ra</name> <operator>=</operator> <call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><call><name>bcmode_a</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>BCMvar</name></expr>:</case>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>rav</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lbase</name><index>[<expr><name>ra</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>ra</name> <operator>=</operator> <call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <default>default:</default> <break>break;</break>  <comment type="block">/* Handled later. */</comment>
  </block_content>}</block></switch>
  <expr_stmt><expr><name>rb</name> <operator>=</operator> <call><name>bc_b</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>bc_c</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><call><name>bcmode_b</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>BCMnone</name></expr>:</case> <expr_stmt><expr><name>rb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>bc_d</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>  <comment type="block">/* Upgrade rc to 'rd'. */</comment>
  <case>case <expr><name>BCMvar</name></expr>:</case>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>rbv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lbase</name><index>[<expr><name>rb</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <name>rb</name> <operator>=</operator> <call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <default>default:</default> <break>break;</break>  <comment type="block">/* Handled later. */</comment>
  </block_content>}</block></switch>
  <switch>switch <condition>(<expr><call><name>bcmode_c</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>BCMvar</name></expr>:</case>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>rcv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lbase</name><index>[<expr><name>rc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name>rc</name> <operator>=</operator> <call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>BCMpri</name></expr>:</case> <expr_stmt><expr><call><name>setpriV</name><argument_list>(<argument><expr><name>rcv</name></expr></argument>, <argument><expr><operator>~</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name>rc</name> <operator>=</operator> <call><name>TREF_PRI</name><argument_list>(<argument><expr><name>IRT_NIL</name><operator>+</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>BCMnum</name></expr>:</case> <block>{<block_content> <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>proto_knumtv</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>rcv</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name>rc</name> <operator>=</operator> <ternary><condition><expr><call><name>tvisint</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>intV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>:
    <expr><call><name>lj_ir_knumint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>numV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt> </block_content>}</block> <break>break;</break>
  <case>case <expr><name>BCMstr</name></expr>:</case> <block>{<block_content> <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>gco2str</name><argument_list>(<argument><expr><call><name>proto_kgc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>, <argument><expr><operator>~</operator><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>rcv</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name>rc</name> <operator>=</operator> <call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block> <break>break;</break>
  <default>default:</default> <break>break;</break>  <comment type="block">/* Handled later. */</comment>
  </block_content>}</block></switch>

  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>

  <comment type="block">/* -- Comparison ops ---------------------------------------------------- */</comment>

  <case>case <expr><name>BC_ISLT</name></expr>:</case> <case>case <expr><name>BC_ISGE</name></expr>:</case> <case>case <expr><name>BC_ISLE</name></expr>:</case> <case>case <expr><name>BC_ISGT</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>tref_iscdata</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>tref_iscdata</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>rec_mm_comp_cdata</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>op</name> <operator>&amp;</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><name>MM_le</name></expr> </then><else>: <expr><name>MM_lt</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Emit nothing for two numeric or string consts. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>tref_isk2</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><name>rc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tref_isnumber_str</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tref_isnumber_str</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRType</name></type> <name>ta</name> <init>= <expr><ternary><condition><expr><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRT_INT</name></expr> </then><else>: <expr><call><name>tref_type</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRType</name></type> <name>tc</name> <init>= <expr><ternary><condition><expr><call><name>tref_isinteger</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRT_INT</name></expr> </then><else>: <expr><call><name>tref_type</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>irop</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>ta</name> <operator>!=</operator> <name>tc</name></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Widen mixed number/int comparisons to number/number comparison. */</comment>
	<if_stmt><if>if <condition>(<expr><name>ta</name> <operator>==</operator> <name>IRT_INT</name> <operator>&amp;&amp;</operator> <name>tc</name> <operator>==</operator> <name>IRT_NUM</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>ra</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>ta</name> <operator>=</operator> <name>IRT_NUM</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ta</name> <operator>==</operator> <name>IRT_NUM</name> <operator>&amp;&amp;</operator> <name>tc</name> <operator>==</operator> <name>IRT_INT</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>LJ_52</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>ta</name> <operator>=</operator> <name>IRT_NIL</name></expr>;</expr_stmt>  <comment type="block">/* Force metamethod for different types. */</comment>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>ta</name> <operator>==</operator> <name>IRT_FALSE</name> <operator>||</operator> <name>ta</name> <operator>==</operator> <name>IRT_TRUE</name><operator>)</operator> <operator>&amp;&amp;</operator>
		     <operator>(</operator><name>tc</name> <operator>==</operator> <name>IRT_FALSE</name> <operator>||</operator> <name>tc</name> <operator>==</operator> <name>IRT_TRUE</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
	  <break>break;</break>  <comment type="block">/* Interpreter will throw for two different types. */</comment>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>rec_comp_prep</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>irop</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>op</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name>BC_ISLT</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>IR_LT</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>ta</name> <operator>==</operator> <name>IRT_NUM</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>irop</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>irop</name> <operator>^=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* ISGE/ISGT are unordered. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_ir_numcmp</name><argument_list>(<argument><expr><call><name>numberVnum</name><argument_list>(<argument><expr><name>rav</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>numberVnum</name><argument_list>(<argument><expr><name>rcv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name>irop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>irop</name> <operator>^=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ta</name> <operator>==</operator> <name>IRT_INT</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_ir_numcmp</name><argument_list>(<argument><expr><call><name>numberVnum</name><argument_list>(<argument><expr><name>rav</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>numberVnum</name><argument_list>(<argument><expr><name>rcv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name>irop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>irop</name> <operator>^=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ta</name> <operator>==</operator> <name>IRT_STR</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_ir_strcmp</name><argument_list>(<argument><expr><call><name>strV</name><argument_list>(<argument><expr><name>rav</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strV</name><argument_list>(<argument><expr><name>rcv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name>irop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>irop</name> <operator>^=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>ra</name> <operator>=</operator> <call><name>lj_ir_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IRCALL_lj_str_cmp</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ta</name> <operator>=</operator> <name>IRT_INT</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>rec_mm_comp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>irop</name></expr></argument>, <argument><expr><name>ta</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>rec_comp_fixup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>op</name> <operator>^</operator> <name>irop</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <break>break;</break>

  <case>case <expr><name>BC_ISEQV</name></expr>:</case> <case>case <expr><name>BC_ISNEV</name></expr>:</case>
  <case>case <expr><name>BC_ISEQS</name></expr>:</case> <case>case <expr><name>BC_ISNES</name></expr>:</case>
  <case>case <expr><name>BC_ISEQN</name></expr>:</case> <case>case <expr><name>BC_ISNEN</name></expr>:</case>
  <case>case <expr><name>BC_ISEQP</name></expr>:</case> <case>case <expr><name>BC_ISNEP</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>tref_iscdata</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>tref_iscdata</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>rec_mm_comp_cdata</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>MM_eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Emit nothing for two non-table, non-udata consts. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>tref_isk2</name><argument_list>(<argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><call><name>tref_istab</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>tref_isudata</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>diff</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>rec_comp_prep</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>diff</name> <operator>=</operator> <call><name>lj_record_objcmp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>rav</name></expr></argument>, <argument><expr><name>rcv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>diff</name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <operator>!</operator><operator>(</operator><call><name>tref_istab</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>tref_isudata</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>rec_comp_fixup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>op</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <operator>!</operator><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>diff</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Only check __eq if different, but same type. */</comment>
	<expr_stmt><expr><call><name>rec_mm_equal</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <break>break;</break>

  <comment type="block">/* -- Unary test and copy ops ------------------------------------------- */</comment>

  <case>case <expr><name>BC_ISTC</name></expr>:</case> <case>case <expr><name>BC_ISFC</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>op</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <call><name>tref_istruecond</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Don't store if condition is not true. */</comment>
    <comment type="block">/* fallthrough */</comment>
  <case>case <expr><name>BC_IST</name></expr>:</case> <case>case <expr><name>BC_ISF</name></expr>:</case>  <comment type="block">/* Type specialization suffices. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>bc_a</name><argument_list>(<argument><expr><name><name>pc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <call><name>bc_a</name><argument_list>(<argument><expr><name><name>pc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Shrink used slots. */</comment>
    <break>break;</break>

  <case>case <expr><name>BC_ISTYPE</name></expr>:</case> <case>case <expr><name>BC_ISNUM</name></expr>:</case>
    <comment type="block">/* These coercions need to correspond with lj_meta_istype(). */</comment>
    <if_stmt><if>if <condition>(<expr><name>LJ_DUALNUM</name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>==</operator> <operator>~</operator><name>LJ_TNUMX</name><operator>+</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ra</name> <operator>=</operator> <call><name>lj_opt_narrow_toint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <operator>~</operator><name>LJ_TNUMX</name><operator>+</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ra</name> <operator>=</operator> <call><name>lj_ir_tonum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <operator>~</operator><name>LJ_TSTR</name><operator>+</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ra</name> <operator>=</operator> <call><name>lj_ir_tostr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* else: type specialization suffices. */</comment>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>ra</name></expr>;</expr_stmt>
    <break>break;</break>

  <comment type="block">/* -- Unary ops --------------------------------------------------------- */</comment>

  <case>case <expr><name>BC_NOT</name></expr>:</case>
    <comment type="block">/* Type specialization already forces const result. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><call><name>tref_istruecond</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>TREF_FALSE</name></expr> </then><else>: <expr><name>TREF_TRUE</name></expr></else></ternary></expr>;</expr_stmt>
    <break>break;</break>

  <case>case <expr><name>BC_LEN</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isstr</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>IRFL_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>LJ_52</name> <operator>&amp;&amp;</operator> <call><name>tref_istab</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ALEN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>TREF_NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rec_mm_len</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>rcv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>

  <comment type="block">/* -- Arithmetic ops ---------------------------------------------------- */</comment>

  <case>case <expr><name>BC_UNM</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isnumber_str</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lj_opt_narrow_unm</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>rcv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>tabv</name></name></expr></argument>, <argument><expr><name>rcv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rec_mm_arith</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name>MM_unm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <break>break;</break>

  <case>case <expr><name>BC_ADDNV</name></expr>:</case> <case>case <expr><name>BC_SUBNV</name></expr>:</case> <case>case <expr><name>BC_MULNV</name></expr>:</case> <case>case <expr><name>BC_DIVNV</name></expr>:</case> <case>case <expr><name>BC_MODNV</name></expr>:</case>
    <comment type="block">/* Swap rb/rc and rbv/rcv. rav is temp. */</comment>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name>rc</name> <operator>=</operator> <name>rb</name></expr>;</expr_stmt> <expr_stmt><expr><name>rb</name> <operator>=</operator> <name><name>ix</name><operator>.</operator><name>tab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>rav</name></expr></argument>, <argument><expr><name>rbv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>rbv</name></expr></argument>, <argument><expr><name>rcv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>rcv</name></expr></argument>, <argument><expr><name>rav</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>BC_MODNV</name></expr>)</condition><block type="pseudo"><block_content>
      <goto>goto <name>recmod</name>;</goto></block_content></block></if></if_stmt>
    <comment type="block">/* fallthrough */</comment>
  <case>case <expr><name>BC_ADDVN</name></expr>:</case> <case>case <expr><name>BC_SUBVN</name></expr>:</case> <case>case <expr><name>BC_MULVN</name></expr>:</case> <case>case <expr><name>BC_DIVVN</name></expr>:</case>
  <case>case <expr><name>BC_ADDVV</name></expr>:</case> <case>case <expr><name>BC_SUBVV</name></expr>:</case> <case>case <expr><name>BC_MULVV</name></expr>:</case> <case>case <expr><name>BC_DIVVV</name></expr>:</case> <block>{<block_content>
    <decl_stmt><decl><type><name>MMS</name></type> <name>mm</name> <init>= <expr><call><name>bcmode_mm</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isnumber_str</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tref_isnumber_str</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lj_opt_narrow_arith</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>rbv</name></expr></argument>, <argument><expr><name>rcv</name></expr></argument>,
			       <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>mm</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name>MM_add</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>IR_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rec_mm_arith</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>
    </block_content>}</block>

  <case>case <expr><name>BC_MODVN</name></expr>:</case> <case>case <expr><name>BC_MODVV</name></expr>:</case>
  <label><name>recmod</name>:</label>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isnumber_str</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tref_isnumber_str</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lj_opt_narrow_mod</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>rbv</name></expr></argument>, <argument><expr><name>rcv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rec_mm_arith</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name>MM_mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>

  <case>case <expr><name>BC_POW</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><call><name>tref_isnumber_str</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tref_isnumber_str</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lj_opt_narrow_pow</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>rbv</name></expr></argument>, <argument><expr><name>rcv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rec_mm_arith</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>, <argument><expr><name>MM_pow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>

  <comment type="block">/* -- Miscellaneous ops ------------------------------------------------- */</comment>

  <case>case <expr><name>BC_CAT</name></expr>:</case>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rec_cat</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <comment type="block">/* -- Constant and move ops --------------------------------------------- */</comment>

  <case>case <expr><name>BC_MOV</name></expr>:</case>
    <comment type="block">/* Clear gap of method call to avoid resurrecting previous refs. */</comment>
    <if_stmt><if>if <condition>(<expr><name>ra</name> <operator>&gt;</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>ra</name> <operator>-</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TRef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_KSTR</name></expr>:</case> <case>case <expr><name>BC_KNUM</name></expr>:</case> <case>case <expr><name>BC_KPRI</name></expr>:</case>
    <break>break;</break>
  <case>case <expr><name>BC_KSHORT</name></expr>:</case>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>int16_t</name><operator>)</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_KNIL</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>LJ_FR2</name> <operator>&amp;&amp;</operator> <name>ra</name> <operator>&gt;</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <while>while <condition>(<expr><name>ra</name> <operator>&lt;=</operator> <name>rc</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>TREF_NIL</name></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&gt;=</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>rc</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <case>case <expr><name>BC_KCDATA</name></expr>:</case>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lj_ir_kgc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>proto_kgc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>, <argument><expr><operator>~</operator><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>rc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IRT_CDATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* -- Upvalue and function ops ------------------------------------------ */</comment>

  <case>case <expr><name>BC_UGET</name></expr>:</case>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rec_upvalue</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_USETV</name></expr>:</case> <case>case <expr><name>BC_USETS</name></expr>:</case> <case>case <expr><name>BC_USETN</name></expr>:</case> <case>case <expr><name>BC_USETP</name></expr>:</case>
    <expr_stmt><expr><call><name>rec_upvalue</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <comment type="block">/* -- Table ops --------------------------------------------------------- */</comment>

  <case>case <expr><name>BC_GGET</name></expr>:</case> <case>case <expr><name>BC_GSET</name></expr>:</case>
    <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>tabv</name></name></expr></argument>, <argument><expr><call><name>tabref</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>fn</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>env</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>tab</name></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getcurrf</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IRFL_FUNC_ENV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>idxchain</name></name> <operator>=</operator> <name>LJ_MAX_IDXCHAIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lj_record_idx</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <case>case <expr><name>BC_TGETB</name></expr>:</case> <case>case <expr><name>BC_TSETB</name></expr>:</case>
    <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ix</name><operator>.</operator><name>keyv</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>key</name></name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* fallthrough */</comment>
  <case>case <expr><name>BC_TGETV</name></expr>:</case> <case>case <expr><name>BC_TGETS</name></expr>:</case> <case>case <expr><name>BC_TSETV</name></expr>:</case> <case>case <expr><name>BC_TSETS</name></expr>:</case>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>idxchain</name></name> <operator>=</operator> <name>LJ_MAX_IDXCHAIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lj_record_idx</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_TGETR</name></expr>:</case> <case>case <expr><name>BC_TSETR</name></expr>:</case>
    <expr_stmt><expr><name><name>ix</name><operator>.</operator><name>idxchain</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lj_record_idx</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <case>case <expr><name>BC_TSETM</name></expr>:</case>
    <expr_stmt><expr><call><name>rec_tsetm</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><operator>(</operator><name>BCReg</name><operator>)</operator><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>rcv</name><operator>-&gt;</operator><name>u32</name><operator>.</operator><name>lo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <case>case <expr><name>BC_TNEW</name></expr>:</case>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>rec_tnew</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_TDUP</name></expr>:</case>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_TDUP</name></expr></argument>, <argument><expr><name>IRT_TAB</name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><call><name>lj_ir_ktab</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>gco2tab</name><argument_list>(<argument><expr><call><name>proto_kgc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>, <argument><expr><operator>~</operator><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUAJIT_ENABLE_TABLE_BUMP</name></cpp:ifdef>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>rbchash</name><index>[<expr><operator>(</operator><name>rc</name> <operator>&amp;</operator> <operator>(</operator><name>RBCHASH_SLOTS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>]</index></name><operator>.</operator><name>ref</name> <operator>=</operator> <call><name>tref_ref</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>rbchash</name><index>[<expr><operator>(</operator><name>rc</name> <operator>&amp;</operator> <operator>(</operator><name>RBCHASH_SLOTS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>]</index></name><operator>.</operator><name>pc</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>rbchash</name><index>[<expr><operator>(</operator><name>rc</name> <operator>&amp;</operator> <operator>(</operator><name>RBCHASH_SLOTS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>]</index></name><operator>.</operator><name>pt</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

  <comment type="block">/* -- Calls and vararg handling ----------------------------------------- */</comment>

  <case>case <expr><name>BC_ITERC</name></expr>:</case>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name></expr>]</index></name> <operator>=</operator> <call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr>]</index></name> <operator>=</operator> <call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>LJ_FR2</name></expr>]</index></name> <operator>=</operator> <call><name>getslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content> <comment type="block">/* Do the actual copy now because lj_record_call needs the values. */</comment>
      <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>b</name><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>b</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>, <argument><expr><name>b</name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>b</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>, <argument><expr><name>b</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>lj_record_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>rc</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <comment type="block">/* L-&gt;top is set to L-&gt;base+ra+rc+NARGS-1+1. See lj_dispatch_ins(). */</comment>
  <case>case <expr><name>BC_CALLM</name></expr>:</case>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator> <operator>-</operator> <name>ra</name> <operator>-</operator> <name>LJ_FR2</name></expr>;</expr_stmt>
    <comment type="block">/* fallthrough */</comment>
  <case>case <expr><name>BC_CALL</name></expr>:</case>
    <expr_stmt><expr><call><name>lj_record_call</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>rc</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <case>case <expr><name>BC_CALLMT</name></expr>:</case>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator> <operator>-</operator> <name>ra</name> <operator>-</operator> <name>LJ_FR2</name></expr>;</expr_stmt>
    <comment type="block">/* fallthrough */</comment>
  <case>case <expr><name>BC_CALLT</name></expr>:</case>
    <expr_stmt><expr><call><name>lj_record_tailcall</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>rc</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <case>case <expr><name>BC_VARG</name></expr>:</case>
    <expr_stmt><expr><call><name>rec_varg</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>rb</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <comment type="block">/* -- Returns ----------------------------------------------------------- */</comment>

  <case>case <expr><name>BC_RETM</name></expr>:</case>
    <comment type="block">/* L-&gt;top is set to L-&gt;base+ra+rc+NRESULTS-1, see lj_dispatch_ins(). */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>BCReg</name><operator>)</operator><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator> <operator>-</operator> <name>ra</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* fallthrough */</comment>
  <case>case <expr><name>BC_RET</name></expr>:</case> <case>case <expr><name>BC_RET0</name></expr>:</case> <case>case <expr><name>BC_RET1</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASPROFILE</name></expr></cpp:if>
    <expr_stmt><expr><call><name>rec_profile_ret</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>lj_record_ret</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>rc</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <comment type="block">/* -- Loops and branches ------------------------------------------------ */</comment>

  <case>case <expr><name>BC_FORI</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><call><name>rec_for</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LOOPEV_LEAVE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>loopref</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_JFORI</name></expr>:</case>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>bc_op</name><argument_list>(<argument><expr><name><name>pc</name><index>[<expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>rc</name><operator>-</operator><name>BCBIAS_J</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_JFORL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>rec_for</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LOOPEV_LEAVE</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Link to existing loop. */</comment>
      <expr_stmt><expr><call><name>lj_record_stop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRLINK_ROOT</name></expr></argument>, <argument><expr><call><name>bc_d</name><argument_list>(<argument><expr><name><name>pc</name><index>[<expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>rc</name><operator>-</operator><name>BCBIAS_J</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Continue tracing if the loop is not entered. */</comment>
    <break>break;</break>

  <case>case <expr><name>BC_FORL</name></expr>:</case>
    <expr_stmt><expr><call><name>rec_loop_interp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><call><name>rec_for</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pc</name><operator>+</operator><operator>(</operator><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>rc</name><operator>-</operator><name>BCBIAS_J</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_ITERL</name></expr>:</case>
    <expr_stmt><expr><call><name>rec_loop_interp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><call><name>rec_iterl</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_LOOP</name></expr>:</case>
    <expr_stmt><expr><call><name>rec_loop_interp</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><call><name>rec_loop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <case>case <expr><name>BC_JFORL</name></expr>:</case>
    <expr_stmt><expr><call><name>rec_loop_jit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><call><name>rec_for</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>pc</name><operator>+</operator><call><name>bc_j</name><argument_list>(<argument><expr><call><name>traceref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>startins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_JITERL</name></expr>:</case>
    <expr_stmt><expr><call><name>rec_loop_jit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><call><name>rec_iterl</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>traceref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>startins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_JLOOP</name></expr>:</case>
    <expr_stmt><expr><call><name>rec_loop_jit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><call><name>rec_loop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <case>case <expr><name>BC_IFORL</name></expr>:</case>
  <case>case <expr><name>BC_IITERL</name></expr>:</case>
  <case>case <expr><name>BC_ILOOP</name></expr>:</case>
  <case>case <expr><name>BC_IFUNCF</name></expr>:</case>
  <case>case <expr><name>BC_IFUNCV</name></expr>:</case>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_BLACKL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <case>case <expr><name>BC_JMP</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>ra</name> <operator>&lt;</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>ra</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Shrink used slots. */</comment>
    <break>break;</break>

  <comment type="block">/* -- Function headers -------------------------------------------------- */</comment>

  <case>case <expr><name>BC_FUNCF</name></expr>:</case>
    <expr_stmt><expr><call><name>rec_func_lua</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_JFUNCF</name></expr>:</case>
    <expr_stmt><expr><call><name>rec_func_jit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <case>case <expr><name>BC_FUNCV</name></expr>:</case>
    <expr_stmt><expr><call><name>rec_func_vararg</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rec_func_lua</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_JFUNCV</name></expr>:</case>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Cannot happen. No hotcall counting for varag funcs. */</comment>
    <break>break;</break>

  <case>case <expr><name>BC_FUNCC</name></expr>:</case>
  <case>case <expr><name>BC_FUNCCW</name></expr>:</case>
    <expr_stmt><expr><call><name>lj_ffrecord_func</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <default>default:</default>
    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>&gt;=</operator> <name>BC__MAX</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lj_ffrecord_func</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* fallthrough */</comment>
  <case>case <expr><name>BC_ITERN</name></expr>:</case>
  <case>case <expr><name>BC_ISNEXT</name></expr>:</case>
  <case>case <expr><name>BC_UCLO</name></expr>:</case>
  <case>case <expr><name>BC_FNEW</name></expr>:</case>
    <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>errinfo</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_trace_err_info</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_NYIBC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* rc == 0 if we have no result yet, e.g. pending __index metamethod call. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>bcmode_a</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BCMdst</name> <operator>&amp;&amp;</operator> <name>rc</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name></expr>]</index></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ra</name> <operator>&gt;=</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name>ra</name> <operator>&gt;</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>ra</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>ra</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rav</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rbv</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rcv</name></cpp:undef>

  <comment type="block">/* Limit the number of recorded IR instructions and constants. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name> <operator>&gt;</operator> <name>REF_FIRST</name><operator>+</operator><operator>(</operator><name>IRRef</name><operator>)</operator><name><name>J</name><operator>-&gt;</operator><name>param</name><index>[<expr><name>JIT_P_maxrecord</name></expr>]</index></name> <operator>||</operator>
      <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nk</name></name> <operator>&lt;</operator> <name>REF_BIAS</name><operator>-</operator><operator>(</operator><name>IRRef</name><operator>)</operator><name><name>J</name><operator>-&gt;</operator><name>param</name><index>[<expr><name>JIT_P_maxirconst</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_TRACEOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Recording setup ----------------------------------------------------- */</comment>

<comment type="block">/* Setup recording for a root trace started by a hot loop. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>rec_setup_root</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Determine the next PC and the bytecode range for the loop. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pcj</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pc</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCIns</name></type> <name>ins</name> <init>= <expr><operator>*</operator><name>pc</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>ra</name> <init>= <expr><call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>BC_FORL</name></expr>:</case>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>bc_extent</name></name> <operator>=</operator> <operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><operator>-</operator><call><name>bc_j</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>BCIns</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>pc</name> <operator>+=</operator> <literal type="number">1</literal><operator>+</operator><call><name>bc_j</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>bc_min</name></name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_ITERL</name></expr>:</case>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>bc_op</name><argument_list>(<argument><expr><name><name>pc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_ITERC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>ra</name> <operator>+</operator> <call><name>bc_b</name><argument_list>(<argument><expr><name><name>pc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>bc_extent</name></name> <operator>=</operator> <operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><operator>-</operator><call><name>bc_j</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>BCIns</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>pc</name> <operator>+=</operator> <literal type="number">1</literal><operator>+</operator><call><name>bc_j</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>bc_op</name><argument_list>(<argument><expr><name><name>pc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_JMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>bc_min</name></name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_LOOP</name></expr>:</case>
    <comment type="block">/* Only check BC range for real loops, but not for "repeat until true". */</comment>
    <expr_stmt><expr><name>pcj</name> <operator>=</operator> <name>pc</name> <operator>+</operator> <call><name>bc_j</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ins</name> <operator>=</operator> <operator>*</operator><name>pcj</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_JMP</name> <operator>&amp;&amp;</operator> <call><name>bc_j</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>bc_min</name></name> <operator>=</operator> <name>pcj</name><operator>+</operator><literal type="number">1</literal> <operator>+</operator> <call><name>bc_j</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>bc_extent</name></name> <operator>=</operator> <operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><operator>-</operator><call><name>bc_j</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>BCIns</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>ra</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_RET</name></expr>:</case>
  <case>case <expr><name>BC_RET0</name></expr>:</case>
  <case>case <expr><name>BC_RET1</name></expr>:</case>
    <comment type="block">/* No bytecode range check for down-recursive root traces. */</comment>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name>ra</name> <operator>+</operator> <call><name>bc_d</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_FUNCF</name></expr>:</case>
    <comment type="block">/* No bytecode range check for root traces started by a hot call. */</comment>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>pt</name><operator>-&gt;</operator><name>numparams</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_CALLM</name></expr>:</case>
  <case>case <expr><name>BC_CALL</name></expr>:</case>
  <case>case <expr><name>BC_ITERC</name></expr>:</case>
    <comment type="block">/* No bytecode range check for stitched traces. */</comment>
    <expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>
  <default>default:</default>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>pc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Setup for recording a new trace. */</comment>
<function><type><name>void</name></type> <name>lj_record_setup</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Initialize state related to current trace. */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUAJIT_ENABLE_TABLE_BUMP</name></cpp:ifdef>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>rbchash</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>rbchash</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>bpropcache</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>bpropcache</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <name>REF_NIL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>pc</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr>;</expr_stmt>  <comment type="block">/* Invoking function is at base[-1-LJ_FR2]. */</comment>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>slot</name></name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>retdepth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>instunroll</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>param</name><index>[<expr><name>JIT_P_instunroll</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>loopunroll</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>param</name><index>[<expr><name>JIT_P_loopunroll</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>tailcalled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>loopref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>bc_min</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>  <comment type="block">/* Means no limit. */</comment>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>bc_extent</name></name> <operator>=</operator> <operator>~</operator><operator>(</operator><name>MSize</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Emit instructions for fixed references. Also triggers initial IR alloc. */</comment>
  <expr_stmt><expr><call><name>emitir_raw</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_BASE</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>exitno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>REF_NIL</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>IRT_NIL</name><operator>+</operator><name>i</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_KPRI</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nk</name></name> <operator>=</operator> <name>REF_TRUE</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>startpc</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>startpc</name></name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Side trace. */</comment>
    <decl_stmt><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name> <init>= <expr><call><name>traceref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceNo</name></type> <name>root</name> <init>= <expr><ternary><condition><expr><name><name>T</name><operator>-&gt;</operator><name>root</name></name></expr> ?</condition><then> <expr><name><name>T</name><operator>-&gt;</operator><name>root</name></name></expr> </then><else>: <expr><name><name>J</name><operator>-&gt;</operator><name>parent</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>root</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>root</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>startins</name></name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_JMP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Check whether we could at least potentially form an extra loop. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>exitno</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>T</name><operator>-&gt;</operator><name>snap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nent</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="block">/* We can narrow a FORL for some side traces, too. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name> <operator>&gt;</operator> <call><name>proto_bc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>bc_op</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_JFORI</name> <operator>&amp;&amp;</operator>
	  <call><name>bc_d</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name><index>[<expr><call><name>bc_j</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>root</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lj_snap_add</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rec_for_loop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>scev</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<goto>goto <name>sidecheck</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>startpc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>  <comment type="block">/* Prevent forming an extra loop. */</comment>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>lj_snap_replay</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>sidecheck</name>:</label>
    <if_stmt><if>if <condition>(<expr><call><name>traceref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nchild</name> <operator>&gt;=</operator> <name><name>J</name><operator>-&gt;</operator><name>param</name><index>[<expr><name>JIT_P_maxside</name></expr>]</index></name> <operator>||</operator>
	<name><name>T</name><operator>-&gt;</operator><name>snap</name><index>[<expr><name><name>J</name><operator>-&gt;</operator><name>exitno</name></name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&gt;=</operator> <name><name>J</name><operator>-&gt;</operator><name>param</name><index>[<expr><name>JIT_P_hotexit</name></expr>]</index></name> <operator>+</operator>
				    <name><name>J</name><operator>-&gt;</operator><name>param</name><index>[<expr><name>JIT_P_tryside</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lj_record_stop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRLINK_INTERP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Root trace. */</comment>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>root</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>startins</name></name> <operator>=</operator> <operator>*</operator><name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <call><name>rec_setup_root</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Note: the loop instruction itself is recorded at the end and not
    ** at the start! So snapshot #0 needs to point to the *next* instruction.
    */</comment>
    <expr_stmt><expr><call><name>lj_snap_add</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>startins</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_FORL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>rec_for_loop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>scev</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>startins</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_ITERC</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>startpc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>pt</name><operator>-&gt;</operator><name>framesize</name></name> <operator>&gt;=</operator> <name>LJ_MAX_JSLOTS</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_STACKOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASPROFILE</name></expr></cpp:if>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>prev_pt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>prev_line</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUAJIT_ENABLE_CHECKHOOK</name></cpp:ifdef>
  <comment type="block">/* Regularly check for instruction/line hooks from compiled code and
  ** exit to the interpreter if the hooks are set.
  **
  ** This is a compile-time option and disabled by default, since the
  ** hook checks may be quite expensive in tight loops.
  **
  ** Note this is only useful if hooks are *not* set most of the time.
  ** Use this only if you want to *asynchronously* interrupt the execution.
  **
  ** You can set the instruction hook via lua_sethook() with a count of 1
  ** from a signal handler or another native thread. Please have a look
  ** at the first few functions in luajit.c for an example (Ctrl-C handler).
  */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>IRT_U8</name></expr></argument>)</argument_list></call></expr></argument>,
		     <argument><expr><call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>hookmask</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IRXLOAD_VOLATILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BAND</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>LUA_MASKLINE</name><operator>|</operator><name>LUA_MASKCOUNT</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>emitir_raw</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>emitir</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
