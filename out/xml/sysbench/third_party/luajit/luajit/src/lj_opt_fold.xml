<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_opt_fold.c"><comment type="block">/*
** FOLD: Constant Folding, Algebraic Simplifications and Reassociation.
** ABCelim: Array Bounds Check Elimination.
** CSE: Common-Subexpression Elimination.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_opt_fold_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_buf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_str.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ircall.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_iropt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_trace.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_carith.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_vm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strfmt.h"</cpp:file></cpp:include>

<comment type="block">/* Here's a short description how the FOLD engine processes instructions:
**
** The FOLD engine receives a single instruction stored in fins (J-&gt;fold.ins).
** The instruction and its operands are used to select matching fold rules.
** These are applied iteratively until a fixed point is reached.
**
** The 8 bit opcode of the instruction itself plus the opcodes of the
** two instructions referenced by its operands form a 24 bit key
** 'ins left right' (unused operands -&gt; 0, literals -&gt; lowest 8 bits).
**
** This key is used for partial matching against the fold rules. The
** left/right operand fields of the key are successively masked with
** the 'any' wildcard, from most specific to least specific:
**
**   ins left right
**   ins any  right
**   ins left any
**   ins any  any
**
** The masked key is used to lookup a matching fold rule in a semi-perfect
** hash table. If a matching rule is found, the related fold function is run.
** Multiple rules can share the same fold function. A fold rule may return
** one of several special values:
**
** - NEXTFOLD means no folding was applied, because an additional test
**   inside the fold function failed. Matching continues against less
**   specific fold rules. Finally the instruction is passed on to CSE.
**
** - RETRYFOLD means the instruction was modified in-place. Folding is
**   retried as if this instruction had just been received.
**
** All other return values are terminal actions -- no further folding is
** applied:
**
** - INTFOLD(i) returns a reference to the integer constant i.
**
** - LEFTFOLD and RIGHTFOLD return the left/right operand reference
**   without emitting an instruction.
**
** - CSEFOLD and EMITFOLD pass the instruction directly to CSE or emit
**   it without passing through any further optimizations.
**
** - FAILFOLD, DROPFOLD and CONDFOLD only apply to instructions which have
**   no result (e.g. guarded assertions): FAILFOLD means the guard would
**   always fail, i.e. the current trace is pointless. DROPFOLD means
**   the guard is always true and has been eliminated. CONDFOLD is a
**   shortcut for FAILFOLD + cond (i.e. drop if true, otherwise fail).
**
** - Any other return value is interpreted as an IRRef or TRef. This
**   can be a reference to an existing or a newly created instruction.
**   Only the least-significant 16 bits (IRRef1) are used to form a TRef
**   which is finally returned to the caller.
**
** The FOLD engine receives instructions both from the trace recorder and
** substituted instructions from LOOP unrolling. This means all types
** of instructions may end up here, even though the recorder bypasses
** FOLD in some cases. Thus all loads, stores and allocations must have
** an any/any rule to avoid being passed on to CSE.
**
** Carefully read the following requirements before adding or modifying
** any fold rules:
**
** Requirement #1: All fold rules must preserve their destination type.
**
** Consistently use INTFOLD() (KINT result) or lj_ir_knum() (KNUM result).
** Never use lj_ir_knumint() which can have either a KINT or KNUM result.
**
** Requirement #2: Fold rules should not create *new* instructions which
** reference operands *across* PHIs.
**
** E.g. a RETRYFOLD with 'fins-&gt;op1 = fleft-&gt;op1' is invalid if the
** left operand is a PHI. Then fleft-&gt;op1 would point across the PHI
** frontier to an invariant instruction. Adding a PHI for this instruction
** would be counterproductive. The solution is to add a barrier which
** prevents folding across PHIs, i.e. 'PHIBARRIER(fleft)' in this case.
** The only exception is for recurrences with high latencies like
** repeated int-&gt;num-&gt;int conversions.
**
** One could relax this condition a bit if the referenced instruction is
** a PHI, too. But this often leads to worse code due to excessive
** register shuffling.
**
** Note: returning *existing* instructions (e.g. LEFTFOLD) is ok, though.
** Even returning fleft-&gt;op1 would be ok, because a new PHI will added,
** if needed. But again, this leads to excessive register shuffling and
** should be avoided.
**
** Requirement #3: The set of all fold rules must be monotonic to guarantee
** termination.
**
** The goal is optimization, so one primarily wants to add strength-reducing
** rules. This means eliminating an instruction or replacing an instruction
** with one or more simpler instructions. Don't add fold rules which point
** into the other direction.
**
** Some rules (like commutativity) do not directly reduce the strength of
** an instruction, but enable other fold rules (e.g. by moving constants
** to the right operand). These rules must be made unidirectional to avoid
** cycles.
**
** Rule of thumb: the trace recorder expands the IR and FOLD shrinks it.
*/</comment>

<comment type="block">/* Some local macros to save typing. Undef'd at the end. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IR</name><parameter_list>(<parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(&amp;J-&gt;cur.ir[(ref)])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fins</name></cpp:macro>		<cpp:value>(&amp;J-&gt;fold.ins)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fleft</name></cpp:macro>		<cpp:value>(J-&gt;fold.left)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fright</name></cpp:macro>		<cpp:value>(J-&gt;fold.right)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>knumleft</name></cpp:macro>	<cpp:value>(ir_knum(fleft)-&gt;n)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>knumright</name></cpp:macro>	<cpp:value>(ir_knum(fright)-&gt;n)</cpp:value></cpp:define>

<comment type="block">/* Pass IR on to next optimization in chain (FOLD). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>emitir</name><parameter_list>(<parameter><type><name>ot</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(lj_ir_set(J, (ot), (a), (b)), lj_opt_fold(J))</cpp:value></cpp:define>

<comment type="block">/* Fold function type. Fastcall on x86 significantly reduces their size. */</comment>
<typedef>typedef <function_decl><type><name>IRRef</name></type> (<name>LJ_FASTCALL</name> <modifier>*</modifier><name>FoldFunc</name>)<parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* Macros for the fold specs, so buildvm can recognize them. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJFOLD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJFOLDX</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJFOLDF</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>static TRef LJ_FASTCALL fold_##name(jit_State *J)</cpp:value></cpp:define>
<comment type="block">/* Note: They must be at the start of a line or buildvm ignores them! */</comment>

<comment type="block">/* Barrier to prevent using operands across PHIs. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHIBARRIER</name><parameter_list>(<parameter><type><name>ir</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>if (irt_isphi((ir)-&gt;t)) return NEXTFOLD</cpp:value></cpp:define>

<comment type="block">/* Barrier to prevent folding across a GC step.
** GC steps can only happen at the head of a trace and at LOOP.
** And the GC is only driven forward if there's at least one allocation.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gcstep_barrier</name><parameter_list>(<parameter><type><name>J</name></type></parameter>, <parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>((ref) &lt; J-&gt;chain[IR_LOOP] &amp;&amp; \
   (J-&gt;chain[IR_SNEW] || J-&gt;chain[IR_XSNEW] || \
    J-&gt;chain[IR_TNEW] || J-&gt;chain[IR_TDUP] || \
    J-&gt;chain[IR_CNEW] || J-&gt;chain[IR_CNEWI] || \
    J-&gt;chain[IR_BUFSTR] || J-&gt;chain[IR_TOSTR] || J-&gt;chain[IR_CALLA]))</cpp:value></cpp:define>

<comment type="block">/* -- Constant folding for FP numbers ------------------------------------- */</comment>

<macro><name>LJFOLD</name><argument_list>(<argument>ADD KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>SUB KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MUL KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>DIV KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>LDEXP KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MIN KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MAX KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_numarith</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>a</name> <init>= <expr><name>knumleft</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>b</name> <init>= <expr><name>knumright</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>y</name> <init>= <expr><call><name>lj_vm_foldarith</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>-</operator> <name>IR_ADD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>NEG KNUM FLOAD</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ABS KNUM FLOAD</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_numabsneg</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>a</name> <init>= <expr><name>knumleft</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>y</name> <init>= <expr><call><name>lj_vm_foldarith</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>-</operator> <name>IR_ADD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>LDEXP KNUM KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_ldexp</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ldexp</name><argument_list>(<argument><expr><name>knumleft</name></expr></argument>, <argument><expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>FPMATH KNUM any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_fpmath</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>a</name> <init>= <expr><name>knumleft</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>y</name> <init>= <expr><call><name>lj_vm_foldfpm</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CALLN KNUM any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_fpcall1</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>CCI_TYPE</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>IRT_NUM</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>y</name> <init>= <expr><operator>(</operator><operator>(</operator><call><call><name>double</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></call><operator>)</operator><name><name>ci</name><operator>-&gt;</operator><name>func</name></name><operator>)</operator><operator>(</operator><name>knumleft</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CALLN CARG IRCALL_atan2</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_fpcall2</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>a</name> <init>= <expr><call><name>ir_knum</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>b</name> <init>= <expr><call><name>ir_knum</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>y</name> <init>= <expr><operator>(</operator><operator>(</operator><call><call><name>double</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>double</name></expr></argument>, <argument><expr><name>double</name></expr></argument>)</argument_list></call><operator>)</operator><name><name>ci</name><operator>-&gt;</operator><name>func</name></name><operator>)</operator><operator>(</operator><name>a</name>, <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>POW KNUM KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>POW KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_numpow</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>a</name> <init>= <expr><name>knumleft</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>b</name> <init>= <expr><ternary><condition><expr><name><name>fright</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name></expr> ?</condition><then> <expr><operator>(</operator><name>lua_Number</name><operator>)</operator><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr> </then><else>: <expr><name>knumright</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>y</name> <init>= <expr><call><name>lj_vm_foldarith</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>IR_POW</name> <operator>-</operator> <name>IR_ADD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<comment type="block">/* Must not use kfold_kref for numbers (could be NaN). */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>EQ KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>NE KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>LT KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>GE KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>LE KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>GT KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ULT KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>UGE KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ULE KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>UGT KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_numcomp</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><call><name>lj_ir_numcmp</name><argument_list>(<argument><expr><name>knumleft</name></expr></argument>, <argument><expr><name>knumright</name></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<comment type="block">/* -- Constant folding for 32 bit integers -------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>kfold_intop</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>k1</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>k2</name></decl></parameter>, <parameter><decl><type><name>IROp</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>IR_ADD</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>+=</operator> <name>k2</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_SUB</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>-=</operator> <name>k2</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_MUL</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>*=</operator> <name>k2</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_MOD</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>=</operator> <call><name>lj_vm_modi</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_NEG</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>=</operator> <operator>-</operator><name>k1</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BAND</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>&amp;=</operator> <name>k2</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BOR</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>|=</operator> <name>k2</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BXOR</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>^=</operator> <name>k2</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BSHL</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>&lt;&lt;=</operator> <operator>(</operator><name>k2</name> <operator>&amp;</operator> <literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BSHR</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>k1</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>k2</name> <operator>&amp;</operator> <literal type="number">31</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BSAR</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>&gt;&gt;=</operator> <operator>(</operator><name>k2</name> <operator>&amp;</operator> <literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BROL</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><call><name>lj_rol</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>k1</name></expr></argument>, <argument><expr><operator>(</operator><name>k2</name> <operator>&amp;</operator> <literal type="number">31</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BROR</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><call><name>lj_ror</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>k1</name></expr></argument>, <argument><expr><operator>(</operator><name>k2</name> <operator>&amp;</operator> <literal type="number">31</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_MIN</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>=</operator> <ternary><condition><expr><name>k1</name> <operator>&lt;</operator> <name>k2</name></expr> ?</condition><then> <expr><name>k1</name></expr> </then><else>: <expr><name>k2</name></expr></else></ternary></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_MAX</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>=</operator> <ternary><condition><expr><name>k1</name> <operator>&gt;</operator> <name>k2</name></expr> ?</condition><then> <expr><name>k1</name></expr> </then><else>: <expr><name>k2</name></expr></else></ternary></expr>;</expr_stmt> <break>break;</break>
  <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>k1</name></expr>;</return>
</block_content>}</block></function>

<macro><name>LJFOLD</name><argument_list>(<argument>ADD KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>SUB KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MUL KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MOD KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>NEG KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BAND KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BOR KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BXOR KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSHL KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSHR KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSAR KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROL KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROR KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MIN KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MAX KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_intarith</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><call><name>kfold_intop</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>ADDOV KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>SUBOV KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MULOV KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_intovarith</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name> <init>= <expr><call><name>lj_vm_foldarith</name><argument_list>(<argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></argument>,
				 <argument><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>-</operator> <name>IR_ADDOV</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>lj_num2int</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>FAILFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BNOT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_bnot</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><operator>~</operator><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BSWAP KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_bswap</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>lj_bswap</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>LT KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>GE KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>LE KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>GT KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ULT KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>UGE KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ULE KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>UGT KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ABC KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_intcomp</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>a</name> <init>= <expr><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl>, <decl><type ref="prev"/><name>b</name> <init>= <expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>IR_LT</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_GE</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><name>a</name> <operator>&gt;=</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_LE</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><name>a</name> <operator>&lt;=</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_GT</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_ULT</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>a</name> <operator>&lt;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_UGE</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>a</name> <operator>&gt;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_ULE</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>a</name> <operator>&lt;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_ABC</name></expr>:</case>
  <case>case <expr><name>IR_UGT</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>a</name> <operator>&gt;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>FAILFOLD</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>UGE any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_intcomp0</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>DROPFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* -- Constant folding for 64 bit integers -------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>uint64_t</name></type> <name>kfold_int64arith</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>k1</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>k2</name></decl></parameter>, <parameter><decl><type><name>IROp</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <case>case <expr><name>IR_ADD</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>+=</operator> <name>k2</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_SUB</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>-=</operator> <name>k2</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_MUL</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>*=</operator> <name>k2</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BAND</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>&amp;=</operator> <name>k2</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BOR</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>|=</operator> <name>k2</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BXOR</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>^=</operator> <name>k2</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BSHL</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>&lt;&lt;=</operator> <operator>(</operator><name>k2</name> <operator>&amp;</operator> <literal type="number">63</literal><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BSHR</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>k1</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>k2</name> <operator>&amp;</operator> <literal type="number">63</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BSAR</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>&gt;&gt;=</operator> <operator>(</operator><name>k2</name> <operator>&amp;</operator> <literal type="number">63</literal><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BROL</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><call><name>lj_rol</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>k1</name></expr></argument>, <argument><expr><operator>(</operator><name>k2</name> <operator>&amp;</operator> <literal type="number">63</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BROR</name></expr>:</case> <expr_stmt><expr><name>k1</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><call><name>lj_ror</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>k1</name></expr></argument>, <argument><expr><operator>(</operator><name>k2</name> <operator>&amp;</operator> <literal type="number">63</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <default>default:</default> <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>k2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>k1</name></expr>;</return>
</block_content>}</block></function>

<macro><name>LJFOLD</name><argument_list>(<argument>ADD KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>SUB KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MUL KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BAND KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BOR KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BXOR KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_int64arith</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>INT64FOLD</name><argument_list>(<argument><expr><call><name>kfold_int64arith</name><argument_list>(<argument><expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>,
				    <argument><expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>DIV KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MOD KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>POW KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_int64arith2</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>k1</name> <init>= <expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></init></decl>, <decl><type ref="prev"/><name>k2</name> <init>= <expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>irt_isi64</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>k1</name> <operator>=</operator> <ternary><condition><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_DIV</name></expr> ?</condition><then> <expr><call><name>lj_carith_divi64</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>k1</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>k2</name></expr></argument>)</argument_list></call></expr> </then><else>:
	 <expr><ternary><condition><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_MOD</name></expr> ?</condition><then> <expr><call><name>lj_carith_modi64</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>k1</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>k2</name></expr></argument>)</argument_list></call></expr> </then><else>:
			     <expr><call><name>lj_carith_powi64</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>k1</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>k2</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>k1</name> <operator>=</operator> <ternary><condition><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_DIV</name></expr> ?</condition><then> <expr><call><name>lj_carith_divu64</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>)</argument_list></call></expr> </then><else>:
	 <expr><ternary><condition><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_MOD</name></expr> ?</condition><then> <expr><call><name>lj_carith_modu64</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>)</argument_list></call></expr> </then><else>:
			     <expr><call><name>lj_carith_powu64</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><call><name>INT64FOLD</name><argument_list>(<argument><expr><name>k1</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>FAILFOLD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BSHL KINT64 KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSHR KINT64 KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSAR KINT64 KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROL KINT64 KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROR KINT64 KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_int64shift</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>k</name> <init>= <expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>sh</name> <init>= <expr><operator>(</operator><name><name>fright</name><operator>-&gt;</operator><name>i</name></name> <operator>&amp;</operator> <literal type="number">63</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>INT64FOLD</name><argument_list>(<argument><expr><call><name>lj_carith_shift64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>sh</name></expr></argument>, <argument><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>-</operator> <name>IR_BSHL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>FAILFOLD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BNOT KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_bnot64</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <return>return <expr><call><name>INT64FOLD</name><argument_list>(<argument><expr><operator>~</operator><call><name>ir_k64</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>FAILFOLD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BSWAP KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_bswap64</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <return>return <expr><call><name>INT64FOLD</name><argument_list>(<argument><expr><call><name>lj_bswap64</name><argument_list>(<argument><expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>FAILFOLD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>LT KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>GE KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>LE KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>GT KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ULT KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>UGE KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ULE KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>UGT KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_int64comp</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>a</name> <init>= <expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></init></decl>, <decl><type ref="prev"/><name>b</name> <init>= <expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>IR_LT</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>a</name> <operator>&lt;</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_GE</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>a</name> <operator>&gt;=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_LE</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>a</name> <operator>&lt;=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_GT</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>a</name> <operator>&gt;</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_ULT</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_UGE</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><name>a</name> <operator>&gt;=</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_ULE</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><name>a</name> <operator>&lt;=</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_UGT</name></expr>:</case> <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</return>
  <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>FAILFOLD</name></expr>;</return>
  </block_content>}</block></switch>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>FAILFOLD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>UGE any KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_int64comp0</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>DROPFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>FAILFOLD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

<comment type="block">/* -- Constant folding for strings ---------------------------------------- */</comment>

<macro><name>LJFOLD</name><argument_list>(<argument>SNEW KKPTR KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_snew_kptr</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>lj_str_new</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>ir_kptr</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>SNEW any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_snew_empty</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>strempty</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>STRREF KGC KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_strref</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>ir_kstr</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name>MSize</name><operator>)</operator><name><name>fright</name><operator>-&gt;</operator><name>i</name></name> <operator>&lt;=</operator> <name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>lj_ir_kkptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>strdata</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>STRREF SNEW any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_strref_snew</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>fright</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</return>  <comment type="block">/* strref(snew(ptr, len), 0) ==&gt; ptr */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* Reassociate: strref(snew(strref(str, a), len), b) ==&gt; strref(str, a+b) */</comment>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_STRREF</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRRef1</name></type> <name>str</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* IRIns * is not valid across emitir. */</comment>
      <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>, <argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Clobbers fins! */</comment>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>ot</name></name> <operator>=</operator> <call><name>IRT</name><argument_list>(<argument><expr><name>IR_STRREF</name></expr></argument>, <argument><expr><name>IRT_PGC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CALLN CARG IRCALL_lj_str_cmp</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_strcmp</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>ir_kstr</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>ir_kstr</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><call><name>lj_str_cmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* -- Constant folding and forwarding for buffers ------------------------- */</comment>

<comment type="block">/*
** Buffer ops perform stores, but their effect is limited to the buffer
** itself. Also, buffer ops are chained: a use of an op implies a use of
** all other ops up the chain. Conversely, if an op is unused, all ops
** up the chain can go unsed. This largely eliminates the need to treat
** them as stores.
**
** Alas, treating them as normal (IRM_N) ops doesn't work, because they
** cannot be CSEd in isolation. CSE for IRM_N is implicitly done in LOOP
** or if FOLD is disabled.
**
** The compromise is to declare them as loads, emit them like stores and
** CSE whole chains manually when the BUFSTR is to be emitted. Any chain
** fragments left over from CSE are eliminated by DCE.
*/</comment>

<comment type="block">/* BUFHDR is emitted like a store, see below. */</comment>

<macro><name>LJFOLD</name><argument_list>(<argument>BUFPUT BUFHDR BUFSTR</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>bufput_append</argument>)</argument_list></macro>
<block>{<block_content>
  <comment type="block">/* New buffer, no other buffer op inbetween and same buffer? */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
      <operator>!</operator><operator>(</operator><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRBUFHDR_APPEND</name><operator>)</operator> <operator>&amp;&amp;</operator>
      <name><name>fleft</name><operator>-&gt;</operator><name>prev</name></name> <operator>==</operator> <name><name>fright</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;&amp;</operator>
      <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>fright</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>op1</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>op2</name> <operator>=</operator> <operator>(</operator><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>|</operator> <name>IRBUFHDR_APPEND</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Modify BUFHDR. */</comment>
    <expr_stmt><expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>op1</name> <operator>=</operator> <name><name>fright</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <return>return <expr><name>ref</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>EMITFOLD</name></expr>;</return>  <comment type="block">/* Always emit, CSE later. */</comment>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BUFPUT any any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>bufput_kgc</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>fright</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KGC</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s2</name> <init>= <expr><call><name>ir_kstr</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s2</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Empty string? */</comment>
      <return>return <expr><name>LEFTFOLD</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>fleft</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BUFPUT</name> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	  <operator>!</operator><call><name>irt_isphi</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Join two constant string puts in a row. */</comment>
	<decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s1</name> <init>= <expr><call><name>ir_kstr</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IRRef</name></type> <name>kref</name> <init>= <expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>lj_buf_cat2str</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* lj_ir_kstr() may realloc the IR and invalidates any IRIns *. */</comment>
	<expr_stmt><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>op2</name> <operator>=</operator> <name>kref</name></expr>;</expr_stmt>  <comment type="block">/* Modify previous BUFPUT. */</comment>
	<return>return <expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>EMITFOLD</name></expr>;</return>  <comment type="block">/* Always emit, CSE later. */</comment>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BUFSTR any any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>bufstr_kfold_cse</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BUFHDR</name> <operator>||</operator> <name><name>fleft</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BUFPUT</name> <operator>||</operator>
	     <name><name>fleft</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CALLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>fleft</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BUFHDR</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* No put operations? */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRBUFHDR_APPEND</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Empty buffer? */</comment>
	<return>return <expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>strempty</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>  <comment type="block">/* Relies on checks in bufput_append. */</comment>
      <return>return <expr><name>CSEFOLD</name></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>fleft</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BUFPUT</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irb</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>irb</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BUFHDR</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>irb</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRBUFHDR_APPEND</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Shortcut for a single put operation. */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Try to CSE the whole chain. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_CSE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_BUFSTR</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>ref</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irs</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ira</name> <init>= <expr><name>fleft</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>irb</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name><name>irb</name><operator>-&gt;</operator><name>o</name></name> <operator>&amp;&amp;</operator> <name><name>ira</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name><name>irb</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BUFHDR</name> <operator>||</operator> <name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BUFPUT</name> <operator>||</operator>
		   <name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CALLL</name> <operator>||</operator> <name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BUFHDR</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>ira</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRBUFHDR_APPEND</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>ref</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* CSE succeeded. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CALLL</name> <operator>&amp;&amp;</operator> <name><name>ira</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRCALL_lj_buf_puttab</name></expr>)</condition><block type="pseudo"><block_content>
	  <break>break;</break></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>ira</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>ira</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>irb</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>irb</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>irs</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>EMITFOLD</name></expr>;</return>  <comment type="block">/* No CSE possible. */</comment>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CALLL CARG IRCALL_lj_buf_putstr_reverse</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CALLL CARG IRCALL_lj_buf_putstr_upper</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CALLL CARG IRCALL_lj_buf_putstr_lower</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CALLL CARG IRCALL_lj_strfmt_putquoted</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>bufput_kfold_op</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SBuf</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><call><name>lj_buf_tmp_</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>sb</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SBuf</name> <operator>*</operator> <operator>(</operator><name>LJ_FASTCALL</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>SBuf</name> <operator>*</operator><operator>,</operator> <name>GCstr</name> <operator>*</operator><operator>)</operator><operator>)</operator><name><name>ci</name><operator>-&gt;</operator><name>func</name></name><operator>)</operator><operator>(</operator><name>sb</name><operator>,</operator>
						       <call><name>ir_kstr</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_BUFPUT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>lj_buf_tostr</name><argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>EMITFOLD</name></expr>;</return>  <comment type="block">/* Always emit, CSE later. */</comment>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CALLL CARG IRCALL_lj_buf_putstr_rep</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>bufput_kfold_rep</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irc</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>irc</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>SBuf</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><call><name>lj_buf_tmp_</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>sb</name> <operator>=</operator> <call><name>lj_buf_putstr_rep</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><call><name>ir_kstr</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>irc</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_BUFPUT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>irc</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>lj_buf_tostr</name><argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>EMITFOLD</name></expr>;</return>  <comment type="block">/* Always emit, CSE later. */</comment>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CALLL CARG IRCALL_lj_strfmt_putfxint</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CALLL CARG IRCALL_lj_strfmt_putfnum_int</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CALLL CARG IRCALL_lj_strfmt_putfnum_uint</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CALLL CARG IRCALL_lj_strfmt_putfnum</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CALLL CARG IRCALL_lj_strfmt_putfstr</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CALLL CARG IRCALL_lj_strfmt_putfchar</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>bufput_kfold_fmt</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irc</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>irc</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* SFormat must be const. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SFormat</name></type> <name>sf</name> <init>= <expr><operator>(</operator><name>SFormat</name><operator>)</operator><call><name>IR</name><argument_list>(<argument><expr><name><name>irc</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ira</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SBuf</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><call><name>lj_buf_tmp_</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>IRCALL_lj_strfmt_putfxint</name></expr>:</case>
      <expr_stmt><expr><name>sb</name> <operator>=</operator> <call><name>lj_strfmt_putfxint</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>sf</name></expr></argument>, <argument><expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>ira</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>IRCALL_lj_strfmt_putfstr</name></expr>:</case>
      <expr_stmt><expr><name>sb</name> <operator>=</operator> <call><name>lj_strfmt_putfstr</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>sf</name></expr></argument>, <argument><expr><call><name>ir_kstr</name><argument_list>(<argument><expr><name>ira</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>IRCALL_lj_strfmt_putfchar</name></expr>:</case>
      <expr_stmt><expr><name>sb</name> <operator>=</operator> <call><name>lj_strfmt_putfchar</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>sf</name></expr></argument>, <argument><expr><name><name>ira</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>IRCALL_lj_strfmt_putfnum_int</name></expr>:</case>
    <case>case <expr><name>IRCALL_lj_strfmt_putfnum_uint</name></expr>:</case>
    <case>case <expr><name>IRCALL_lj_strfmt_putfnum</name></expr>:</case>
    <default>default:</default> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>CCallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>&amp;</operator><name><name>lj_ir_callinfo</name><index>[<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>sb</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SBuf</name> <operator>*</operator> <call>(<modifier>*</modifier>)<argument_list>(<argument><expr><name>SBuf</name> <operator>*</operator></expr></argument>, <argument><expr><name>SFormat</name></expr></argument>, <argument><expr><name>lua_Number</name></expr></argument>)</argument_list></call><operator>)</operator><name><name>ci</name><operator>-&gt;</operator><name>func</name></name><operator>)</operator><operator>(</operator><name>sb</name><operator>,</operator> <name>sf</name><operator>,</operator>
							 <call><name>ir_knum</name><argument_list>(<argument><expr><name>ira</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n</name><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_BUFPUT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>irc</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>lj_buf_tostr</name><argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>EMITFOLD</name></expr>;</return>  <comment type="block">/* Always emit, CSE later. */</comment>
</block_content>}</block>

<comment type="block">/* -- Constant folding of pointer arithmetic ------------------------------ */</comment>

<macro><name>LJFOLD</name><argument_list>(<argument>ADD KGC KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ADD KGC KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_add_kgc</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>ir_kgc</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>ofs</name> <init>= <expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><call><name>ir_kint64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>ofs</name> <init>= <expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>irt_iscdata</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gco2cd</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
	<call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isfunc</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
	<call><name>ctype_iscomplex</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isvector</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>lj_ir_kkptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>o</name> <operator>+</operator> <name>ofs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>o</name> <operator>+</operator> <name>ofs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>ADD KPTR KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ADD KPTR KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ADD KKPTR KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ADD KKPTR KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_add_kptr</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ir_kptr</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>ofs</name> <init>= <expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><call><name>ir_kint64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>ofs</name> <init>= <expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><call><name>lj_ir_kptr_</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>o</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <name>ofs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>ADD any KGC</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ADD any KPTR</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ADD any KKPTR</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_add_kright</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fleft</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name> <operator>||</operator> <name><name>fleft</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT64</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRRef1</name></type> <name>tmp</name> <init>= <expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* -- Constant folding of conversions ------------------------------------- */</comment>

<macro><name>LJFOLD</name><argument_list>(<argument>TOBIT KNUM KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_tobit</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><call><name>lj_num2bit</name><argument_list>(<argument><expr><name>knumleft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV KINT IRCONV_NUM_INT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_conv_kint_num</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV KINT IRCONV_NUM_U32</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_conv_kintu32_num</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV KINT IRCONV_INT_I8</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV KINT IRCONV_INT_U8</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV KINT IRCONV_INT_I16</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV KINT IRCONV_INT_U16</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_conv_kint_ext</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator> <operator>==</operator> <name>IRT_I8</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>int8_t</name><operator>)</operator><name>k</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator> <operator>==</operator> <name>IRT_U8</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>k</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator> <operator>==</operator> <name>IRT_I16</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><name>k</name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>k</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV KINT IRCONV_I64_INT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV KINT IRCONV_U64_INT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV KINT IRCONV_I64_U32</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV KINT IRCONV_U64_U32</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_conv_kint_i64</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SEXT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>INT64FOLD</name><argument_list>(<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><call><name>INT64FOLD</name><argument_list>(<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV KINT64 IRCONV_NUM_I64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_conv_kint64_num_i64</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><operator>(</operator><name>int64_t</name><operator>)</operator><call><name>ir_kint64</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV KINT64 IRCONV_NUM_U64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_conv_kint64_num_u64</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><call><name>ir_kint64</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV KINT64 IRCONV_INT_I64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV KINT64 IRCONV_U32_I64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_conv_kint64_int_i64</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>ir_kint64</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV KNUM IRCONV_INT_NUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_conv_knum_int_num</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name> <init>= <expr><name>knumleft</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>lj_num2int</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>irt_isguard</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>!=</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* We're about to create a guard which always fails, like CONV +1.5.
    ** Some pathological loops cause this during LICM, e.g.:
    **   local x,k,t = 0,1.5,{1,[1.5]=2}
    **   for i=1,200 do x = x+ t[k]; k = k == 1 and 1.5 or 1 end
    **   assert(x == 300)
    */</comment>
    <return>return <expr><name>FAILFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV KNUM IRCONV_U32_NUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_conv_knum_u32_num</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
  <block>{<block_content>  <comment type="block">/* Workaround for MSVC bug. */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>uint32_t</name></type> <name>u</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>knumleft</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>knumleft</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV KNUM IRCONV_I64_NUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_conv_knum_i64_num</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>INT64FOLD</name><argument_list>(<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>knumleft</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV KNUM IRCONV_U64_NUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_conv_knum_u64_num</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>INT64FOLD</name><argument_list>(<argument><expr><call><name>lj_num2u64</name><argument_list>(<argument><expr><name>knumleft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>TOSTR KNUM any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_tostr_knum</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>lj_strfmt_num</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><call><name>ir_knum</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>TOSTR KINT any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_tostr_kint</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>lj_ir_kstr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRTOSTR_INT</name></expr> ?</condition><then>
		       <expr><call><name>lj_strfmt_int</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
		       <expr><call><name>lj_strfmt_char</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>STRTO KGC</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_strto</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>n</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lj_strscan_num</name><argument_list>(<argument><expr><call><name>ir_kstr</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>numV</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>FAILFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* -- Constant folding of equality checks --------------------------------- */</comment>

<comment type="block">/* Don't constant-fold away FLOAD checks against KNULL. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>EQ FLOAD KNULL</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>NE FLOAD KNULL</argument>)</argument_list></macro>
<macro><name>LJFOLDX</name><argument_list>(<argument>lj_opt_cse</argument>)</argument_list></macro>

<comment type="block">/* But fold all other KNULL compares, since only KNULL is equal to KNULL. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>EQ any KNULL</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>NE any KNULL</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>EQ KNULL any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>NE KNULL any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>EQ KINT KINT</argument>)</argument_list></macro>  <comment type="block">/* Constants are unique, so same refs &lt;==&gt; same value. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>NE KINT KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>EQ KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>NE KINT64 KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>EQ KGC KGC</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>NE KGC KGC</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_kref</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name><operator>)</operator> <operator>^</operator> <operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_NE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<comment type="block">/* -- Algebraic shortcuts ------------------------------------------------- */</comment>

<macro><name>LJFOLD</name><argument_list>(<argument>FPMATH FPMATH IRFPM_FLOOR</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FPMATH FPMATH IRFPM_CEIL</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FPMATH FPMATH IRFPM_TRUNC</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>shortcut_round</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRFPMathOp</name></type> <name>op</name> <init>= <expr><operator>(</operator><name>IRFPMathOp</name><operator>)</operator><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>IRFPM_FLOOR</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>IRFPM_CEIL</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>IRFPM_TRUNC</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* round(round_left(x)) = round_left(x) */</comment>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>ABS ABS FLOAD</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>shortcut_left</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><name>LEFTFOLD</name></expr>;</return>  <comment type="block">/* f(g(x)) ==&gt; g(x) */</comment>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>ABS NEG FLOAD</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>shortcut_dropleft</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>  <comment type="block">/* abs(neg(x)) ==&gt; abs(x) */</comment>
  <return>return <expr><name>RETRYFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Note: no safe shortcuts with STRTO and TOSTR ("1e2" ==&gt; +100 ==&gt; "100"). */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>NEG NEG any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BNOT BNOT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSWAP BSWAP</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>shortcut_leftleft</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* See above. Fold would be ok, but not beneficial. */</comment>
  <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</return>  <comment type="block">/* f(g(x)) ==&gt; x */</comment>
</block_content>}</block>

<comment type="block">/* -- FP algebraic simplifications ---------------------------------------- */</comment>

<comment type="block">/* FP arithmetic is tricky -- there's not much to simplify.
** Please note the following common pitfalls before sending "improvements":
**   x+0 ==&gt; x  is INVALID for x=-0
**   0-x ==&gt; -x is INVALID for x=+0
**   x*0 ==&gt; 0  is INVALID for x=-0, x=+-Inf or x=NaN
*/</comment>

<macro><name>LJFOLD</name><argument_list>(<argument>ADD NEG any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_numadd_negx</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_SUB</name></expr>;</expr_stmt>  <comment type="block">/* (-a) + b ==&gt; b - a */</comment>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
  <return>return <expr><name>RETRYFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>ADD any NEG</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_numadd_xneg</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_SUB</name></expr>;</expr_stmt>  <comment type="block">/* a + (-b) ==&gt; a - b */</comment>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fright</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
  <return>return <expr><name>RETRYFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>SUB any KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_numsub_k</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name> <init>= <expr><name>knumright</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* x - (+-0) ==&gt; x */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>SUB NEG KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_numsub_negk</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>  <comment type="block">/* (-x) - k ==&gt; (-k) - x */</comment>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>-</operator><name>knumright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>RETRYFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>SUB any NEG</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_numsub_xneg</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_ADD</name></expr>;</expr_stmt>  <comment type="block">/* a - (-b) ==&gt; a + b */</comment>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fright</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
  <return>return <expr><name>RETRYFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>MUL any KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>DIV any KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_nummuldiv_k</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name> <init>= <expr><name>knumright</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1.0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* x o 1 ==&gt; x */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <operator>-</operator><literal type="number">1.0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* x o -1 ==&gt; -x */</comment>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>op1</name> <init>= <expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_ksimd</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_KSIMD_NEG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Modifies fins. */</comment>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name>op1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_NEG</name></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_MUL</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">2.0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* x * 2 ==&gt; x + x */</comment>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_ADD</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_DIV</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* x / 2^k ==&gt; x * 2^-k */</comment>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>u</name> <init>= <expr><call><name>ir_knum</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>ex</name> <init>= <expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>u</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7ff</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>u</name> <operator>&amp;</operator> <call><name>U64x</name><argument_list>(<argument><expr><literal type="number">000fffff</literal></expr></argument>,<argument><expr><name>ffffffff</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ex</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;</operator> <literal type="number">0x7fd</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>u</name> <operator>=</operator> <operator>(</operator><name>u</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">63</literal><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><literal type="number">0x7fe</literal> <operator>-</operator> <name>ex</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">52</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_MUL</name></expr>;</expr_stmt>  <comment type="block">/* Multiply by exact reciprocal. */</comment>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <call><name>lj_ir_knum_u64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>MUL NEG KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>DIV NEG KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_nummuldiv_negk</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>  <comment type="block">/* (-a) o k ==&gt; a o (-k) */</comment>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_knum</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>-</operator><name>knumright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>RETRYFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>MUL NEG NEG</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>DIV NEG NEG</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_nummuldiv_negneg</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>  <comment type="block">/* (-a) o (-b) ==&gt; a o b */</comment>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fright</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
  <return>return <expr><name>RETRYFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>POW any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_numpow_xkint</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>ref</name> <init>= <expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* x ^ 0 ==&gt; 1 */</comment>
    <return>return <expr><call><name>lj_ir_knum_one</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Result must be a number, not an int. */</comment>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* x ^ 1 ==&gt; x */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>k</name><operator>+</operator><literal type="number">65536</literal><operator>)</operator> <operator>&gt;</operator> <literal type="number">2</literal><operator>*</operator><literal type="number">65536u</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Limit code explosion. */</comment>
    <return>return <expr><name>NEXTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* x ^ (-k) ==&gt; (1/x) ^ k. */</comment>
    <expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_DIV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lj_ir_knum_one</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>-</operator><name>k</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Unroll x^k for 1 &lt;= k &lt;= 65536. */</comment>
  <for>for <control>(<init>;</init> <condition><expr><operator>(</operator><name>k</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>k</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* Handle leading zeros. */</comment>
    <expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_MUL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>k</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Handle trailing bits. */</comment>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tmp</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_MUL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>k</name> <operator>!=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>k</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_MUL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_MUL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_MUL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>ref</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>POW any KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_numpow_xknum</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>knumright</name> <operator>==</operator> <literal type="number">0.5</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* x ^ 0.5 ==&gt; sqrt(x) */</comment>
    <return>return <expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_FPMATH</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>, <argument><expr><name>IRFPM_SQRT</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>POW KNUM any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_numpow_kx</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name> <init>= <expr><name>knumleft</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">2.0</literal> <operator>&amp;&amp;</operator> <call><name>irt_isint</name><argument_list>(<argument><expr><name><name>fright</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* 2.0 ^ i ==&gt; ldexp(1.0, i) */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
    <comment type="block">/* Different IR_LDEXP calling convention on x86/x64 requires conversion. */</comment>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_CONV</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>IRCONV_NUM_INT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_opt_fold</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_knum_one</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_LDEXP</name></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* -- Simplify conversions ------------------------------------------------ */</comment>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV CONV IRCONV_NUM_INT</argument>)</argument_list></macro>  <comment type="block">/* _NUM */</comment>
<macro><name>LJFOLDF</name><argument_list>(<argument>shortcut_conv_num_int</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Only safe with a guarded conversion to int. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator> <operator>==</operator> <name>IRT_NUM</name> <operator>&amp;&amp;</operator> <call><name>irt_isguard</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* f(g(x)) ==&gt; x */</comment>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV CONV IRCONV_INT_NUM</argument>)</argument_list></macro>  <comment type="block">/* _INT */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV CONV IRCONV_U32_NUM</argument>)</argument_list></macro>  <comment type="block">/* _U32*/</comment>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_conv_int_num</argument>)</argument_list></macro>
<block>{<block_content>
  <comment type="block">/* Fold even across PHI to avoid expensive num-&gt;int conversions in loop. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator> <operator>==</operator>
      <operator>(</operator><operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_DSTMASK</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>IRCONV_DSH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV CONV IRCONV_I64_NUM</argument>)</argument_list></macro>  <comment type="block">/* _INT or _U32 */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV CONV IRCONV_U64_NUM</argument>)</argument_list></macro>  <comment type="block">/* _INT or _U32 */</comment>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_conv_i64_num</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator> <operator>==</operator> <name>IRT_INT</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Reduce to a sign-extension. */</comment>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>IRT_I64</name><operator>&lt;&lt;</operator><literal type="number">5</literal><operator>)</operator><operator>|</operator><name>IRT_INT</name><operator>|</operator><name>IRCONV_SEXT</name><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator> <operator>==</operator> <name>IRT_U32</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:if>
    <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Reduce to a zero-extension. */</comment>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRT_I64</name><operator>&lt;&lt;</operator><literal type="number">5</literal><operator>)</operator><operator>|</operator><name>IRT_U32</name></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV CONV IRCONV_INT_I64</argument>)</argument_list></macro>  <comment type="block">/* _INT or _U32 */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV CONV IRCONV_INT_U64</argument>)</argument_list></macro>  <comment type="block">/* _INT or _U32 */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV CONV IRCONV_U32_I64</argument>)</argument_list></macro>  <comment type="block">/* _INT or _U32 */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV CONV IRCONV_U32_U64</argument>)</argument_list></macro>  <comment type="block">/* _INT or _U32 */</comment>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_conv_int_i64</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>src</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>IRT_INT</name> <operator>||</operator> <name>src</name> <operator>==</operator> <name>IRT_U32</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_DSTMASK</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>IRCONV_DSH</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_DSTMASK</name><operator>)</operator> <operator>|</operator> <name>src</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>CONV CONV IRCONV_FLOAT_NUM</argument>)</argument_list></macro>  <comment type="block">/* _FLOAT */</comment>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_conv_flt_num</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator> <operator>==</operator> <name>IRT_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Shortcut TOBIT + IRT_NUM &lt;- IRT_INT/IRT_U32 conversion. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>TOBIT CONV KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_tobit_conv</argument>)</argument_list></macro>
<block>{<block_content>
  <comment type="block">/* Fold even across PHI to avoid expensive num-&gt;int conversions in loop. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator> <operator>==</operator> <name>IRT_INT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator> <operator>==</operator> <name>IRT_U32</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_CONV</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRT_INT</name><operator>&lt;&lt;</operator><literal type="number">5</literal><operator>)</operator><operator>|</operator><name>IRT_U32</name></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Shortcut floor/ceil/round + IRT_NUM &lt;- IRT_INT/IRT_U32 conversion. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>FPMATH CONV IRFPM_FLOOR</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FPMATH CONV IRFPM_CEIL</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FPMATH CONV IRFPM_TRUNC</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_floor_conv</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator> <operator>==</operator> <name>IRT_INT</name> <operator>||</operator>
      <operator>(</operator><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator> <operator>==</operator> <name>IRT_U32</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Strength reduction of widening. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV any IRCONV_I64_INT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV any IRCONV_U64_INT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_conv_sext</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>ofs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SEXT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NEXTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>fleft</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_XLOAD</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>irt_isu8</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>irt_isu16</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>ok_reduce</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>fleft</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_ADD</name> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ofs</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Use scalar evolution analysis results to strength-reduce sign-extension. */</comment>
  <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>==</operator> <name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>idx</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>lo</name> <init>= <expr><ternary><condition><expr><name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>dir</name></name></expr> ?</condition><then> <expr><name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>start</name></name></expr> </then><else>: <expr><name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>stop</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>irt_isint</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>scev</name><operator>.</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>lo</name> <operator>&amp;&amp;</operator> <call><name>IR</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_KINT</name> <operator>&amp;&amp;</operator> <call><name>IR</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name> <operator>+</operator> <name>ofs</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <label><name>ok_reduce</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:if>
      <comment type="block">/* Eliminate widening. All 32 bit ops do an implicit zero-extension. */</comment>
      <return>return <expr><name>LEFTFOLD</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* Reduce to a (cheaper) zero-extension. */</comment>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>IRCONV_SEXT</name></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Strength reduction of narrowing. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV ADD IRCONV_INT_I64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV SUB IRCONV_INT_I64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV MUL IRCONV_INT_I64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV ADD IRCONV_INT_U64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV SUB IRCONV_INT_U64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV MUL IRCONV_INT_U64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV ADD IRCONV_U32_I64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV SUB IRCONV_U32_I64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV MUL IRCONV_U32_I64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV ADD IRCONV_U32_U64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV SUB IRCONV_U32_U64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV MUL IRCONV_U32_U64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_conv_narrow</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IROp</name></type> <name>op</name> <init>= <expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>fleft</name><operator>-&gt;</operator><name>o</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><call><name>irt_type</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>op1</name> <init>= <expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>, <decl><type ref="prev"/><name>op2</name> <init>= <expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></init></decl>, <decl><type ref="prev"/><name>mode</name> <init>= <expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>op1</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>op1</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>op2</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>op2</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>ot</name></name> <operator>=</operator> <call><name>IRT</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name>op1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>op2</name></expr>;</expr_stmt>
  <return>return <expr><name>RETRYFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Special CSE rule for CONV. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV any any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>cse_conv</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_CSE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>op1</name> <init>= <expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>, <decl><type ref="prev"/><name>op2</name> <init>= <expr><operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_MODEMASK</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>guard</name> <init>= <expr><call><name>irt_isguard</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_CONV</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>ref</name> <operator>&gt;</operator> <name>op1</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="block">/* Commoning with stronger checks is ok. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name>op1</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_MODEMASK</name><operator>)</operator> <operator>==</operator> <name>op2</name> <operator>&amp;&amp;</operator>
	  <call><name>irt_isguard</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>guard</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>ref</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>EMITFOLD</name></expr>;</return>  <comment type="block">/* No fallthrough to regular CSE. */</comment>
</block_content>}</block>

<comment type="block">/* FP conversion narrowing. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>TOBIT ADD KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>TOBIT SUB KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV ADD IRCONV_INT_NUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV SUB IRCONV_INT_NUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV ADD IRCONV_I64_NUM</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CONV SUB IRCONV_I64_NUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>narrow_convert</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Narrowing ignores PHIs and repeating it inside the loop is not useful. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_LOOP</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NEXTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>!=</operator> <name>IR_CONV</name> <operator>||</operator> <operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name><operator>&amp;</operator><name>IRCONV_CONVMASK</name><operator>)</operator> <operator>!=</operator> <name>IRCONV_TOBIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>lj_opt_narrow_convert</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<comment type="block">/* -- Integer algebraic simplifications ----------------------------------- */</comment>

<macro><name>LJFOLD</name><argument_list>(<argument>ADD any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ADDOV any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>SUBOV any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intadd_k</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i o 0 ==&gt; i */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>MULOV any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intmul_k</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i * 0 ==&gt; 0 */</comment>
    <return>return <expr><name>RIGHTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i * 1 ==&gt; i */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* i * 2 ==&gt; i + i */</comment>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_ADDOV</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>SUB any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intsub_k</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i - 0 ==&gt; i */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_ADD</name></expr>;</expr_stmt>  <comment type="block">/* i - k ==&gt; i + (-k) */</comment>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>-</operator><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Overflow for -2^31 ok. */</comment>
  <return>return <expr><name>RETRYFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>SUB KINT any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>SUB KINT64 any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intsub_kleft</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><ternary><condition><expr><name><name>fleft</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name></expr> ?</condition><then> <expr><operator>(</operator><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><call><name>ir_kint64</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></else></ternary></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_NEG</name></expr>;</expr_stmt>  <comment type="block">/* 0 - i ==&gt; -i */</comment>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>ADD any KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intadd_k64</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>ir_kint64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i + 0 ==&gt; i */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>SUB any KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intsub_k64</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>k</name> <init>= <expr><call><name>ir_kint64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i - 0 ==&gt; i */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_ADD</name></expr>;</expr_stmt>  <comment type="block">/* i - k ==&gt; i + (-k) */</comment>
  <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_kint64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>-</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>RETRYFOLD</name></expr>;</return>
</block_content>}</block>

<function><type><specifier>static</specifier> <name>TRef</name></type> <name>simplify_intmul_k</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Note: many more simplifications are possible, e.g. 2^k1 +- 2^k2.
  ** But this is mainly intended for simple address arithmetic.
  ** Also it's easier for the backend to optimize the original multiplies.
  */</comment>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* i * 0 ==&gt; 0 */</comment>
    <return>return <expr><name>RIGHTFOLD</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* i * 1 ==&gt; i */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>k</name> <operator>&amp;</operator> <operator>(</operator><name>k</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* i * 2^k ==&gt; i &lt;&lt; k */</comment>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_BSHL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>lj_fls</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block></function>

<macro><name>LJFOLD</name><argument_list>(<argument>MUL any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intmul_k32</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>simplify_intmul_k</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>MUL any KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intmul_k64</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>ir_kint64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name> <operator>&lt;</operator> <literal type="number">0x80000000u</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>simplify_intmul_k</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>ir_kint64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>FAILFOLD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>MOD any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intmod_k</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>k</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>k</name> <operator>&amp;</operator> <operator>(</operator><name>k</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* i % (2^k) ==&gt; i &amp; (2^k-1) */</comment>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_BAND</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>k</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>MOD KINT any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intmod_kleft</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>SUB any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>SUBOV any any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intsub</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i - i ==&gt; 0 */</comment>
    <return>return <expr><ternary><condition><expr><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>INT64FOLD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>SUB ADD any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intsubadd_leftcancel</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* (i + j) - i ==&gt; j */</comment>
      <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* (i + j) - j ==&gt; i */</comment>
      <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>SUB SUB any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intsubsub_leftcancel</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* (i - j) - i ==&gt; 0 - j */</comment>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>SUB any SUB</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intsubsub_rightcancel</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>fright</name><operator>-&gt;</operator><name>op1</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i - (i - j) ==&gt; j */</comment>
      <return>return <expr><name><name>fright</name><operator>-&gt;</operator><name>op2</name></name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>SUB any ADD</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intsubadd_rightcancel</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>fright</name><operator>-&gt;</operator><name>op1</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* i - (i + j) ==&gt; 0 - j */</comment>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fright</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>fright</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* i - (j + i) ==&gt; 0 - j */</comment>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fright</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>SUB ADD ADD</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_intsubaddadd_cancel</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>fright</name><operator>-&gt;</operator><name>op1</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* (i + j1) - (i + j2) ==&gt; j1 - j2 */</comment>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fright</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>fright</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* (i + j1) - (j2 + i) ==&gt; j1 - j2 */</comment>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fright</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name><name>fright</name><operator>-&gt;</operator><name>op1</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* (j1 + i) - (i + j2) ==&gt; j1 - j2 */</comment>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fright</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name><name>fright</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* (j1 + i) - (j2 + i) ==&gt; j1 - j2 */</comment>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fright</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BAND any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BAND any KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_band_k</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><ternary><condition><expr><name><name>fright</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name></expr> ?</condition><then> <expr><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr> </then><else>:
				     <expr><operator>(</operator><name>int64_t</name><operator>)</operator><call><name>ir_k64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i &amp; 0 ==&gt; 0 */</comment>
    <return>return <expr><name>RIGHTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i &amp; -1 ==&gt; i */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BOR any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BOR any KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_bor_k</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><ternary><condition><expr><name><name>fright</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name></expr> ?</condition><then> <expr><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr> </then><else>:
				     <expr><operator>(</operator><name>int64_t</name><operator>)</operator><call><name>ir_k64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i | 0 ==&gt; i */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i | -1 ==&gt; -1 */</comment>
    <return>return <expr><name>RIGHTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BXOR any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BXOR any KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_bxor_k</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><ternary><condition><expr><name><name>fright</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name></expr> ?</condition><then> <expr><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr> </then><else>:
				     <expr><operator>(</operator><name>int64_t</name><operator>)</operator><call><name>ir_k64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i xor 0 ==&gt; i */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* i xor -1 ==&gt; ~i */</comment>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_BNOT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BSHL any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSHR any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSAR any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROL any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROR any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_shift_ik</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>mask</name> <init>= <expr><ternary><condition><expr><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">63</literal></expr> </then><else>: <expr><literal type="number">31</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><operator>(</operator><name><name>fright</name><operator>-&gt;</operator><name>i</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i o 0 ==&gt; i */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BSHL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* i &lt;&lt; 1 ==&gt; i + i */</comment>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_ADD</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>!=</operator> <name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* i o k ==&gt; i o (k &amp; mask) */</comment>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LJ_TARGET_UNIFYROT</name></cpp:ifndef>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BROR</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* bror(i, k) ==&gt; brol(i, (-k)&amp;mask) */</comment>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_BROL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><operator>-</operator><name>k</name><operator>)</operator><operator>&amp;</operator><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BSHL any BAND</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSHR any BAND</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSAR any BAND</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROL any BAND</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROR any BAND</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_shift_andk</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irk</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fright</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>&lt;</operator> <name>IR_BROL</name></expr> ?</condition><then> <expr><name>LJ_TARGET_MASKSHIFT</name></expr> </then><else>: <expr><name>LJ_TARGET_MASKROT</name></expr></else></ternary><operator>)</operator> <operator>&amp;&amp;</operator>
      <name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* i o (j &amp; mask) ==&gt; i o j */</comment>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>mask</name> <init>= <expr><ternary><condition><expr><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">63</literal></expr> </then><else>: <expr><literal type="number">31</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><name><name>irk</name><operator>-&gt;</operator><name>i</name></name> <operator>&amp;</operator> <name>mask</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <name>mask</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fright</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BSHL KINT any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSHR KINT any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSHL KINT64 any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSHR KINT64 any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_shift1_ki</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><ternary><condition><expr><name><name>fleft</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name></expr> ?</condition><then> <expr><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name></expr> </then><else>:
				    <expr><operator>(</operator><name>int64_t</name><operator>)</operator><call><name>ir_k64</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* 0 o i ==&gt; 0 */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BSAR KINT any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROL KINT any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROR KINT any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSAR KINT64 any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROL KINT64 any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROR KINT64 any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_shift2_ki</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>k</name> <init>= <expr><ternary><condition><expr><name><name>fleft</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name></expr> ?</condition><then> <expr><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>fleft</name><operator>-&gt;</operator><name>i</name></name></expr> </then><else>:
				    <expr><operator>(</operator><name>int64_t</name><operator>)</operator><call><name>ir_k64</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>k</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* 0 o i ==&gt; 0; -1 o i ==&gt; -1 */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BSHL BAND KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSHR BAND KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROL BAND KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROR BAND KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_shiftk_andk</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irk</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* (i &amp; k1) o k2 ==&gt; (i o k2) &amp; (k1 o k2) */</comment>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>kfold_intop</name><argument_list>(<argument><expr><name><name>irk</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_opt_fold</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>ot</name></name> <operator>=</operator> <call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT64</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>k</name> <init>= <expr><call><name>kfold_int64arith</name><argument_list>(<argument><expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>irk</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>, <argument><expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IROpT</name></type> <name>ot</name> <init>= <expr><name><name>fleft</name><operator>-&gt;</operator><name>ot</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_opt_fold</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_kint64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>ot</name></name> <operator>=</operator> <name>ot</name></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BAND BSHL KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BAND BSHR KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_andk_shiftk</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irk</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name> <operator>&amp;&amp;</operator>
      <call><name>kfold_intop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>irk</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>fleft</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* (i o k1) &amp; k2 ==&gt; i, if (-1 o k1) == k2 */</comment>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BAND BOR KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BOR BAND KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_andor_k</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irk</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>kfold_intop</name><argument_list>(<argument><expr><name><name>irk</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* (i | k1) &amp; k2 ==&gt; i &amp; k2, if (k1 &amp; k2) == 0. */</comment>
    <comment type="block">/* (i &amp; k1) | k2 ==&gt; i | k2, if (k1 | k2) == -1. */</comment>
    <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <operator>(</operator><ternary><condition><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BAND</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BAND BOR KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BOR BAND KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>simplify_andor_k64</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irk</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT64</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>k</name> <init>= <expr><call><name>kfold_int64arith</name><argument_list>(<argument><expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>irk</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>,
				  <argument><expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* (i | k1) &amp; k2 ==&gt; i &amp; k2, if (k1 &amp; k2) == 0. */</comment>
    <comment type="block">/* (i &amp; k1) | k2 ==&gt; i | k2, if (k1 | k2) == -1. */</comment>
    <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <operator>(</operator><ternary><condition><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BAND</name></expr> ?</condition><then> <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">0</literal></expr> </then><else>: <expr><operator>~</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>FAILFOLD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

<comment type="block">/* -- Reassociation ------------------------------------------------------- */</comment>

<macro><name>LJFOLD</name><argument_list>(<argument>ADD ADD KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MUL MUL KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BAND BAND KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BOR BOR KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BXOR BXOR KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>reassoc_intarith_k</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irk</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>kfold_intop</name><argument_list>(<argument><expr><name><name>irk</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <name><name>irk</name><operator>-&gt;</operator><name>i</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* (i o k1) o k2 ==&gt; i o k1, if (k1 o k2) == k1. */</comment>
      <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>  <comment type="block">/* (i o k1) o k2 ==&gt; i o (k1 o k2) */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>ADD ADD KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MUL MUL KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BAND BAND KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BOR BOR KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BXOR BXOR KINT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>reassoc_intarith_k64</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irk</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT64</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>k</name> <init>= <expr><call><name>kfold_int64arith</name><argument_list>(<argument><expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>irk</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>,
				  <argument><expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_kint64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>  <comment type="block">/* (i o k1) o k2 ==&gt; i o (k1 o k2) */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>FAILFOLD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BAND BAND any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BOR BOR any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>reassoc_dup</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name> <operator>||</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* (a o b) o a ==&gt; a o b; (a o b) o b ==&gt; a o b */</comment>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>MIN MIN any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MAX MAX any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>reassoc_dup_minmax</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* (a o b) o b ==&gt; a o b */</comment>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BXOR BXOR any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>reassoc_bxor</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* (a xor b) xor a ==&gt; b */</comment>
    <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* (a xor b) xor b ==&gt; a */</comment>
    <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BSHL BSHL KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSHR BSHR KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BSAR BSAR KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROL BROL KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BROR BROR KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>reassoc_shift</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irk</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* The (shift any KINT) rule covers k2 == 0 and more. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* (i o k1) o k2 ==&gt; i o (k1 + k2) */</comment>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>mask</name> <init>= <expr><ternary><condition><expr><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">63</literal></expr> </then><else>: <expr><literal type="number">31</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><operator>(</operator><name><name>irk</name><operator>-&gt;</operator><name>i</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>fright</name><operator>-&gt;</operator><name>i</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <name>mask</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Combined shift too wide? */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BSHL</name> <operator>||</operator> <name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BSHR</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><ternary><condition><expr><name>mask</name> <operator>==</operator> <literal type="number">31</literal></expr> ?</condition><then> <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>INT64FOLD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_BSAR</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <name>mask</name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name>k</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>MIN MIN KINT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MAX MAX KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>reassoc_minmax_k</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irk</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>a</name> <init>= <expr><name><name>irk</name><operator>-&gt;</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>y</name> <init>= <expr><call><name>kfold_intop</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name></expr></argument>, <argument><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>y</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* (x o k1) o k2 ==&gt; x o k1, if (k1 o k2) == k1. */</comment>
      <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>  <comment type="block">/* (x o k1) o k2 ==&gt; x o (k1 o k2) */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* -- Array bounds check elimination -------------------------------------- */</comment>

<comment type="block">/* Eliminate ABC across PHIs to handle t[i-1] forwarding case.
** ABC(asize, (i+k)+(-k)) ==&gt; ABC(asize, i), but only if it already exists.
** Could be generalized to (i+k1)+k2 ==&gt; i+(k1+k2), but needs better disambig.
*/</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>ABC any ADD</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>abc_fwd</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_ABC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>fright</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>add2</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fright</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>add2</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_ADD</name> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name><name>add2</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	  <call><name>IR</name><argument_list>(<argument><expr><name><name>fright</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name> <operator>==</operator> <operator>-</operator><call><name>IR</name><argument_list>(<argument><expr><name><name>add2</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_ABC</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IRRef</name></type> <name>lim</name> <init>= <expr><name><name>add2</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>&gt;</operator> <name>lim</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lim</name> <operator>=</operator> <name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<while>while <condition>(<expr><name>ref</name> <operator>&gt;</operator> <name>lim</name></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name><name>add2</name><operator>-&gt;</operator><name>op1</name></name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>DROPFOLD</name></expr>;</return></block_content></block></if></if_stmt>
	  <expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Eliminate ABC for constants.
** ABC(asize, k1), ABC(asize k2) ==&gt; ABC(asize, max(k1, k2))
** Drop second ABC if k2 is lower. Otherwise patch first ABC with k2.
*/</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>ABC any KINT</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>abc_k</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_ABC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_ABC</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>asize</name> <init>= <expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>ref</name> <operator>&gt;</operator> <name>asize</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name>asize</name> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fright</name><operator>-&gt;</operator><name>i</name></name> <operator>&gt;</operator> <name>k</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>DROPFOLD</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>EMITFOLD</name></expr>;</return>  <comment type="block">/* Already performed CSE. */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Eliminate invariant ABC inside loop. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>ABC any any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>abc_invar</argument>)</argument_list></macro>
<block>{<block_content>
  <comment type="block">/* Invariant ABC marked as PTR. Drop if op1 is invariant, too. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irt_isint</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>&lt;</operator> <name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_LOOP</name></expr>]</index></name> <operator>&amp;&amp;</operator>
      <operator>!</operator><call><name>irt_isphi</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>DROPFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* -- Commutativity ------------------------------------------------------- */</comment>

<comment type="block">/* The refs of commutative ops are canonicalized. Lower refs go to the right.
** Rationale behind this:
** - It (also) moves constants to the right.
** - It reduces the number of FOLD rules (e.g. (BOR any KINT) suffices).
** - It helps CSE to find more matches.
** - The assembler generates better code with constants at the right.
*/</comment>

<macro><name>LJFOLD</name><argument_list>(<argument>ADD any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MUL any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ADDOV any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MULOV any any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>comm_swap</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>&lt;</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Move lower ref to the right. */</comment>
    <decl_stmt><decl><type><name>IRRef1</name></type> <name>tmp</name> <init>= <expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>EQ any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>NE any any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>comm_equal</argument>)</argument_list></macro>
<block>{<block_content>
  <comment type="block">/* For non-numbers only: x == x ==&gt; drop; x ~= x ==&gt; fail */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_EQ</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>fold_comm_swap</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>LT any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>GE any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>LE any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>GT any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ULT any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>UGE any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>ULE any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>UGT any any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>comm_comp</argument>)</argument_list></macro>
<block>{<block_content>
  <comment type="block">/* For non-numbers only: x &lt;=&gt; x ==&gt; drop; x &lt;&gt; x ==&gt; fail */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>CONDFOLD</name><argument_list>(<argument><expr><operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>^</operator> <operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>&lt;</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Move lower ref to the right. */</comment>
    <decl_stmt><decl><type><name>IRRef1</name></type> <name>tmp</name> <init>= <expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>^=</operator> <literal type="number">3</literal></expr>;</expr_stmt> <comment type="block">/* GT &lt;-&gt; LT, GE &lt;-&gt; LE, does not affect U */</comment>
    <return>return <expr><name>RETRYFOLD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BAND any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BOR any any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>comm_dup</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* x o x ==&gt; x */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>fold_comm_swap</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>MIN any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>MAX any any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>comm_dup_minmax</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* x o x ==&gt; x */</comment>
    <return>return <expr><name>LEFTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>BXOR any any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>comm_bxor</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* i xor i ==&gt; 0 */</comment>
    <return>return <expr><ternary><condition><expr><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>INT64FOLD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>fold_comm_swap</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<comment type="block">/* -- Simplification of compound expressions ------------------------------ */</comment>

<function><type><specifier>static</specifier> <name>TRef</name></type> <name>kfold_xload</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>irt_type</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>IRT_NUM</name></expr>:</case> <return>return <expr><call><name>lj_ir_knum_u64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IRT_I8</name></expr>:</case> <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IRT_U8</name></expr>:</case> <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IRT_I16</name></expr>:</case> <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>int16_t</name><operator>)</operator><call><name>lj_getu16</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IRT_U16</name></expr>:</case> <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>uint16_t</name><operator>)</operator><call><name>lj_getu16</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IRT_INT</name></expr>:</case> <case>case <expr><name>IRT_U32</name></expr>:</case> <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><call><name>lj_getu32</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IRT_I64</name></expr>:</case> <case>case <expr><name>IRT_U64</name></expr>:</case> <return>return <expr><call><name>lj_ir_kint64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
  <default>default:</default> <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
  <return>return <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Turn: string.sub(str, a, b) == kstr
** into: string.byte(str, a) == string.byte(kstr, 1) etc.
** Note: this creates unaligned XLOADs on x86/x64.
*/</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>EQ SNEW KGC</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>NE SNEW KGC</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>merge_eqne_snew_kgc</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>kstr</name> <init>= <expr><call><name>ir_kstr</name><argument_list>(<argument><expr><name>fright</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>kstr</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>irt_isstr</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_UNALIGNED</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOLD_SNEW_MAX_LEN</name></cpp:macro>	<cpp:value>4</cpp:value></cpp:define>  <comment type="block">/* Handle string lengths 0, 1, 2, 3, 4. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOLD_SNEW_TYPE8</name></cpp:macro>		<cpp:value>IRT_I8</cpp:value></cpp:define>	<comment type="block">/* Creates shorter immediates. */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOLD_SNEW_MAX_LEN</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>  <comment type="block">/* Handle string lengths 0 or 1. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOLD_SNEW_TYPE8</name></cpp:macro>		<cpp:value>IRT_U8</cpp:value></cpp:define>  <comment type="block">/* Prefer unsigned loads. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>FOLD_SNEW_MAX_LEN</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IROp</name></type> <name>op</name> <init>= <expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>strref</name> <init>= <expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IR</name><argument_list>(<argument><expr><name>strref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>o</name> <operator>!=</operator> <name>IR_STRREF</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>NEXTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>IR_EQ</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Caveat: fins/fleft/fright is no longer valid after emitir. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="block">/* NE is not expanded since this would need an OR of two conds. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Only handle the constant length case. */</comment>
	<return>return <expr><name>NEXTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>DROPFOLD</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="block">/* A 4 byte load for length 3 is ok -- all strings have an extra NUL. */</comment>
      <decl_stmt><decl><type><name>uint16_t</name></type> <name>ot</name> <init>= <expr><operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>FOLD_SNEW_TYPE8</name></expr></argument>)</argument_list></call></expr> </then><else>:
			       <expr><ternary><condition><expr><name>len</name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>IRT_U16</name></expr></argument>)</argument_list></call></expr> </then><else>:
			       <expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TRef</name></type> <name>tmp</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><name>ot</name></expr></argument>, <argument><expr><name>strref</name></expr></argument>,
			<argument><expr><name>IRXLOAD_READONLY</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>IRXLOAD_UNALIGNED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TRef</name></type> <name>val</name> <init>= <expr><call><name>kfold_xload</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IR</name><argument_list>(<argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>kstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BAND</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>,
		     <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>LJ_ENDIAN_SELECT</name><argument_list>(<argument><expr><literal type="number">0x00ffffff</literal></expr></argument>, <argument><expr><literal type="number">0xffffff00</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><name>tmp</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><name>val</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fins</name><operator>-&gt;</operator><name>ot</name></name> <operator>=</operator> <operator>(</operator><name>IROpT</name><operator>)</operator><call><name>IRTGI</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>RETRYFOLD</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><name>DROPFOLD</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* -- Loads --------------------------------------------------------------- */</comment>

<comment type="block">/* Loads cannot be folded or passed on to CSE in general.
** Alias analysis is needed to check for forwarding opportunities.
**
** Caveat: *all* loads must be listed here or they end up at CSE!
*/</comment>

<macro><name>LJFOLD</name><argument_list>(<argument>ALOAD any</argument>)</argument_list></macro>
<macro><name>LJFOLDX</name><argument_list>(<argument>lj_opt_fwd_aload</argument>)</argument_list></macro>

<comment type="block">/* From HREF fwd (see below). Must eliminate, not supported by fwd/backend. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>HLOAD KKPTR</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>kfold_hload_kkptr</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ir_kptr</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>niltvg</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TREF_NIL</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>HLOAD any</argument>)</argument_list></macro>
<macro><name>LJFOLDX</name><argument_list>(<argument>lj_opt_fwd_hload</argument>)</argument_list></macro>

<macro><name>LJFOLD</name><argument_list>(<argument>ULOAD any</argument>)</argument_list></macro>
<macro><name>LJFOLDX</name><argument_list>(<argument>lj_opt_fwd_uload</argument>)</argument_list></macro>

<macro><name>LJFOLD</name><argument_list>(<argument>ALEN any any</argument>)</argument_list></macro>
<macro><name>LJFOLDX</name><argument_list>(<argument>lj_opt_fwd_alen</argument>)</argument_list></macro>

<comment type="block">/* Upvalue refs are really loads, but there are no corresponding stores.
** So CSE is ok for them, except for UREFO across a GC step (see below).
** If the referenced function is const, its upvalue addresses are const, too.
** This can be used to improve CSE by looking for the same address,
** even if the upvalues originate from a different function.
*/</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>UREFO KGC any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>UREFC KGC any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>cse_uref</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_CSE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><call><name>ir_kfunc</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCupval</name> <modifier>*</modifier></type><name>uv</name> <init>= <expr><call><name>gco2uv</name><argument_list>(<argument><expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>uvptr</name><index>[<expr><operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>ref</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn2</name> <init>= <expr><call><name>ir_kfunc</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>gco2uv</name><argument_list>(<argument><expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>fn2</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>uvptr</name><index>[<expr><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>uv</name></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_UREFO</name> <operator>&amp;&amp;</operator> <call><name>gcstep_barrier</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <break>break;</break></block_content></block></if></if_stmt>
	  <return>return <expr><name>ref</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>EMITFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>HREFK any any</argument>)</argument_list></macro>
<macro><name>LJFOLDX</name><argument_list>(<argument>lj_opt_fwd_hrefk</argument>)</argument_list></macro>

<macro><name>LJFOLD</name><argument_list>(<argument>HREF TNEW any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fwd_href_tnew</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>lj_opt_fwd_href_nokey</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_ir_kkptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>niltvg</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>HREF TDUP KPRI</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>HREF TDUP KGC</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>HREF TDUP KNUM</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fwd_href_tdup</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>keyv</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_ir_kvalue</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keyv</name></expr></argument>, <argument><expr><name>fright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lj_tab_get</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><call><name>ir_ktab</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>keyv</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>niltvg</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <call><name>lj_opt_fwd_href_nokey</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_ir_kkptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>niltvg</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* We can safely FOLD/CSE array/hash refs and field loads, since there
** are no corresponding stores. But we need to check for any NEWREF with
** an aliased table, as it may invalidate all of the pointers and fields.
** Only HREF needs the NEWREF check -- AREF and HREFK already depend on
** FLOADs. And NEWREF itself is treated like a store (see below).
** LREF is constant (per trace) since coroutine switches are not inlined.
*/</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD TNEW IRFL_TAB_ASIZE</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fload_tab_tnew_asize</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>lj_opt_fwd_tptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD TNEW IRFL_TAB_HMASK</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fload_tab_tnew_hmask</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>lj_opt_fwd_tptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD TDUP IRFL_TAB_ASIZE</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fload_tab_tdup_asize</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>lj_opt_fwd_tptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>ir_ktab</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>asize</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD TDUP IRFL_TAB_HMASK</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fload_tab_tdup_hmask</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>lj_opt_fwd_tptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>ir_ktab</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>hmask</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>HREF any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD any IRFL_TAB_ARRAY</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD any IRFL_TAB_NODE</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD any IRFL_TAB_ASIZE</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD any IRFL_TAB_HMASK</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fload_tab_ah</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_opt_cse</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><call><name>lj_opt_fwd_tptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>tr</name></expr> </then><else>: <expr><name>EMITFOLD</name></expr></else></ternary></expr>;</return>
</block_content>}</block>

<comment type="block">/* Strings are immutable, so we can safely FOLD/CSE the related FLOAD. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD KGC IRFL_STR_LEN</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fload_str_len_kgc</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>ir_kstr</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD SNEW IRFL_STR_LEN</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fload_str_len_snew</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>PHIBARRIER</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD TOSTR IRFL_STR_LEN</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fload_str_len_tostr</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRTOSTR_CHAR</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* The C type ID of cdata objects is immutable. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD KGC IRFL_CDATA_CTYPEID</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fload_cdata_typeid_kgc</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>ir_kcdata</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Get the contents of immutable cdata objects. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD KGC IRFL_CDATA_PTR</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD KGC IRFL_CDATA_INT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD KGC IRFL_CDATA_INT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fload_cdata_int64_kgc</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>cdataptr</name><argument_list>(<argument><expr><call><name>ir_kcdata</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>INT64FOLD</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <return>return <expr><call><name>INTFOLD</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD CNEW IRFL_CDATA_CTYPEID</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD CNEWI IRFL_CDATA_CTYPEID</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fload_cdata_typeid_cnew</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op1</name></name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* No PHI barrier needed. CNEW/CNEWI op1 is const. */</comment>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Pointer, int and int64 cdata objects are immutable. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD CNEWI IRFL_CDATA_PTR</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD CNEWI IRFL_CDATA_INT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD CNEWI IRFL_CDATA_INT64</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fload_cdata_ptr_int64_cnew</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name><name>fleft</name><operator>-&gt;</operator><name>op2</name></name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Fold even across PHI to avoid allocations. */</comment>
  <return>return <expr><name>NEXTFOLD</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD any IRFL_STR_LEN</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD any IRFL_FUNC_ENV</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD any IRFL_THREAD_ENV</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD any IRFL_CDATA_CTYPEID</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD any IRFL_CDATA_PTR</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD any IRFL_CDATA_INT</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD any IRFL_CDATA_INT64</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>VLOAD any any</argument>)</argument_list></macro>  <comment type="block">/* Vararg loads have no corresponding stores. */</comment>
<macro><name>LJFOLDX</name><argument_list>(<argument>lj_opt_cse</argument>)</argument_list></macro>

<comment type="block">/* All other field loads need alias analysis. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>FLOAD any any</argument>)</argument_list></macro>
<macro><name>LJFOLDX</name><argument_list>(<argument>lj_opt_fwd_fload</argument>)</argument_list></macro>

<comment type="block">/* This is for LOOP only. Recording handles SLOADs internally. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>SLOAD any any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>fwd_sload</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRSLOAD_FRAME</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_opt_cse</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_RETF</name></expr>]</index></name></expr> ?</condition><then> <expr><name>EMITFOLD</name></expr> </then><else>: <expr><name>tr</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block>

<comment type="block">/* Only fold for KKPTR. The pointer _and_ the contents must be const. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>XLOAD KKPTR any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>xload_kptr</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>kfold_xload</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>fins</name></expr></argument>, <argument><expr><call><name>ir_kptr</name><argument_list>(<argument><expr><name>fleft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><name>tr</name></expr> ?</condition><then> <expr><name>tr</name></expr> </then><else>: <expr><name>NEXTFOLD</name></expr></else></ternary></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>XLOAD any any</argument>)</argument_list></macro>
<macro><name>LJFOLDX</name><argument_list>(<argument>lj_opt_fwd_xload</argument>)</argument_list></macro>

<comment type="block">/* -- Write barriers ------------------------------------------------------ */</comment>

<comment type="block">/* Write barriers are amenable to CSE, but not across any incremental
** GC steps.
**
** The same logic applies to open upvalue references, because a stack
** may be resized during a GC step (not the current stack, but maybe that
** of a coroutine).
*/</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>TBAR any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>OBAR any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>UREFO any any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>barrier_tab</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>lj_opt_cse</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>gcstep_barrier</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* CSE across GC step? */</comment>
    <return>return <expr><name>EMITFOLD</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Raw emit. Assumes fins is left intact by CSE. */</comment>
  <return>return <expr><name>tr</name></expr>;</return>
</block_content>}</block>

<macro><name>LJFOLD</name><argument_list>(<argument>TBAR TNEW</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>TBAR TDUP</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>barrier_tnew_tdup</argument>)</argument_list></macro>
<block>{<block_content>
  <comment type="block">/* New tables are always white and never need a barrier. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>&lt;</operator> <name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_LOOP</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Except across a GC step. */</comment>
    <return>return <expr><name>NEXTFOLD</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>DROPFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* -- Profiling ----------------------------------------------------------- */</comment>

<macro><name>LJFOLD</name><argument_list>(<argument>PROF any any</argument>)</argument_list></macro>
<macro><name>LJFOLDF</name><argument_list>(<argument>prof</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_PROF</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>ref</name><operator>+</operator><literal type="number">1</literal> <operator>==</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Drop neighbouring IR_PROF. */</comment>
    <return>return <expr><name>ref</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>EMITFOLD</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* -- Stores and allocations ---------------------------------------------- */</comment>

<comment type="block">/* Stores and allocations cannot be folded or passed on to CSE in general.
** But some stores can be eliminated with dead-store elimination (DSE).
**
** Caveat: *all* stores and allocs must be listed here or they end up at CSE!
*/</comment>

<macro><name>LJFOLD</name><argument_list>(<argument>ASTORE any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>HSTORE any any</argument>)</argument_list></macro>
<macro><name>LJFOLDX</name><argument_list>(<argument>lj_opt_dse_ahstore</argument>)</argument_list></macro>

<macro><name>LJFOLD</name><argument_list>(<argument>USTORE any any</argument>)</argument_list></macro>
<macro><name>LJFOLDX</name><argument_list>(<argument>lj_opt_dse_ustore</argument>)</argument_list></macro>

<macro><name>LJFOLD</name><argument_list>(<argument>FSTORE any any</argument>)</argument_list></macro>
<macro><name>LJFOLDX</name><argument_list>(<argument>lj_opt_dse_fstore</argument>)</argument_list></macro>

<macro><name>LJFOLD</name><argument_list>(<argument>XSTORE any any</argument>)</argument_list></macro>
<macro><name>LJFOLDX</name><argument_list>(<argument>lj_opt_dse_xstore</argument>)</argument_list></macro>

<macro><name>LJFOLD</name><argument_list>(<argument>NEWREF any any</argument>)</argument_list></macro>  <comment type="block">/* Treated like a store. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>CALLA any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CALLL any any</argument>)</argument_list></macro>  <comment type="block">/* Safeguard fallback. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>CALLS any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CALLXS any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>XBAR</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>RETF any any</argument>)</argument_list></macro>  <comment type="block">/* Modifies BASE. */</comment>
<macro><name>LJFOLD</name><argument_list>(<argument>TNEW any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>TDUP any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>CNEW any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>XSNEW any any</argument>)</argument_list></macro>
<macro><name>LJFOLD</name><argument_list>(<argument>BUFHDR any any</argument>)</argument_list></macro>
<macro><name>LJFOLDX</name><argument_list>(<argument>lj_ir_emit</argument>)</argument_list></macro>

<comment type="block">/* ------------------------------------------------------------------------ */</comment>

<comment type="block">/* Every entry in the generated hash table is a 32 bit pattern:
**
** xxxxxxxx iiiiiii lllllll rrrrrrrrrr
**
**   xxxxxxxx = 8 bit index into fold function table
**    iiiiiii = 7 bit folded instruction opcode
**    lllllll = 7 bit left instruction opcode
** rrrrrrrrrr = 8 bit right instruction opcode or 10 bits from literal field
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_folddef.h"</cpp:file></cpp:include>

<comment type="block">/* ------------------------------------------------------------------------ */</comment>

<comment type="block">/* Fold IR instruction. */</comment>
<function><type><name>TRef</name> <name>LJ_FASTCALL</name></type> <name>lj_opt_fold</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>key</name></decl>, <decl><type ref="prev"/><name>any</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_MASK</name><operator>)</operator> <operator>!=</operator> <name>JIT_F_OPT_DEFAULT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>JIT_F_OPT_FOLD</name><operator>|</operator><name>JIT_F_OPT_FWD</name><operator>|</operator><name>JIT_F_OPT_CSE</name><operator>|</operator><name>JIT_F_OPT_DSE</name><operator>)</operator> <operator>|</operator>
		<name>JIT_F_OPT_DEFAULT</name><operator>)</operator> <operator>==</operator> <name>JIT_F_OPT_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Folding disabled? Chain to CSE, but not for loads/stores/allocs. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_FOLD</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>irm_kind</name><argument_list>(<argument><expr><name><name>lj_ir_mode</name><index>[<expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>IRM_N</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>lj_opt_cse</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* No FOLD, forwarding or CSE? Emit raw IR for loads, except for SLOAD. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>JIT_F_OPT_FOLD</name><operator>|</operator><name>JIT_F_OPT_FWD</name><operator>|</operator><name>JIT_F_OPT_CSE</name><operator>)</operator><operator>)</operator> <operator>!=</operator>
		    <operator>(</operator><name>JIT_F_OPT_FOLD</name><operator>|</operator><name>JIT_F_OPT_FWD</name><operator>|</operator><name>JIT_F_OPT_CSE</name><operator>)</operator> <operator>&amp;&amp;</operator>
	<call><name>irm_kind</name><argument_list>(<argument><expr><name><name>lj_ir_mode</name><index>[<expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>IRM_L</name> <operator>&amp;&amp;</operator> <name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>!=</operator> <name>IR_SLOAD</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>lj_ir_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* No FOLD or DSE? Emit raw IR for stores. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>JIT_F_OPT_FOLD</name><operator>|</operator><name>JIT_F_OPT_DSE</name><operator>)</operator><operator>)</operator> <operator>!=</operator>
		    <operator>(</operator><name>JIT_F_OPT_FOLD</name><operator>|</operator><name>JIT_F_OPT_DSE</name><operator>)</operator> <operator>&amp;&amp;</operator>
	<call><name>irm_kind</name><argument_list>(<argument><expr><name><name>lj_ir_mode</name><index>[<expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>IRM_S</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>lj_ir_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Fold engine start/retry point. */</comment>
<label><name>retry</name>:</label>
  <comment type="block">/* Construct key from opcode and operand opcodes (unless literal/none). */</comment>
  <expr_stmt><expr><name>key</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>o</name></name> <operator>&lt;&lt;</operator> <literal type="number">17</literal><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>&gt;=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nk</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>key</name> <operator>+=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>IR</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>o</name> <operator>&lt;&lt;</operator> <literal type="number">10</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>fleft</name> <operator>=</operator> <operator>*</operator><call><name>IR</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>&lt;</operator> <name>REF_TRUE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>fleft</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">1</literal></expr>]</index></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&gt;=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nk</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>key</name> <operator>+=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>IR</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>o</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>fright</name> <operator>=</operator> <operator>*</operator><call><name>IR</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&lt;</operator> <name>REF_TRUE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>fright</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">1</literal></expr>]</index></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>key</name> <operator>+=</operator> <operator>(</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <literal type="number">0x3ffu</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Literal mask. Must include IRCONV_*MASK. */</comment>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Check for a match in order from most specific to least specific. */</comment>
  <expr_stmt><expr><name>any</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>k</name> <init>= <expr><name>key</name> <operator>|</operator> <operator>(</operator><name>any</name> <operator>&amp;</operator> <literal type="number">0x1ffff</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>h</name> <init>= <expr><call><name>fold_hashkey</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>fh</name> <init>= <expr><name><name>fold_hash</name><index>[<expr><name>h</name></expr>]</index></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Lookup key in semi-perfect hash table. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fh</name> <operator>&amp;</operator> <literal type="number">0xffffff</literal><operator>)</operator> <operator>==</operator> <name>k</name> <operator>||</operator> <operator>(</operator><name>fh</name> <operator>=</operator> <name><name>fold_hash</name><index>[<expr><name>h</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>,</operator> <operator>(</operator><name>fh</name> <operator>&amp;</operator> <literal type="number">0xffffff</literal><operator>)</operator> <operator>==</operator> <name>k</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ref</name> <operator>=</operator> <operator>(</operator><name>IRRef</name><operator>)</operator><macro><name>tref_ref</name><argument_list>(<argument>fold_func[fh &gt;&gt; <literal type="number">24</literal>](J)</argument>)</argument_list></macro></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>!=</operator> <name>NEXTFOLD</name></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>any</name> <operator>==</operator> <literal type="number">0xfffff</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Exhausted folding. Pass on to CSE. */</comment>
      <return>return <expr><call><name>lj_opt_cse</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>any</name> <operator>=</operator> <operator>(</operator><name>any</name> <operator>|</operator> <operator>(</operator><name>any</name> <operator>&gt;&gt;</operator> <literal type="number">10</literal><operator>)</operator><operator>)</operator> <operator>^</operator> <literal type="number">0xffc00</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Return value processing, ordered by frequency. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name>ref</name> <operator>&gt;=</operator> <name>MAX_FOLD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>TREF</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><call><name>irt_t</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>==</operator> <name>RETRYFOLD</name></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>==</operator> <name>KINTFOLD</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>fins</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>==</operator> <name>FAILFOLD</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_GFAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>ref</name> <operator>==</operator> <name>DROPFOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>REF_DROP</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Common-Subexpression Elimination ------------------------------------ */</comment>

<comment type="block">/* CSE an IR instruction. This is very fast due to the skip-list chains. */</comment>
<function><type><name>TRef</name> <name>LJ_FASTCALL</name></type> <name>lj_opt_cse</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Avoid narrow to wide store-to-load forwarding stall */</comment>
  <decl_stmt><decl><type><name>IRRef2</name></type> <name>op12</name> <init>= <expr><operator>(</operator><name>IRRef2</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>IRRef2</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IROp</name></type> <name>op</name> <init>= <expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JIT_F_OPT_CSE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Limited search for same operands in per-opcode chain. */</comment>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>op</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>lim</name> <init>= <expr><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&gt;</operator> <name>lim</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lim</name> <operator>=</operator> <name><name>fins</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Relies on lit &lt; REF_BIAS. */</comment>
    <while>while <condition>(<expr><name>ref</name> <operator>&gt;</operator> <name>lim</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>op12</name> <operator>==</operator> <name>op12</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><call><name>TREF</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><call><name>irt_t</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Common subexpression found. */</comment>
      <expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Otherwise emit IR (inlined for speed). */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><call><name>lj_ir_nextins</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>op12</name></name> <operator>=</operator> <name>op12</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>op</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><name>ref</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>guardemit</name><operator>.</operator><name>irt</name></name> <operator>|=</operator> <name><name>fins</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name></expr>;</expr_stmt>
    <return>return <expr><call><name>TREF</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><call><name>irt_t</name><argument_list>(<argument><expr><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name><name>fins</name><operator>-&gt;</operator><name>t</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* CSE with explicit search limit. */</comment>
<function><type><name>TRef</name> <name>LJ_FASTCALL</name></type> <name>lj_opt_cselim</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>lim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name><name>fins</name><operator>-&gt;</operator><name>o</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef2</name></type> <name>op12</name> <init>= <expr><operator>(</operator><name>IRRef2</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>op1</name></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>IRRef2</name><operator>)</operator><name><name>fins</name><operator>-&gt;</operator><name>op2</name></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>ref</name> <operator>&gt;</operator> <name>lim</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>op12</name> <operator>==</operator> <name>op12</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>ref</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><call><name>lj_ir_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------ */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>fins</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>fleft</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>fright</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>knumleft</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>knumright</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>emitir</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
