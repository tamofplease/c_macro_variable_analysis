<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_bcread.c"><comment type="block">/*
** Bytecode reader.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_bcread_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_buf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_str.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_bc.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cdata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lualib.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_lex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_bcdump.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strfmt.h"</cpp:file></cpp:include>

<comment type="block">/* Reuse some lexer fields for our own purposes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bcread_flags</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>ls-&gt;level</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bcread_swap</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>((bcread_flags(ls) &amp; BCDUMP_F_BE) != LJ_BE*BCDUMP_F_BE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bcread_oldtop</name><parameter_list>(<parameter><type><name>L</name></type></parameter>, <parameter><type><name>ls</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>restorestack(L, ls-&gt;lastline)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bcread_savetop</name><parameter_list>(<parameter><type><name>L</name></type></parameter>, <parameter><type><name>ls</name></type></parameter>, <parameter><type><name>top</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>ls-&gt;lastline = (BCLine)savestack(L, (top))</cpp:value></cpp:define>

<comment type="block">/* -- Input buffer handling ----------------------------------------------- */</comment>

<comment type="block">/* Throw reader error. */</comment>
<function><type><specifier>static</specifier> <name>LJ_NOINLINE</name> <name>void</name></type> <name>bcread_error</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>em</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>chunkarg</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <name>BCDUMP_HEAD1</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">"(binary)"</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'@'</literal> <operator>||</operator> <operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>err2msg</name><argument_list>(<argument><expr><name>em</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_err_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_ERRSYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Refill buffer. */</comment>
<function><type><specifier>static</specifier> <name>LJ_NOINLINE</name> <name>void</name></type> <name>bcread_fill</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>need</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>LJ_MAX_BUF</name> <operator>||</operator> <name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>bcread_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>LJ_ERR_BCBAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <do>do <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sbufB</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MSize</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>pe</name></name> <operator>-</operator> <name><name>ls</name><operator>-&gt;</operator><name>p</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Copy remainder to buffer. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>sbuflen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Move down in buffer. */</comment>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>pe</name></name> <operator>==</operator> <call><name>sbufP</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>!=</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Copy from buffer provided by reader. */</comment>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lj_buf_need</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>pe</name></name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>setsbufP</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name><name>ls</name><operator>-&gt;</operator><name>rfunc</name></name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>rdata</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Get more data from reader. */</comment>
    <if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>sz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* EOF? */</comment>
      <if_stmt><if>if <condition>(<expr><name>need</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bcread_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>LJ_ERR_BCBAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Only bad if we get called again. */</comment>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;=</operator> <name>LJ_MAX_BUF</name> <operator>-</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_err_mem</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Append to buffer. */</comment>
      <expr_stmt><expr><name>n</name> <operator>+=</operator> <operator>(</operator><name>MSize</name><operator>)</operator><name>sz</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lj_buf_need</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>n</name> <operator>&lt;</operator> <name>len</name></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><name>n</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>sbufP</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setsbufP</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>pe</name></name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Return buffer provided by reader. */</comment>
      <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>pe</name></name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>sz</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block> while <condition>(<expr><operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>pe</name></name> <operator>-</operator> <name><name>ls</name><operator>-&gt;</operator><name>p</name></name><operator>)</operator> <operator>&lt;</operator> <name>len</name></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/* Need a certain number of bytes. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>void</name></type> <name>bcread_need</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>pe</name></name> <operator>-</operator> <name><name>ls</name><operator>-&gt;</operator><name>p</name></name><operator>)</operator> <operator>&lt;</operator> <name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>bcread_fill</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Want to read up to a certain number of bytes, but may need less. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>void</name></type> <name>bcread_want</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>pe</name></name> <operator>-</operator> <name><name>ls</name><operator>-&gt;</operator><name>p</name></name><operator>)</operator> <operator>&lt;</operator> <name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>bcread_fill</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return memory block from buffer. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>uint8_t</name> <modifier>*</modifier></type><name>bcread_mem</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>ls</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>&lt;=</operator> <name><name>ls</name><operator>-&gt;</operator><name>pe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Copy memory block from buffer. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcread_block</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>q</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>bcread_mem</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Read byte from buffer. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>uint32_t</name></type> <name>bcread_byte</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>&lt;</operator> <name><name>ls</name><operator>-&gt;</operator><name>pe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><operator>*</operator><name><name>ls</name><operator>-&gt;</operator><name>p</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read ULEB128 value from buffer. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>uint32_t</name></type> <name>bcread_uleb128</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>v</name> <init>= <expr><call><name>lj_buf_ruleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>&lt;=</operator> <name><name>ls</name><operator>-&gt;</operator><name>pe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read top 32 bits of 33 bit ULEB128 value from buffer. */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>bcread_uleb128_33</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>ls</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>v</name> <init>= <expr><operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name>v</name> <operator>&gt;=</operator> <literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>sh</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>v</name> <operator>&amp;=</operator> <literal type="number">0x3f</literal></expr>;</expr_stmt>
    <do>do <block>{<block_content>
     <expr_stmt><expr><name>v</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>sh</name> <operator>+=</operator> <literal type="number">7</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
   </block_content>}</block> while <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>&gt;=</operator> <literal type="number">0x80</literal></expr>)</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>&lt;=</operator> <name><name>ls</name><operator>-&gt;</operator><name>pe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Bytecode reader ----------------------------------------------------- */</comment>

<comment type="block">/* Read debug info of a prototype. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcread_dbg</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>sizedbg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>lineinfo</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>proto_lineinfo</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>bcread_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>lineinfo</name></expr></argument>, <argument><expr><name>sizedbg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Swap lineinfo if the endianess differs. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>bcread_swap</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pt</name><operator>-&gt;</operator><name>numline</name></name> <operator>&gt;=</operator> <literal type="number">256</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><name><name>pt</name><operator>-&gt;</operator><name>sizebc</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pt</name><operator>-&gt;</operator><name>numline</name></name> <operator>&lt;</operator> <literal type="number">65536</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>lineinfo</name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator><operator>|</operator><operator>(</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>lineinfo</name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lj_bswap</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Find pointer to varinfo. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>bcread_varinfo</name><parameter_list>(<parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>proto_uvinfo</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>n</name> <init>= <expr><name><name>pt</name><operator>-&gt;</operator><name>sizeuv</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition><block type="pseudo"><block_content> <while>while <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>||</operator> <operator>--</operator><name>n</name></expr>)</condition><block type="pseudo"><block_content> <empty_stmt>;</empty_stmt></block_content></block></while></block_content></block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read a single constant key/value of a template table. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcread_ktabk</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>tp</name> <init>= <expr><call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tp</name> <operator>&gt;=</operator> <name>BCDUMP_KTAB_STR</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>MSize</name></type> <name>len</name> <init>= <expr><name>tp</name> <operator>-</operator> <name>BCDUMP_KTAB_STR</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>bcread_mem</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>lj_str_new</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tp</name> <operator>==</operator> <name>BCDUMP_KTAB_INT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tp</name> <operator>==</operator> <name>BCDUMP_KTAB_NUM</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u32</name><operator>.</operator><name>lo</name></name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u32</name><operator>.</operator><name>hi</name></name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>tp</name> <operator>&lt;=</operator> <name>BCDUMP_KTAB_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setpriV</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>~</operator><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Read a template table. */</comment>
<function><type><specifier>static</specifier> <name>GCtab</name> <modifier>*</modifier></type><name>bcread_ktab</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>narray</name> <init>= <expr><call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>nhash</name> <init>= <expr><call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>lj_tab_new</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>narray</name></expr></argument>, <argument><expr><call><name>hsize2hbits</name><argument_list>(<argument><expr><name>nhash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>narray</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Read array entries. */</comment>
    <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>tvref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>narray</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>o</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>bcread_ktabk</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>nhash</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Read hash entries. */</comment>
    <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nhash</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>TValue</name></type> <name>key</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>bcread_ktabk</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bcread_ktabk</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>lj_tab_set</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read GC constants of a prototype. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcread_kgc</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>sizekgc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCRef</name> <modifier>*</modifier></type><name>kr</name> <init>= <expr><call><name>mref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>k</name></name></expr></argument>, <argument><expr><name>GCRef</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>sizekgc</name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sizekgc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>kr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>MSize</name></type> <name>tp</name> <init>= <expr><call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>tp</name> <operator>&gt;=</operator> <name>BCDUMP_KGC_STR</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>MSize</name></type> <name>len</name> <init>= <expr><name>tp</name> <operator>-</operator> <name>BCDUMP_KGC_STR</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>bcread_mem</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><operator>*</operator><name>kr</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><call><name>lj_str_new</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tp</name> <operator>==</operator> <name>BCDUMP_KGC_TAB</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><operator>*</operator><name>kr</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><call><name>bcread_ktab</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tp</name> <operator>!=</operator> <name>BCDUMP_KGC_CHILD</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><ternary><condition><expr><name>tp</name> <operator>==</operator> <name>BCDUMP_KGC_COMPLEX</name></expr> ?</condition><then> <expr><name>CTID_COMPLEX_DOUBLE</name></expr> </then><else>:
		   <expr><ternary><condition><expr><name>tp</name> <operator>==</operator> <name>BCDUMP_KGC_I64</name></expr> ?</condition><then> <expr><name>CTID_INT64</name></expr> </then><else>: <expr><name>CTID_UINT64</name></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name> <init>= <expr><ternary><condition><expr><name>tp</name> <operator>==</operator> <name>BCDUMP_KGC_COMPLEX</name></expr> ?</condition><then> <expr><literal type="number">16</literal></expr> </then><else>: <expr><literal type="number">8</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>lj_cdata_new_</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>TValue</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><operator>*</operator><name>kr</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>u32</name><operator>.</operator><name>lo</name></name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>u32</name><operator>.</operator><name>hi</name></name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>tp</name> <operator>==</operator> <name>BCDUMP_KGC_COMPLEX</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>u32</name><operator>.</operator><name>lo</name></name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>u32</name><operator>.</operator><name>hi</name></name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>tp</name> <operator>==</operator> <name>BCDUMP_KGC_CHILD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&lt;=</operator> <call><name>bcread_oldtop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Stack underflow? */</comment>
	<expr_stmt><expr><call><name>bcread_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>LJ_ERR_BCBAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><operator>*</operator><name>kr</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><call><name>protoV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Read number constants of a prototype. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcread_knum</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>sizekn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>mref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>k</name></name></expr></argument>, <argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sizekn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>o</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>isnum</name> <init>= <expr><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>lo</name> <init>= <expr><call><name>bcread_uleb128_33</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnum</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u32</name><operator>.</operator><name>lo</name></name> <operator>=</operator> <name>lo</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u32</name><operator>.</operator><name>hi</name></name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Read bytecode instructions. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcread_bytecode</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>sizebc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCIns</name> <modifier>*</modifier></type><name>bc</name> <init>= <expr><call><name>proto_bc</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>bc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTO_VARARG</name><operator>)</operator></expr> ?</condition><then> <expr><name>BC_FUNCV</name></expr> </then><else>: <expr><name>BC_FUNCF</name></expr></else></ternary></expr></argument>,
		   <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>framesize</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcread_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>bc</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>sizebc</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><operator>(</operator><name>MSize</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>BCIns</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Swap bytecode instructions if the endianess differs. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>bcread_swap</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sizebc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lj_bswap</name><argument_list>(<argument><expr><name><name>bc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Read upvalue refs. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcread_uv</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>sizeuv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>sizeuv</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>uv</name> <init>= <expr><call><name>proto_uv</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>bcread_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>uv</name></expr></argument>, <argument><expr><name>sizeuv</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Swap upvalue refs if the endianess differs. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>bcread_swap</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sizeuv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>uv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>uv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator><operator>|</operator><operator>(</operator><name><name>uv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Read a prototype. */</comment>
<function><type><name>GCproto</name> <modifier>*</modifier></type><name>lj_bcread_proto</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>framesize</name></decl>, <decl><type ref="prev"/><name>numparams</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>, <decl><type ref="prev"/><name>sizeuv</name></decl>, <decl><type ref="prev"/><name>sizekgc</name></decl>, <decl><type ref="prev"/><name>sizekn</name></decl>, <decl><type ref="prev"/><name>sizebc</name></decl>, <decl><type ref="prev"/><name>sizept</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>ofsk</name></decl>, <decl><type ref="prev"/><name>ofsuv</name></decl>, <decl><type ref="prev"/><name>ofsdbg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>sizedbg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCLine</name></type> <name>firstline</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>numline</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Read prototype header. */</comment>
  <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>bcread_byte</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>numparams</name> <operator>=</operator> <call><name>bcread_byte</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>framesize</name> <operator>=</operator> <call><name>bcread_byte</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sizeuv</name> <operator>=</operator> <call><name>bcread_byte</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sizekgc</name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sizekn</name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sizebc</name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>bcread_flags</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BCDUMP_F_STRIP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>sizedbg</name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>sizedbg</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>firstline</name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>numline</name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Calculate total size of prototype including all colocated arrays. */</comment>
  <expr_stmt><expr><name>sizept</name> <operator>=</operator> <operator>(</operator><name>MSize</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>GCproto</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
	   <name>sizebc</name><operator>*</operator><operator>(</operator><name>MSize</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>BCIns</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
	   <name>sizekgc</name><operator>*</operator><operator>(</operator><name>MSize</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>GCRef</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>sizept</name> <operator>=</operator> <operator>(</operator><name>sizept</name> <operator>+</operator> <operator>(</operator><name>MSize</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>MSize</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>ofsk</name> <operator>=</operator> <name>sizept</name></expr>;</expr_stmt> <expr_stmt><expr><name>sizept</name> <operator>+=</operator> <name>sizekn</name><operator>*</operator><operator>(</operator><name>MSize</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>ofsuv</name> <operator>=</operator> <name>sizept</name></expr>;</expr_stmt> <expr_stmt><expr><name>sizept</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>sizeuv</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>~</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>ofsdbg</name> <operator>=</operator> <name>sizept</name></expr>;</expr_stmt> <expr_stmt><expr><name>sizept</name> <operator>+=</operator> <name>sizedbg</name></expr>;</expr_stmt>

  <comment type="block">/* Allocate prototype object and initialize its fields. */</comment>
  <expr_stmt><expr><name>pt</name> <operator>=</operator> <operator>(</operator><name>GCproto</name> <operator>*</operator><operator>)</operator><call><name>lj_mem_newgco</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>(</operator><name>MSize</name><operator>)</operator><name>sizept</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>gct</name></name> <operator>=</operator> <operator>~</operator><name>LJ_TPROTO</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>numparams</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>numparams</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>framesize</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>framesize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>sizebc</name></name> <operator>=</operator> <name>sizebc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>k</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pt</name> <operator>+</operator> <name>ofsk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>uv</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pt</name> <operator>+</operator> <name>ofsuv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>sizekgc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Set to zero until fully initialized. */</comment>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>sizekn</name></name> <operator>=</operator> <name>sizekn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>sizept</name></name> <operator>=</operator> <name>sizept</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>sizeuv</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>sizeuv</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>trace</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>chunkname</name></name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>chunkname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Close potentially uninitialized gap between bc and kgc. */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pt</name> <operator>+</operator> <name>ofsk</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GCRef</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>sizekgc</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Read bytecode instructions and upvalue refs. */</comment>
  <expr_stmt><expr><call><name>bcread_bytecode</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><name>sizebc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcread_uv</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><name>sizeuv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read constants. */</comment>
  <expr_stmt><expr><call><name>bcread_kgc</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><name>sizekgc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>sizekgc</name></name> <operator>=</operator> <name>sizekgc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcread_knum</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><name>sizekn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read and initialize debug info. */</comment>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>firstline</name></name> <operator>=</operator> <name>firstline</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>numline</name></name> <operator>=</operator> <name>numline</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>sizedbg</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>MSize</name></type> <name>sizeli</name> <init>= <expr><operator>(</operator><name>sizebc</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>numline</name> <operator>&lt;</operator> <literal type="number">256</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><ternary><condition><expr><name>numline</name> <operator>&lt;</operator> <literal type="number">65536</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>lineinfo</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pt</name> <operator>+</operator> <name>ofsdbg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>uvinfo</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pt</name> <operator>+</operator> <name>ofsdbg</name> <operator>+</operator> <name>sizeli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bcread_dbg</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><name>sizedbg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>varinfo</name></name></expr></argument>, <argument><expr><call><name>bcread_varinfo</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>lineinfo</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>uvinfo</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>varinfo</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read and check header of bytecode dump. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>bcread_header</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>flags</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>bcread_want</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>+</operator><literal type="number">5</literal><operator>+</operator><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>bcread_byte</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BCDUMP_HEAD2</name> <operator>||</operator>
      <call><name>bcread_byte</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BCDUMP_HEAD3</name> <operator>||</operator>
      <call><name>bcread_byte</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BCDUMP_VERSION</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>bcread_flags</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>flags</name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>BCDUMP_F_KNOWN</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BCDUMP_F_FR2</name><operator>)</operator> <operator>!=</operator> <name>LJ_FR2</name><operator>*</operator><name>BCDUMP_F_FR2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BCDUMP_F_FFI</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
    <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_ctsG</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>oldtop</name> <init>= <expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>luaopen_ffi</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Load FFI library on-demand. */</comment>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BCDUMP_F_STRIP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>chunkname</name></name> <operator>=</operator> <call><name>lj_str_newz</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>chunkarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>MSize</name></type> <name>len</name> <init>= <expr><call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>bcread_need</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>chunkname</name></name> <operator>=</operator> <call><name>lj_str_new</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>bcread_mem</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Ok. */</comment>
</block_content>}</block></function>

<comment type="block">/* Read a bytecode dump. */</comment>
<function><type><name>GCproto</name> <modifier>*</modifier></type><name>lj_bcread</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <name>BCDUMP_HEAD1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcread_savetop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ls</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_buf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Check for a valid bytecode dump header. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bcread_header</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>bcread_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>LJ_ERR_BCFMT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>  <comment type="block">/* Process all prototypes in the bytecode dump. */</comment>
    <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MSize</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>startp</name></decl>;</decl_stmt>
    <comment type="block">/* Read length. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>&lt;</operator> <name><name>ls</name><operator>-&gt;</operator><name>pe</name></name> <operator>&amp;&amp;</operator> <name><name>ls</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Shortcut EOF. */</comment>
      <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>bcread_want</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>bcread_uleb128</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* EOF */</comment>
    <expr_stmt><expr><call><name>bcread_need</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>startp</name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>p</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pt</name> <operator>=</operator> <call><name>lj_bcread_proto</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>!=</operator> <name>startp</name> <operator>+</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>bcread_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>LJ_ERR_BCBAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>setprotoV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>pe</name></name> <operator>!=</operator> <name><name>ls</name><operator>-&gt;</operator><name>p</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ls</name><operator>-&gt;</operator><name>endmark</name></name><operator>)</operator> <operator>||</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal> <operator>!=</operator> <call><name>bcread_oldtop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>bcread_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>LJ_ERR_BCBAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <comment type="block">/* Pop off last prototype. */</comment>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>
  <return>return <expr><call><name>protoV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

</unit>
