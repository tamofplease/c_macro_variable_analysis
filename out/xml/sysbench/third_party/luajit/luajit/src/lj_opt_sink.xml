<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_opt_sink.c"><comment type="block">/*
** SINK: Allocation Sinking and Store Sinking.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_opt_sink_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_iropt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_target.h"</cpp:file></cpp:include>

<comment type="block">/* Some local macros to save typing. Undef'd at the end. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IR</name><parameter_list>(<parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(&amp;J-&gt;cur.ir[(ref)])</cpp:value></cpp:define>

<comment type="block">/* Check whether the store ref points to an eligible allocation. */</comment>
<function><type><specifier>static</specifier> <name>IRIns</name> <modifier>*</modifier></type><name>sink_checkalloc</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Non-constant key. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_HREFK</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_AREF</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_HREF</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_NEWREF</name> <operator>||</operator>
	     <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_FREF</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_ADD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Unhandled reference type (for XSTORE). */</comment>
  <expr_stmt><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TNEW</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TDUP</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEW</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Not an allocation. */</comment>
  <return>return <expr><name>ir</name></expr>;</return>  <comment type="block">/* Return allocation. */</comment>
</block_content>}</block></function>

<comment type="block">/* Recursively check whether a value depends on a PHI. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sink_phidep</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>irt_isphi</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>&gt;=</operator> <name>REF_FIRST</name> <operator>&amp;&amp;</operator> <call><name>sink_phidep</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&gt;=</operator> <name>REF_FIRST</name> <operator>&amp;&amp;</operator> <call><name>sink_phidep</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check whether a value is a sinkable PHI or loop-invariant. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sink_checkphi</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ira</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&gt;=</operator> <name>REF_FIRST</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>irt_isphi</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CONV</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRCONV_NUM_INT</name> <operator>&amp;&amp;</operator>
			     <call><name>irt_isphi</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>ira</name><operator>-&gt;</operator><name>prev</name></name><operator>++</operator></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Sinkable PHI. */</comment>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Otherwise the value must be loop-invariant. */</comment>
    <return>return <expr><name>ref</name> <operator>&lt;</operator> <name><name>J</name><operator>-&gt;</operator><name>loopref</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sink_phidep</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Constant (non-PHI). */</comment>
</block_content>}</block></function>

<comment type="block">/* Mark non-sinkable allocations using single-pass backward propagation.
**
** Roots for the marking process are:
** - Some PHIs or snapshots (see below).
** - Non-PHI, non-constant values stored to PHI allocations.
** - All guards.
** - Any remaining loads not eliminated by store-to-load forwarding.
** - Stores with non-constant keys.
** - All stored values.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sink_mark_ins</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>irlast</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>ir</name> <operator>=</operator> <name>irlast</name></expr> ;</init> <condition>;</condition> <incr><expr><name>ir</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>IR_BASE</name></expr>:</case>
      <return>return;</return>  <comment type="block">/* Finished. */</comment>
    <case>case <expr><name>IR_ALOAD</name></expr>:</case> <case>case <expr><name>IR_HLOAD</name></expr>:</case> <case>case <expr><name>IR_XLOAD</name></expr>:</case> <case>case <expr><name>IR_TBAR</name></expr>:</case> <case>case <expr><name>IR_ALEN</name></expr>:</case>
      <expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Mark ref for remaining loads. */</comment>
      <break>break;</break>
    <case>case <expr><name>IR_FLOAD</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>irt_ismarked</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRFL_TAB_META</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Mark table for remaining loads. */</comment>
      <break>break;</break>
    <case>case <expr><name>IR_ASTORE</name></expr>:</case> <case>case <expr><name>IR_HSTORE</name></expr>:</case> <case>case <expr><name>IR_FSTORE</name></expr>:</case> <case>case <expr><name>IR_XSTORE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ira</name> <init>= <expr><call><name>sink_checkalloc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ira</name> <operator>||</operator> <operator>(</operator><call><name>irt_isphi</name><argument_list>(<argument><expr><name><name>ira</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sink_checkphi</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ira</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Mark ineligible ref. */</comment>
      <expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Mark stored value. */</comment>
      <break>break;</break>
      </block_content>}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
    <case>case <expr><name>IR_CNEWI</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>irt_isphi</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	  <operator>(</operator><operator>!</operator><call><name>sink_checkphi</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
	   <operator>(</operator><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>ir</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>irlast</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_HIOP</name> <operator>&amp;&amp;</operator>
	    <operator>!</operator><call><name>sink_checkphi</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op2</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Mark ineligible allocation. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><name>IR_USTORE</name></expr>:</case>
      <expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Mark stored value. */</comment>
      <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
    <case>case <expr><name>IR_CALLXS</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>IR_CALLS</name></expr>:</case>
      <expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Mark (potentially) stored values. */</comment>
      <break>break;</break>
    <case>case <expr><name>IR_PHI</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irl</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>irr</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>irl</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>irr</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Clear PHI value counts. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>irl</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name><name>irr</name><operator>-&gt;</operator><name>o</name></name> <operator>&amp;&amp;</operator>
	  <operator>(</operator><name><name>irl</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TNEW</name> <operator>||</operator> <name><name>irl</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TDUP</name> <operator>||</operator>
	   <operator>(</operator><name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>irl</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEW</name> <operator>||</operator> <name><name>irl</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEWI</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><name><name>irl</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><name><name>irr</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block>
    <default>default:</default>
      <if_stmt><if>if <condition>(<expr><call><name>irt_ismarked</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>irt_isguard</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Propagate mark. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>&gt;=</operator> <name>REF_FIRST</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&gt;=</operator> <name>REF_FIRST</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Mark all instructions referenced by a snapshot. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sink_mark_snap</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>SnapShot</name> <modifier>*</modifier></type><name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snapmap</name><index>[<expr><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>nent</name> <init>= <expr><name><name>snap</name><operator>-&gt;</operator><name>nent</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nent</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><call><name>snap_ref</name><argument_list>(<argument><expr><name><name>map</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irref_isk</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Iteratively remark PHI refs with differing marks or PHI value counts. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sink_remark_phi</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>remark</name></decl>;</decl_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>remark</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_PHI</name></expr>;</condition> <incr><expr><name>ir</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irl</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>irr</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>irl</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>^</operator> <name><name>irr</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name><operator>)</operator> <operator>&amp;</operator> <name>IRT_MARK</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>irl</name><operator>-&gt;</operator><name>prev</name></name> <operator>==</operator> <name><name>irr</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition><block type="pseudo"><block_content>
	<continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>remark</name> <operator>|=</operator> <operator>(</operator><operator>~</operator><operator>(</operator><name><name>irl</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>&amp;</operator> <name><name>irr</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name><operator>)</operator> <operator>&amp;</operator> <name>IRT_MARK</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>irt_setmark</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block> while <condition>(<expr><name>remark</name></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/* Sweep instructions and tag sunken allocations and stores. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sink_sweep_ins</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>irbase</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>REF_BASE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ;</init> <condition><expr><name>ir</name> <operator>&gt;=</operator> <name>irbase</name></expr>;</condition> <incr><expr><name>ir</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>IR_ASTORE</name></expr>:</case> <case>case <expr><name>IR_HSTORE</name></expr>:</case> <case>case <expr><name>IR_FSTORE</name></expr>:</case> <case>case <expr><name>IR_XSTORE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ira</name> <init>= <expr><call><name>sink_checkalloc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>ira</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>irt_ismarked</name><argument_list>(<argument><expr><name><name>ira</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ir</name> <operator>-</operator> <name>ira</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>REGSP</name><argument_list>(<argument><expr><name>RID_SINK</name></expr></argument>, <argument><expr><ternary><condition><expr><name>delta</name> <operator>&gt;</operator> <literal type="number">255</literal></expr> ?</condition><then> <expr><literal type="number">255</literal></expr> </then><else>: <expr><name>delta</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>REGSP_INIT</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
      </block_content>}</block>
    <case>case <expr><name>IR_NEWREF</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irt_ismarked</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>REGSP</name><argument_list>(<argument><expr><name>RID_SINK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>irt_clearmark</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>REGSP_INIT</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
    <case>case <expr><name>IR_CNEW</name></expr>:</case> <case>case <expr><name>IR_CNEWI</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>IR_TNEW</name></expr>:</case> <case>case <expr><name>IR_TDUP</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irt_ismarked</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>&amp;=</operator> <operator>~</operator><name>IRT_GUARD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>REGSP</name><argument_list>(<argument><expr><name>RID_SINK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>sinktags</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Signal present SINK tags to assembler. */</comment>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>irt_clearmark</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>REGSP_INIT</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>IR_PHI</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ira</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irt_ismarked</name><argument_list>(<argument><expr><name><name>ira</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	  <operator>(</operator><name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TNEW</name> <operator>||</operator> <name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TDUP</name> <operator>||</operator>
	   <operator>(</operator><name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEW</name> <operator>||</operator> <name><name>ira</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEWI</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>REGSP</name><argument_list>(<argument><expr><name>RID_SINK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>REGSP_INIT</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
      </block_content>}</block>
    <default>default:</default>
      <expr_stmt><expr><call><name>irt_clearmark</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>REGSP_INIT</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for>
  <for>for <control>(<init><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nk</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ir</name> <operator>&lt;</operator> <name>irbase</name></expr>;</condition> <incr><expr><name>ir</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>irt_clearmark</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>REGSP_INIT</name></expr>;</expr_stmt>
    <comment type="block">/* The false-positive of irt_is64() for ASMREF_L (REF_NIL) is OK here. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>!=</operator> <name>IR_KNULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ir</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Allocation sinking and store sinking.
**
** 1. Mark all non-sinkable allocations.
** 2. Then sink all remaining allocations and the related stores.
*/</comment>
<function><type><name>void</name></type> <name>lj_opt_sink</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>need</name> <init>= <expr><operator>(</operator><name>JIT_F_OPT_SINK</name><operator>|</operator><name>JIT_F_OPT_FWD</name><operator>|</operator>
			 <name>JIT_F_OPT_DCE</name><operator>|</operator><name>JIT_F_OPT_CSE</name><operator>|</operator><name>JIT_F_OPT_FOLD</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>need</name><operator>)</operator> <operator>==</operator> <name>need</name> <operator>&amp;&amp;</operator>
      <operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_TNEW</name></expr>]</index></name> <operator>||</operator> <name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_TDUP</name></expr>]</index></name> <operator>||</operator>
       <operator>(</operator><name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_CNEW</name></expr>]</index></name> <operator>||</operator> <name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_CNEWI</name></expr>]</index></name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>J</name><operator>-&gt;</operator><name>loopref</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>sink_mark_snap</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snap</name><index>[<expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nsnap</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sink_mark_ins</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>loopref</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>sink_remark_phi</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sink_sweep_ins</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IR</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
