<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_gc.c"><comment type="block">/*
** Garbage collector.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
**
** Major portions taken verbatim or adapted from the Lua interpreter.
** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_gc_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_buf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_str.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_udata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_meta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_frame.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cdata.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_vm.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCSTEPSIZE</name></cpp:macro>	<cpp:value>1024u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCSWEEPMAX</name></cpp:macro>	<cpp:value>40</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCSWEEPCOST</name></cpp:macro>	<cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCFINALIZECOST</name></cpp:macro>	<cpp:value>100</cpp:value></cpp:define>

<comment type="block">/* Macros to set GCobj colors and flags. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>white2gray</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((x)-&gt;gch.marked &amp;= (uint8_t)~LJ_GC_WHITES)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gray2black</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((x)-&gt;gch.marked |= LJ_GC_BLACK)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isfinalized</name><parameter_list>(<parameter><type><name>u</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((u)-&gt;marked &amp; LJ_GC_FINALIZED)</cpp:value></cpp:define>

<comment type="block">/* -- Mark phase ---------------------------------------------------------- */</comment>

<comment type="block">/* Mark a TValue (if needed). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_marktv</name><parameter_list>(<parameter><type><name>g</name></type></parameter>, <parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ lua_assert(!tvisgcv(tv) || (~itype(tv) == gcval(tv)-&gt;gch.gct)); \
    if (tviswhite(tv)) gc_mark(g, gcV(tv)); }</cpp:value></cpp:define>

<comment type="block">/* Mark a GCobj (if needed). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_markobj</name><parameter_list>(<parameter><type><name>g</name></type></parameter>, <parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ if (iswhite(obj2gco(o))) gc_mark(g, obj2gco(o)); }</cpp:value></cpp:define>

<comment type="block">/* Mark a string object. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_mark_str</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((s)-&gt;marked &amp;= (uint8_t)~LJ_GC_WHITES)</cpp:value></cpp:define>

<comment type="block">/* Mark a white GCobj. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gc_mark</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>gct</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>gct</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>iswhite</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>white2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name>gct</name> <operator>==</operator> <operator>~</operator><name>LJ_TUDATA</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><call><name>tabref</name><argument_list>(<argument><expr><call><name>gco2ud</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Userdata are never gray. */</comment>
    <if_stmt><if>if <condition>(<expr><name>mt</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>tabref</name><argument_list>(<argument><expr><call><name>gco2ud</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>env</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name>gct</name> <operator>==</operator> <operator>~</operator><name>LJ_TUPVAL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCupval</name> <modifier>*</modifier></type><name>uv</name> <init>= <expr><call><name>gco2uv</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>gc_marktv</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>uvval</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>uv</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Closed upvalues are never gray. */</comment>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>gct</name> <operator>!=</operator> <operator>~</operator><name>LJ_TSTR</name> <operator>&amp;&amp;</operator> <name>gct</name> <operator>!=</operator> <operator>~</operator><name>LJ_TCDATA</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>gct</name> <operator>==</operator> <operator>~</operator><name>LJ_TFUNC</name> <operator>||</operator> <name>gct</name> <operator>==</operator> <operator>~</operator><name>LJ_TTAB</name> <operator>||</operator>
	       <name>gct</name> <operator>==</operator> <operator>~</operator><name>LJ_TTHREAD</name> <operator>||</operator> <name>gct</name> <operator>==</operator> <operator>~</operator><name>LJ_TPROTO</name> <operator>||</operator> <name>gct</name> <operator>==</operator> <operator>~</operator><name>LJ_TTRACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>gclist</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>gray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>gray</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Mark GC roots. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gc_mark_gcroot</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>GCROOT_MAX</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gcroot</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gcroot</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/* Start a GC cycle and mark the root set. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gc_mark_start</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>gray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>grayagain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>weak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>mainthread</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>tabref</name><argument_list>(<argument><expr><call><name>mainthread</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>env</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gc_marktv</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>registrytv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gc_mark_gcroot</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>GCSpropagate</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Mark open upvalues. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gc_mark_uv</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCupval</name> <modifier>*</modifier></type><name>uv</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>uv</name> <operator>=</operator> <call><name>uvnext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>uvhead</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>uv</name> <operator>!=</operator> <operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>uvhead</name></name></expr>;</condition> <incr><expr><name>uv</name> <operator>=</operator> <call><name>uvnext</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>uvprev</name><argument_list>(<argument><expr><call><name>uvnext</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>uv</name> <operator>&amp;&amp;</operator> <call><name>uvnext</name><argument_list>(<argument><expr><call><name>uvprev</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isgray</name><argument_list>(<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>gc_marktv</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>uvval</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Mark userdata in mmudata list. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gc_mark_mmudata</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>u</name> <init>= <expr><name>root</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>u</name></expr>)</condition> <block>{<block_content>
    <do>do <block>{<block_content>
      <expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>gcnext</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Could be from previous GC. */</comment>
      <expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>u</name> <operator>!=</operator> <name>root</name></expr>)</condition>;</do>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Separate userdata objects to be finalized to mmudata list. */</comment>
<function><type><name>size_t</name></type> <name>lj_gc_separateudata</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>all</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCRef</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><call><name>mainthread</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nextgc</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
  <while>while <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>gcref</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>iswhite</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>all</name><operator>)</operator> <operator>||</operator> <call><name>isfinalized</name><argument_list>(<argument><expr><call><name>gco2ud</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr>;</expr_stmt>  <comment type="block">/* Nothing to do. */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>lj_meta_fastg</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>tabref</name><argument_list>(<argument><expr><call><name>gco2ud</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MM_gc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>markfinalized</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Done, as there's no __gc metamethod. */</comment>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Otherwise move userdata to be finalized to mmudata list. */</comment>
      <expr_stmt><expr><name>m</name> <operator>+=</operator> <call><name>sizeudata</name><argument_list>(<argument><expr><call><name>gco2ud</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>markfinalized</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Link to end of mmudata list. */</comment>
	<decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Create circular list. */</comment>
	<expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Propagation phase --------------------------------------------------- */</comment>

<comment type="block">/* Traverse a table. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>gc_traverse_tab</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>weak</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>mode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><call><name>tabref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>mt</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>lj_meta_fastg</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>, <argument><expr><name>MM_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>&amp;&amp;</operator> <call><name>tvisstr</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Valid __mode field? */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modestr</name> <init>= <expr><call><name>strVdata</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>modestr</name><operator>++</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'k'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>weak</name> <operator>|=</operator> <name>LJ_GC_WEAKKEY</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'v'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>weak</name> <operator>|=</operator> <name>LJ_GC_WEAKVAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>weak</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Weak tables are cleared in the atomic phase. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
      <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>cts</name> <operator>&amp;&amp;</operator> <name><name>cts</name><operator>-&gt;</operator><name>finalizer</name></name> <operator>==</operator> <name>t</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>weak</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>~</operator><literal type="number">0u</literal> <operator>&amp;</operator> <operator>~</operator><name>LJ_GC_WEAKVAL</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{<block_content>
	<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>marked</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>marked</name></name> <operator>&amp;</operator> <operator>~</operator><name>LJ_GC_WEAK</name><operator>)</operator> <operator>|</operator> <name>weak</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>gclist</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>weak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>weak</name></name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>weak</name> <operator>==</operator> <name>LJ_GC_WEAK</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Nothing to mark if both keys/values are weak. */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>weak</name> <operator>&amp;</operator> <name>LJ_GC_WEAKVAL</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Mark array part. */</comment>
    <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>asize</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>asize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>gc_marktv</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>arrayslot</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Mark hash part. */</comment>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>hmask</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>hmask</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Mark non-empty slot. */</comment>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>weak</name> <operator>&amp;</operator> <name>LJ_GC_WEAKKEY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gc_marktv</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>weak</name> <operator>&amp;</operator> <name>LJ_GC_WEAKVAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gc_marktv</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>weak</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Traverse a function. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gc_traverse_func</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>tabref</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>env</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isluafunc</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>nupvalues</name></name> <operator>&lt;=</operator> <call><name>funcproto</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>sizeuv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>funcproto</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fn</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>nupvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* Mark Lua function upvalues. */</comment>
      <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>gcref</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>uvptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>nupvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* Mark C function upvalues. */</comment>
      <expr_stmt><expr><call><name>gc_marktv</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>upvalue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
<comment type="block">/* Mark a trace. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gc_marktrace</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>TraceNo</name></type> <name>traceno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>obj2gco</name><argument_list>(<argument><expr><call><name>traceref</name><argument_list>(<argument><expr><call><name>G2J</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>traceno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>traceno</name> <operator>!=</operator> <call><name>G2J</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>cur</name><operator>.</operator><name>traceno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>iswhite</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>white2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>gclist</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>gray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>gray</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Traverse a trace. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gc_traverse_trace</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>T</name><operator>-&gt;</operator><name>traceno</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name><name>T</name><operator>-&gt;</operator><name>nk</name></name></expr>;</init> <condition><expr><name>ref</name> <operator>&lt;</operator> <name>REF_TRUE</name></expr>;</condition> <incr><expr><name>ref</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name>ref</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KGC</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>ir_kgc</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>!=</operator> <name>IR_KNULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ref</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name><name>T</name><operator>-&gt;</operator><name>link</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gc_marktrace</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>T</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>T</name><operator>-&gt;</operator><name>nextroot</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gc_marktrace</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>T</name><operator>-&gt;</operator><name>nextroot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>T</name><operator>-&gt;</operator><name>nextside</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gc_marktrace</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>T</name><operator>-&gt;</operator><name>nextside</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>startpt</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* The current trace is a GC root while not anchored in the prototype (yet). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_traverse_curtrace</name><parameter_list>(<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>gc_traverse_trace(g, &amp;G2J(g)-&gt;cur)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_traverse_curtrace</name><parameter_list>(<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>UNUSED(g)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Traverse a prototype. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gc_traverse_proto</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>gc_mark_str</name><argument_list>(<argument><expr><call><name>proto_chunkname</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name><name>pt</name><operator>-&gt;</operator><name>sizekgc</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* Mark collectable consts. */</comment>
    <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>proto_kgc</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>pt</name><operator>-&gt;</operator><name>trace</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gc_marktrace</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>trace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Traverse the frame structure of a stack. */</comment>
<function><type><specifier>static</specifier> <name>MSize</name></type> <name>gc_traverse_frames</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>frame</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>top</name> <init>= <expr><name><name>th</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bot</name> <init>= <expr><call><name>tvref</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Note: extra vararg frame not skipped, marks function twice (harmless). */</comment>
  <for>for <control>(<init><expr><name>frame</name> <operator>=</operator> <name><name>th</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>frame</name> <operator>&gt;</operator> <name>bot</name><operator>+</operator><name>LJ_FR2</name></expr>;</condition> <incr><expr><name>frame</name> <operator>=</operator> <call><name>frame_prev</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><call><name>frame_func</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>ftop</name> <init>= <expr><name>frame</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isluafunc</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ftop</name> <operator>+=</operator> <call><name>funcproto</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ftop</name> <operator>&gt;</operator> <name>top</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>top</name> <operator>=</operator> <name>ftop</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LJ_FR2</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Need to mark hidden function (or L). */</comment>
  </block_content>}</block></for>
  <expr_stmt><expr><name>top</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* Correct bias of -1 (frame == base-1). */</comment>
  <if_stmt><if>if <condition>(<expr><name>top</name> <operator>&gt;</operator> <call><name>tvref</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>maxstack</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>top</name> <operator>=</operator> <call><name>tvref</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>maxstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><name>top</name> <operator>-</operator> <name>bot</name><operator>)</operator></expr>;</return>  <comment type="block">/* Return minimum needed stack size. */</comment>
</block_content>}</block></function>

<comment type="block">/* Traverse a thread object. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gc_traverse_thread</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>top</name> <init>= <expr><name><name>th</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>o</name> <operator>=</operator> <call><name>tvref</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr>;</init> <condition><expr><name>o</name> <operator>&lt;</operator> <name>top</name></expr>;</condition> <incr><expr><name>o</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>gc_marktv</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSatomic</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>top</name> <operator>=</operator> <call><name>tvref</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>th</name><operator>-&gt;</operator><name>stacksize</name></name></expr>;</expr_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>o</name> <operator>&lt;</operator> <name>top</name></expr>;</condition> <incr><expr><name>o</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* Clear unmarked slots. */</comment>
      <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>tabref</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>env</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_state_shrinkstack</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><call><name>gc_traverse_frames</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Propagate one gray object. Traverse it and turn it black. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>propagatemark</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>gray</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>gct</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>gct</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isgray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>gray</name></name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>gclist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Remove from gray list. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name>gct</name> <operator>==</operator> <operator>~</operator><name>LJ_TTAB</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>gco2tab</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>gc_traverse_tab</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>black2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Keep weak tables gray. */</comment>
    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>GCtab</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>t</name><operator>-&gt;</operator><name>asize</name></name> <operator>+</operator>
			   <operator>(</operator><ternary><condition><expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name>gct</name> <operator>==</operator> <operator>~</operator><name>LJ_TFUNC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><call><name>gco2func</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>gc_traverse_func</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><call><name>isluafunc</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>sizeLfunc</name><argument_list>(<argument><expr><operator>(</operator><name>MSize</name><operator>)</operator><name><name>fn</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>nupvalues</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
			   <expr><call><name>sizeCfunc</name><argument_list>(<argument><expr><operator>(</operator><name>MSize</name><operator>)</operator><name><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>nupvalues</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name>gct</name> <operator>==</operator> <operator>~</operator><name>LJ_TPROTO</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>gco2pt</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>gc_traverse_proto</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>pt</name><operator>-&gt;</operator><name>sizept</name></name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name>gct</name> <operator>==</operator> <operator>~</operator><name>LJ_TTHREAD</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>gclist</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>grayagain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>grayagain</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>black2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Threads are never black. */</comment>
    <expr_stmt><expr><call><name>gc_traverse_thread</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>lua_State</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>th</name><operator>-&gt;</operator><name>stacksize</name></name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
    <decl_stmt><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name> <init>= <expr><call><name>gco2trace</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>gc_traverse_trace</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>GCtrace</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">7</literal><operator>)</operator><operator>&amp;</operator><operator>~</operator><literal type="number">7</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>T</name><operator>-&gt;</operator><name>nins</name></name><operator>-</operator><name><name>T</name><operator>-&gt;</operator><name>nk</name></name><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>IRIns</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
	   <name><name>T</name><operator>-&gt;</operator><name>nsnap</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>SnapShot</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>T</name><operator>-&gt;</operator><name>nsnapmap</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>SnapEntry</name></expr></argument>)</argument_list></sizeof></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Propagate all gray objects. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>gc_propagate_gray</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>gray</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>m</name> <operator>+=</operator> <call><name>propagatemark</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Sweep phase --------------------------------------------------------- */</comment>

<comment type="block">/* Type of GC free functions. */</comment>
<typedef>typedef <function_decl><type><name>void</name></type> (<name>LJ_FASTCALL</name> <modifier>*</modifier><name>GCFreeFunc</name>)<parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* GC free functions for LJ_TSTR .. LJ_TUDATA. ORDER LJ_T */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>GCFreeFunc</name></type> <name><name>gc_freefunc</name><index>[]</index></name> <init>= <expr><block>{
  <expr><operator>(</operator><name>GCFreeFunc</name><operator>)</operator><name>lj_str_free</name></expr>,
  <expr><operator>(</operator><name>GCFreeFunc</name><operator>)</operator><name>lj_func_freeuv</name></expr>,
  <expr><operator>(</operator><name>GCFreeFunc</name><operator>)</operator><name>lj_state_free</name></expr>,
  <expr><operator>(</operator><name>GCFreeFunc</name><operator>)</operator><name>lj_func_freeproto</name></expr>,
  <expr><operator>(</operator><name>GCFreeFunc</name><operator>)</operator><name>lj_func_free</name></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
  <expr><operator>(</operator><name>GCFreeFunc</name><operator>)</operator><name>lj_trace_free</name></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><operator>(</operator><name>GCFreeFunc</name><operator>)</operator><literal type="number">0</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <expr><operator>(</operator><name>GCFreeFunc</name><operator>)</operator><name>lj_cdata_free</name></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><operator>(</operator><name>GCFreeFunc</name><operator>)</operator><literal type="number">0</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><operator>(</operator><name>GCFreeFunc</name><operator>)</operator><name>lj_tab_free</name></expr>,
  <expr><operator>(</operator><name>GCFreeFunc</name><operator>)</operator><name>lj_udata_free</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Full sweep of a GC list. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_fullsweep</name><parameter_list>(<parameter><type><name>g</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>gc_sweep(g, (p), ~(uint32_t)0)</cpp:value></cpp:define>

<comment type="block">/* Partial sweep of a GC list. */</comment>
<function><type><specifier>static</specifier> <name>GCRef</name> <modifier>*</modifier></type><name>gc_sweep</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCRef</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>lim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Mask with other white and LJ_GC_FIXED. Or LJ_GC_SFIXED on shutdown. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ow</name> <init>= <expr><call><name>otherwhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
  <while>while <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>gcref</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>lim</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>gct</name></name> <operator>==</operator> <operator>~</operator><name>LJ_TTHREAD</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Need to sweep open upvalues, too. */</comment>
      <expr_stmt><expr><call><name>gc_fullsweep</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>openupval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>marked</name></name> <operator>^</operator> <name>LJ_GC_WHITES</name><operator>)</operator> <operator>&amp;</operator> <name>ow</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Black or current white? */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>marked</name></name> <operator>&amp;</operator> <name>LJ_GC_FIXED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Value is alive, change to the current white. */</comment>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Otherwise value is dead, free it. */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>ow</name> <operator>==</operator> <name>LJ_GC_SFIXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>root</name></name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Adjust list anchor. */</comment>
      <expr_stmt><expr><name><name>gc_freefunc</name><index>[<expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>gct</name></name> <operator>-</operator> <operator>~</operator><name>LJ_TSTR</name></expr>]</index></name><operator>(</operator><name>g</name><operator>,</operator> <name>o</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check whether we can clear a key or a value slot from a table. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>gc_mayclear</name><parameter_list>(<parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>tvisgcv</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Only collectable objects can be weak references. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* But strings cannot be used as weak references. */</comment>
      <expr_stmt><expr><call><name>gc_mark_str</name><argument_list>(<argument><expr><call><name>strV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* And need to be marked. */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>iswhite</name><argument_list>(<argument><expr><call><name>gcV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Object is about to be collected. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>tvisudata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>val</name> <operator>&amp;&amp;</operator> <call><name>isfinalized</name><argument_list>(<argument><expr><call><name>udataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Finalized userdata is dropped only from values. */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Cannot clear. */</comment>
</block_content>}</block></function>

<comment type="block">/* Clear collected entries from weak tables. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gc_clearweak</name><parameter_list>(<parameter><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <while>while <condition>(<expr><name>o</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>gco2tab</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>marked</name></name> <operator>&amp;</operator> <name>LJ_GC_WEAK</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>marked</name></name> <operator>&amp;</operator> <name>LJ_GC_WEAKVAL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>asize</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>asize</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>asize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	<comment type="block">/* Clear array slot when value is about to be collected. */</comment>
	<decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>arrayslot</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>gc_mayclear</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>hmask</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>hmask</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Clear hash slot when key or value is about to be collected. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>gc_mayclear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
				  <call><name>gc_mayclear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>gcref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>gclist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Call a userdata or cdata finalizer. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gc_call_finalizer</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>,
			      <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>mo</name></decl></parameter>, <parameter><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Save and restore lots of state around the __gc callback. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>oldh</name> <init>= <expr><call><name>hook_save</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCSize</name></type> <name>oldt</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>threshold</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>errcode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>top</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_trace_abort</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>hook_entergc</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Disable hooks and new traces during __gc. */</comment>
  <if_stmt><if>if <condition>(<expr><name>LJ_HASPROFILE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>oldh</name> <operator>&amp;</operator> <name>HOOK_PROFILE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_dispatch_update</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>threshold</name></name> <operator>=</operator> <name>LJ_MAX_MEM</name></expr>;</expr_stmt>  <comment type="block">/* Prevent GC steps. */</comment>
  <expr_stmt><expr><name>top</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name><operator>++</operator></expr></argument>, <argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>LJ_FR2</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name>top</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>setgcV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><operator>~</operator><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>gct</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>top</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>lj_vm_pcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Stack: |mo|o| -&gt; | */</comment>
  <expr_stmt><expr><call><name>hook_restore</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>oldh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>LJ_HASPROFILE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>oldh</name> <operator>&amp;</operator> <name>HOOK_PROFILE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_dispatch_update</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>threshold</name></name> <operator>=</operator> <name>oldt</name></expr>;</expr_stmt>  <comment type="block">/* Restore GC threshold. */</comment>
  <if_stmt><if>if <condition>(<expr><name>errcode</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Propagate errors. */</comment>
</block_content>}</block></function>

<comment type="block">/* Finalize one userdata or cdata object from the mmudata list. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gc_finalize</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>gcnext</name><argument_list>(<argument><expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>mo</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>tvref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>jit_base</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Must not be called on trace. */</comment>
  <comment type="block">/* Unchain from list of userdata to be finalized. */</comment>
  <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>gct</name></name> <operator>==</operator> <operator>~</operator><name>LJ_TCDATA</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TValue</name></type> <name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tv</name></decl>;</decl_stmt>
    <comment type="block">/* Add cdata back to the GC list and make it white. */</comment>
    <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>root</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>marked</name></name> <operator>&amp;=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>~</operator><name>LJ_GC_CDATA_FIN</name></expr>;</expr_stmt>
    <comment type="block">/* Resolve finalizer. */</comment>
    <expr_stmt><expr><call><name>setcdataV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><call><name>gco2cd</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tv</name> <operator>=</operator> <call><name>lj_tab_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>finalizer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>nocdatafin</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Clear entry in finalizer table. */</comment>
      <expr_stmt><expr><call><name>gc_call_finalizer</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* Add userdata back to the main userdata list and make it white. */</comment>
  <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>, <argument><expr><call><name>mainthread</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nextgc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><call><name>mainthread</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nextgc</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Resolve the __gc metamethod. */</comment>
  <expr_stmt><expr><name>mo</name> <operator>=</operator> <call><name>lj_meta_fastg</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>tabref</name><argument_list>(<argument><expr><call><name>gco2ud</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MM_gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>mo</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>gc_call_finalizer</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>mo</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Finalize all userdata objects from mmudata list. */</comment>
<function><type><name>void</name></type> <name>lj_gc_finalize_udata</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <while>while <condition>(<expr><call><name>gcref</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>gc_finalize</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<comment type="block">/* Finalize all cdata objects from finalizer table. */</comment>
<function><type><name>void</name></type> <name>lj_gc_finalize_cdata</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>cts</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name><name>cts</name><operator>-&gt;</operator><name>finalizer</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Mark finalizer table as disabled. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tviscdata</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>gcV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TValue</name></type> <name>tmp</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>marked</name></name> <operator>&amp;=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>~</operator><name>LJ_GC_CDATA_FIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gc_call_finalizer</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Free all remaining GC objects. */</comment>
<function><type><name>void</name></type> <name>lj_gc_freeall</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>strmask</name></decl>;</decl_stmt>
  <comment type="block">/* Free everything, except super-fixed objects (the main thread). */</comment>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>currentwhite</name></name> <operator>=</operator> <name>LJ_GC_WHITES</name> <operator>|</operator> <name>LJ_GC_SFIXED</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gc_fullsweep</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>strmask</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>strmask</name></name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>strmask</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* Free all string hash chains. */</comment>
    <expr_stmt><expr><call><name>gc_fullsweep</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>strhash</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/* -- Collector ----------------------------------------------------------- */</comment>

<comment type="block">/* Atomic part of the GC cycle, transitioning from mark to sweep phase. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>atomic</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>udsize</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>gc_mark_uv</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Need to remark open upvalues (the thread may be dead). */</comment>
  <expr_stmt><expr><call><name>gc_propagate_gray</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Propagate any left-overs. */</comment>

  <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>gray</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>weak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Empty the list of weak tables. */</comment>
  <expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>weak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>iswhite</name><argument_list>(<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><call><name>mainthread</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gc_markobj</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Mark running thread. */</comment>
  <expr_stmt><expr><call><name>gc_traverse_curtrace</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Traverse current trace. */</comment>
  <expr_stmt><expr><call><name>gc_mark_gcroot</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Mark GC roots (again). */</comment>
  <expr_stmt><expr><call><name>gc_propagate_gray</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Propagate all of the above. */</comment>

  <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>gray</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>grayagain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Empty the 2nd chance list. */</comment>
  <expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>grayagain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gc_propagate_gray</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Propagate it. */</comment>

  <expr_stmt><expr><name>udsize</name> <operator>=</operator> <call><name>lj_gc_separateudata</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Separate userdata to be finalized. */</comment>
  <expr_stmt><expr><call><name>gc_mark_mmudata</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Mark them. */</comment>
  <expr_stmt><expr><name>udsize</name> <operator>+=</operator> <call><name>gc_propagate_gray</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* And propagate the marks. */</comment>

  <comment type="block">/* All marking done, clear weak tables. */</comment>
  <expr_stmt><expr><call><name>gc_clearweak</name><argument_list>(<argument><expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>weak</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>lj_buf_shrink</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>tmpbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Shrink temp buffer. */</comment>

  <comment type="block">/* Prepare for sweep phase. */</comment>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>currentwhite</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><call><name>otherwhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Flip current white. */</comment>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>strempty</name><operator>.</operator><name>marked</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>currentwhite</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>sweep</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>estimate</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>total</name></name> <operator>-</operator> <operator>(</operator><name>GCSize</name><operator>)</operator><name>udsize</name></expr>;</expr_stmt>  <comment type="block">/* Initial estimate. */</comment>
</block_content>}</block></function>

<comment type="block">/* GC state machine. Returns a cost estimate for each step performed. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>gc_onestep</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>GCSpause</name></expr>:</case>
    <expr_stmt><expr><call><name>gc_mark_start</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Start a new GC cycle by marking all GC roots. */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  <case>case <expr><name>GCSpropagate</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>gray</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>propagatemark</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Propagate one gray object. */</comment>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>GCSatomic</name></expr>;</expr_stmt>  <comment type="block">/* End of mark phase. */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  <case>case <expr><name>GCSatomic</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><call><name>tvref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>jit_base</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Don't run atomic phase on trace. */</comment>
      <return>return <expr><name>LJ_MAX_MEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>atomic</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>GCSsweepstring</name></expr>;</expr_stmt>  <comment type="block">/* Start of sweep phase. */</comment>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>sweepstr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  <case>case <expr><name>GCSsweepstring</name></expr>:</case> <block>{<block_content>
    <decl_stmt><decl><type><name>GCSize</name></type> <name>old</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>total</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>gc_fullsweep</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>strhash</name><index>[<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>sweepstr</name></name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Sweep one chain. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>sweepstr</name></name> <operator>&gt;</operator> <name><name>g</name><operator>-&gt;</operator><name>strmask</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>GCSsweep</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* All string hash chains sweeped. */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>old</name> <operator>&gt;=</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>total</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>estimate</name></name> <operator>-=</operator> <name>old</name> <operator>-</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>total</name></name></expr>;</expr_stmt>
    <return>return <expr><name>GCSWEEPCOST</name></expr>;</return>
    </block_content>}</block>
  <case>case <expr><name>GCSsweep</name></expr>:</case> <block>{<block_content>
    <decl_stmt><decl><type><name>GCSize</name></type> <name>old</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>total</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>sweep</name></name></expr></argument>, <argument><expr><call><name>gc_sweep</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>mref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>sweep</name></name></expr></argument>, <argument><expr><name>GCRef</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>GCSWEEPMAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>old</name> <operator>&gt;=</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>total</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>estimate</name></name> <operator>-=</operator> <name>old</name> <operator>-</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>total</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>gcref</name><argument_list>(<argument><expr><operator>*</operator><call><name>mref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>sweep</name></name></expr></argument>, <argument><expr><name>GCRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>strnum</name></name> <operator>&lt;=</operator> <operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>strmask</name></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>strmask</name></name> <operator>&gt;</operator> <name>LJ_MIN_STRTAB</name><operator>*</operator><literal type="number">2</literal><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_str_resize</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>strmask</name></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Shrink string table. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Need any finalizations? */</comment>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>GCSfinalize</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>nocdatafin</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Otherwise skip this phase to help the JIT. */</comment>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>GCSpause</name></expr>;</expr_stmt>  <comment type="block">/* End of GC cycle. */</comment>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>debt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>GCSWEEPMAX</name><operator>*</operator><name>GCSWEEPCOST</name></expr>;</return>
    </block_content>}</block>
  <case>case <expr><name>GCSfinalize</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>mmudata</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>tvref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>jit_base</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Don't call finalizers on trace. */</comment>
	<return>return <expr><name>LJ_MAX_MEM</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>gc_finalize</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Finalize one userdata object. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>estimate</name></name> <operator>&gt;</operator> <name>GCFINALIZECOST</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>estimate</name></name> <operator>-=</operator> <name>GCFINALIZECOST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><name>GCFINALIZECOST</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>nocdatafin</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_tab_rehash</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>ctype_ctsG</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>finalizer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>GCSpause</name></expr>;</expr_stmt>  <comment type="block">/* End of GC cycle. */</comment>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>debt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  <default>default:</default>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Perform a limited amount of incremental GC steps. */</comment>
<function><type><name>int</name> <name>LJ_FASTCALL</name></type> <name>lj_gc_step</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCSize</name></type> <name>lim</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>ostate</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>vmstate</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setvmstate</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>GC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>lim</name> <operator>=</operator> <operator>(</operator><name>GCSTEPSIZE</name><operator>/</operator><literal type="number">100</literal><operator>)</operator> <operator>*</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>stepmul</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>lim</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>lim</name> <operator>=</operator> <name>LJ_MAX_MEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>total</name></name> <operator>&gt;</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>threshold</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>debt</name></name> <operator>+=</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>total</name></name> <operator>-</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>threshold</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>lim</name> <operator>-=</operator> <operator>(</operator><name>GCSize</name><operator>)</operator><call><name>gc_onestep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSpause</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>threshold</name></name> <operator>=</operator> <operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>estimate</name></name><operator>/</operator><literal type="number">100</literal><operator>)</operator> <operator>*</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>pause</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>vmstate</name></name> <operator>=</operator> <name>ostate</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Finished a GC cycle. */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block> while <condition>(<expr><ternary><condition><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lim</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>lim</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>lim</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></else></ternary></expr>)</condition>;</do>
  <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>debt</name></name> <operator>&lt;</operator> <name>GCSTEPSIZE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>threshold</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>total</name></name> <operator>+</operator> <name>GCSTEPSIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>vmstate</name></name> <operator>=</operator> <name>ostate</name></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>debt</name></name> <operator>-=</operator> <name>GCSTEPSIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>threshold</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>total</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>vmstate</name></name> <operator>=</operator> <name>ostate</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Ditto, but fix the stack top first. */</comment>
<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>lj_gc_step_fixtop</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>curr_funcisL</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>curr_topL</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_gc_step</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
<comment type="block">/* Perform multiple GC steps. Called from JIT-compiled code. */</comment>
<function><type><name>int</name> <name>LJ_FASTCALL</name></type> <name>lj_gc_step_jit</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>steps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><call><name>gco2th</name><argument_list>(<argument><expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>cur_L</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <call><name>tvref</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>jit_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>curr_topL</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>steps</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>lj_gc_step</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <empty_stmt>;</empty_stmt></block_content></block></while>
  <comment type="block">/* Return 1 to force a trace exit. */</comment>
  <return>return <expr><operator>(</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSatomic</name> <operator>||</operator> <call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSfinalize</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Perform a full GC cycle. */</comment>
<function><type><name>void</name></type> <name>lj_gc_fullgc</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>ostate</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>vmstate</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setvmstate</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>GC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>&lt;=</operator> <name>GCSatomic</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Caught somewhere in the middle. */</comment>
    <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>sweep</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Sweep everything (preserving it). */</comment>
    <expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>gray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Reset lists from partial propagation. */</comment>
    <expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>grayagain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>weak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>GCSsweepstring</name></expr>;</expr_stmt>  <comment type="block">/* Fast forward to the sweep phase. */</comment>
    <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>sweepstr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <while>while <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSsweepstring</name> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSsweep</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>gc_onestep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>  <comment type="block">/* Finish sweep. */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSfinalize</name> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSpause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Now perform a full GC. */</comment>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>GCSpause</name></expr>;</expr_stmt>
  <do>do <block>{<block_content> <expr_stmt><expr><call><name>gc_onestep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>!=</operator> <name>GCSpause</name></expr>)</condition>;</do>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>threshold</name></name> <operator>=</operator> <operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>estimate</name></name><operator>/</operator><literal type="number">100</literal><operator>)</operator> <operator>*</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>pause</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>vmstate</name></name> <operator>=</operator> <name>ostate</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Write barriers ------------------------------------------------------ */</comment>

<comment type="block">/* Move the GC propagation frontier forward. */</comment>
<function><type><name>void</name></type> <name>lj_gc_barrierf</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isblack</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>iswhite</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>!=</operator> <name>GCSfinalize</name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>!=</operator> <name>GCSpause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>gct</name></name> <operator>!=</operator> <operator>~</operator><name>LJ_TTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Preserve invariant during propagation. Otherwise it doesn't matter. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSpropagate</name> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSatomic</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* Move frontier forward. */</comment>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* Make it white to avoid the following barrier. */</comment>
</block_content>}</block></function>

<comment type="block">/* Specialized barrier for closed upvalue. Pass &amp;uv-&gt;tv. */</comment>
<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>lj_gc_barrieruv</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TV2MARKED</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>(*((uint8_t *)(x) - offsetof(GCupval, tv) + offsetof(GCupval, marked)))</cpp:value></cpp:define>
  <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSpropagate</name> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSatomic</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gcV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>TV2MARKED</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><call><name>TV2MARKED</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>~</operator><name>LJ_GC_COLORS</name><operator>)</operator> <operator>|</operator> <call><name>curwhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TV2MARKED</name></cpp:undef>
</block_content>}</block></function>

<comment type="block">/* Close upvalue. Also needs a write barrier. */</comment>
<function><type><name>void</name></type> <name>lj_gc_closeuv</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCupval</name> <modifier>*</modifier></type><name>uv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Copy stack slot to upvalue itself and point to the copy. */</comment>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><call><name>mainthread</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>uv</name><operator>-&gt;</operator><name>tv</name></name></expr></argument>, <argument><expr><call><name>uvval</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>uv</name><operator>-&gt;</operator><name>tv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>uv</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>root</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isgray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* A closed upvalue is never gray, so fix this. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSpropagate</name> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSatomic</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Make it black and preserve invariant. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>tviswhite</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uv</name><operator>-&gt;</operator><name>tv</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_gc_barrierf</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>gcV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uv</name><operator>-&gt;</operator><name>tv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Make it white, i.e. sweep the upvalue. */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>!=</operator> <name>GCSfinalize</name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>!=</operator> <name>GCSpause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>
<comment type="block">/* Mark a trace if it's saved during the propagation phase. */</comment>
<function><type><name>void</name></type> <name>lj_gc_barriertrace</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>traceno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSpropagate</name> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>GCSatomic</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>gc_marktrace</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>traceno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- Allocator ----------------------------------------------------------- */</comment>

<comment type="block">/* Call pluggable memory allocator to allocate or resize a fragment. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>lj_mem_realloc</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>GCSize</name></type> <name>osz</name></decl></parameter>, <parameter><decl><type><name>GCSize</name></type> <name>nsz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name>osz</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>p</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name><name>g</name><operator>-&gt;</operator><name>allocf</name></name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>allocd</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>osz</name></expr></argument>, <argument><expr><name>nsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>nsz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_mem</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name>nsz</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>p</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>checkptrGC</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>total</name></name> <operator>=</operator> <operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>total</name></name> <operator>-</operator> <name>osz</name><operator>)</operator> <operator>+</operator> <name>nsz</name></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Allocate new GC object and link it to the root set. */</comment>
<function><type><name>void</name> <modifier>*</modifier> <name>LJ_FASTCALL</name></type> <name>lj_mem_newgco</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCSize</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><operator>(</operator><name>GCobj</name> <operator>*</operator><operator>)</operator><call><name><name>g</name><operator>-&gt;</operator><name>allocf</name></name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>allocd</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_mem</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>checkptrGC</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>total</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gc</name><operator>.</operator><name>root</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>newwhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Resize growable vector. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>lj_mem_grow</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>MSize</name> <modifier>*</modifier></type><name>szp</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>lim</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>esz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>sz</name> <init>= <expr><operator>(</operator><operator>*</operator><name>szp</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;</operator> <name>LJ_MIN_VECSZ</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <name>LJ_MIN_VECSZ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;</operator> <name>lim</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <name>lim</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lj_mem_realloc</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>szp</name><operator>)</operator><operator>*</operator><name>esz</name></expr></argument>, <argument><expr><name>sz</name><operator>*</operator><name>esz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>szp</name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

</unit>
