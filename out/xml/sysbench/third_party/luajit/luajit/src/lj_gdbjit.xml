<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_gdbjit.c"><comment type="block">/*
** Client for the GDB JIT API.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_gdbjit_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_frame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_buf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strfmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_dispatch.h"</cpp:file></cpp:include>

<comment type="block">/* This is not compiled in by default.
** Enable with -DLUAJIT_USE_GDBJIT in the Makefile and recompile everything.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUAJIT_USE_GDBJIT</name></cpp:ifdef>

<comment type="block">/* The GDB JIT API allows JIT compilers to pass debug information about
** JIT-compiled code back to GDB. You need at least GDB 7.0 or higher
** to see it in action.
**
** This is a passive API, so it works even when not running under GDB
** or when attaching to an already running process. Alas, this implies
** enabling it always has a non-negligible overhead -- do not use in
** release mode!
**
** The LuaJIT GDB JIT client is rather minimal at the moment. It gives
** each trace a symbol name and adds a source location and frame unwind
** information. Obviously LuaJIT itself and any embedding C application
** should be compiled with debug symbols, too (see the Makefile).
**
** Traces are named TRACE_1, TRACE_2, ... these correspond to the trace
** numbers from -jv or -jdump. Use "break TRACE_1" or "tbreak TRACE_1" etc.
** to set breakpoints on specific traces (even ahead of their creation).
**
** The source location for each trace allows listing the corresponding
** source lines with the GDB command "list" (but only if the Lua source
** has been loaded from a file). Currently this is always set to the
** location where the trace has been started.
**
** Frame unwind information can be inspected with the GDB command
** "info frame". This also allows proper backtraces across JIT-compiled
** code with the GDB command "bt".
**
** You probably want to add the following settings to a .gdbinit file
** (or add them to ~/.gdbinit):
**   set disassembly-flavor intel
**   set breakpoint pending on
**
** Here's a sample GDB session:
** ------------------------------------------------------------------------

$ cat &gt;x.lua
for outer=1,100 do
  for inner=1,100 do end
end
^D

$ luajit -jv x.lua
[TRACE   1 x.lua:2]
[TRACE   2 (1/3) x.lua:1 -&gt; 1]

$ gdb --quiet --args luajit x.lua
(gdb) tbreak TRACE_1
Function "TRACE_1" not defined.
Temporary breakpoint 1 (TRACE_1) pending.
(gdb) run
Starting program: luajit x.lua

Temporary breakpoint 1, TRACE_1 () at x.lua:2
2	  for inner=1,100 do end
(gdb) list
1	for outer=1,100 do
2	  for inner=1,100 do end
3	end
(gdb) bt
#0  TRACE_1 () at x.lua:2
#1  0x08053690 in lua_pcall [...]
[...]
#7  0x0806ff90 in main [...]
(gdb) disass TRACE_1
Dump of assembler code for function TRACE_1:
0xf7fd9fba &lt;TRACE_1+0&gt;:	mov    DWORD PTR ds:0xf7e0e2a0,0x1
0xf7fd9fc4 &lt;TRACE_1+10&gt;:	movsd  xmm7,QWORD PTR [edx+0x20]
[...]
0xf7fd9ff8 &lt;TRACE_1+62&gt;:	jmp    0xf7fd2014
End of assembler dump.
(gdb) tbreak TRACE_2
Function "TRACE_2" not defined.
Temporary breakpoint 2 (TRACE_2) pending.
(gdb) cont
Continuing.

Temporary breakpoint 2, TRACE_2 () at x.lua:1
1	for outer=1,100 do
(gdb) info frame
Stack level 0, frame at 0xffffd7c0:
 eip = 0xf7fd9f60 in TRACE_2 (x.lua:1); saved eip 0x8053690
 called by frame at 0xffffd7e0
 source language unknown.
 Arglist at 0xffffd78c, args:
 Locals at 0xffffd78c, Previous frame's sp is 0xffffd7c0
 Saved registers:
  ebx at 0xffffd7ac, ebp at 0xffffd7b8, esi at 0xffffd7b0, edi at 0xffffd7b4,
  eip at 0xffffd7bc
(gdb)

** ------------------------------------------------------------------------
*/</comment>

<comment type="block">/* -- GDB JIT API --------------------------------------------------------- */</comment>

<comment type="block">/* GDB JIT actions. */</comment>
<enum>enum <block>{
  <decl><name>GDBJIT_NOACTION</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
  <decl><name>GDBJIT_REGISTER</name></decl>,
  <decl><name>GDBJIT_UNREGISTER</name></decl>
}</block>;</enum>

<comment type="block">/* GDB JIT entry. */</comment>
<typedef>typedef <type><struct>struct <name>GDBJITentry</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>GDBJITentry</name></name> <modifier>*</modifier></type><name>next_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>GDBJITentry</name></name> <modifier>*</modifier></type><name>prev_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>symfile_addr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>symfile_size</name></decl>;</decl_stmt>
}</block></struct></type> <name>GDBJITentry</name>;</typedef>

<comment type="block">/* GDB JIT descriptor. */</comment>
<typedef>typedef <type><struct>struct <name>GDBJITdesc</name> <block>{
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>version</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>action_flag</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GDBJITentry</name> <modifier>*</modifier></type><name>relevant_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GDBJITentry</name> <modifier>*</modifier></type><name>first_entry</name></decl>;</decl_stmt>
}</block></struct></type> <name>GDBJITdesc</name>;</typedef>

<decl_stmt><decl><type><name>GDBJITdesc</name></type> <name>__jit_debug_descriptor</name> <init>= <expr><block>{
  <expr><literal type="number">1</literal></expr>, <expr><name>GDBJIT_NOACTION</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* GDB sets a breakpoint at this function. */</comment>
<function><type><name>void</name> <name>LJ_NOINLINE</name></type> <name>__jit_debug_register_code</name><parameter_list>()</parameter_list>
<block>{<block_content>
  <asm>__asm__ <specifier>__volatile__</specifier>("");</asm>
</block_content>}</block></function><empty_stmt>;</empty_stmt>

<comment type="block">/* -- In-memory ELF object definitions ------------------------------------ */</comment>

<comment type="block">/* ELF definitions. */</comment>
<typedef>typedef <type><struct>struct <name>ELFheader</name> <block>{
  <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>emagic</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>eclass</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>eendian</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>eversion</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>eosabi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>eabiversion</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>epad</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>machine</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>version</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>phofs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>shofs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>ehsize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>phentsize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>phnum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>shentsize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>shnum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>shstridx</name></decl>;</decl_stmt>
}</block></struct></type> <name>ELFheader</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ELFsectheader</name> <block>{
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>addr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>ofs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>link</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>info</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>align</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>entsize</name></decl>;</decl_stmt>
}</block></struct></type> <name>ELFsectheader</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELFSECT_IDX_ABS</name></cpp:macro>		<cpp:value>0xfff1</cpp:value></cpp:define>

<enum>enum <block>{
  <decl><name>ELFSECT_TYPE_PROGBITS</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <decl><name>ELFSECT_TYPE_SYMTAB</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
  <decl><name>ELFSECT_TYPE_STRTAB</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
  <decl><name>ELFSECT_TYPE_NOBITS</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>
}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELFSECT_FLAGS_WRITE</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELFSECT_FLAGS_ALLOC</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELFSECT_FLAGS_EXEC</name></cpp:macro>	<cpp:value>4</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>ELFsymbol</name> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>info</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>other</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>sectidx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>size</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>info</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>other</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>sectidx</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>ELFsymbol</name>;</typedef>

<enum>enum <block>{
  <decl><name>ELFSYM_TYPE_FUNC</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
  <decl><name>ELFSYM_TYPE_FILE</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
  <decl><name>ELFSYM_BIND_LOCAL</name> <init>= <expr><literal type="number">0</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr></init></decl>,
  <decl><name>ELFSYM_BIND_GLOBAL</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr></init></decl>,
}</block>;</enum>

<comment type="block">/* DWARF definitions. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_CIE_VERSION</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>

<enum>enum <block>{
  <decl><name>DW_CFA_nop</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>,
  <decl><name>DW_CFA_offset_extended</name> <init>= <expr><literal type="number">0x5</literal></expr></init></decl>,
  <decl><name>DW_CFA_def_cfa</name> <init>= <expr><literal type="number">0xc</literal></expr></init></decl>,
  <decl><name>DW_CFA_def_cfa_offset</name> <init>= <expr><literal type="number">0xe</literal></expr></init></decl>,
  <decl><name>DW_CFA_offset_extended_sf</name> <init>= <expr><literal type="number">0x11</literal></expr></init></decl>,
  <decl><name>DW_CFA_advance_loc</name> <init>= <expr><literal type="number">0x40</literal></expr></init></decl>,
  <decl><name>DW_CFA_offset</name> <init>= <expr><literal type="number">0x80</literal></expr></init></decl>
}</block>;</enum>

<enum>enum <block>{
  <decl><name>DW_EH_PE_udata4</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
  <decl><name>DW_EH_PE_textrel</name> <init>= <expr><literal type="number">0x20</literal></expr></init></decl>
}</block>;</enum>

<enum>enum <block>{
  <decl><name>DW_TAG_compile_unit</name> <init>= <expr><literal type="number">0x11</literal></expr></init></decl>
}</block>;</enum>

<enum>enum <block>{
  <decl><name>DW_children_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
  <decl><name>DW_children_yes</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>
}</block>;</enum>

<enum>enum <block>{
  <decl><name>DW_AT_name</name> <init>= <expr><literal type="number">0x03</literal></expr></init></decl>,
  <decl><name>DW_AT_stmt_list</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>,
  <decl><name>DW_AT_low_pc</name> <init>= <expr><literal type="number">0x11</literal></expr></init></decl>,
  <decl><name>DW_AT_high_pc</name> <init>= <expr><literal type="number">0x12</literal></expr></init></decl>
}</block>;</enum>

<enum>enum <block>{
  <decl><name>DW_FORM_addr</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>,
  <decl><name>DW_FORM_data4</name> <init>= <expr><literal type="number">0x06</literal></expr></init></decl>,
  <decl><name>DW_FORM_string</name> <init>= <expr><literal type="number">0x08</literal></expr></init></decl>
}</block>;</enum>

<enum>enum <block>{
  <decl><name>DW_LNS_extended_op</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
  <decl><name>DW_LNS_copy</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <decl><name>DW_LNS_advance_pc</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
  <decl><name>DW_LNS_advance_line</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>
}</block>;</enum>

<enum>enum <block>{
  <decl><name>DW_LNE_end_sequence</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <decl><name>DW_LNE_set_address</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>
}</block>;</enum>

<enum>enum <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
  <decl><name>DW_REG_AX</name></decl>, <decl><name>DW_REG_CX</name></decl>, <decl><name>DW_REG_DX</name></decl>, <decl><name>DW_REG_BX</name></decl>,
  <decl><name>DW_REG_SP</name></decl>, <decl><name>DW_REG_BP</name></decl>, <decl><name>DW_REG_SI</name></decl>, <decl><name>DW_REG_DI</name></decl>,
  <decl><name>DW_REG_RA</name></decl>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:elif>
  <comment type="block">/* Yes, the order is strange, but correct. */</comment>
  <decl><name>DW_REG_AX</name></decl>, <decl><name>DW_REG_DX</name></decl>, <decl><name>DW_REG_CX</name></decl>, <decl><name>DW_REG_BX</name></decl>,
  <decl><name>DW_REG_SI</name></decl>, <decl><name>DW_REG_DI</name></decl>, <decl><name>DW_REG_BP</name></decl>, <decl><name>DW_REG_SP</name></decl>,
  <decl><name>DW_REG_8</name></decl>, <decl><name>DW_REG_9</name></decl>, <decl><name>DW_REG_10</name></decl>, <decl><name>DW_REG_11</name></decl>,
  <decl><name>DW_REG_12</name></decl>, <decl><name>DW_REG_13</name></decl>, <decl><name>DW_REG_14</name></decl>, <decl><name>DW_REG_15</name></decl>,
  <decl><name>DW_REG_RA</name></decl>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM</name></expr></cpp:elif>
  <decl><name>DW_REG_SP</name> <init>= <expr><literal type="number">13</literal></expr></init></decl>,
  <decl><name>DW_REG_RA</name> <init>= <expr><literal type="number">14</literal></expr></init></decl>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM64</name></expr></cpp:elif>
  <decl><name>DW_REG_SP</name> <init>= <expr><literal type="number">31</literal></expr></init></decl>,
  <decl><name>DW_REG_RA</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_PPC</name></expr></cpp:elif>
  <decl><name>DW_REG_SP</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <decl><name>DW_REG_RA</name> <init>= <expr><literal type="number">65</literal></expr></init></decl>,
  <decl><name>DW_REG_CR</name> <init>= <expr><literal type="number">70</literal></expr></init></decl>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_MIPS</name></expr></cpp:elif>
  <decl><name>DW_REG_SP</name> <init>= <expr><literal type="number">29</literal></expr></init></decl>,
  <decl><name>DW_REG_RA</name> <init>= <expr><literal type="number">31</literal></expr></init></decl>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Unsupported target architecture"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</enum>

<comment type="block">/* Minimal list of sections for the in-memory ELF object. */</comment>
<enum>enum <block>{
  <decl><name>GDBJIT_SECT_NULL</name></decl>,
  <decl><name>GDBJIT_SECT_text</name></decl>,
  <decl><name>GDBJIT_SECT_eh_frame</name></decl>,
  <decl><name>GDBJIT_SECT_shstrtab</name></decl>,
  <decl><name>GDBJIT_SECT_strtab</name></decl>,
  <decl><name>GDBJIT_SECT_symtab</name></decl>,
  <decl><name>GDBJIT_SECT_debug_info</name></decl>,
  <decl><name>GDBJIT_SECT_debug_abbrev</name></decl>,
  <decl><name>GDBJIT_SECT_debug_line</name></decl>,
  <decl><name>GDBJIT_SECT__MAX</name></decl>
}</block>;</enum>

<enum>enum <block>{
  <decl><name>GDBJIT_SYM_UNDEF</name></decl>,
  <decl><name>GDBJIT_SYM_FILE</name></decl>,
  <decl><name>GDBJIT_SYM_FUNC</name></decl>,
  <decl><name>GDBJIT_SYM__MAX</name></decl>
}</block>;</enum>

<comment type="block">/* In-memory ELF object. */</comment>
<typedef>typedef <type><struct>struct <name>GDBJITobj</name> <block>{
  <decl_stmt><decl><type><name>ELFheader</name></type> <name>hdr</name></decl>;</decl_stmt>			<comment type="block">/* ELF header. */</comment>
  <decl_stmt><decl><type><name>ELFsectheader</name></type> <name><name>sect</name><index>[<expr><name>GDBJIT_SECT__MAX</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* ELF sections. */</comment>
  <decl_stmt><decl><type><name>ELFsymbol</name></type> <name><name>sym</name><index>[<expr><name>GDBJIT_SYM__MAX</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* ELF symbol table. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>space</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>			<comment type="block">/* Space for various section data. */</comment>
}</block></struct></type> <name>GDBJITobj</name>;</typedef>

<comment type="block">/* Combined structure for GDB JIT entry and ELF object. */</comment>
<typedef>typedef <type><struct>struct <name>GDBJITentryobj</name> <block>{
  <decl_stmt><decl><type><name>GDBJITentry</name></type> <name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GDBJITobj</name></type> <name>obj</name></decl>;</decl_stmt>
}</block></struct></type> <name>GDBJITentryobj</name>;</typedef>

<comment type="block">/* Template for in-memory ELF header. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ELFheader</name></type> <name>elfhdr_template</name> <init>= <expr><block>{
  <expr><operator>.</operator><name>emagic</name> <operator>=</operator> <block>{ <expr><literal type="number">0x7f</literal></expr>, <expr><literal type="char">'E'</literal></expr>, <expr><literal type="char">'L'</literal></expr>, <expr><literal type="char">'F'</literal></expr> }</block></expr>,
  <expr><operator>.</operator><name>eclass</name> <operator>=</operator> <name>LJ_64</name> <operator>?</operator> <literal type="number">2</literal> <operator>:</operator> <literal type="number">1</literal></expr>,
  <expr><operator>.</operator><name>eendian</name> <operator>=</operator> <call><name>LJ_ENDIAN_SELECT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>,
  <expr><operator>.</operator><name>eversion</name> <operator>=</operator> <literal type="number">1</literal></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_LINUX</name></expr></cpp:if>
  <expr><operator>.</operator><name>eosabi</name> <operator>=</operator> <literal type="number">0</literal></expr>,  <comment type="block">/* Nope, it's not 3. */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr><operator>.</operator><name>eosabi</name> <operator>=</operator> <literal type="number">9</literal></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr><operator>.</operator><name>eosabi</name> <operator>=</operator> <literal type="number">2</literal></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr><operator>.</operator><name>eosabi</name> <operator>=</operator> <literal type="number">12</literal></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__DragonFly__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr><operator>.</operator><name>eosabi</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__sun__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__svr4__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>
  <expr><operator>.</operator><name>eosabi</name> <operator>=</operator> <literal type="number">6</literal></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><operator>.</operator><name>eosabi</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><operator>.</operator><name>eabiversion</name> <operator>=</operator> <literal type="number">0</literal></expr>,
  <expr><operator>.</operator><name>epad</name> <operator>=</operator> <block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><operator>.</operator><name>type</name> <operator>=</operator> <literal type="number">1</literal></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
  <expr><operator>.</operator><name>machine</name> <operator>=</operator> <literal type="number">3</literal></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:elif>
  <expr><operator>.</operator><name>machine</name> <operator>=</operator> <literal type="number">62</literal></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM</name></expr></cpp:elif>
  <expr><operator>.</operator><name>machine</name> <operator>=</operator> <literal type="number">40</literal></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM64</name></expr></cpp:elif>
  <expr><operator>.</operator><name>machine</name> <operator>=</operator> <literal type="number">183</literal></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_PPC</name></expr></cpp:elif>
  <expr><operator>.</operator><name>machine</name> <operator>=</operator> <literal type="number">20</literal></expr>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_MIPS</name></expr></cpp:elif>
  <expr><operator>.</operator><name>machine</name> <operator>=</operator> <literal type="number">8</literal></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Unsupported target architecture"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><operator>.</operator><name>version</name> <operator>=</operator> <literal type="number">1</literal></expr>,
  <expr><operator>.</operator><name>entry</name> <operator>=</operator> <literal type="number">0</literal></expr>,
  <expr><operator>.</operator><name>phofs</name> <operator>=</operator> <literal type="number">0</literal></expr>,
  <expr><operator>.</operator><name>shofs</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>GDBJITobj</name></expr></argument>, <argument><expr><name>sect</name></expr></argument>)</argument_list></call></expr>,
  <expr><operator>.</operator><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>,
  <expr><operator>.</operator><name>ehsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ELFheader</name></expr></argument>)</argument_list></sizeof></expr>,
  <expr><operator>.</operator><name>phentsize</name> <operator>=</operator> <literal type="number">0</literal></expr>,
  <expr><operator>.</operator><name>phnum</name> <operator>=</operator> <literal type="number">0</literal></expr>,
  <expr><operator>.</operator><name>shentsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ELFsectheader</name></expr></argument>)</argument_list></sizeof></expr>,
  <expr><operator>.</operator><name>shnum</name> <operator>=</operator> <name>GDBJIT_SECT__MAX</name></expr>,
  <expr><operator>.</operator><name>shstridx</name> <operator>=</operator> <name>GDBJIT_SECT_shstrtab</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* -- In-memory ELF object generation ------------------------------------- */</comment>

<comment type="block">/* Context for generating the ELF object for the GDB JIT API. */</comment>
<typedef>typedef <type><struct>struct <name>GDBJITctx</name> <block>{
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>		<comment type="block">/* Pointer to next address in obj.space. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>startp</name></decl>;</decl_stmt>	<comment type="block">/* Pointer to start address in obj.space. */</comment>
  <decl_stmt><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl>;</decl_stmt>		<comment type="block">/* Generate symbols for this trace. */</comment>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>mcaddr</name></decl>;</decl_stmt>	<comment type="block">/* Machine code address. */</comment>
  <decl_stmt><decl><type><name>MSize</name></type> <name>szmcode</name></decl>;</decl_stmt>	<comment type="block">/* Size of machine code. */</comment>
  <decl_stmt><decl><type><name>MSize</name></type> <name>spadjp</name></decl>;</decl_stmt>		<comment type="block">/* Stack adjustment for parent trace or interpreter. */</comment>
  <decl_stmt><decl><type><name>MSize</name></type> <name>spadj</name></decl>;</decl_stmt>		<comment type="block">/* Stack adjustment for trace itself. */</comment>
  <decl_stmt><decl><type><name>BCLine</name></type> <name>lineno</name></decl>;</decl_stmt>	<comment type="block">/* Starting line number. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>	<comment type="block">/* Starting file name. */</comment>
  <decl_stmt><decl><type><name>size_t</name></type> <name>objsize</name></decl>;</decl_stmt>	<comment type="block">/* Final size of ELF object. */</comment>
  <decl_stmt><decl><type><name>GDBJITobj</name></type> <name>obj</name></decl>;</decl_stmt>	<comment type="block">/* In-memory ELF object. */</comment>
}</block></struct></type> <name>GDBJITctx</name>;</typedef>

<comment type="block">/* Add a zero-terminated string. */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>gdbjit_strz</name><parameter_list>(<parameter><decl><type><name>GDBJITctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>ofs</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name><name>ctx</name><operator>-&gt;</operator><name>startp</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>*</operator><name>str</name></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><operator>*</operator><name>str</name><operator>++</operator></expr>)</condition>;</do>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <return>return <expr><name>ofs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append a decimal number. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gdbjit_catnum</name><parameter_list>(<parameter><decl><type><name>GDBJITctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content> <decl_stmt><decl><type><name>uint32_t</name></type> <name>m</name> <init>= <expr><name>n</name> <operator>/</operator> <literal type="number">10</literal></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>n</name> <operator>=</operator> <name>n</name> <operator>%</operator> <literal type="number">10</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>gdbjit_catnum</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a SLEB128 value. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gdbjit_sleb128</name><parameter_list>(<parameter><decl><type><name>GDBJITctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>v</name><operator>+</operator><literal type="number">0x40</literal><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0x80</literal></expr>;</condition> <incr><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Shortcuts to generate DWARF structures. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DB</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(*p++ = (x))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DI8</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(*(int8_t *)p = (x), p++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DU16</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(*(uint16_t *)p = (x), p += 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DU32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(*(uint32_t *)p = (x), p += 4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DADDR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(*(uintptr_t *)p = (x), p += sizeof(uintptr_t))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUV</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(p = (uint8_t *)lj_strfmt_wuleb128((char *)p, (x)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSV</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(ctx-&gt;p = p, gdbjit_sleb128(ctx, (x)), p = ctx-&gt;p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSTR</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(ctx-&gt;p = p, gdbjit_strz(ctx, (str)), p = ctx-&gt;p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DALIGNNOP</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>while ((uintptr_t)p &amp; ((s)-1)) *p++ = DW_CFA_nop</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSECT</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>stmt</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ uint32_t *szp_##name = (uint32_t *)p; p += 4; stmt \
    *szp_##name = (uint32_t)((p-(uint8_t *)szp_##name)-4); }</cpp:value></cpp:define> \

<comment type="block">/* Initialize ELF section headers. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>gdbjit_secthdr</name><parameter_list>(<parameter><decl><type><name>GDBJITctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ELFsectheader</name> <modifier>*</modifier></type><name>sect</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>  <comment type="block">/* Empty string at start of string table. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECTDEF</name><parameter_list>(<parameter><type><name>id</name></type></parameter>, <parameter><type><name>tp</name></type></parameter>, <parameter><type><name>al</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>sect = &amp;ctx-&gt;obj.sect[GDBJIT_SECT_##id]; \
  sect-&gt;name = gdbjit_strz(ctx, "." #id); \
  sect-&gt;type = ELFSECT_TYPE_##tp; \
  sect-&gt;align = (al)</cpp:value></cpp:define>

  <expr_stmt><expr><call><name>SECTDEF</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>NOBITS</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sect</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>ELFSECT_FLAGS_ALLOC</name><operator>|</operator><name>ELFSECT_FLAGS_EXEC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sect</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>mcaddr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sect</name><operator>-&gt;</operator><name>ofs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sect</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>szmcode</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SECTDEF</name><argument_list>(<argument><expr><name>eh_frame</name></expr></argument>, <argument><expr><name>PROGBITS</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uintptr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sect</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>ELFSECT_FLAGS_ALLOC</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SECTDEF</name><argument_list>(<argument><expr><name>shstrtab</name></expr></argument>, <argument><expr><name>STRTAB</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SECTDEF</name><argument_list>(<argument><expr><name>strtab</name></expr></argument>, <argument><expr><name>STRTAB</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SECTDEF</name><argument_list>(<argument><expr><name>symtab</name></expr></argument>, <argument><expr><name>SYMTAB</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uintptr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sect</name><operator>-&gt;</operator><name>ofs</name></name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>GDBJITobj</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sect</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>obj</name><operator>.</operator><name>sym</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sect</name><operator>-&gt;</operator><name>link</name></name> <operator>=</operator> <name>GDBJIT_SECT_strtab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sect</name><operator>-&gt;</operator><name>entsize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ELFsymbol</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sect</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <name>GDBJIT_SYM_FUNC</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SECTDEF</name><argument_list>(<argument><expr><name>debug_info</name></expr></argument>, <argument><expr><name>PROGBITS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SECTDEF</name><argument_list>(<argument><expr><name>debug_abbrev</name></expr></argument>, <argument><expr><name>PROGBITS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SECTDEF</name><argument_list>(<argument><expr><name>debug_line</name></expr></argument>, <argument><expr><name>PROGBITS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SECTDEF</name></cpp:undef>
</block_content>}</block></function>

<comment type="block">/* Initialize symbol table. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>gdbjit_symtab</name><parameter_list>(<parameter><decl><type><name>GDBJITctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ELFsymbol</name> <modifier>*</modifier></type><name>sym</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>  <comment type="block">/* Empty string at start of string table. */</comment>

  <expr_stmt><expr><name>sym</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>obj</name><operator>.</operator><name>sym</name><index>[<expr><name>GDBJIT_SYM_FILE</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>gdbjit_strz</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"JIT mcode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>sectidx</name></name> <operator>=</operator> <name>ELFSECT_IDX_ABS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <name>ELFSYM_TYPE_FILE</name><operator>|</operator><name>ELFSYM_BIND_LOCAL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>sym</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>obj</name><operator>.</operator><name>sym</name><index>[<expr><name>GDBJIT_SYM_FUNC</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>gdbjit_strz</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"TRACE_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gdbjit_catnum</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>traceno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>sectidx</name></name> <operator>=</operator> <name>GDBJIT_SECT_text</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>szmcode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <name>ELFSYM_TYPE_FUNC</name><operator>|</operator><name>ELFSYM_BIND_GLOBAL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize .eh_frame section. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>gdbjit_ehframe</name><parameter_list>(<parameter><decl><type><name>GDBJITctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>framep</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Emit DWARF EH CIE. */</comment>
  <macro><name>DSECT</name><argument_list>(<argument>CIE</argument>,
    <argument>DU32(<literal type="number">0</literal>);			<comment type="block">/* Offset to CIE itself. */</comment>
    DB(DW_CIE_VERSION);
    DSTR(<literal type="string">"zR"</literal>);			<comment type="block">/* Augmentation. */</comment>
    DUV(<literal type="number">1</literal>);			<comment type="block">/* Code alignment factor. */</comment>
    DSV(-(int32_t)sizeof(uintptr_t));  <comment type="block">/* Data alignment factor. */</comment>
    DB(DW_REG_RA);		<comment type="block">/* Return address register. */</comment>
    DB(<literal type="number">1</literal>); DB(DW_EH_PE_textrel|DW_EH_PE_udata4);  <comment type="block">/* Augmentation data. */</comment>
    DB(DW_CFA_def_cfa); DUV(DW_REG_SP); DUV(sizeof(uintptr_t));
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_PPC</name></expr></cpp:if>
    DB(DW_CFA_offset_extended_sf); DB(DW_REG_RA); DSV(-<literal type="number">1</literal>);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    DB(DW_CFA_offset|DW_REG_RA); DUV(<literal type="number">1</literal>);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    DALIGNNOP(sizeof(uintptr_t));</argument>
  )</argument_list></macro>

  <comment type="block">/* Emit DWARF EH FDE. */</comment>
  <macro><name>DSECT</name><argument_list>(<argument>FDE</argument>,
    <argument>DU32((uint32_t)(p-framep));	<comment type="block">/* Offset to CIE. */</comment>
    DU32(<literal type="number">0</literal>);			<comment type="block">/* Machine code offset relative to .text. */</comment>
    DU32(ctx-&gt;szmcode);		<comment type="block">/* Machine code length. */</comment>
    DB(<literal type="number">0</literal>);			<comment type="block">/* Augmentation data. */</comment>
    <comment type="block">/* Registers saved in CFRAME. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
    DB(DW_CFA_offset|DW_REG_BP); DUV(<literal type="number">2</literal>);
    DB(DW_CFA_offset|DW_REG_DI); DUV(<literal type="number">3</literal>);
    DB(DW_CFA_offset|DW_REG_SI); DUV(<literal type="number">4</literal>);
    DB(DW_CFA_offset|DW_REG_BX); DUV(<literal type="number">5</literal>);
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:elif>
    DB(DW_CFA_offset|DW_REG_BP); DUV(<literal type="number">2</literal>);
    DB(DW_CFA_offset|DW_REG_BX); DUV(<literal type="number">3</literal>);
    DB(DW_CFA_offset|DW_REG_15); DUV(<literal type="number">4</literal>);
    DB(DW_CFA_offset|DW_REG_14); DUV(<literal type="number">5</literal>);
    <comment type="block">/* Extra registers saved for JIT-compiled code. */</comment>
    DB(DW_CFA_offset|DW_REG_13); DUV(LJ_GC64 ? <literal type="number">10</literal> : <literal type="number">9</literal>);
    DB(DW_CFA_offset|DW_REG_12); DUV(LJ_GC64 ? <literal type="number">11</literal> : <literal type="number">10</literal>);
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM</name></expr></cpp:elif>
    {
      int i;
      for (i = <literal type="number">11</literal>; i &gt;= <literal type="number">4</literal>; i--) { DB(DW_CFA_offset|i); DUV(<literal type="number">2</literal>+(<literal type="number">11</literal>-i)); }
    }
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM64</name></expr></cpp:elif>
    {
      int i;
      DB(DW_CFA_offset|<literal type="number">31</literal>); DUV(<literal type="number">2</literal>);
      for (i = <literal type="number">28</literal>; i &gt;= <literal type="number">19</literal>; i--) { DB(DW_CFA_offset|i); DUV(<literal type="number">3</literal>+(<literal type="number">28</literal>-i)); }
      for (i = <literal type="number">15</literal>; i &gt;= <literal type="number">8</literal>; i--) { DB(DW_CFA_offset|<literal type="number">32</literal>|i); DUV(<literal type="number">28</literal>-i); }
    }
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_PPC</name></expr></cpp:elif>
    {
      int i;
      DB(DW_CFA_offset_extended); DB(DW_REG_CR); DUV(<literal type="number">55</literal>);
      for (i = <literal type="number">14</literal>; i &lt;= <literal type="number">31</literal>; i++) {
	DB(DW_CFA_offset|i); DUV(<literal type="number">37</literal>+(<literal type="number">31</literal>-i));
	DB(DW_CFA_offset|<literal type="number">32</literal>|i); DUV(<literal type="number">2</literal>+<literal type="number">2</literal>*(<literal type="number">31</literal>-i));
      }
    }
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_MIPS</name></expr></cpp:elif>
    {
      int i;
      DB(DW_CFA_offset|<literal type="number">30</literal>); DUV(<literal type="number">2</literal>);
      for (i = <literal type="number">23</literal>; i &gt;= <literal type="number">16</literal>; i--) { DB(DW_CFA_offset|i); DUV(<literal type="number">26</literal>-i); }
      for (i = <literal type="number">30</literal>; i &gt;= <literal type="number">20</literal>; i -= <literal type="number">2</literal>) { DB(DW_CFA_offset|<literal type="number">32</literal>|i); DUV(<literal type="number">42</literal>-i); }
    }
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Unsupported target architecture"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    if (ctx-&gt;spadjp != ctx-&gt;spadj) {  <comment type="block">/* Parent/interpreter stack frame size. */</comment>
      DB(DW_CFA_def_cfa_offset); DUV(ctx-&gt;spadjp);
      DB(DW_CFA_advance_loc|<literal type="number">1</literal>);  <comment type="block">/* Only an approximation. */</comment>
    }
    DB(DW_CFA_def_cfa_offset); DUV(ctx-&gt;spadj);  <comment type="block">/* Trace stack frame size. */</comment>
    DALIGNNOP(sizeof(uintptr_t));</argument>
  )</argument_list></macro>

  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize .debug_info section. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>gdbjit_debuginfo</name><parameter_list>(<parameter><decl><type><name>GDBJITctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>

  <macro><name>DSECT</name><argument_list>(<argument>info</argument>,
    <argument>DU16(<literal type="number">2</literal>);			<comment type="block">/* DWARF version. */</comment>
    DU32(<literal type="number">0</literal>);			<comment type="block">/* Abbrev offset. */</comment>
    DB(sizeof(uintptr_t));	<comment type="block">/* Pointer size. */</comment>

    DUV(<literal type="number">1</literal>);			<comment type="block">/* Abbrev #1: DW_TAG_compile_unit. */</comment>
    DSTR(ctx-&gt;filename);	<comment type="block">/* DW_AT_name. */</comment>
    DADDR(ctx-&gt;mcaddr);		<comment type="block">/* DW_AT_low_pc. */</comment>
    DADDR(ctx-&gt;mcaddr + ctx-&gt;szmcode);  <comment type="block">/* DW_AT_high_pc. */</comment>
    DU32(<literal type="number">0</literal>);</argument>			<comment type="block">/* DW_AT_stmt_list. */</comment>
  )</argument_list></macro>

  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize .debug_abbrev section. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>gdbjit_debugabbrev</name><parameter_list>(<parameter><decl><type><name>GDBJITctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Abbrev #1: DW_TAG_compile_unit. */</comment>
  <expr_stmt><expr><call><name>DUV</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>DUV</name><argument_list>(<argument><expr><name>DW_TAG_compile_unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DB</name><argument_list>(<argument><expr><name>DW_children_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DUV</name><argument_list>(<argument><expr><name>DW_AT_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<expr_stmt><expr><call><name>DUV</name><argument_list>(<argument><expr><name>DW_FORM_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DUV</name><argument_list>(<argument><expr><name>DW_AT_low_pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<expr_stmt><expr><call><name>DUV</name><argument_list>(<argument><expr><name>DW_FORM_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DUV</name><argument_list>(<argument><expr><name>DW_AT_high_pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<expr_stmt><expr><call><name>DUV</name><argument_list>(<argument><expr><name>DW_FORM_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DUV</name><argument_list>(<argument><expr><name>DW_AT_stmt_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<expr_stmt><expr><call><name>DUV</name><argument_list>(<argument><expr><name>DW_FORM_data4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DB</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>DB</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLNE</name><parameter_list>(<parameter><type><name>op</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(DB(DW_LNS_extended_op), DUV(1+(s)), DB((op)))</cpp:value></cpp:define>

<comment type="block">/* Initialize .debug_line section. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>LJ_FASTCALL</name></type> <name>gdbjit_debugline</name><parameter_list>(<parameter><decl><type><name>GDBJITctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>

  <macro><name>DSECT</name><argument_list>(<argument>line</argument>,
    <argument>DU16(<literal type="number">2</literal>);			<comment type="block">/* DWARF version. */</comment>
    DSECT(header,
      DB(<literal type="number">1</literal>);			<comment type="block">/* Minimum instruction length. */</comment>
      DB(<literal type="number">1</literal>);			<comment type="block">/* is_stmt. */</comment>
      DI8(<literal type="number">0</literal>);			<comment type="block">/* Line base for special opcodes. */</comment>
      DB(<literal type="number">2</literal>);			<comment type="block">/* Line range for special opcodes. */</comment>
      DB(<literal type="number">3</literal>+<literal type="number">1</literal>);			<comment type="block">/* Opcode base at DW_LNS_advance_line+1. */</comment>
      DB(<literal type="number">0</literal>); DB(<literal type="number">1</literal>); DB(<literal type="number">1</literal>);	<comment type="block">/* Standard opcode lengths. */</comment>
      <comment type="block">/* Directory table. */</comment>
      DB(<literal type="number">0</literal>);
      <comment type="block">/* File name table. */</comment>
      DSTR(ctx-&gt;filename); DUV(<literal type="number">0</literal>); DUV(<literal type="number">0</literal>); DUV(<literal type="number">0</literal>);
      DB(<literal type="number">0</literal>);
    )

    DLNE(DW_LNE_set_address, sizeof(uintptr_t)); DADDR(ctx-&gt;mcaddr);
    if (ctx-&gt;lineno) {
      DB(DW_LNS_advance_line); DSV(ctx-&gt;lineno-<literal type="number">1</literal>);
    }
    DB(DW_LNS_copy);
    DB(DW_LNS_advance_pc); DUV(ctx-&gt;szmcode);
    DLNE(DW_LNE_end_sequence, <literal type="number">0</literal>);</argument>
  )</argument_list></macro>

  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DLNE</name></cpp:undef>

<comment type="block">/* Undef shortcuts. */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DB</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DI8</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DU16</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DU32</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DADDR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DUV</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DSV</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DSTR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DALIGNNOP</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DSECT</name></cpp:undef>

<comment type="block">/* Type of a section initializer callback. */</comment>
<typedef>typedef <function_decl><type><name>void</name></type> (<name>LJ_FASTCALL</name> <modifier>*</modifier><name>GDBJITinitf</name>)<parameter_list>(<parameter><decl><type><name>GDBJITctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* Call section initializer and set the section offset and size. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gdbjit_initsect</name><parameter_list>(<parameter><decl><type><name>GDBJITctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sect</name></decl></parameter>, <parameter><decl><type><name>GDBJITinitf</name></type> <name>initf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>startp</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>p</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>obj</name><operator>.</operator><name>sect</name><index>[<expr><name>sect</name></expr>]</index></name><operator>.</operator><name>ofs</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>obj</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>initf</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>obj</name><operator>.</operator><name>sect</name><index>[<expr><name>sect</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name> <operator>-</operator> <name><name>ctx</name><operator>-&gt;</operator><name>startp</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECTALIGN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>((p) = (uint8_t *)(((uintptr_t)(p) + ((a)-1)) &amp; ~(uintptr_t)((a)-1)))</cpp:value></cpp:define>

<comment type="block">/* Build in-memory ELF object. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gdbjit_buildobj</name><parameter_list>(<parameter><decl><type><name>GDBJITctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GDBJITobj</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Fill in ELF header and clear structures. */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elfhdr_template</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ELFheader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>sect</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ELFsectheader</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>GDBJIT_SECT__MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>sym</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ELFsymbol</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>GDBJIT_SYM__MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Initialize sections. */</comment>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>space</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gdbjit_initsect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>GDBJIT_SECT_shstrtab</name></expr></argument>, <argument><expr><name>gdbjit_secthdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gdbjit_initsect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>GDBJIT_SECT_strtab</name></expr></argument>, <argument><expr><name>gdbjit_symtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gdbjit_initsect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>GDBJIT_SECT_debug_info</name></expr></argument>, <argument><expr><name>gdbjit_debuginfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gdbjit_initsect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>GDBJIT_SECT_debug_abbrev</name></expr></argument>, <argument><expr><name>gdbjit_debugabbrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gdbjit_initsect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>GDBJIT_SECT_debug_line</name></expr></argument>, <argument><expr><name>gdbjit_debugline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SECTALIGN</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uintptr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gdbjit_initsect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>GDBJIT_SECT_eh_frame</name></expr></argument>, <argument><expr><name>gdbjit_ehframe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>objsize</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>p</name></name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>obj</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>objsize</name></name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GDBJITobj</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SECTALIGN</name></cpp:undef>

<comment type="block">/* -- Interface to GDB JIT API -------------------------------------------- */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>gdbjit_lock</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>gdbjit_lock_acquire</name><parameter_list>()</parameter_list>
<block>{<block_content>
  <while>while <condition>(<expr><call><name>__sync_lock_test_and_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gdbjit_lock</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Just spin; futexes or pthreads aren't worth the portability cost. */</comment>
  </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>gdbjit_lock_release</name><parameter_list>()</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>__sync_lock_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gdbjit_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add new entry to GDB JIT symbol chain. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gdbjit_newentry</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GDBJITctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Allocate memory for GDB JIT entry and ELF object. */</comment>
  <decl_stmt><decl><type><name>MSize</name></type> <name>sz</name> <init>= <expr><operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>GDBJITentryobj</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GDBJITobj</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>ctx</name><operator>-&gt;</operator><name>objsize</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GDBJITentryobj</name> <modifier>*</modifier></type><name>eo</name> <init>= <expr><call><name>lj_mem_newt</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>GDBJITentryobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eo</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>objsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Copy ELF object. */</comment>
  <expr_stmt><expr><name><name>eo</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>T</name><operator>-&gt;</operator><name>gdbjit_entry</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>eo</name></expr>;</expr_stmt>
  <comment type="block">/* Link new entry to chain and register it. */</comment>
  <expr_stmt><expr><name><name>eo</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>prev_entry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gdbjit_lock_acquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eo</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>next_entry</name></name> <operator>=</operator> <name><name>__jit_debug_descriptor</name><operator>.</operator><name>first_entry</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>eo</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>next_entry</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>eo</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>next_entry</name><operator>-&gt;</operator><name>prev_entry</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>eo</name><operator>-&gt;</operator><name>entry</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>eo</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>symfile_addr</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>eo</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eo</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>symfile_size</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>objsize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>__jit_debug_descriptor</name><operator>.</operator><name>first_entry</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>eo</name><operator>-&gt;</operator><name>entry</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>__jit_debug_descriptor</name><operator>.</operator><name>relevant_entry</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>eo</name><operator>-&gt;</operator><name>entry</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>__jit_debug_descriptor</name><operator>.</operator><name>action_flag</name></name> <operator>=</operator> <name>GDBJIT_REGISTER</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>__jit_debug_register_code</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gdbjit_lock_release</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add debug info for newly compiled trace and notify GDB. */</comment>
<function><type><name>void</name></type> <name>lj_gdbjit_addtrace</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GDBJITctx</name></type> <name>ctx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><operator>&amp;</operator><call><name>gcref</name><argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>startpt</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TraceNo</name></type> <name>parent</name> <init>= <expr><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name>REF_BASE</name></expr>]</index></name><operator>.</operator><name>op1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>startpc</name> <init>= <expr><call><name>mref</name><argument_list>(<argument><expr><name><name>T</name><operator>-&gt;</operator><name>startpc</name></name></expr></argument>, <argument><expr><specifier>const</specifier> <name>BCIns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>T</name></name> <operator>=</operator> <name>T</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>mcaddr</name></name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>T</name><operator>-&gt;</operator><name>mcode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>szmcode</name></name> <operator>=</operator> <name><name>T</name><operator>-&gt;</operator><name>szmcode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>spadjp</name></name> <operator>=</operator> <name>CFRAME_SIZE_JIT</name> <operator>+</operator>
	       <operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>parent</name></expr> ?</condition><then> <expr><call><name>traceref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>spadjust</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>spadj</name></name> <operator>=</operator> <name>CFRAME_SIZE_JIT</name> <operator>+</operator> <name><name>T</name><operator>-&gt;</operator><name>spadjust</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>startpc</name> <operator>&gt;=</operator> <call><name>proto_bc</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>startpc</name> <operator>&lt;</operator> <call><name>proto_bc</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>pt</name><operator>-&gt;</operator><name>sizebc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>lineno</name></name> <operator>=</operator> <call><name>lj_debug_line</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><call><name>proto_bcpos</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>startpc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>filename</name></name> <operator>=</operator> <call><name>proto_chunknamestr</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>.</operator><name>filename</name></name> <operator>==</operator> <literal type="char">'@'</literal> <operator>||</operator> <operator>*</operator><name><name>ctx</name><operator>.</operator><name>filename</name></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>filename</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>filename</name></name> <operator>=</operator> <literal type="string">"(string)"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>gdbjit_buildobj</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gdbjit_newentry</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Delete debug info for trace and notify GDB. */</comment>
<function><type><name>void</name></type> <name>lj_gdbjit_deltrace</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GDBJITentryobj</name> <modifier>*</modifier></type><name>eo</name> <init>= <expr><operator>(</operator><name>GDBJITentryobj</name> <operator>*</operator><operator>)</operator><name><name>T</name><operator>-&gt;</operator><name>gdbjit_entry</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>eo</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>gdbjit_lock_acquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>eo</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>prev_entry</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>eo</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>prev_entry</name><operator>-&gt;</operator><name>next_entry</name></name> <operator>=</operator> <name><name>eo</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>next_entry</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>__jit_debug_descriptor</name><operator>.</operator><name>first_entry</name></name> <operator>=</operator> <name><name>eo</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>next_entry</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>eo</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>next_entry</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>eo</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>next_entry</name><operator>-&gt;</operator><name>prev_entry</name></name> <operator>=</operator> <name><name>eo</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>prev_entry</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>__jit_debug_descriptor</name><operator>.</operator><name>relevant_entry</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>eo</name><operator>-&gt;</operator><name>entry</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>__jit_debug_descriptor</name><operator>.</operator><name>action_flag</name></name> <operator>=</operator> <name>GDBJIT_UNREGISTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>__jit_debug_register_code</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>gdbjit_lock_release</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_mem_free</name><argument_list>(<argument><expr><call><name>J2G</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>eo</name></expr></argument>, <argument><expr><name><name>eo</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
